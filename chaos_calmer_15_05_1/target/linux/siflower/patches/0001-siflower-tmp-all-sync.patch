Index: linux-3.18.29/arch/mips/Kbuild.platforms
===================================================================
--- linux-3.18.29.orig/arch/mips/Kbuild.platforms	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/Kbuild.platforms	2017-11-21 20:13:12.434710526 +0800
@@ -16,6 +16,7 @@
 platforms += loongson
 platforms += loongson1
 platforms += mti-malta
+platforms += siflower
 platforms += mti-sead3
 platforms += netlogic
 platforms += paravirt
Index: linux-3.18.29/arch/mips/Kconfig
===================================================================
--- linux-3.18.29.orig/arch/mips/Kconfig	2017-11-21 20:13:11.346710494 +0800
+++ linux-3.18.29/arch/mips/Kconfig	2017-11-21 20:13:12.434710526 +0800
@@ -326,6 +326,7 @@
 	select I8259
 	select MIPS_BONITO64
 	select MIPS_CPU_SCACHE
+	select MIPS_L1_CACHE_SHIFT_6
 	select PCI_GT64XXX_PCI0
 	select MIPS_MSC
 	select SWAP_IO_SPACE
@@ -350,6 +351,55 @@
 	  This enables support for the MIPS Technologies Malta evaluation
 	  board.
 
+config SIFLOWER
+	bool "MIPS Siflower SOC"
+	select ARCH_MAY_HAVE_PC_FDC
+	select BOOT_ELF32
+	select BOOT_RAW
+	select CEVT_R4K
+	select CSRC_R4K
+	select CSRC_GIC
+	select HAVE_PCSPKR_PLATFORM
+	select IRQ_CPU
+	select IRQ_GIC
+#	select HW_HAS_PCI
+#	select I8253
+#	select I8259
+	select MIPS_BONITO64
+	select MIPS_CPU_SCACHE
+	select PCI_GT64XXX_PCI0
+	select MIPS_MSC
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS32_R3_5
+	select SYS_HAS_CPU_NEVADA
+	select SYS_HAS_CPU_RM7000
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+#	select SYS_SUPPORTS_MIPS_CMP
+	select SYS_SUPPORTS_MIPS_CPS
+	select CONFIG_MIPS_CPS
+	select SYS_SUPPORTS_MIPS16
+	select SYS_SUPPORTS_MULTITHREADING
+	select SYS_SUPPORTS_SMARTMIPS
+	select SYS_SUPPORTS_ZBOOT
+	select DMA_MAYBE_COHERENT
+	select USE_OF
+	select COMMON_CLK
+	select PINCTRL
+	select PINCTRL_SFAX8
+	select ARCH_WANT_OPTIONAL_GPIOLIB
+	select ARCH_REQUIRE_GPIOLIB
+	select REGMAP_MMIO
+	select GENERIC_PINCONF
+	select MFD_SYSCON
+	select CPU_SUPPORTS_CPUFREQ
+
+	help
+	  This enables support for the MIPS Technologies Siflower evaluation
+	  board.
+
+
 config MIPS_SEAD3
 	bool "MIPS SEAD3 board"
 	select BOOT_ELF32
@@ -853,6 +903,7 @@
 source "arch/mips/loongson1/Kconfig"
 source "arch/mips/netlogic/Kconfig"
 source "arch/mips/paravirt/Kconfig"
+source "arch/mips/siflower/Kconfig"
 
 endmenu
 
@@ -1793,6 +1844,7 @@
 	select TRAD_SIGNALS
 	help
 	  Select this option if you want to build a 32-bit kernel.
+
 config 64BIT
 	bool "64-bit kernel"
 	depends on CPU_SUPPORTS_64BIT_KERNEL && SYS_SUPPORTS_64BIT_KERNEL
@@ -1913,7 +1965,6 @@
 config MIPS_CPU_SCACHE
 	bool
 	select BOARD_SCACHE
-	select MIPS_L1_CACHE_SHIFT_6
 
 config R5000_CPU_SCACHE
 	bool
@@ -1949,8 +2000,8 @@
 config MIPS_MT_SMP
 	bool "MIPS MT SMP support (1 TC on each available VPE)"
 	depends on SYS_SUPPORTS_MULTITHREADING
-	select CPU_MIPSR2_IRQ_VI
-	select CPU_MIPSR2_IRQ_EI
+#	select CPU_MIPSR2_IRQ_VI
+#	select CPU_MIPSR2_IRQ_EI
 	select SYNC_R4K
 	select MIPS_GIC_IPI
 	select MIPS_MT
Index: linux-3.18.29/arch/mips/Kconfig.debug
===================================================================
--- linux-3.18.29.orig/arch/mips/Kconfig.debug	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/Kconfig.debug	2017-11-21 20:13:12.434710526 +0800
@@ -55,7 +55,7 @@
 config CMDLINE
 	string "Default kernel command string"
 	depends on CMDLINE_BOOL
-	default ""
+	default "console=ttyS0,115200 rdinit=/etc/preinit rootfstype=squashfs"
 	help
 	  On some platforms, there is currently no way for the boot loader to
 	  pass arguments to the kernel.  For these platforms, and for the cases
Index: linux-3.18.29/arch/mips/boot/dts/Makefile
===================================================================
--- linux-3.18.29.orig/arch/mips/boot/dts/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/boot/dts/Makefile	2017-11-21 20:13:12.434710526 +0800
@@ -8,7 +8,13 @@
 dtb-$(CONFIG_DTB_RT305X_EVAL)		+= rt3052_eval.dtb
 dtb-$(CONFIG_DTB_RT3883_EVAL)		+= rt3883_eval.dtb
 dtb-$(CONFIG_DTB_MT7620A_EVAL)		+= mt7620a_eval.dtb
-dtb-$(CONFIG_MIPS_SEAD3)		+= sead3.dtb
+dtb-$(CONFIG_MIPS_SEAD3)		   += sead3.dtb
+dtb-$(CONFIG_DT_SF16A18_MPW0_P10)	+= sf16a18_mpw0_p10.dtb
+dtb-$(CONFIG_DT_SF16A18_MPW0_P10_RN5T567)	+= sf16a18_mpw0_p10_rn5t567.dtb
+dtb-$(CONFIG_DT_SF16A18_MPW0_P20)	+= sf16a18_mpw0_p20.dtb
+dtb-$(CONFIG_DT_SF16A18_MPW1_P10)	+= sf16a18_mpw1_p10.dtb
+dtb-$(CONFIG_DT_SF16A18_MPW1_P20)	+= sf16a18_mpw1_p20.dtb
+dtb-$(CONFIG_DT_SF16A18_MPW1_FPGA)	+= sf16a18_mpw1_fpga.dtb
 
 obj-y		+= $(patsubst %.dtb, %.dtb.o, $(dtb-y))
 
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_eval_fpga.dts
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_eval_fpga.dts	2017-11-21 20:13:12.434710526 +0800
@@ -0,0 +1,493 @@
+/dts-v1/;
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "siflower,sf16a18-soc";
+
+	aliases {
+		gdu = &gdu;
+		gdma = &gdma;
+		usb = &usb;
+		emmc = &emmc;
+		sdio = &sdio;
+		i2s = &i2s;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		uart0=&uart0;
+		uart1=&uart1;
+		uart2=&uart2;
+		uart3=&uart3;
+		pcm0 = &pcm0;
+		pcm1 = &pcm1;
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		timer0 = &timer0;
+		timer1 = &timer1;
+		timer2 = &timer2;
+		timer3 = &timer3;
+		watchdog = &watchdog;
+		spdif = &spdif;
+	};
+
+	cpus{
+		cpu@0 {
+			compatible = "mips,interAptiv";
+		};
+		cpu@1 {
+			compatible = "mips,interAptiv";
+		};
+		cpu@2 {
+			compatible = "mips,interAptiv";
+		};
+		cpu@3 {
+			compatible = "mips,interAptiv";
+		};
+	};
+
+	clocks{
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		osc: oscillator {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <12000000>;
+			clock-output-names = "osc";
+		};
+
+		bus1xnclk: cfg@19e01400 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "bus1xnclk";
+		};
+
+		bus2xnclk: cfg@19e01420 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "bus2xnclk";
+		};
+
+		bus3xnclk: cfg@19e01440 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <80000000>;
+			clock-output-names = "bus3xnclk";
+		};
+
+		cpuclk: cfg@19e01500 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <40000000>;
+			clock-output-names = "cpuclk";
+		};
+
+		pbusclk: cfg@19e01520 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "pbusclk";
+		};
+
+		memphyclk: cfg@19e01540 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <140000000>;
+			clock-output-names = "memphyclk";
+		};
+
+		audioclk: cfg@19e01560 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <60000000>;
+			clock-output-names = "audioclk";
+		};
+
+		uartclk: cfg@19e01580 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <60000000>;
+			clock-output-names = "uartclk";
+		};
+
+		spdifclk: cfg@19e015a0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <60000000>;
+			clock-output-names = "spdifclk";
+		};
+
+		sdhcclk: cfg@19e015c0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "sdhcclk";
+		};
+
+		inandclk: cfg@19e015e0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "inandclk";
+		};
+
+		ethrefclk: cfg@19e01600 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <25000000>;
+			clock-output-names = "ethrefclk";
+		};
+
+		ethbyprefclk: cfg@19e01620 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <125000000>;
+			clock-output-names = "ethbyprefclk";
+		};
+
+		ethtsuclk: cfg@19e01640 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <25000000>;
+			clock-output-names = "ethtsuclk";
+		};
+
+		wlan24clk: cfg@19e016c0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <30000000>;
+			clock-output-names = "wlan24clk";
+		};
+
+		wlan5clk: cfg@19e016e0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <30000000>;
+			clock-output-names = "wlan5clk";
+		};
+
+		usbphyclk: cfg@19e01700 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "usbphyclk";
+		};
+
+		tclk: cfg@19e01720 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "tclk";
+		};
+
+		npupeclk: cfg@19e01740 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <500000000>;
+			clock-output-names = "npupeclk";
+		};
+
+		gdu0clk: cfg@19e01760 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <198000000>;
+			clock-output-names = "gdu0clk";
+		};
+
+		gdu0eitfclk: cfg@19e01780 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <237600000>;
+			clock-output-names = "gdu0eitfclk";
+		};
+
+		tvif0clk: cfg@19e017a0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <198000000>;
+			clock-output-names = "tvif0clk";
+		};
+
+	};
+	cpuintc: cpuintc@0 {
+		compatible = "mti,cpu-interrupt-controller";
+		#address-cells = <0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	gpio: gpio@19d00000 {
+		compatible = "snps,dw-apb-gpio";
+		reg=<0x19d00000 0x100000>;
+		#gpio-cells=<2>;
+	};
+
+	gic: gic@1bdc0000 {
+		#interrupt-cells = <2>;
+		interrupt-controller;
+		compatible = "siflower,sf16a18-gic";
+		reg = <0x1bdc0000 0x20000>;/*gic*/
+		clock-frequency = <40000000>;
+	};
+
+	palmbus@10000000 {
+		compatible = "palmbus";
+		reg = <0x10000000 0x10000000>;
+		ranges = <0x0 0x10000000 0xFFFFFFF>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&gic>;
+
+		ethernet@0000000 {
+			compatible = "siflower,sfa18-eth";
+			reg = <0x0000000 0x6CFFFF>;
+			mac-address = [ 00 11 22 33 44 66 ];
+			interrupts = <16 0>;
+		};
+
+		switch@0000000 {
+			compatible = "siflower,sfa18-switch";
+			reg = <0x0000000 0x6CFFFF>;
+			interrupts = <25 0>;
+			max-speed = <100>;
+			sfa18,port-map = "llllw";
+		};
+
+		ethernet@800000 {
+			compatible = "siflower,sf16a18-gmac";
+			reg = <0x800000 0x200000>;
+			interrupts = <32 0>;
+
+			mac-address = [ 00 11 22 33 44 55 ];
+			phy = <&phy0>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			phy0: ethernet-phy@0 {
+				reg = <1>;
+				max-speed = <1000>;
+			};
+		};
+
+		gdu: gdu@c00000 {
+			compatible = "siflower,sf16a18-gdu";
+			reg = <0xc00000 0x10000>;
+			interrupts = <39 0>;
+		};
+
+		gdma: dma@1800000 {
+			compatible = "siflower,sf16a18-gdma";
+			reg = <0x1800000 0x1000>;
+			interrupts = <80 0>;
+			#dma-cells = <1>;
+			#dma-channels = <7>;
+			#dma-requests = <32>;
+		};
+
+		usb: usb@7000000 {
+			compatible = "siflower,sfa18-usb";
+			reg = <0x7000000 0x40000>;
+			interrupts = <128 0>;
+			dr_mode = <3>;
+		};
+
+		emmc: emmc@7800000 {
+			compatible = "siflower,sf16a18-mmc";
+			reg = <0x7800000 0x200000>;
+			interrupt = <144 0>;
+		};
+
+		sdio: sdio@7c00000 {
+			compatible = "siflower,sf16a18-mmc";
+			reg = <0x7c00000 0x200000>;
+			interrupt = <160 0>;
+		};
+
+		i2s: i2s@8000000 {
+			compatible = "siflower,sf16a18-i2s";
+			reg = <0x8000000 0x100000>;
+			interrupt = <208 0>,<211 0>;
+		};
+
+		i2c0: i2c@8100000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8100000 0x1000>;
+			interrupts = <217 0>;
+		};
+
+		i2c1: i2c@8101000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8101000 0x1000>;
+			interrupts = <218 0>;
+		};
+
+		i2c2: i2c@8102000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8102000 0x1000>;
+			interrupts = <219 0>;
+		};
+
+		spi0: spi@8200000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8200000 0x1000>;
+			num-cs = <2>;
+			clock = <50000000>;
+			cs-gpios = <&gpio 5 0>, <&gpio 6 0>;
+			spi-max-frequency = <12500000>;
+
+			clocks = <&pbusclk 0>;
+
+			interrupt-parent = <&gic>;
+			interrupts = <223 0>;
+
+			use-dma;
+			dmas = <&gdma 10
+				&gdma 11>;
+			dma-names = "sfax8-spi-tx", "sfax8-spi-rx";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+				w25q128@0 {
+					compatible = "w25q128";
+					reg = <0>;	/* chip select */
+					cs-gpios = <&gpio 5 0>;
+					spi-cpha;
+					spi-cpol;
+					spi-max-frequency = <12000000>;
+				};
+
+				spidev: spi@8200000 {
+					compatible = "rohm,dh2228fv";
+					reg = <1>;
+					clock = <50000000>;
+					spi-cpha;
+					spi-cpol;
+					spi-max-frequency=<12000000>;
+				};
+
+		};
+
+		spi1: spi@8201000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8201000 0x1000>;
+			clocks = <&pbusclk 0>;
+			interrupts = <224 0>;
+		};
+
+		uart0: serial@8300000 {
+			compatible = "siflower,sf16a18-uart";
+			reg = <0x8300000 0x1000>;
+			interrupts = <226 0>;
+			clocks = <&uartclk 0>;
+		};
+
+		uart1: serial@8301000 {
+			compatible = "siflower,sf16a18-uart";
+			reg = <0x8301000 0x1000>;
+			interrupts = <227 0>;
+			clocks = <&uartclk 0>;
+			dmas = <&gdma 14
+			&gdma 15>;
+			dma-names = "tx", "rx";
+		};
+
+		uart2: serial@8302000 {
+			compatible = "siflower,sf16a18-uart";
+			reg = <0x8302000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <228 0>;
+		};
+
+		uart3: serial@8303000 {
+			compatible = "siflower,sf16a18-uart";
+			reg = <0x8303000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <229 0>;
+		};
+
+		pcm0: pcm@8400000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8400000 0x1000>;
+			interrupts = <230 0>;
+		};
+
+		pcm1: pcm@8401000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8401000 0x1000>;
+			interrupts = <231 0>;
+		};
+
+		pwm0: pwm@8500000 {
+			compatible = "siflower,sfax8-pwm";
+			reg = <0x8500000 0x1000>;
+			interrupts = <232 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+		};
+
+		pwm1: pwm@8501000 {
+			compatible = "siflower,sfax8-pwm";
+			reg = <0x8501000 0x1000>;
+			interrupts = <233 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+		};
+
+		timer0: timer@8600000 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8600000 0x14>;
+			interrupts = <234 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+		};
+
+		timer1: timer@8600014 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8600014 0x14>;
+			interrupts = <235 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+		};
+
+		timer2: timer@8601000 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8601000 0x14>;
+			interrupts = <236 0>;
+			status="disable";
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+		};
+
+		timer3: timer@8601014 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8601014 0x14>;
+			interrupts = <237 0>;
+			status="disable";
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+		};
+
+		watchdog: watchdog@8700000 {
+			compatible = "siflower,sfax8-wdt";
+			reg = <0x8700000 0x1000>;
+			interrupt-parent = <&gic>;
+			interrupts = <238 0>;
+
+			clocks = <&pbusclk 0>;
+		};
+
+		spdif: spdif@8800000 {
+			compatible = "siflower,sfax8-spdif";
+			reg = <0x8800000 0x1000>;
+			interrupts = <239 0>;
+		};
+
+	}; /* palmbus */
+
+};
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_eval_sim.dts
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_eval_sim.dts	2017-11-21 20:13:12.434710526 +0800
@@ -0,0 +1,586 @@
+/dts-v1/;
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "siflower,sf16a18-soc";
+
+	aliases {
+		gdu = &gdu;
+		gdma = &gdma;
+		usb = &usb;
+		emmc = &emmc;
+		sdio = &sdio;
+		i2s = &i2s;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		uart0=&uart0;
+		uart1=&uart1;
+		uart2=&uart2;
+		uart3=&uart3;
+		pcm0 = &pcm0;
+		pcm1 = &pcm1;
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		timer0 = &timer0;
+		timer1 = &timer1;
+		timer2 = &timer2;
+		timer3 = &timer3;
+		watchdog = &watchdog;
+		spdif = &spdif;
+	};
+
+	cpus{
+		cpu@0 {
+			compatible = "mips,interAptiv";
+		};
+		cpu@1 {
+			compatible = "mips,interAptiv";
+		};
+		cpu@2 {
+			compatible = "mips,interAptiv";
+		};
+		cpu@3 {
+			compatible = "mips,interAptiv";
+		};
+	};
+
+	clocks{
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		osc: oscillator {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <12000000>;
+			clock-output-names = "osc";
+		};
+
+		cpupll: pll@19e01000 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <56>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "cpu_pll";
+			clock-output-names = "cpupll";
+		};
+
+		ddrpll: pll@19e01040 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <133>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "ddr_pll";
+			clock-output-names = "ddrpll";
+		};
+
+		cmnpll: pll@19e01080 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <99>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "cmn_pll";
+			clock-output-names = "cmnpll";
+		};
+
+		spcpll: pll@19e010c0 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <125>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "spc_pll";
+			clock-output-names = "spcpll";
+		};
+
+		bus1xnclk: cfg@19e01400 {
+			compatible = "siflower,sf16a18-bus1-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "bus1_clk";
+			reg = <0x19e01400 0x20>;
+			clock-output-names = "bus1xnclk";
+		};
+
+		bus2xnclk: cfg@19e01420 {
+			compatible = "siflower,sf16a18-bus2-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "bus2_clk";
+			reg = <0x19e01420 0x20>;
+			clock-output-names = "bus2xnclk";
+		};
+
+		bus3xnclk: cfg@19e01440 {
+			compatible = "siflower,sf16a18-bus3-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "bus3_clk";
+			reg = <0x19e01440 0x20>;
+			clock-output-names = "bus3xnclk";
+		};
+
+		cpuclk: cfg@19e01500 {
+			compatible = "siflower,sf16a18-cpu-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "cpu_clk";
+			reg = <0x19e01500 0x20>;
+			clock-output-names = "cpuclk";
+		};
+
+		pbusclk: cfg@19e01520 {
+			compatible = "siflower,sf16a18-pbus-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "pbus_clk";
+			reg = <0x19e01520 0x20>;
+			clock-output-names = "pbusclk";
+		};
+
+		memphyclk: cfg@19e01540 {
+			compatible = "siflower,sf16a18-memphy-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "mem_phy_clk";
+			reg = <0x19e01540 0x20>;
+			clock-output-names = "memphyclk";
+		};
+
+		audioclk: cfg@19e01560 {
+			compatible = "siflower,sf16a18-audio-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "audio_clk";
+			reg = <0x19e01560 0x20>;
+			clock-output-names = "audioclk";
+		};
+
+		uartclk: cfg@19e01580 {
+			compatible = "siflower,sf16a18-uart-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "uart_clk";
+			reg = <0x19e01580 0x20>;
+			clock-output-names = "uartclk";
+		};
+
+		spdifclk: cfg@19e015a0 {
+			compatible = "siflower,sf16a18-spdif-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "spdif_clk";
+			reg = <0x19e015a0 0x20>;
+			clock-output-names = "spdifclk";
+		};
+
+		sdhcclk: cfg@19e015c0 {
+			compatible = "siflower,sf16a18-sdhc-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "sdio_clk";
+			reg = <0x19e015c0 0x20>;
+			clock-output-names = "sdhcclk";
+		};
+
+		inandclk: cfg@19e015e0 {
+			compatible = "siflower,sf16a18-emmc-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "emmc_clk";
+			reg = <0x19e015e0 0x20>;
+			clock-output-names = "inandclk";
+		};
+
+		ethrefclk: cfg@19e01600 {
+			compatible = "siflower,sf16a18-eth-ref-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "eth_ref_clk";
+			reg = <0x19e01600 0x20>;
+			clock-output-names = "ethrefclk";
+		};
+
+		ethbyprefclk: cfg@19e01620 {
+			compatible = "siflower,sf16a18-eth-byp-ref-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "eth_byp_ref_clk";
+			reg = <0x19e01620 0x20>;
+			clock-output-names = "ethbyprefclk";
+		};
+
+		ethtsuclk: cfg@19e01640 {
+			compatible = "siflower,sf16a18-eth-tsu-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "eth_tsu_clk";
+			reg = <0x19e01640 0x20>;
+			clock-output-names = "ethtsuclk";
+		};
+
+		wlan24clk: cfg@19e016c0 {
+			compatible = "siflower,sf16a18-wlan24-mac-wt-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "wlan24_mac_wt_clk";
+			reg = <0x19e016c0 0x20>;
+			clock-output-names = "wlan24clk";
+		};
+
+		wlan5clk: cfg@19e016e0 {
+			compatible = "siflower,sf16a18-wlan5-mac-wt-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "wlan5_mac_wt_clk";
+			reg = <0x19e016e0 0x20>;
+			clock-output-names = "wlan5clk";
+		};
+
+		usbphyclk: cfg@19e01700 {
+			compatible = "siflower,sf16a18-usbphy-ref-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "usb_phy_clk";
+			reg = <0x19e01700 0x20>;
+			clock-output-names = "usbphyclk";
+		};
+
+		tclk: cfg@19e01720 {
+			compatible = "siflower,sf16a18-tclk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "tclk";
+			reg = <0x19e01720 0x20>;
+			clock-output-names = "tclk";
+		};
+
+		npupeclk: cfg@19e01740 {
+			compatible = "siflower,sf16a18-npupe-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "npu_pe_clk";
+			reg = <0x19e01740 0x20>;
+			clock-output-names = "npupeclk";
+		};
+
+		gdu0clk: cfg@19e01760 {
+			compatible = "siflower,sf16a18-gdu0-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "gdu0_clk";
+			reg = <0x19e01760 0x20>;
+			clock-output-names = "gdu0clk";
+		};
+
+		gdu0eitfclk: cfg@19e01780 {
+			compatible = "siflower,sf16a18-gdu0-eitf-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "gdu0_eitf_clk";
+			reg = <0x19e01780 0x20>;
+			clock-output-names = "gdu0eitfclk";
+		};
+
+		tvif0clk: cfg@19e017a0 {
+			compatible = "siflower,sf16a18-tvif0-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "tvif0_clk";
+			reg = <0x19e017a0 0x20>;
+			clock-output-names = "tvif0clk";
+		};
+
+	};
+	cpuintc: cpuintc@0 {
+		compatible = "mti,cpu-interrupt-controller";
+		#address-cells = <0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	gpio: gpio@19d00000 {
+		compatible = "snps,dw-apb-gpio";
+		reg=<0x19d00000 0x100000>;
+		#gpio-cells=<2>;
+	};
+
+	gic: gic@1bdc0000 {
+		#interrupt-cells = <2>;
+		interrupt-controller;
+		compatible = "siflower,sf16a18-gic";
+		reg = <0x1bdc0000 0x20000>;/*gic*/
+		clock-frequency = <40000000>;
+	};
+
+	palmbus@10000000 {
+		compatible = "palmbus";
+		reg = <0x10000000 0x10000000>;
+		ranges = <0x0 0x10000000 0xFFFFFFF>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&gic>;
+
+		ethernet@0000000 {
+			compatible = "siflower,sfa18-eth";
+			reg = <0x0000000 0x6CFFFF>;
+			mac-address = [ 00 11 22 33 44 66 ];
+			interrupts = <16 0>;
+		};
+
+		switch@0000000 {
+			compatible = "siflower,sfa18-switch";
+			reg = <0x0000000 0x6CFFFF>;
+			interrupts = <25 0>;
+			max-speed = <100>;
+			sfa18,port-map = "llllw";
+		};
+
+		ethernet@800000 {
+			compatible = "siflower,sf16a18-gmac";
+			reg = <0x800000 0x200000>;
+			interrupts = <32 0>;
+
+			mac-address = [ 00 11 22 33 44 55 ];
+			phy = <&phy0>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			phy0: ethernet-phy@0 {
+				reg = <1>;
+				max-speed = <1000>;
+			};
+		};
+
+		gdu: gdu@c00000 {
+			compatible = "siflower,sf16a18-gdu";
+			reg = <0xc00000 0x10000>;
+			interrupts = <39 0>;
+		};
+
+		gdma: dma@1800000 {
+			compatible = "siflower,sf16a18-gdma";
+			reg = <0x1800000 0x1000>;
+			interrupts = <80 0>;
+			#dma-cells = <1>;
+			#dma-channels = <7>;
+			#dma-requests = <32>;
+		};
+
+		usb: usb@7000000 {
+			compatible = "siflower,sfa18-usb";
+			reg = <0x7000000 0x40000>;
+			interrupts = <128 0>;
+		};
+
+		emmc: emmc@7800000 {
+			compatible = "siflower,sf16a18-mmc";
+			reg = <0x7800000 0x200000>;
+			interrupt = <144 0>;
+		};
+
+		sdio: sdio@7c00000 {
+			compatible = "siflower,sf16a18-mmc";
+			reg = <0x7c00000 0x200000>;
+			interrupt = <160 0>;
+		};
+
+		i2s: i2s@8000000 {
+			compatible = "siflower,sf16a18-i2s";
+			reg = <0x8000000 0x100000>;
+			interrupt = <208 0>,<211 0>;
+		};
+
+		i2c0: i2c@8100000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8100000 0x1000>;
+			interrupts = <217 0>;
+		};
+
+		i2c1: i2c@8101000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8101000 0x1000>;
+			interrupts = <218 0>;
+		};
+
+		i2c2: i2c@8102000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8102000 0x1000>;
+			interrupts = <219 0>;
+		};
+
+		spi0: spi@8200000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8200000 0x1000>;
+			num-cs = <2>;
+			clock = <50000000>;
+			cs-gpios = <&gpio 5 0>, <&gpio 6 0>;
+			spi-max-frequency = <12500000>;
+
+			clocks = <&pbusclk 0>;
+
+			interrupt-parent = <&gic>;
+			interrupts = <223 0>;
+
+			use-dma;
+			dmas = <&gdma 10
+				&gdma 11>;
+			dma-names = "sfax8-spi-tx", "sfax8-spi-rx";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+				w25q128@0 {
+					compatible = "w25q128";
+					reg = <0>;	/* chip select */
+					cs-gpios = <&gpio 5 0>;
+					spi-cpha;
+					spi-cpol;
+					spi-max-frequency = <12000000>;
+				};
+
+				spidev: spi@8200000 {
+					compatible = "rohm,dh2228fv";
+					reg = <1>;
+					clock = <50000000>;
+					spi-cpha;
+					spi-cpol;
+					spi-max-frequency=<12000000>;
+				};
+
+		};
+
+		spi1: spi@8201000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8201000 0x1000>;
+			clocks = <&pbusclk 0>;
+			interrupts = <224 0>;
+		};
+
+		uart0: serial@8300000 {
+			compatible = "siflower,sf16a18-uart";
+			reg = <0x8300000 0x1000>;
+			interrupts = <226 0>;
+			clocks = <&uartclk 0>;
+		};
+
+		uart1: serial@8301000 {
+			compatible = "siflower,sf16a18-uart";
+			reg = <0x8301000 0x1000>;
+			interrupts = <227 0>;
+			clocks = <&uartclk 0>;
+			dmas = <&gdma 14
+			&gdma 15>;
+			dma-names = "tx", "rx";
+		};
+
+		uart2: serial@8302000 {
+			compatible = "siflower,sf16a18-uart";
+			reg = <0x8302000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <228 0>;
+		};
+
+		uart3: serial@8303000 {
+			compatible = "siflower,sf16a18-uart";
+			reg = <0x8303000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <229 0>;
+		};
+
+		pcm0: pcm@8400000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8400000 0x1000>;
+			clocks =<&audioclk 0>;
+			id = <0>;
+			dmas = <&gdma 20
+				&gdma 21>;
+			dma-names = "tx","rx";
+			interrupts = <230 0>;
+		};
+
+		pcm1: pcm@8401000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8401000 0x1000>;
+			clocks =<&audioclk 0>;
+			id = <1>;
+			dmas = <&gdma 22
+				&gdma 23>;
+			dma-names = "tx","rx";
+			interrupts = <231 0>;
+		};
+
+		pwm0: pwm@8500000 {
+			compatible = "siflower,sfax8-pwm";
+			reg = <0x8500000 0x1000>;
+			interrupts = <232 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+		};
+
+		pwm1: pwm@8501000 {
+			compatible = "siflower,sfax8-pwm";
+			reg = <0x8501000 0x1000>;
+			interrupts = <233 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+		};
+
+		timer0: timer@8600000 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8600000 0x14>;
+			interrupts = <234 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+		};
+
+		timer1: timer@8600014 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8600014 0x14>;
+			interrupts = <235 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+		};
+
+		timer2: timer@8601000 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8601000 0x14>;
+			interrupts = <236 0>;
+			status="disable";
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+		};
+
+		timer3: timer@8601014 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8601014 0x14>;
+			interrupts = <237 0>;
+			status="disable";
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+		};
+
+		watchdog: watchdog@8700000 {
+			compatible = "siflower,sfax8-wdt";
+			reg = <0x8700000 0x1000>;
+			interrupt-parent = <&gic>;
+			interrupts = <238 0>;
+
+			clocks = <&pbusclk 0>;
+		};
+
+		spdif: spdif@8800000 {
+			compatible = "siflower,sfax8-spdif";
+			reg = <0x8800000 0x1000>;
+			interrupts = <239 0>;
+		};
+
+	}; /* palmbus */
+
+};
Index: linux-3.18.29/arch/mips/include/asm/compiler.h
===================================================================
--- linux-3.18.29.orig/arch/mips/include/asm/compiler.h	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/include/asm/compiler.h	2017-11-21 20:13:12.434710526 +0800
@@ -16,4 +16,30 @@
 #define GCC_REG_ACCUM "accum"
 #endif
 
+#ifdef CONFIG_CPU_MIPSR6
+/* All MIPS R6 toolchains support the ZC constrain */
+#define GCC_OFF_SMALL_ASM() "ZC"
+#else
+#ifndef CONFIG_CPU_MICROMIPS
+#define GCC_OFF_SMALL_ASM() "R"
+#elif __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 9)
+#define GCC_OFF_SMALL_ASM() "ZC"
+#else
+#error "microMIPS compilation unsupported with GCC older than 4.9"
+#endif /* CONFIG_CPU_MICROMIPS */
+#endif /* CONFIG_CPU_MIPSR6 */
+
+#ifdef CONFIG_CPU_MIPSR6
+#define MIPS_ISA_LEVEL "mips64r6"
+#define MIPS_ISA_ARCH_LEVEL MIPS_ISA_LEVEL
+#define MIPS_ISA_LEVEL_RAW mips64r6
+#define MIPS_ISA_ARCH_LEVEL_RAW MIPS_ISA_LEVEL_RAW
+#else
+/* MIPS64 is a superset of MIPS32 */
+#define MIPS_ISA_LEVEL "mips64r2"
+#define MIPS_ISA_ARCH_LEVEL "arch=r4000"
+#define MIPS_ISA_LEVEL_RAW mips64r2
+#define MIPS_ISA_ARCH_LEVEL_RAW MIPS_ISA_LEVEL_RAW
+#endif /* CONFIG_CPU_MIPSR6 */
+
 #endif /* _ASM_COMPILER_H */
Index: linux-3.18.29/arch/mips/include/asm/mips-boards/generic.h
===================================================================
--- linux-3.18.29.orig/arch/mips/include/asm/mips-boards/generic.h	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/include/asm/mips-boards/generic.h	2017-11-21 20:13:12.434710526 +0800
@@ -40,6 +40,8 @@
 #define MIPS_REVISION_CORID_CORE_24K	   10
 #define MIPS_REVISION_CORID_CORE_FPGA4	   11
 #define MIPS_REVISION_CORID_CORE_FPGA5	   12
+#define MIPS_REVISION_CORID_CORE_SF16A18 0x28
+
 
 /**** Artificial corid defines ****/
 /*
@@ -54,6 +56,8 @@
 #define MIPS_REVISION_SCON_OTHER	   0
 #define MIPS_REVISION_SCON_SOCITSC	   1
 #define MIPS_REVISION_SCON_SOCITSCP	   2
+#define MIPS_REVISION_SCON_SF16A18    0x53
+
 
 /* Artificial SCON defines for MIPS_REVISION_SCON_OTHER */
 #define MIPS_REVISION_SCON_UNKNOWN	   -1
Index: linux-3.18.29/arch/mips/include/asm/mips-cm.h
===================================================================
--- linux-3.18.29.orig/arch/mips/include/asm/mips-cm.h	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/include/asm/mips-cm.h	2017-11-21 20:13:12.434710526 +0800
@@ -173,8 +173,8 @@
 #define CM_GCR_BASE_GCRBASE_MSK			(_ULCAST_(0x1ffff) << 15)
 #define CM_GCR_BASE_CMDEFTGT_SHF		0
 #define CM_GCR_BASE_CMDEFTGT_MSK		(_ULCAST_(0x3) << 0)
-#define  CM_GCR_BASE_CMDEFTGT_DISABLED		0
-#define  CM_GCR_BASE_CMDEFTGT_MEM		1
+#define  CM_GCR_BASE_CMDEFTGT_MEM		0
+#define  CM_GCR_BASE_CMDEFTGT_DISABLED		1
 #define  CM_GCR_BASE_CMDEFTGT_IOCU0		2
 #define  CM_GCR_BASE_CMDEFTGT_IOCU1		3
 
Index: linux-3.18.29/arch/mips/kernel/cevt-gic.c
===================================================================
--- linux-3.18.29.orig/arch/mips/kernel/cevt-gic.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/kernel/cevt-gic.c	2017-11-21 20:13:12.434710526 +0800
@@ -13,7 +13,10 @@
 
 #include <asm/time.h>
 #include <asm/gic.h>
-#include <asm/mips-boards/maltaint.h>
+
+#ifdef CONFIG_SOC_SF16A18
+#include <sf16a18int.h>
+#endif
 
 DEFINE_PER_CPU(struct clock_event_device, gic_clockevent_device);
 int gic_timer_irq_installed;
@@ -80,7 +83,7 @@
 
 	/* Calculate the min / max delta */
 	cd->max_delta_ns	= clockevent_delta2ns(0x7fffffff, cd);
-	cd->min_delta_ns	= clockevent_delta2ns(0x300, cd);
+	cd->min_delta_ns	= clockevent_delta2ns(0x600, cd);
 
 	cd->rating		= 300;
 	cd->irq			= irq;
@@ -103,3 +106,19 @@
 	irq_set_handler(irq, handle_percpu_irq);
 	return 0;
 }
+
+void gic_clockevent_update_freq(u32 freq)
+{
+	struct clock_event_device *cd;
+	int i;
+
+	for(i = 0; i < NR_CPUS; i++) {
+		cd = &per_cpu(gic_clockevent_device, i);
+		clockevents_unbind_device(cd, i);
+		clockevent_set_clock(cd, freq);
+		smp_call_function_single(i,
+			(void (*)(void *))clockevents_register_device, cd, 1);
+	}
+
+	return;
+}
Index: linux-3.18.29/arch/mips/kernel/smp-cps.c
===================================================================
--- linux-3.18.29.orig/arch/mips/kernel/smp-cps.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/kernel/smp-cps.c	2017-11-21 20:13:12.434710526 +0800
@@ -279,7 +279,7 @@
 	if (cpu_has_mipsmt)
 		dmt();
 
-	change_c0_status(ST0_IM, STATUSF_IP3 | STATUSF_IP4 |
+	change_c0_status(ST0_IM, STATUSF_IP3 | STATUSF_IP4 | STATUSF_IP2 |
 				 STATUSF_IP6 | STATUSF_IP7);
 }
 
Index: linux-3.18.29/drivers/amba/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/amba/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/amba/Makefile	2017-11-21 20:13:12.434710526 +0800
@@ -1,2 +1,2 @@
-obj-$(CONFIG_ARM_AMBA)		+= bus.o
+obj-$(CONFIG_ARM_AMBA | CONFIG_SIFLOWER)		+= bus.o
 obj-$(CONFIG_TEGRA_AHB)		+= tegra-ahb.o
Index: linux-3.18.29/drivers/clocksource/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/clocksource/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/clocksource/Kconfig	2017-11-21 20:13:12.434710526 +0800
@@ -22,7 +22,7 @@
 	bool
 
 config DW_APB_TIMER_OF
-	bool
+	bool 
 	select DW_APB_TIMER
 	select CLKSRC_OF
 
@@ -138,6 +138,16 @@
 	help
 	  Support for Multi Core Timer controller on Exynos SoCs.
 
+config CLKSRC_SFAX8_PWM
+	tristate "Siflower SFAX8 PWM clocksource support"
+	depends on SIFLOWER
+	select CLKSRC_OF
+	select GENERIC_SCHED_CLOCK
+	help
+	  This is a new clocksource driver for the PWM timer found in
+	  SIFLOWER sfax8 soc, replacing an earlier driver
+	  for all devicetree enabled platforms.
+
 config CLKSRC_SAMSUNG_PWM
 	bool
 	help
@@ -211,6 +221,14 @@
 
 config CLKSRC_QCOM
 	bool
+	
+config SFAX8_TIMER
+	bool "Siflower timer"
+	select CLKSRC_OF
+	select GENERIC_SCHED_CLOCK
+	help
+		This enables build of a clocksource and clockevent driver for the 
+		SFAX8 Timer hardware availbale on a Socs.
 
 config CLKSRC_VERSATILE
 	bool "ARM Versatile (Express) reference platforms clock source"
Index: linux-3.18.29/drivers/clocksource/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/clocksource/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/clocksource/Makefile	2017-11-21 20:13:12.434710526 +0800
@@ -35,6 +35,7 @@
 obj-$(CONFIG_CLKSRC_EFM32)	+= time-efm32.o
 obj-$(CONFIG_CLKSRC_EXYNOS_MCT)	+= exynos_mct.o
 obj-$(CONFIG_CLKSRC_SAMSUNG_PWM)	+= samsung_pwm_timer.o
+obj-$(CONFIG_CLKSRC_SFAX8_PWM)	+= sfax8_pwm_timer.o
 obj-$(CONFIG_FSL_FTM_TIMER)	+= fsl_ftm_timer.o
 obj-$(CONFIG_VF_PIT_TIMER)	+= vf_pit_timer.o
 obj-$(CONFIG_CLKSRC_QCOM)	+= qcom-timer.o
@@ -46,3 +47,4 @@
 obj-$(CONFIG_ARCH_HAS_TICK_BROADCAST)	+= dummy_timer.o
 obj-$(CONFIG_ARCH_KEYSTONE)		+= timer-keystone.o
 obj-$(CONFIG_CLKSRC_VERSATILE)		+= versatile.o
+obj-$(CONFIG_SFAX8_TIMER)		+= sfax8_timer.o
Index: linux-3.18.29/drivers/clocksource/sfax8_pwm_timer.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/clocksource/sfax8_pwm_timer.c	2017-11-15 11:09:39.336422000 +0800
@@ -0,0 +1,464 @@
+/*
+ * Copyright (C) 2016 Shanghai Siflower Communication Technology Co., Ltd.
+ *
+ * sfax8 - Common hr-timer support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/clockchips.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/sched_clock.h>
+#include <sf16a18.h>
+
+#include <clocksource/sfax8_pwm.h>
+
+
+/*
+ * Clocksource driver
+ */
+
+#define REG_TCFG0			0x00
+#define REG_TCFG1			0x04
+#define REG_TCON			0x08
+#define REG_TINT_CSTAT			0x44
+
+#define REG_TCNTB(chan)			(0x0c + 12 * (chan))
+#define REG_TCMPB(chan)			(0x10 + 12 * (chan))
+
+#define TCFG0_PRESCALER_MASK		0xff
+#define TCFG0_PRESCALER1_SHIFT		8
+
+#define TCFG1_SHIFT(x)			((x) * 4)
+#define TCFG1_MUX_MASK			0xf
+
+/*
+ * Each channel occupies 4 bits in TCON register, but there is a gap of 4
+ * bits (one channel) after channel 0, so channels have different numbering
+ * when accessing TCON register.
+ *
+ * In addition, the location of autoreload bit for channel 4 (TCON channel 5)
+ * in its set of bits is 2 as opposed to 3 for other channels.
+ */
+#define TCON_START(chan)		(1 << (4 * (chan) + 0))
+#define TCON_MANUALUPDATE(chan)		(1 << (4 * (chan) + 1))
+#define TCON_INVERT(chan)		(1 << (4 * (chan) + 2))
+#define _TCON_AUTORELOAD(chan)		(1 << (4 * (chan) + 3))
+#define _TCON_AUTORELOAD4(chan)		(1 << (4 * (chan) + 2))
+#define TCON_AUTORELOAD(chan)		\
+	((chan < 5) ? _TCON_AUTORELOAD(chan) : _TCON_AUTORELOAD4(chan))
+
+DEFINE_SPINLOCK(sfax8_pwm_lock);
+EXPORT_SYMBOL(sfax8_pwm_lock);
+
+struct sfax8_pwm_clocksource {
+	void __iomem *base;
+	void __iomem *source_reg;
+	unsigned int irq[SFAX8_PWM_NUM];
+	struct sfax8_pwm_variant variant;
+
+	struct clk *timerclk;
+
+	unsigned int event_id;
+	unsigned int source_id;
+	unsigned int tcnt_max;
+	unsigned int tscaler_div;
+	unsigned int tdiv;
+
+	unsigned long clock_count_per_tick;
+};
+
+static struct sfax8_pwm_clocksource pwm;
+
+static void sfax8_timer_set_prescale(unsigned int channel, u16 prescale)
+{
+	unsigned long flags;
+	u8 shift = 0;
+	u32 reg;
+
+	if (channel >= 2)
+		shift = TCFG0_PRESCALER1_SHIFT;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	reg = readl(pwm.base + REG_TCFG0);
+	reg &= ~(TCFG0_PRESCALER_MASK << shift);
+	reg |= (prescale - 1) << shift;
+	writel(reg, pwm.base + REG_TCFG0);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+}
+
+static void sfax8_timer_set_divisor(unsigned int channel, u8 divisor)
+{
+	u8 shift = TCFG1_SHIFT(channel);
+	unsigned long flags;
+	u32 reg;
+	u8 bits;
+
+	bits = 8 + (fls(divisor) - 1) - pwm.variant.div_base;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	reg = readl(pwm.base + REG_TCFG1);
+	reg &= ~(TCFG1_MUX_MASK << shift);
+	reg |= bits << shift;
+	writel(reg, pwm.base + REG_TCFG1);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+}
+
+static void sfax8_time_stop(unsigned int channel)
+{
+	unsigned long tcon;
+	unsigned long flags;
+
+	if (channel > 0)
+		++channel;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	tcon = __raw_readl(pwm.base + REG_TCON);
+	tcon &= ~TCON_START(channel);
+	__raw_writel(tcon, pwm.base + REG_TCON);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+}
+
+static void sfax8_time_setup(unsigned int channel, unsigned long tcnt)
+{
+	unsigned long tcon;
+	unsigned long flags;
+	unsigned int tcon_chan = channel;
+
+	if (tcon_chan > 0)
+		++tcon_chan;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	tcon = __raw_readl(pwm.base + REG_TCON);
+
+	tcon &= ~(TCON_START(tcon_chan) | TCON_AUTORELOAD(tcon_chan));
+	tcon |= TCON_MANUALUPDATE(tcon_chan);
+
+	__raw_writel(tcnt, pwm.base + REG_TCNTB(channel));
+	__raw_writel(tcnt, pwm.base + REG_TCMPB(channel));
+	__raw_writel(tcon, pwm.base + REG_TCON);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+}
+
+static void sfax8_time_start(unsigned int channel, bool periodic)
+{
+	unsigned long tcon;
+	unsigned long flags;
+
+	if (channel > 0)
+		++channel;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	tcon = __raw_readl(pwm.base + REG_TCON);
+
+	tcon &= ~TCON_MANUALUPDATE(channel);
+	tcon |= TCON_START(channel);
+
+	if (periodic)
+		tcon |= TCON_AUTORELOAD(channel);
+	else
+		tcon &= ~TCON_AUTORELOAD(channel);
+
+	__raw_writel(tcon, pwm.base + REG_TCON);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+}
+
+static int sfax8_set_next_event(unsigned long cycles,
+				struct clock_event_device *evt)
+{
+	/*
+	 * This check is needed to account for internal rounding
+	 * errors inside clockevents core, which might result in
+	 * passing cycles = 0, which in turn would not generate any
+	 * timer interrupt and hang the system.
+	 *
+	 * Another solution would be to set up the clockevent device
+	 * with min_delta = 2, but this would unnecessarily increase
+	 * the minimum sleep period.
+	 */
+	if (!cycles)
+		cycles = 1;
+
+	sfax8_time_setup(pwm.event_id, cycles);
+	sfax8_time_start(pwm.event_id, false);
+
+	return 0;
+}
+
+static void sfax8_set_mode(enum clock_event_mode mode,
+				struct clock_event_device *evt)
+{
+	sfax8_time_stop(pwm.event_id);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		sfax8_time_setup(pwm.event_id, pwm.clock_count_per_tick - 1);
+		sfax8_time_start(pwm.event_id, true);
+		break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		break;
+
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_RESUME:
+		break;
+	}
+}
+
+static void sfax8_clockevent_resume(struct clock_event_device *cev)
+{
+	sfax8_timer_set_prescale(pwm.event_id, pwm.tscaler_div);
+	sfax8_timer_set_divisor(pwm.event_id, pwm.tdiv);
+
+	if (pwm.variant.has_tint_cstat) {
+		u32 mask = (1 << pwm.event_id);
+		writel(mask | (mask << 5), pwm.base + REG_TINT_CSTAT);
+	}
+}
+
+static struct clock_event_device time_event_device = {
+	.name		= "sfax8_event_timer",
+	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.rating		= 200,
+	.set_next_event	= sfax8_set_next_event,
+	.set_mode	= sfax8_set_mode,
+	.resume		= sfax8_clockevent_resume,
+};
+
+static irqreturn_t sfax8_clock_event_isr(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = dev_id;
+
+	if (pwm.variant.has_tint_cstat) {
+		u32 mask = (1 << pwm.event_id);
+		writel(mask | (mask << 5), pwm.base + REG_TINT_CSTAT);
+	}
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction sfax8_clock_event_irq = {
+	.name		= "sfax8_time_irq",
+	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= sfax8_clock_event_isr,
+	.dev_id		= &time_event_device,
+};
+
+static void __init sfax8_clockevent_init(void)
+{
+	unsigned long pclk;
+	unsigned long clock_rate;
+	unsigned int irq_number;
+
+	pclk = clk_get_rate(pwm.timerclk);
+
+	sfax8_timer_set_prescale(pwm.event_id, pwm.tscaler_div);
+	sfax8_timer_set_divisor(pwm.event_id, pwm.tdiv);
+
+	clock_rate = pclk / (pwm.tscaler_div * (1 << pwm.tdiv));
+	pwm.clock_count_per_tick = clock_rate / HZ;
+
+	time_event_device.cpumask = cpumask_of(0);
+	clockevents_config_and_register(&time_event_device,
+						clock_rate, 1, pwm.tcnt_max);
+
+	irq_number = pwm.irq[pwm.event_id];
+	sfax8_clock_event_irq.irq = irq_number;
+	//setup_irq(irq_number, &sfax8_clock_event_irq);
+
+	if (pwm.variant.has_tint_cstat) {
+		u32 mask = (1 << pwm.event_id);
+		writel(mask | (mask << 5), pwm.base + REG_TINT_CSTAT);
+	}
+}
+
+static void sfax8_clocksource_suspend(struct clocksource *cs)
+{
+	sfax8_time_stop(pwm.source_id);
+}
+
+static void sfax8_clocksource_resume(struct clocksource *cs)
+{
+	sfax8_timer_set_prescale(pwm.source_id, pwm.tscaler_div);
+	sfax8_timer_set_divisor(pwm.source_id, pwm.tdiv);
+
+	sfax8_time_setup(pwm.source_id, pwm.tcnt_max);
+	sfax8_time_start(pwm.source_id, true);
+}
+
+static cycle_t sfax8_clocksource_read(struct clocksource *c)
+{
+	return ~readl_relaxed(pwm.source_reg);
+}
+
+static struct clocksource sfax8_clocksource = {
+	.name		= "pwm_timer",
+	.rating		= 350,
+	.read		= sfax8_clocksource_read,
+	.suspend	= sfax8_clocksource_suspend,
+	.resume		= sfax8_clocksource_resume,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/*
+ * Override the global weak sched_clock symbol with this
+ * local implementation which uses the clocksource to get some
+ * better resolution when scheduling the kernel. We accept that
+ * this wraps around for now, since it is just a relative time
+ * stamp. (Inspired by U300 implementation.)
+ */
+static u64 notrace sfax8_read_sched_clock(void)
+{
+	return sfax8_clocksource_read(NULL);
+}
+
+static void __init sfax8_clocksource_init(void)
+{
+	unsigned long pclk;
+	unsigned long clock_rate;
+	int ret;
+
+	pclk = clk_get_rate(pwm.timerclk);
+
+	sfax8_timer_set_prescale(pwm.source_id, pwm.tscaler_div);
+	sfax8_timer_set_divisor(pwm.source_id, pwm.tdiv);
+
+	clock_rate = pclk / (pwm.tscaler_div * (1 << pwm.tdiv));
+
+	sfax8_time_setup(pwm.source_id, pwm.tcnt_max);
+	sfax8_time_start(pwm.source_id, true);
+
+	if (pwm.source_id == 4)
+		pwm.source_reg = pwm.base + 0x40;
+	else
+		pwm.source_reg = pwm.base + pwm.source_id * 0x0c + 0x14;
+
+	sched_clock_register(sfax8_read_sched_clock,
+						pwm.variant.bits, clock_rate);
+
+	sfax8_clocksource.mask = CLOCKSOURCE_MASK(pwm.variant.bits);
+	ret = clocksource_register_hz(&sfax8_clocksource, clock_rate);
+	if (ret)
+		panic("sfax8_clocksource_timer: can't register clocksource\n");
+}
+
+static void __init sfax8_timer_resources(void)
+{
+	clk_prepare_enable(pwm.timerclk);
+
+	if(pwm.variant.bits == 32)
+		pwm.tcnt_max = ~1UL;
+	else
+		pwm.tcnt_max = (1UL << pwm.variant.bits) - 1;
+
+	if (pwm.variant.bits == 16) {
+		pwm.tscaler_div = 25;
+		pwm.tdiv = 2;
+	} else {
+		pwm.tscaler_div = 2;
+		pwm.tdiv = 1;
+	}
+}
+
+/*
+ * PWM master driver
+ */
+static void __init _sfax8_pwm_clocksource_init(void)
+{
+	u8 mask;
+	int channel;
+
+	mask = ~pwm.variant.output_mask & ((1 << SFAX8_PWM_NUM) - 1);
+	channel = fls(mask) - 1;
+	if (channel < 0)
+		panic("failed to find PWM channel for clocksource");
+	pwm.source_id = channel;
+
+	mask &= ~(1 << channel);
+	channel = fls(mask) - 1;
+	if (channel < 0)
+		panic("failed to find PWM channel for clock event");
+	pwm.event_id = channel;
+
+	sfax8_timer_resources();
+	sfax8_clockevent_init();
+	sfax8_clocksource_init();
+}
+
+#ifdef CONFIG_CLKSRC_OF
+static void __init sfax8_pwm_alloc(struct device_node *np,
+				     const struct sfax8_pwm_variant *variant)
+{
+	struct property *prop;
+	const __be32 *cur;
+	u32 val;
+	int i;
+
+	memcpy(&pwm.variant, variant, sizeof(pwm.variant));
+	for (i = 0; i < SFAX8_PWM_NUM; ++i)
+		pwm.irq[i] = irq_of_parse_and_map(np, 0);
+
+	of_property_for_each_u32(np, "pwm-outputs", prop, cur, val) {
+		if (val >= SFAX8_PWM_NUM) {
+			pr_warning("%s: invalid channel index in sfax8,pwm-outputs property\n",
+								__func__);
+			continue;
+		}
+		pwm.variant.output_mask |= 1 << val;
+	}
+
+	pwm.base = of_iomap(np, 0);
+	if (!pwm.base) {
+		pr_err("%s: failed to map PWM registers\n", __func__);
+		return;
+	}
+
+	pwm.timerclk = of_clk_get_by_name(np, NULL);
+	if (IS_ERR(pwm.timerclk))
+		panic("failed to get timers clock for timer");
+
+	_sfax8_pwm_clocksource_init();
+}
+
+static const struct sfax8_pwm_variant sfax8_variant = {
+	.bits		= 16,
+	.div_base	= 0,
+	.has_tint_cstat	= false,
+	.tclk_mask	= 0,
+};
+
+static void __init sfax8_pwm_clocksource_init(struct device_node *np)
+{
+	if(release_reset(SF_PWM_SOFT_RESET))
+		return;
+
+	sfax8_pwm_alloc(np, &sfax8_variant);
+}
+CLOCKSOURCE_OF_DECLARE(sfax8_pwm, "siflower,sfax8-pwm",
+						sfax8_pwm_clocksource_init);
+#endif
Index: linux-3.18.29/drivers/dma/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/dma/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/dma/Kconfig	2017-11-21 20:13:12.434710526 +0800
@@ -250,6 +250,13 @@
 	  You need to provide platform specific settings via
 	  platform_data for a dma-pl330 device.
 
+config SFAX8_DMA
+	tristate "DMA API Driver for SIFLOWER DMA"
+	select DMA_ENGINE
+	depends on SIFLOWER
+	help
+	  SFAX8 global dma driver.
+
 config PCH_DMA
 	tristate "Intel EG20T PCH / LAPIS Semicon IOH(ML7213/ML7223/ML7831) DMA"
 	depends on PCI && (X86_32 || COMPILE_TEST)
Index: linux-3.18.29/drivers/dma/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/dma/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/dma/Makefile	2017-11-21 20:13:12.434710526 +0800
@@ -31,6 +31,7 @@
 obj-$(CONFIG_TEGRA20_APB_DMA) += tegra20-apb-dma.o
 obj-$(CONFIG_S3C24XX_DMAC) += s3c24xx-dma.o
 obj-$(CONFIG_PL330_DMA) += pl330.o
+obj-$(CONFIG_SFAX8_DMA) += sfax8_dma.o
 obj-$(CONFIG_PCH_DMA) += pch_dma.o
 obj-$(CONFIG_AMBA_PL08X) += amba-pl08x.o
 obj-$(CONFIG_EP93XX_DMA) += ep93xx_dma.o
Index: linux-3.18.29/drivers/i2c/busses/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/i2c/busses/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/i2c/busses/Kconfig	2017-11-21 20:13:12.434710526 +0800
@@ -465,6 +465,14 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-designware-pci.
 
+config I2C_SFAX8
+	tristate "Siflower AX8 I2C"
+	depends on (ACPI && COMMON_CLK) || !ACPI
+	help
+	  If you say yes to this option, support will be included for the
+	  Sf16ax8 I2C adapter. Only master mode is supported.
+	  This driver can also be built as a module.
+
 config I2C_EFM32
 	tristate "EFM32 I2C controller"
 	depends on ARCH_EFM32 || COMPILE_TEST
Index: linux-3.18.29/drivers/i2c/busses/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/i2c/busses/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/i2c/busses/Makefile	2017-11-21 20:13:12.434710526 +0800
@@ -48,6 +48,7 @@
 obj-$(CONFIG_I2C_EXYNOS5)	+= i2c-exynos5.o
 obj-$(CONFIG_I2C_GPIO)		+= i2c-gpio.o
 obj-$(CONFIG_I2C_HIGHLANDER)	+= i2c-highlander.o
+obj-$(CONFIG_I2C_SFAX8)	+= i2c-sfax8-core.o i2c-sfax8-platdrv.o 
 obj-$(CONFIG_I2C_HIX5HD2)	+= i2c-hix5hd2.o
 obj-$(CONFIG_I2C_IBM_IIC)	+= i2c-ibm_iic.o
 obj-$(CONFIG_I2C_IMX)		+= i2c-imx.o
Index: linux-3.18.29/drivers/mfd/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/mfd/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/mfd/Kconfig	2017-11-21 20:13:12.434710526 +0800
@@ -1354,5 +1354,21 @@
 	  System Registers are the platform configuration block
 	  on the ARM Ltd. Versatile Express board.
 
+config MFD_SFAX8_IP6103
+	bool "SIFLOWER SFAX8"
+	select MFD_CORE
+	select REGMAP_I2C
+	depends on I2C=y
+	help
+	  Support for the SFAX8 machine
+
+config MFD_SFAX8_RN5T567
+	bool "SIFLOWER SFAX8"
+	select MFD_CORE
+	select REGMAP_I2C
+	depends on I2C=y
+	help
+	  Support for the SFAX8 machine
+
 endmenu
 endif
Index: linux-3.18.29/drivers/mfd/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/mfd/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/mfd/Makefile	2017-11-21 20:13:12.434710526 +0800
@@ -174,6 +174,7 @@
 obj-$(CONFIG_MFD_IPAQ_MICRO)	+= ipaq-micro.o
 obj-$(CONFIG_MFD_MENF21BMC)	+= menf21bmc.o
 obj-$(CONFIG_MFD_HI6421_PMIC)	+= hi6421-pmic-core.o
-
+obj-$(CONFIG_MFD_SFAX8_IP6103)	+= sfax8_ip6103.o
+obj-$(CONFIG_MFD_SFAX8_RN5T567)	+= sfax8_rn5t567.o
 intel-soc-pmic-objs		:= intel_soc_pmic_core.o intel_soc_pmic_crc.o
 obj-$(CONFIG_INTEL_SOC_PMIC)	+= intel-soc-pmic.o
Index: linux-3.18.29/drivers/mmc/host/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/mmc/host/Kconfig	2017-11-21 20:13:12.242710521 +0800
+++ linux-3.18.29/drivers/mmc/host/Kconfig	2017-11-21 20:13:12.434710526 +0800
@@ -773,3 +773,13 @@
 	help
 	  This selects support for the SD/MMC Host Controller on
 	  Allwinner sunxi SoCs.
+
+config MMC_DW_SFAX8
+	tristate "Siflower specific extensions for Synopsys DW Memory Card Interface"
+	depends on MMC_DW
+	help
+		This enables support for the Siflower SFAX8 SD/MMM controller, which is
+		based on Designware IP. The device is compatible with at least
+		SD 3.0, SDIO 3.0 and MMC 4.5 and supports common eMMC chips as well
+		as removeable SD and micro-SD cards.
+
Index: linux-3.18.29/drivers/mmc/host/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/mmc/host/Makefile	2017-11-21 20:13:12.242710521 +0800
+++ linux-3.18.29/drivers/mmc/host/Makefile	2017-11-21 20:13:12.434710526 +0800
@@ -48,6 +48,7 @@
 obj-$(CONFIG_MMC_DW_K3)		+= dw_mmc-k3.o
 obj-$(CONFIG_MMC_DW_PCI)	+= dw_mmc-pci.o
 obj-$(CONFIG_MMC_DW_ROCKCHIP)	+= dw_mmc-rockchip.o
+obj-$(CONFIG_MMC_DW_SFAX8)	+= dw_mmc-sfax8.o
 obj-$(CONFIG_MMC_SH_MMCIF)	+= sh_mmcif.o
 obj-$(CONFIG_MMC_JZ4740)	+= jz4740_mmc.o
 obj-$(CONFIG_MMC_VUB300)	+= vub300.o
Index: linux-3.18.29/drivers/mmc/host/dw_mmc-sfax8.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/mmc/host/dw_mmc-sfax8.c	2017-11-15 17:26:54.357090000 +0800
@@ -0,0 +1,151 @@
+/*
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/dw_mmc.h>
+#include <linux/of_address.h>
+#include <sf16a18.h>
+
+#include "dw_mmc.h"
+#include "dw_mmc-pltfm.h"
+
+#define SFAX8_CLKGEN_DIV       1
+
+static void dw_mci_sfax8_prepare_command(struct dw_mci *host, u32 *cmdr)
+{
+	*cmdr |= SDMMC_CMD_USE_HOLD_REG;
+}
+
+static int dw_mci_sfax8_setup_clock(struct dw_mci *host)
+{
+	host->bus_hz /= SFAX8_CLKGEN_DIV;
+
+	return 0;
+}
+
+#ifdef CONFIG_SF16A18_MPW0
+static void dw_mci_sfax8_set_ios(struct dw_mci *host, struct mmc_ios *ios)
+{
+	int ret;
+	unsigned int cclkin;
+	u32 bus_hz;
+
+	/*
+	 * cclkin: source clock of mmc controller
+	 * bus_hz: card interface clock generated by CLKGEN
+	 * bus_hz = cclkin / SFAX8_CLKGEN_DIV
+	 * ios->clock = (div == 0) ? bus_hz : (bus_hz / (2 * div))
+	 *
+	 * Note: div can only be 0 or 1
+	 *       if DDR50 8bit mode(only emmc work in 8bit mode),
+	 *       div must be set 1
+	 */
+	if (ios->bus_width == MMC_BUS_WIDTH_8 &&
+	    ios->timing == MMC_TIMING_MMC_DDR52)
+		cclkin = 2 * ios->clock * SFAX8_CLKGEN_DIV;
+	else
+		cclkin = ios->clock * SFAX8_CLKGEN_DIV;
+
+	ret = clk_set_rate(host->ciu_clk, cclkin);
+	if (ret)
+		dev_warn(host->dev, "failed to set rate %uHz\n", ios->clock);
+
+	bus_hz = clk_get_rate(host->ciu_clk) / SFAX8_CLKGEN_DIV;
+	if (bus_hz != host->bus_hz) {
+		host->bus_hz = bus_hz;
+		/* force dw_mci_setup_bus() */
+		host->current_speed = 0;
+	}
+}
+#endif
+
+static const struct dw_mci_drv_data sfax8_drv_data = {
+	.prepare_command        = dw_mci_sfax8_prepare_command,
+#ifdef CONFIG_SF16A18_MPW0
+	.set_ios		= dw_mci_sfax8_set_ios,
+#endif
+	.setup_clock    = dw_mci_sfax8_setup_clock,
+};
+
+static const struct of_device_id dw_mci_sfax8_match[] = {
+	{ .compatible = "siflower,sfax8-mmc",
+		.data = &sfax8_drv_data },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dw_mci_sfax8_match);
+
+static int dw_mci_sfax8_probe(struct platform_device *pdev)
+{
+	const struct dw_mci_drv_data *drv_data;
+	const struct of_device_id *match;
+
+	if(release_reset(SF_SDIO_SOFT_RESET))
+		return -EFAULT;
+
+	if(release_reset(SF_EMMC_SOFT_RESET))
+		return -EFAULT;
+
+	if (!pdev->dev.of_node)
+		return -ENODEV;
+
+	match = of_match_node(dw_mci_sfax8_match, pdev->dev.of_node);
+	drv_data = match->data;
+
+	return dw_mci_pltfm_register(pdev, drv_data);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int dw_mci_sfax8_suspend(struct device *dev)
+{
+	struct dw_mci *host = dev_get_drvdata(dev);
+
+	return dw_mci_suspend(host);
+}
+
+static int dw_mci_sfax8_resume(struct device *dev)
+{
+	struct dw_mci *host = dev_get_drvdata(dev);
+
+	return dw_mci_resume(host);
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(dw_mci_sfax8_pmops,
+			 dw_mci_sfax8_suspend,
+			 dw_mci_sfax8_resume);
+
+int dw_mci_sfax8_remove(struct platform_device *pdev)
+{
+	int ret;
+	ret = dw_mci_pltfm_remove(pdev);
+	if(hold_reset(SF_SDIO_SOFT_RESET))
+		return -EFAULT;
+
+	if(hold_reset(SF_EMMC_SOFT_RESET))
+		return -EFAULT;
+	return ret;
+}
+
+static struct platform_driver dw_mci_sfax8_pltfm_driver = {
+	.probe		= dw_mci_sfax8_probe,
+	.remove		= dw_mci_sfax8_remove,
+	.driver		= {
+		.name		= "dwmmc_sfax8",
+		.of_match_table	= dw_mci_sfax8_match,
+		.pm		= &dw_mci_sfax8_pmops,
+	},
+};
+
+module_platform_driver(dw_mci_sfax8_pltfm_driver);
+
+MODULE_AUTHOR("Mark Cai <mark.cai@siflower.com.cn>");
+MODULE_ALIAS("platform:dwmmc-sfax8");
+MODULE_LICENSE("GPL v2");
Index: linux-3.18.29/drivers/net/ethernet/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/net/ethernet/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/net/ethernet/Kconfig	2017-11-21 20:13:12.438710526 +0800
@@ -37,6 +37,7 @@
 source "drivers/net/ethernet/chelsio/Kconfig"
 source "drivers/net/ethernet/cirrus/Kconfig"
 source "drivers/net/ethernet/cisco/Kconfig"
+source "drivers/net/ethernet/siflower/Kconfig"
 
 config CX_ECAT
 	tristate "Beckhoff CX5020 EtherCAT master support"
Index: linux-3.18.29/drivers/net/ethernet/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/net/ethernet/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/net/ethernet/Makefile	2017-11-21 20:13:12.438710526 +0800
@@ -84,3 +84,4 @@
 obj-$(CONFIG_NET_VENDOR_WIZNET) += wiznet/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
+obj-$(CONFIG_NET_VENDOR_SIFLOWER) += siflower/
Index: linux-3.18.29/drivers/net/ethernet/siflower/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/Kconfig	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,54 @@
+config NET_VENDOR_SIFLOWER
+	tristate "vender siflower switch driver support sfax8"
+	help
+	  This driver supports the ethernet/switch inside
+
+if NET_VENDOR_SIFLOWER
+
+config  SFAX8_SWITCH
+	tristate "sfax8 switch driver"
+	help
+	  This driver supports the ethernet/switch inside
+
+config SFAX8_SWITCH_PTP
+	bool "PTP support"
+	depends on (SFAX8_RGMII_GMAC || SFAX8_RMII_GMAC) && (SFAX8_SWITCH)
+
+config SFAX8_SWITCH_FPGA
+	bool "Fpga version"
+	depends on (SFAX8_SWITCH)
+
+config SFAX8_SWITCH_VLAN
+	bool "vlan config enable"
+	depends on (SFAX8_SWITCH)
+
+config SFAX8_SWITCH_API
+	bool "api enable"
+	depends on (SFAX8_SWITCH)
+
+config SFAX8_SWITCH_POWERSAVE
+	bool "power save enable"
+	depends on (SFAX8_SWITCH_VLAN)
+
+config SFAX8_SWITCH_AGEING
+	bool "Ageing mac address"
+	depends on (SFAX8_SWITCH)
+
+config SFAX8_RGMII_GMAC
+tristate "vender siflower RGMII mode GMAC Ethernet driver support sf16AX8"
+	select CRC32
+	select MII
+	select PHYLIB
+	select PTP_1588_CLOCK
+	help
+	  This driver supports the RGMII mode GMAC
+
+config SFAX8_RMII_GMAC
+tristate "vender siflower RMII mode GMAC Ethernet driver support sf16AX8"
+	select CRC32
+	select MII
+	select PHYLIB
+	select PTP_1588_CLOCK
+	help
+	  This driver supports the RMII mode GMAC
+endif
Index: linux-3.18.29/drivers/net/ethernet/siflower/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/Makefile	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,17 @@
+sfax8eth-y += sf_eth.o
+sfax8eth-y += sf_debug.o
+sfax8eth-y += sf_switch.o
+sfax8eth-y += sf_switch_hash_table.o
+sfax8eth-y += sf_switch_init.o
+sfax8eth-y += sf_mdio.o
+sfax8eth-y += sf_ethtool.o
+ccflags-y += -DSF_TX_SHUTDOWN
+
+sfax8eth-$(CONFIG_SFAX8_SWITCH_PTP) += sf_ptp.o
+sfax8eth-$(CONFIG_SFAX8_SWITCH_VLAN) += genl_netlink.o
+sfax8eth-$(CONFIG_SFAX8_SWITCH_API) += sf_api.o
+
+obj-$(CONFIG_SFAX8_SWITCH)			  += sfax8eth.o
+
+obj-$(CONFIG_SFAX8_RGMII_GMAC) += sgmac.o
+obj-$(CONFIG_SFAX8_RMII_GMAC) += sgmac.o
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_api.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_api.c	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,1219 @@
+#ifdef CONFIG_SFAX8_SWITCH_API
+#include "sf_api.h"
+#endif
+#include "sf_eth.h"
+#include "sf_mdio.h"
+#include "sf_common.h"
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+#include "sf_switch.h"
+#endif
+#include "sf_eth_addr.h"
+#include "sf_switch_init.h"
+
+/* set global snoop special mac
+ * @idx decide which addr register to choose;
+ * @mac a pointer to the mac addr;
+ * @mask a pointer to the mask addr;
+ * @enable enable snoop control register,always set to 1;
+ * return 0 success,-1 fail;
+ * Description : save the special mac addr.If match the mac addr,the packet will be punted to host.
+ */
+int set_global_snoop_special_mac(int idx, unsigned long long *mac, unsigned long long *mask, int enable)
+{
+	int read_val = 0;
+	int mac_msb   = ((*mac >> 40) & 0xFF) | ((*mac >> 24) & 0xFF00);
+	int mac_lsb   = *mac & 0xFFFFFFFF;
+	int mask_msb  = ((*mask >> 40) & 0xFF) | ((*mask >> 24) & 0xFF00);
+	int mask_lsb  = *mask & 0xFFFFFFFF;
+	if(idx == 0) {
+		if(enable) {
+			read_val = sf_readl(REG_CLASS_SNOOP_CTRL);
+			sf_writel(STP_CTRL_ADDR1_REG_VAL|read_val, REG_CLASS_SNOOP_CTRL);
+
+			sf_writel(mac_lsb, REG_CLASS_SNOOP_SPL_MCAST_ADDR1_LSB);
+			sf_writel(mac_msb, REG_CLASS_SNOOP_SPL_MCAST_ADDR1_MSB);
+			sf_writel(mask_lsb, REG_CLASS_SNOOP_SPL_MCAST_MASK1_LSB);
+			sf_writel(mask_msb, REG_CLASS_SNOOP_SPL_MCAST_MASK1_MSB);
+			printk("set value 0x%x to REG_CLASS_SNOOP_CTRL,read value is 0x%x\n", (STP_CTRL_ADDR1_REG_VAL|read_val), sf_readl(REG_CLASS_SNOOP_CTRL));
+			printk("set mac_lsb 0x%x mac_msb 0x%x, read value is 0x%x 0x%x\n",
+					mac_lsb, mac_msb, sf_readl(REG_CLASS_SNOOP_SPL_MCAST_ADDR1_LSB), sf_readl(REG_CLASS_SNOOP_SPL_MCAST_ADDR1_MSB));
+			printk("set mask_lsb 0x%x mask_msb 0x%x, read value is 0x%x 0x%x\n",
+					mask_lsb, mask_msb, sf_readl(REG_CLASS_SNOOP_SPL_MCAST_MASK1_LSB), sf_readl(REG_CLASS_SNOOP_SPL_MCAST_MASK1_MSB));
+		}
+		else {
+			read_val = sf_readl(REG_CLASS_SNOOP_CTRL);
+			sf_writel((~STP_CTRL_ADDR1_REG_VAL)&read_val, REG_CLASS_SNOOP_CTRL);
+			printk("set value 0x%x to REG_CLASS_SNOOP_CTRL, read value is 0x%x\n", (~STP_CTRL_ADDR1_REG_VAL)&read_val, sf_readl(REG_CLASS_SNOOP_CTRL));
+		}
+
+	}
+	else if (idx == 1) {
+		if(enable) {
+			read_val = sf_readl(REG_CLASS_SNOOP_CTRL);
+			sf_writel(STP_CTRL_ADDR2_REG_VAL|read_val, REG_CLASS_SNOOP_CTRL);
+
+			sf_writel(mac_lsb, REG_CLASS_SNOOP_SPL_MCAST_ADDR2_LSB);
+			sf_writel(mac_msb, REG_CLASS_SNOOP_SPL_MCAST_ADDR2_MSB);
+			sf_writel(mask_lsb, REG_CLASS_SNOOP_SPL_MCAST_MASK2_LSB);
+			sf_writel(mask_msb, REG_CLASS_SNOOP_SPL_MCAST_MASK2_MSB);
+			printk("set value 0x%x to REG_CLASS_SNOOP_CTRL,read value is 0x%x\n", (STP_CTRL_ADDR2_REG_VAL|read_val), sf_readl(REG_CLASS_SNOOP_CTRL));
+			printk("set mac_lsb 0x%x mac_msb 0x%x, read value is 0x%x 0x%x\n",
+					mac_lsb, mac_msb, sf_readl(REG_CLASS_SNOOP_SPL_MCAST_ADDR2_LSB), sf_readl(REG_CLASS_SNOOP_SPL_MCAST_ADDR2_MSB));
+			printk("set mask_lsb 0x%x mask_msb 0x%x, read value is 0x%x 0x%x\n",
+					mask_lsb, mask_msb, sf_readl(REG_CLASS_SNOOP_SPL_MCAST_MASK2_LSB), sf_readl(REG_CLASS_SNOOP_SPL_MCAST_MASK2_MSB));
+
+		}
+		else {
+			read_val = sf_readl(REG_CLASS_SNOOP_CTRL);
+			sf_writel((~STP_CTRL_ADDR2_REG_VAL)&read_val, REG_CLASS_SNOOP_CTRL);
+			printk("set value 0x%x to REG_CLASS_SNOOP_CTRL,read value is 0x%x\n", (STP_CTRL_ADDR2_REG_VAL|read_val), sf_readl(REG_CLASS_SNOOP_CTRL));
+		}
+	}
+	else {
+		return -1;
+	}
+	return 0;
+}
+
+/*set mac loopback
+ *@port_list 0x1f bit 1 equivalent to port 0,bit 5 equivalent to port 4
+ *Description : decide which ports to set loopback,set to 1 means set loopback
+ */
+void set_mac_loopback(int port_list)
+{
+	int i = 0, mac_cfg = 0, value = 0;
+	for(i = 0; i < 5; i++){
+		value = port_list & (1 << i);
+		if(value){
+			mac_cfg = sf_readl(get_mac_cfg_addr(i));
+			mac_cfg |= MAC_CFG_LOOPBACK_MODE;
+			sf_writel(mac_cfg, get_mac_cfg_addr(i));
+		}
+	}
+}
+
+void set_mac_no_loopback(int port)
+{
+	int mac_cfg = 0;
+	mac_cfg = sf_readl(get_mac_cfg_addr(port));
+	mac_cfg &= ~MAC_CFG_LOOPBACK_MODE;
+	sf_writel(mac_cfg, get_mac_cfg_addr(port));
+}
+
+/* configure tmu schedulers
+ * @psch a pointer to struct tmu_schd_params_t
+ * return 0 success,-1 fail;
+ */
+int set_tmu_scheduler_config(tmu_schd_params_t *psch)
+{
+	int read_val = 0;
+
+	/*checking for allw_tdq_prog-> bit 4 in PHY0_TDQ_CTRL register */
+	read_val = sf_readl(REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * psch->tlsd_dev_id));
+
+	/* checking  for allw_tdq_prog-> 1 and hw_en -> 0 */
+	if (!(((read_val & 0x00000010) == 0x00000010) &&
+				((read_val & 0x00000002) == 0)))
+		return -1;
+
+	/* writing algorithm type */
+	sf_writel(psch->tlsd_algo,
+			REG_TMU_PHY0_SCH0_CTRL + psch->tlsd_schd_id * TMU_EACH_SCH_OFFSET +
+			TMU_EACH_PHY_OFFFSET * psch->tlsd_dev_id );
+	printk("set tmu algorithm type 0x%x ,read value is 0x%x\n", psch->tlsd_algo,
+			sf_readl(REG_TMU_PHY0_SCH0_CTRL + psch->tlsd_schd_id * TMU_EACH_SCH_OFFSET +TMU_EACH_PHY_OFFFSET * psch->tlsd_dev_id));
+
+	if(psch->tlsd_rate_units < 2){
+		sf_writel(psch->tlsd_rate_units,
+				REG_TMU_PHY0_SCH1_BIT_RATE + psch->tlsd_schd_id * TMU_EACH_SCH_OFFSET +
+				TMU_EACH_PHY_OFFFSET * psch->tlsd_dev_id );
+		printk("set tmu rate units 0x%x in scheduler,read value is 0x%x\n", psch->tlsd_rate_units,
+				sf_readl(REG_TMU_PHY0_SCH1_BIT_RATE + psch->tlsd_schd_id * TMU_EACH_SCH_OFFSET + TMU_EACH_PHY_OFFFSET * psch->tlsd_dev_id));
+	}
+
+	if (psch->tlsd_schd_id == 0) {
+		/* writing the o/p of sch0 position connection to sch1 */
+		sf_writel(psch->tlsd_position,
+				REG_TMU_PHY0_SCH0_POS +
+				TMU_EACH_PHY_OFFFSET * psch->tlsd_dev_id );
+		printk("set tmu sch0 position 0x%x ,read value is 0x%x\n", psch->tlsd_position,
+				sf_readl(REG_TMU_PHY0_SCH0_POS + TMU_EACH_PHY_OFFFSET * psch->tlsd_dev_id));
+
+		/*Update que weight*/
+		sf_writel(psch->tlsd_weight,
+				REG_TMU_PHY0_SCH0_Q0_WGHT + TMU_EACH_SCH_OFFSET * 1 + REG_LEN * psch->tlsd_position +
+				TMU_EACH_PHY_OFFFSET * psch->tlsd_dev_id );
+		printk("set tmu queue weight 0x%x ,read value is 0x%x\n", psch->tlsd_weight,
+				sf_readl(REG_TMU_PHY0_SCH0_Q0_WGHT + TMU_EACH_SCH_OFFSET * 1 + REG_LEN * psch->tlsd_position + TMU_EACH_PHY_OFFFSET * psch->tlsd_dev_id));
+	}
+
+	return 0;
+}
+
+
+/* Description : To get shaper config parameters calculated based on rate and frequency */
+int tmu_shaper_config_parameters_pps(uint rate_units, uint rate,
+		uint clk_frequency, uint *intwt, uint *frcwt, uint *clkd){
+	int wt = 0, sysclk_khz = 0, temp = 0;
+	int clkdiv = 0, trydiv = 0, w_i = 0, w_f = 0;
+
+	/*Clock division intial value*/
+	clkdiv = 2;
+
+	/*Changing Mhz to KHz*/
+	sysclk_khz = clk_frequency * 1000;
+
+	/* find the clkdiv value that gives us the largest valid wt value */
+	//define MAX_CLKDIV is 16384,MAX_WT is 0xFFFF
+	while (clkdiv < 16384) {
+		trydiv = clkdiv << 1;
+		wt = (((rate * trydiv)/sysclk_khz) * (4096));
+		if (wt > 0xFFFFF)
+			break;
+		clkdiv = trydiv;
+		temp++;
+	}
+	wt = (((rate * clkdiv)/sysclk_khz) * (4096));
+	w_i = wt >> 12;
+	w_f = wt & 0xfff;
+
+	/*Updating values*/
+	/* *clkd = clkdiv; */
+	*clkd = temp;
+	*frcwt = w_f;
+	*intwt = w_i;
+	return 0;
+}
+
+/* Description : To get shaper config parameters calculated based on rate and frequency */
+int tmu_shaper_config_parameters(uint rate_units, uint rate,
+		uint clk_frequency, uint *intwt, uint *frcwt, uint *clkd){
+	int wt = 0, sysclk_khz = 0, temp = 0;
+	int clkdiv = 0, trydiv = 0, w_i = 0, w_f = 0;
+
+	/*Clock division intial value*/
+	clkdiv = 2;
+
+	/*Changing Mhz to KHz*/
+	sysclk_khz = clk_frequency * 1023;
+
+	/* find the clkdiv value that gives us the largest valid wt value */
+	while (clkdiv < 16384) {
+		trydiv = clkdiv << 1;
+		/* wt = (rate * trydiv * (4096 / 8)) / (sysclk_khz) ; */
+		wt = (((rate * trydiv)/sysclk_khz) * (4096 / 8));
+		if (wt > 0xFFFFF)
+			break;
+		clkdiv = trydiv;
+		temp++;
+	}
+	/* wt = (rate * clkdiv * (4096 / 8)) / (sysclk_khz); */
+	wt = (((rate * clkdiv)/sysclk_khz) * (4096 / 8));
+	w_i = wt >> 12;
+	w_f = wt & 0xfff;
+
+	/*Updating values*/
+	/* *clkd = clkdiv; */
+	*clkd = temp;
+	*frcwt = w_f;
+	*intwt = w_i;
+	return 0;
+}
+
+/*configure tmu shapers
+ *@pshp a pointer to struct tmu_shpr_params_t
+ *@dynamic dynamic condition to checking appropriate value is set
+ * */
+int set_tmu_shaper_config(tmu_shpr_params_t *pshp,  uint dynamic)
+{
+	int read_val = 0;
+	int write_val = 0;
+	int intwt, frc_wt, clk_div;
+
+	/*To get shpaer config parameters
+	  calculated based on rate and frequency*/
+	if (pshp->tlsp_rate_units)
+		tmu_shaper_config_parameters_pps(pshp->tlsp_rate_units,
+				pshp->tlsp_rate,
+				pshp->tlsp_clk_frequency,
+				&intwt, &frc_wt, &clk_div);
+	else
+		tmu_shaper_config_parameters(pshp->tlsp_rate_units,
+				pshp->tlsp_rate,
+				pshp->tlsp_clk_frequency,
+				&intwt, &frc_wt, &clk_div);
+
+	/*checking for allw_tdq_prog-> bit 4 in PHY0_TDQ_CTRL register */
+	read_val = sf_readl(REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * pshp->tlsp_dev_id));
+
+	if (!dynamic) {
+		/* checking  for allw_tdq_prog-> 1 and hw_en -> 0 */
+		if (!(((read_val & 0x00000010) == 0x00000010) &&
+					((read_val & 0x00000002) == 0)))
+			return -1;
+	}
+
+	/* writing clock division value in TMU_SHP0_CTRL register */
+	write_val = SHPR_EN_BIT + (clk_div << 1);
+	sf_writel(write_val,REG_TMU_PHY0_SHP0_CTRL + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) +
+			(DEV_ADDRESS_MASK * pshp->tlsp_dev_id));
+	printk("set clk_div 0x%x,read value is 0x%x\n", write_val,
+			sf_readl(REG_TMU_PHY0_SHP0_CTRL + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) + (DEV_ADDRESS_MASK * pshp->tlsp_dev_id)));
+
+	write_val = 0;
+	/* writing fractional wght and int_wgt in TMU_SHP0_WGHT register */
+	write_val = (frc_wt & 0x00000FFF) | ((intwt & 0x000000FF) << 12);
+	sf_writel(write_val,REG_TMU_PHY0_SHP0_WGHT + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) +
+			(DEV_ADDRESS_MASK * pshp->tlsp_dev_id));
+	printk("set weight 0x%x,read value is 0x%x\n", write_val,
+			sf_readl(REG_TMU_PHY0_SHP0_WGHT + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) + (DEV_ADDRESS_MASK * pshp->tlsp_dev_id)));
+
+	write_val = 0;
+	/* writing max credit value in TMU_SHP0_MAX_CREDIT register */
+	write_val = ((pshp->tlsp_max_credit) << 10);
+	sf_writel(write_val,REG_TMU_PHY0_SHP0_MAX_CREDIT + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) +
+			(DEV_ADDRESS_MASK * pshp->tlsp_dev_id));
+	printk("set max credit value 0x%x,read value is 0x%x\n", write_val,
+			sf_readl(REG_TMU_PHY0_SHP0_MAX_CREDIT + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) + (DEV_ADDRESS_MASK * pshp->tlsp_dev_id)));
+
+	write_val = 0;
+	/* writing rate units and position in TMU_SHP0_CTRL2 register */
+	write_val =  ((pshp->tlsp_rate_units) |
+			((pshp->tlsp_position) << 1)|
+			((pshp->tlsp_mode) << 6));
+
+	sf_writel(write_val,REG_TMU_PHY0_SHP0_CTRL2 + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) +
+			(DEV_ADDRESS_MASK * pshp->tlsp_dev_id));
+	printk("set rate units and position 0x%x in shaper,read value is 0x%x\n", write_val,
+			sf_readl(REG_TMU_PHY0_SHP0_CTRL2 + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) + (DEV_ADDRESS_MASK * pshp->tlsp_dev_id)));
+
+	write_val = 0;
+	/* writing min credit in TMU_SHP0_MIN_CREDIT register */
+	write_val =  ((pshp->tlsp_min_credit));
+	sf_writel(write_val,REG_TMU_PHY0_SHP0_MIN_CREDIT + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) +
+			(DEV_ADDRESS_MASK * pshp->tlsp_dev_id));
+	printk("set min credit 0x%x,read value is 0x%x\n", write_val,
+			sf_readl(REG_TMU_PHY0_SHP0_MIN_CREDIT + (SHPR_ADDRESS_MASK * pshp->tlsp_shpr_id) + (DEV_ADDRESS_MASK * pshp->tlsp_dev_id)));
+
+	return 0;
+}
+
+/*Description : Context memory register write function Writes given value in given address.*/
+void write_fasw_context_memory(uint data, uint que_no, uint phy_no, uint reg_no)
+{
+	/* selecting register */
+	sf_writel( (reg_no + que_no * TOTAL_CONTEXT_REGS)
+			+ (phy_no << 16), REG_TMU_CNTX_ADDR);
+	printk("selecting register 0x%x ,read value is 0x%x\n", (reg_no + que_no * TOTAL_CONTEXT_REGS) + (phy_no << 16), sf_readl(REG_TMU_CNTX_ADDR));
+
+	/* initialising the register with 0 */
+	sf_writel(data, REG_TMU_CNTX_DATA);
+	printk("initialising register with 0x%x ,read value is 0x%x\n", data, sf_readl(REG_TMU_CNTX_DATA));
+
+	/* csr_cntx_ind_cmd -> 1 and csr_cntx_ind_start->1 */
+	sf_writel(WRITE_CMD, REG_TMU_CNTX_CMD);
+	sf_writel( WRITE_CMD + START_CMD, REG_TMU_CNTX_CMD);
+	printk("set csr_cntx_ind_cmd and csr_cntx_ind_start 0x%x ,read value is 0x%x\n",WRITE_CMD + START_CMD, sf_readl(REG_TMU_CNTX_CMD));
+
+	/* poll for csr_cntx_ind_done bit */
+	while (!(sf_readl(REG_TMU_CNTX_CMD)
+				& DONE_BIT));  /* End of while loop */
+
+}
+
+/*Description : Helper function for pcm_classq_add() Function*/
+int tmu_add_queue2scheduler(tmu_classq_params_t *que)
+{
+	uint read_val = 0;
+	uint read_val1 = 0, read_val2 = 0;
+
+	/*Loop for number of achedulers*/
+	/*Read Alloc0 register*/
+	read_val1 = sf_readl(REG_TMU_PHY0_SCH0_Q_ALLOC0 + SHED_ADDRESS_MASK * que->tlcq_schd_id +
+			(DEV_ADDRESS_MASK * que->tlcq_dev_id));
+	/*Read alloc1 register*/
+	read_val2 = sf_readl(REG_TMU_PHY0_SCH0_Q_ALLOC1 + SHED_ADDRESS_MASK * que->tlcq_schd_id +
+			(DEV_ADDRESS_MASK * que->tlcq_dev_id));
+
+	/*Switch to select que priority*/
+	switch (que->tlcq_schd_slot) {
+		case SCH_SLOT_ZERO:
+			/*Update alloc register with given queue number*/
+			read_val1 = (read_val1 & 0xFFFFFFF0) |
+				(que->tlcq_classq_id & 0x0000000F);
+			break;
+		case SCH_SLOT_ONE:
+			/*Update alloc register with given queue number*/
+			read_val1 = (read_val1 & 0xFFFFF0FF) |
+				((que->tlcq_classq_id & 0x0000000F) << 8);
+			break;
+		case SCH_SLOT_TWO:
+			/*Update alloc register with given queue number*/
+			read_val1 = (read_val1 & 0xFFF0FFFF) |
+				((que->tlcq_classq_id & 0x0000000F) << 16);
+			break;
+		case SCH_SLOT_THREE:
+			/*Update alloc register with given queue number*/
+			read_val1 = (read_val1 & 0xF0FFFFFF) |
+				((que->tlcq_classq_id & 0x0000000F) << 24);
+			break;
+		case SCH_SLOT_FOUR:
+			/*Update alloc register with given queue number*/
+			read_val2 = (read_val2 & 0xFFFFFFF0) | (que->tlcq_classq_id & 0x0000000F);
+			break;
+		case SCH_SLOT_FIVE:
+			/*Update alloc register with given queue number*/
+			read_val2 = (read_val2 & 0xFFFFF0FF) | ((que->tlcq_classq_id & 0x0000000F) << 8);
+			break;
+		case SCH_SLOT_SIX:
+			/*Update alloc register with given queue number*/
+			read_val2 = (read_val2 & 0xFFF0FFFF) | ((que->tlcq_classq_id & 0x0000000F) << 16);
+			break;
+		case SCH_SLOT_SEVEN:
+			/*Update alloc register with given queue number*/
+			read_val2 = (read_val2 & 0xF0FFFFFF) | ((que->tlcq_classq_id & 0x0000000F) << 24);
+			break;
+		default:
+			break;
+	}
+
+	/*checking for allw_tdq_prog-> bit 4 in PHY0_TDQ_CTRL register */
+	read_val = sf_readl(REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * que->tlcq_dev_id));
+
+	/* checking  for allw_tdq_prog-> 1 and hw_en -> 0 */
+	if (!(((read_val & 0x00000010) == 0x00000010) &&
+				((read_val & 0x00000002) == 0))) {
+
+		return -1;
+	}
+
+	/*Update que weight*/
+	sf_writel(que->tlcq_weight,REG_TMU_PHY0_SCH0_Q0_WGHT + REG_LEN * que->tlcq_classq_id +
+			SHED_ADDRESS_MASK * que->tlcq_schd_id + (DEV_ADDRESS_MASK * que->tlcq_dev_id ));
+
+	/*Write que number into hardware*/
+	if (que->tlcq_schd_slot < SCH_SLOT_FOUR) {
+
+		sf_writel(read_val1,REG_TMU_PHY0_SCH0_Q_ALLOC0 +
+				SHED_ADDRESS_MASK * que->tlcq_schd_id + (DEV_ADDRESS_MASK * que->tlcq_dev_id ));
+
+	} else {
+
+		sf_writel(read_val2,REG_TMU_PHY0_SCH0_Q_ALLOC1 +
+				SHED_ADDRESS_MASK * que->tlcq_schd_id + (DEV_ADDRESS_MASK * que->tlcq_dev_id));
+	}
+
+	return 0;
+}
+
+/*Description : This function adds classq for a given scheduler*/
+int set_tmu_classq_add(tmu_classq_params_t *que)
+{
+	uint write_val = 0;
+
+	if (que->tlcq_qmgmt == TMU_QUE_TAIL_DROP) {
+		/* writing queue managment in register */
+
+		/* Qmax: Qmin : cfg = ([19:11],[10:2],[1:0]) */
+		write_val = ((que->tlcq_max_len) << 11) + que->tlcq_qmgmt;
+
+		write_fasw_context_memory(write_val, que->tlcq_classq_id,
+				que->tlcq_dev_id, CURQ_QMAX_QMIN_CFG);
+
+		/* if queue management is WRED */
+	} else if (que->tlcq_qmgmt == TMU_QUE_WRED) {
+		/* writing queue managment , Qmax and Qmin values to register */
+
+		write_val = 0;
+		/* Qmax: Qmin : cfg = ([19:11],[10:2],[1:0]) */
+		write_val = ((que->tlcq_max_len) << 11) +
+			((que->tlcq_min_len) << 2) + que->tlcq_qmgmt;
+
+		write_fasw_context_memory(write_val, que->tlcq_classq_id,
+				que->tlcq_dev_id, CURQ_QMAX_QMIN_CFG);
+
+		/* writing probability values to prob_cfg registers */
+		write_val = 0;
+		write_val = ((que->tlcq_prob_cfg5) << 25) +
+			((que->tlcq_prob_cfg4) << 20) +
+			((que->tlcq_prob_cfg3) << 15) +
+			((que->tlcq_prob_cfg2) << 10) +
+			((que->tlcq_prob_cfg1) << 5) +
+			que->tlcq_prob_cfg0;
+		write_fasw_context_memory(write_val, que->tlcq_classq_id,
+				que->tlcq_dev_id, CURQ_HW_PROB_CFG_TBL0);
+
+		write_val = 0;
+		write_val = ((que->tlcq_prob_cfg7) << 5) +
+			que->tlcq_prob_cfg6;
+		write_fasw_context_memory(write_val, que->tlcq_classq_id,
+				que->tlcq_dev_id,
+				CURQ_HW_PROB_CFG_TBL1);
+
+	}
+
+	/*Add queue to scheduler*/
+	tmu_add_queue2scheduler(que);
+
+	return 0;
+}
+
+void set_tmu_tdq_default_enable(void) {
+	sf_writel(TMU_HW_EN, REG_TMU_PHY0_TDQ_CTRL);
+	sf_writel(TMU_HW_EN, REG_TMU_PHY1_TDQ_CTRL);
+	sf_writel(TMU_HW_EN, REG_TMU_PHY2_TDQ_CTRL);
+	sf_writel(TMU_HW_EN, REG_TMU_PHY3_TDQ_CTRL);
+	sf_writel(TMU_HW_EN, REG_TMU_PHY4_TDQ_CTRL);
+	sf_writel(TMU_HW_EN, REG_TMU_PHY5_TDQ_CTRL);
+	printk("set tmu HW_EN 0x%x for every port, read value is port0 0x%x port1 0x%x port2 0x%x port3 0x%x port4 0x%x port 5 0x%x\n",TMU_HW_EN,
+			sf_readl(REG_TMU_PHY0_TDQ_CTRL), sf_readl(REG_TMU_PHY1_TDQ_CTRL), sf_readl(REG_TMU_PHY2_TDQ_CTRL),
+			sf_readl(REG_TMU_PHY3_TDQ_CTRL), sf_readl(REG_TMU_PHY4_TDQ_CTRL), sf_readl(REG_TMU_PHY5_TDQ_CTRL));
+}
+
+/*TMU_PHY0_TDQ_CTRL
+ *Description:	bit 0 - shp_clk_cntrl_en
+ *				bit 1 - hw_en for tdq_sch_shaper
+ *				bit 3:2 - for enabling the schedulers
+ *				bit 4 - allw_tdq_prog
+ * */
+int set_tmu_tdq_enable(int dev_no, int enable)
+{
+	int read_val = 0,write_val = 0;
+
+	if(enable) {
+		/*making the hw_en -> 1 */
+		read_val = sf_readl(REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * dev_no));
+		write_val = (read_val & 0xFFFFFFFD) | 0x2;
+		sf_writel(write_val, REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * dev_no));
+		printk("set tmu_tdg_enable 0x%x ,read value is 0x%x\n", write_val, sf_readl(REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * dev_no)));
+
+	}
+	else {
+		/*making the hw_en -> 0 */
+		read_val = sf_readl(REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * dev_no));
+		write_val = read_val & 0xFFFFFFFD;
+		sf_writel(write_val, REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * dev_no));
+		printk("set dev_no %d tmu_tdg_disable 0x%x ,read value is 0x%x\n", dev_no, write_val, sf_readl(REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * dev_no)));
+		/* polling for allw_tdq_prog-> 1 */
+		while (!((sf_readl(REG_TMU_PHY0_TDQ_CTRL + (REG_LEN * dev_no)) & 0x00000010) == 0x00000010)); /* End of while loop */
+	}
+	return 0;
+}
+
+/*set tmu various configure
+ *@tsch_in scheduler parameters;
+ *@tshp_in shaper parameters;
+ *@tque_in queues parameters;
+ *@port_list port list;
+ *Description : set tmu configure,else with default.
+ * */
+int set_tmu_various_cfg(tmu_schd_params_t* tsch_in,tmu_shpr_params_t* tshp_in, tmu_classq_params_t* tque_in,int port_list)
+{
+	int i = 0, j = 0;
+	int  phy_no = 0, max_dev_no = 0, ret_val = 0;
+	tmu_schd_params_t tsch;
+	tmu_shpr_params_t tshp;
+	tmu_classq_params_t tque;
+
+	memset(&tsch, 0, sizeof(tmu_schd_params_t));
+	memset(&tshp, 0, sizeof(tmu_shpr_params_t));
+	memset(&tque, 0, sizeof(tmu_classq_params_t));
+
+	max_dev_no = TMU_MAX_DEV_NUM;
+
+	for (phy_no = 0; phy_no < max_dev_no; phy_no++) {
+		if((port_list != 0) && ((port_list & (0x1 << phy_no)) == 0))
+			continue;
+		set_tmu_tdq_enable(phy_no, 0);
+	}
+
+	/*Scheduler config*/
+	for (j = 1; j <= max_dev_no; j++) {
+		if((port_list != 0) && ((port_list & (0x1 << (j-1) )) == 0))
+			continue;
+
+		for (i = 1; i <= TMU_MAX_SCHED_NUM; i++) {
+			if (i == 1) {
+				tsch.tlsd_position = 1;
+				if(tsch_in) {
+					tsch.tlsd_algo = tsch_in->tlsd_algo;
+					tsch.tlsd_weight = tsch_in->tlsd_weight;
+					tsch.tlsd_rate_units = tsch_in->tlsd_rate_units;
+				}
+				else {
+					tsch.tlsd_algo = 3; /* Round Robbin */
+				}
+			} else {
+				if(tsch_in){
+					tsch.tlsd_algo = tsch_in->tlsd_algo;
+					tsch.tlsd_weight = tsch_in->tlsd_weight;
+					tsch.tlsd_rate_units = tsch_in->tlsd_rate_units;
+				}
+				else {
+					tsch.tlsd_algo = 0; /* priority queuing */
+				}
+			}
+			tsch.tlsd_dev_id = j;
+			tsch.tlsd_schd_id = i;
+			ret_val = set_tmu_scheduler_config(&tsch);
+
+		}
+	}
+
+	/*Shaper config*/
+	for (j = 1; j <= max_dev_no; j++) {
+		if((port_list != 0) && ((port_list & (0x1 << (j-1) )) == 0))
+			continue;
+
+		for (i = 1; i <= TMU_MAX_SHPR_NUM; i++) {
+
+			if(tshp_in){
+				tshp.tlsp_max_credit = tshp_in->tlsp_max_credit;
+				tshp.tlsp_rate_units = tshp_in->tlsp_rate_units;
+				/* 40 Mhz system clock */
+				tshp.tlsp_clk_frequency  = tshp_in->tlsp_clk_frequency;
+				tshp.tlsp_rate  = tshp_in->tlsp_rate ; /* 50Mbps */
+			}
+			else {
+				tshp.tlsp_max_credit = 0x3FFE00;
+				tshp.tlsp_rate_units = 1;
+				/* 40 Mhz system clock */
+				tshp.tlsp_clk_frequency  = 250;
+				tshp.tlsp_rate  = 100000; /* 100Mbps */
+			}
+			tshp.tlsp_dev_id = j;
+			tshp.tlsp_shpr_id = i;
+			/* shaper 0 and 1 are connected to SP7 and SP8 */
+			/* shaper 2 and 3 are Invalid */
+			if (i < 3) {
+				if(tshp_in){
+					tshp.tlsp_mode = tshp_in->tlsp_mode; /*0x1-credit based mode */
+				}
+				else {
+					tshp.tlsp_mode = 0x1; /*0x1-credit based mode */
+				}
+				tshp.tlsp_position = i+7;
+			} else {
+				tshp.tlsp_mode = 0x0; /*0x1-credit based mode */
+				tshp.tlsp_position = 18;
+			}
+			if (tshp.tlsp_mode == 0)
+				tshp.tlsp_min_credit = (tshp.tlsp_max_credit);
+			else
+				tshp.tlsp_min_credit = tshp.tlsp_max_credit;
+			ret_val = set_tmu_shaper_config(&tshp, 0);
+		}
+	}
+
+	/* queues adding*/
+	for (j = 1; j <= max_dev_no; j++) {
+		if((port_list != 0) && ((port_list & (0x1 << (j-1) )) == 0))
+			continue;
+
+		for (i = 1; i <= TMU_MAX_QUE_NO; i++) {
+			if(tque_in) {
+				tque.tlcq_qmgmt  =  tque_in->tlcq_qmgmt;
+				tque.tlcq_max_len = tque_in->tlcq_max_len;
+				if(tque.tlcq_qmgmt == TMU_QUE_WRED) {
+					tque.tlcq_min_len   = tque_in->tlcq_min_len;
+					tque.tlcq_prob_cfg0 = tque_in->tlcq_prob_cfg0;
+					tque.tlcq_prob_cfg1 = tque_in->tlcq_prob_cfg1;
+					tque.tlcq_prob_cfg2 = tque_in->tlcq_prob_cfg2;
+					tque.tlcq_prob_cfg3 = tque_in->tlcq_prob_cfg3;
+					tque.tlcq_prob_cfg4 = tque_in->tlcq_prob_cfg4;
+					tque.tlcq_prob_cfg5 = tque_in->tlcq_prob_cfg5;
+					tque.tlcq_prob_cfg6 = tque_in->tlcq_prob_cfg6;
+					tque.tlcq_prob_cfg7 = tque_in->tlcq_prob_cfg7;
+				}
+				else {
+					tque.tlcq_max_len =  tque_in->tlcq_max_len;
+					tque.tlcq_qmgmt = 1;
+				}
+			}
+			else {
+				tque.tlcq_max_len = 100;
+				tque.tlcq_qmgmt = 0;
+			}
+			tque.tlcq_weight = 0x3fe;
+			tque.tlcq_dev_id = j;
+			tque.tlcq_classq_id = i;
+
+			if ((i == 3) || (i == 4)) {
+				tque.tlcq_schd_id = 2;
+				/* Actuval Q2 and Q3 connected to schedular-1, q6 and q7 */
+				tque.tlcq_schd_slot = i+4;
+			} else {
+				tque.tlcq_schd_id = 1;
+				tque.tlcq_schd_slot = i;
+			}
+			ret_val = set_tmu_classq_add(&tque);
+		}
+	}
+
+	/* HW enable for the tdq fsm */
+	set_tmu_tdq_default_enable();
+	return 0;
+
+}
+
+int get_gpi_addr_base( int dev_no)
+{
+	int addr = 0;
+	switch (dev_no)
+	{
+		case 0 :
+			addr = EGPI0_BASE_OFFSET;
+			break;
+		case 1 :
+			addr = EGPI1_BASE_OFFSET;
+			break;
+		case 2 :
+			addr = EGPI2_BASE_OFFSET;
+			break;
+		case 3 :
+			addr = EGPI3_BASE_OFFSET;
+			break;
+		case 4 :
+			addr = EGPI4_BASE_OFFSET;
+			break;
+		case 5 :
+			addr = HGPI_BASE_OFFSET;
+			break;
+		default:
+			break;
+	}
+	return addr;
+}
+
+/*npu gpi ingress config
+ *@pshp shaper parameters;
+ *@dev_no device number;
+ *@effect Bits [1:0] value 00 Shaper0 is for port level data rate,
+ *value 01 Shaper0 is for BCAST Packets, value 10 Shaper0 is for MCAST Packets.
+ *		  Bits [3:2] value 00 Shaper1 is for port level data rate,
+ *value 01 Shaper1 is for BCAST Packets, value 10 Shaper1 is for MCAST Packets
+ *Description : ingress qos, config shape register.
+ * */
+int npu_gpi_ingress_config(tmu_shpr_params_t * pshp, int dev_no, int effect)
+{
+	int reg_shp_config = 0, reg_shp0_ctrl = 0, reg_shp0_wght = 0, reg_shp1_ctrl = 0, reg_shp1_wght = 0;
+	reg_shp_config = get_gpi_addr_base(dev_no) + REG_EGPI_PORT_SHP_CONFIG;
+	reg_shp0_ctrl = get_gpi_addr_base(dev_no) + REG_EGPI_PORT_SHP0_CTRL;
+	reg_shp0_wght = get_gpi_addr_base(dev_no) + REG_EGPI_PORT_SHP0_WGHT;
+	reg_shp1_ctrl = get_gpi_addr_base(dev_no) + REG_EGPI_PORT_SHP1_CTRL;
+	reg_shp1_wght = get_gpi_addr_base(dev_no) + REG_EGPI_PORT_SHP1_WGHT;
+
+	if(pshp == NULL){
+		sf_writel(0x10,     reg_shp_config);
+		sf_writel(0x3fff0005, reg_shp0_ctrl);
+		sf_writel(0x260,    reg_shp0_wght);
+        sf_writel(0x3fff0005, reg_shp1_ctrl);
+        sf_writel(0x260,    reg_shp1_wght);
+    }
+    else{
+        int intwt = 0, frc_wt = 0, clk_div = 0, write_val = 0;
+
+        if (pshp->tlsp_rate_units)
+            tmu_shaper_config_parameters_pps(pshp->tlsp_rate_units,pshp->tlsp_rate,pshp->tlsp_clk_frequency,&intwt, &frc_wt, &clk_div);
+        else
+            tmu_shaper_config_parameters(pshp->tlsp_rate_units,pshp->tlsp_rate,pshp->tlsp_clk_frequency, &intwt, &frc_wt, &clk_div);
+
+        //write clk div && max credit
+        write_val = SHPR_EN_BIT | (clk_div << 0x1) | (pshp->tlsp_max_credit << 0x8);
+        sf_writel(write_val, reg_shp0_ctrl);
+        sf_writel(write_val, reg_shp1_ctrl);
+		printk("set value 0x%x to reg_shp0_ctrl and reg_shp1_ctrl,read value is 0x%x 0x%x\n", write_val, sf_readl(reg_shp0_ctrl), sf_readl(reg_shp1_ctrl));
+        write_val = 0;
+        //write weight
+        write_val = (frc_wt & 0x000000FF) | ((intwt & 0x0007) << 8);
+        sf_writel(write_val, reg_shp0_wght);
+        sf_writel(write_val, reg_shp1_wght);
+		printk("set value 0x%x to reg_shp0_wght and reg_shp1_wght,read value is 0x%x 0x%x\n", write_val, sf_readl(reg_shp0_wght), sf_readl(reg_shp1_wght));
+        //write data units && effect
+        write_val = 0;
+        write_val = pshp->tlsp_rate_units | (pshp->tlsp_rate_units << 0x1 ) | (effect << 0x2);
+        sf_writel(write_val,reg_shp_config);
+		printk("set value 0x%x to reg_shp_config,read value is 0x%x\n", write_val, sf_readl(reg_shp_config));
+    }
+
+    return 0;
+}
+
+/*set global cutthru etype
+ *@port_list 0x3f global ports
+ *@cutthru_type cutthru type
+ * */
+int set_cutthru(int port_list, int cutthru_type)
+{
+	//init global cutthru list
+	//indicates etype/tpid will be rewritten on some egress ports
+	sf_writel( port_list| (cutthru_type << CUTTHRU_TYPE_START_POS),
+			REG_CLASS_HW_GLOBAL_CUTTHRU_REG);
+	printk("set value 0x%x to REG_CLASS_HW_GLOBAL_CUTTHRU_REG,read value is 0x%x\n",
+			(port_list| (cutthru_type << CUTTHRU_TYPE_START_POS)), sf_readl(REG_CLASS_HW_GLOBAL_CUTTHRU_REG));
+
+	return 0;
+}
+
+/*set dos register's value
+ *@item decide which dos filter module to load or choose a function;
+ *@value decide which type to filtering or what value set;
+ *return 0 success, 0 fail.
+ * */
+int set_dos_value(int item, int value)
+{
+    int address = 0, write_val = 0,read_val = 0;
+    switch ( item )
+    {
+        case DOS_ENABLE :
+            address = REG_CLASS_DOS_CONTRL1;
+            read_val = sf_readl(address);
+            write_val = (value & DOS_ALL_ENABLE_MASK) | (read_val & (~DOS_ALL_ENABLE_MASK));
+            break;
+
+        case DOS_FILTER_ENABLE :
+            address = REG_CLASS_DOS_CONTRL2;
+            read_val = sf_readl(address);
+            switch(value) {
+                case IPV4_SIP_EQ_DIP_EN:
+                    write_val = read_val| 0x1;
+                    break;
+                case IPV4_ICMP_FRAG_EN:
+                    write_val = read_val| (0x1 << 1);
+                    break;
+                case IPV4_ICMP_PING_TOO_BIG_EN:
+                    write_val = read_val| (0x1 << 2);
+                    break;
+                case IPV4_UDP_SP_EQ_DP_EN:
+                    write_val = read_val| (0x1 << 3);
+                    break;
+                case IPV4_TCP_FLAG_CHK:
+                    write_val = read_val| (0x1 << 4);
+                    break;
+                case IPV4_TCP_SP_EQ_DP:
+                    write_val = read_val| (0x1 << 5);
+                    break;
+                case IPV4_TCP_FRAG_OFF1:
+                    write_val = read_val| (0x1 << 6);
+                    break;
+                case IPV4_TCP_SYN_ERR:
+                    write_val = read_val| (0x1 << 7);
+                    break;
+                case IPV4_TCP_XMAS:
+                    write_val = read_val| (0x1 << 8);
+                    break;
+                case IPV4_TCP_NULL:
+                    write_val = read_val| (0x1 << 9);
+                    break;
+                case IPV6_SIP_EQ_DIP_EN:
+                    write_val = read_val| (0x1 << 16);
+                    break;
+                case IPV6_ICMP_FRAG_EN:
+                    write_val = read_val| (0x1 << 17);
+                    break;
+                case IPV6_ICMP_PING_TOO_BIG_EN:
+                    write_val = read_val| (0x1 << 18);
+                    break;
+                case IPV6_UDP_SP_EQ_DP_EN:
+                    write_val = read_val| (0x1 << 19);
+                    break;
+                case IPV6_TCP_FLAG_CHK:
+                    write_val = read_val| (0x1 << 20);
+                    break;
+                case IPV6_TCP_SP_EQ_DP:
+                    write_val = read_val| (0x1 << 21);
+                    break;
+                case IPV6_TCP_FRAG_OFF1:
+                    write_val = read_val| (0x1 << 22);
+                    break;
+                case IPV6_TCP_SYN_ERR:
+                    write_val = read_val| (0x1 << 23);
+                    break;
+                case IPV6_TCP_XMAS:
+                    write_val = read_val| (0x1 << 24);
+                    break;
+                case IPV6_TCP_NULL:
+                    write_val = read_val| (0x1 << 25);
+                    break;
+                default:
+                    break;
+            }
+            break;
+
+        case DOS_COMB_FILTER_ENABLE :
+            address = REG_CLASS_DOS_CONTRL1;
+            read_val = sf_readl(address);
+            switch(value) {
+                case COMB_FILTER_1:
+                    write_val = ((0x1 & DOS_COMB_CONTROL_MASK) << DOS_COMB_CONTROL_START_POS) | read_val;
+                    break;
+                case COMB_FILTER_2:
+                    write_val = (((0x1 << 1) & DOS_COMB_CONTROL_MASK) << DOS_COMB_CONTROL_START_POS) | read_val;
+                    break;
+                case COMB_FILTER_3:
+                    write_val = (((0x1 << 2) & DOS_COMB_CONTROL_MASK) << DOS_COMB_CONTROL_START_POS) | read_val ;
+                    break;
+                case COMB_FILTER_4:
+                    write_val = (((0x1 << 3) & DOS_COMB_CONTROL_MASK) << DOS_COMB_CONTROL_START_POS) | read_val;
+                    break;
+                default:
+                    break;
+            }
+            break;
+
+        case DOS_COMB_FILTER_VALUE :
+            address = REG_CLASS_DOS_TCP_FLAGCHK_COMB_VALUE1;
+            write_val = (value & DOS_COMB_VALUE_MASK);
+            break;
+
+        case DOS_ICMPV4_MAX_LEN :
+            address = REG_CLASS_DOS_ICMPV4_MAX_PKTLEN;
+            write_val = (value & DOS_IPV4_MAX_LEN_MASK);
+            break;
+
+        default:
+            return -1;
+    }
+
+	sf_writel(write_val, address);
+	printk("write value 0x%x to address 0x%x,read value 0x%x\n", write_val, address, sf_readl(address));
+    return 0;
+}
+
+/*2 Bit TC_Sel value mapping to DSCP2TC or PCP2TC or PID2TC as given below
+  TC_SEL[1:0] == 0 -> DSCP2TC map
+  TC_SEL[1:0] == 1 -> PCP2TC Map
+  TC_Sel[1:0] == 2 -> MACDA2TC Map
+  TC_Sel[1:0] == 3 -> PID2TC Map
+  */
+int set_tc_sel(int port, int map) {
+	int val = 0, addr =0;
+	switch(port){
+		case 0:
+			val = sf_readl(REG_CLASS_QOS_PORT01_TC_SEL);
+            val &= 0xFFFF0000;
+            map &= 0x0000FFFF;
+            addr = REG_CLASS_QOS_PORT01_TC_SEL;
+			break;
+
+        case 1:
+            val = sf_readl(REG_CLASS_QOS_PORT01_TC_SEL);
+            val &= 0x0000FFFF;
+            map &= 0xFFFF0000;
+            addr = REG_CLASS_QOS_PORT01_TC_SEL;
+            break;
+
+        case 2:
+            val = sf_readl(REG_CLASS_QOS_PORT23_TC_SEL);
+            val &= 0xFFFF0000;
+            map &= 0x0000FFFF;
+            addr = REG_CLASS_QOS_PORT23_TC_SEL;
+            break;
+
+        case 3:
+            val = sf_readl(REG_CLASS_QOS_PORT23_TC_SEL);
+            val &= 0x0000FFFF;
+            map &= 0xFFFF0000;
+            addr = REG_CLASS_QOS_PORT23_TC_SEL;
+            break;
+
+        case 4:
+            val = sf_readl(REG_CLASS_QOS_PORT45_TC_SEL);
+            val &= 0xFFFF0000;
+            map &= 0x0000FFFF;
+            addr = REG_CLASS_QOS_PORT45_TC_SEL;
+            break;
+
+        case 5:
+            val = sf_readl(REG_CLASS_QOS_PORT45_TC_SEL);
+            val &= 0x0000FFFF;
+            map &= 0xFFFF0000;
+            addr = REG_CLASS_QOS_PORT45_TC_SEL;
+            break;
+
+        default:
+            return -1;
+			break;
+    }
+
+	sf_writel(map|val, addr);
+	printk("set TC_Sel value 0x%x, read value is 0x%x\n", map|val, sf_readl(addr));
+    return 0;
+}
+
+/*provides the TC value to be mapped for each PCP of the packet.*/
+int set_pcp2tc_map(int port,int map){
+	int addr = 0;
+	switch(port){
+		case 0:
+			addr = REG_CLASS_QOS_PORT0_PCP2TC_MAP;
+			break;
+		case 1:
+			addr = REG_CLASS_QOS_PORT1_PCP2TC_MAP;
+			break;
+		case 2:
+			addr = REG_CLASS_QOS_PORT2_PCP2TC_MAP;
+			break;
+		case 3:
+			addr = REG_CLASS_QOS_PORT3_PCP2TC_MAP;
+			break;
+		case 4:
+			addr = REG_CLASS_QOS_PORT4_PCP2TC_MAP;
+			break;
+		case 5:
+			addr = REG_CLASS_QOS_PORT5_PCP2TC_MAP;
+			break;
+		default:
+			return -1;
+			break;
+	}
+	sf_writel(map, addr);
+	printk("set pcp2tc_map 0x%x ,read value is 0x%x\n", map, sf_readl(addr));
+	return 0;
+}
+
+/*Based on the packet receive Ingress port, the respect PID value is mapped as TC*/
+int set_pid2tc_map(int map){
+	sf_writel(map, REG_CLASS_QOS_PORT_PID2TC_MAP);
+	printk("set map 0x%x to REG_CLASS_QOS_PORT_PID2TC_MAP,read value is 0x%x\n", map, sf_readl(REG_CLASS_QOS_PORT_PID2TC_MAP));
+	return 0;
+}
+
+int set_tc_sel_one_to_one(int port, int type)
+{
+	int map = 0;
+	switch(type){
+		case TC_DSCP:
+			map = 0;
+			break;
+		case TC_PCP:
+			map = 0x5555;
+			break;
+		case TC_PID:
+			map = 0xAAAA;
+			break;
+		case TC_MACDA:
+			map = 0xFFFF;
+			break;
+		default:
+			break;
+	}
+
+	switch(port){
+		case 0:
+			set_tc_sel(0, map);
+			break;
+		case 1:
+			set_tc_sel(1, map);
+			break;
+		case 2:
+			set_tc_sel(2, map);
+			break;
+		case 3:
+			set_tc_sel(3, map);
+			break;
+		case 4:
+			set_tc_sel(4, map);
+			break;
+		case 5:
+			set_tc_sel(5, map);
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+/*set global management ether type
+ *@mgmt_type management ether type, always set to 0x8100
+ * */
+int set_global_mgmt_port(int port, int mgmt_type)
+{
+	sf_writel(mgmt_type| (port << GLOBAL_MGMT_PORT_START_POS),
+			REG_CLASS_GLOBAL_MGMT_REG);
+	printk("set global mgmt_type 0x%x to port address,read value is 0x%x\n", mgmt_type| (port << GLOBAL_MGMT_PORT_START_POS), sf_readl(REG_CLASS_GLOBAL_MGMT_REG));
+	return 0;
+}
+
+/*set port control*/
+int set_port_enable(int port_num,int enable)
+{
+	int addr2 = get_port_address(port_num,2);
+	int val = ((enable -1) < 0) ? 1 : 0;
+	int tmp = sf_readl(addr2);
+	if(addr2 != 0){
+		tmp &= ~PORT_SHUTDOWN_MASK;
+		sf_writel( ((val << PORT_SHUTDOWN_START_POS) & PORT_SHUTDOWN_MASK)| tmp, addr2);
+		printk("set port control 0x%x to port address,read value is 0x%x\n", ((val << PORT_SHUTDOWN_START_POS) & PORT_SHUTDOWN_MASK)| tmp, sf_readl(addr2));
+	}
+	return 0;
+}
+
+/*set port vlan attribute*/
+int set_port_vlan_attr(int port_num, int attr)
+{
+	int addr2 = get_port_address(port_num,2);
+	int tmp = sf_readl(addr2);
+	if(addr2 != 0){
+		tmp &= ~PORT_AFT_MASK;
+		sf_writel( ((attr<< PORT_AFT_START_POS) & PORT_AFT_MASK)| tmp, addr2);
+		printk("set port vlan_attr 0x%x to port address,read value is 0x%x\n", ((attr<< PORT_AFT_START_POS) & PORT_AFT_MASK)| tmp, sf_readl(addr2));
+	}
+	return 0;
+}
+
+/*set global snoop ethertype
+ *@idx decide snoop ethertype module;
+ *@snoop_etype decide snoop ethertype value;
+ *@enable enable or shutdown.
+ * */
+int set_global_snoop_ethertype(int idx, unsigned long long* snoop_etype, int enable)
+{
+    int read_val = 0, set_val = 0;
+    switch ( idx ){
+        case SNOOP_IGMP :
+            if(enable)
+                set_val = 0x1 << SNOOP_IGMP;
+            else
+                set_val = ~(0x1 << SNOOP_IGMP);
+            break;
+        case SNOOP_ETYPE0:
+            if(enable){
+                int read_val = sf_readl(REG_CLASS_SNOOP_SPL_ETYPE_REG01);
+                sf_writel( (((*snoop_etype >> 8) & 0x00ff) | ((*snoop_etype << 8) & 0xff00) | (read_val & 0xffff0000)), REG_CLASS_SNOOP_SPL_ETYPE_REG01);
+                set_val = 0x1 << SNOOP_ETYPE0;
+            }
+            else
+                set_val = ~(0x1 << SNOOP_ETYPE0);
+            break;
+        case SNOOP_ETYPE1 :
+            if(enable){
+                int read_val = sf_readl(REG_CLASS_SNOOP_SPL_ETYPE_REG01);
+                sf_writel( (((*snoop_etype >> 8) & 0x00ff) | ((*snoop_etype << 8) & 0xff00) | (read_val & 0x0000ffff)), REG_CLASS_SNOOP_SPL_ETYPE_REG01);
+                set_val = 0x1 << SNOOP_ETYPE1;
+            }
+            else
+                set_val = ~(0x1 << SNOOP_ETYPE1);
+            break;
+        case SNOOP_ETYPE2:
+            if(enable){
+                sf_writel( (((*snoop_etype >> 8) & 0x00ff) | ((*snoop_etype << 8) & 0xff00)), REG_CLASS_SNOOP_SPL_ETYPE_REG23);
+                set_val = 0x1 << SNOOP_ETYPE2;
+            }
+            else
+                set_val = ~(0x1 << SNOOP_ETYPE2);
+            break;
+        case SNOOP_ETYPE3:
+            if(enable){
+                sf_writel( ((((*snoop_etype >> 8) & 0x00ff) | ((*snoop_etype << 8) & 0xff00)) << 16), REG_CLASS_SNOOP_SPL_ETYPE_REG23);
+                set_val = 0x1 << SNOOP_ETYPE3;
+            }
+            else
+                set_val = ~(0x1 << SNOOP_ETYPE3);
+            break;
+        case SNOOP_ETYPE_ARP:
+            if(enable)
+                set_val = 0x1 << SNOOP_ETYPE_ARP;
+            else
+                set_val = ~(0x1 << SNOOP_ETYPE_ARP);
+            break;
+        case SNOOP_ETYPE_RARP:
+
+            if(enable)
+                set_val = 0x1 << SNOOP_ETYPE_RARP;
+            else
+                set_val = ~(0x1 << SNOOP_ETYPE_RARP);
+            break;
+
+        case SNOOP_HOPOPTS:
+
+            if(enable)
+                set_val = 0x1 << SNOOP_HOPOPTS;
+            else
+                set_val = ~(0x1 << SNOOP_HOPOPTS);
+            break;
+
+        case SNOOP_MLDV2:
+            if(enable)
+                set_val = 0x1 << SNOOP_MLDV2;
+            else
+                set_val = ~(0x1 << SNOOP_MLDV2);
+            break;
+        default:
+            break;
+        }
+    if(enable){
+        read_val = sf_readl(REG_CLASS_SNOOP_CTRL);
+        sf_writel( set_val| read_val, REG_CLASS_SNOOP_CTRL);
+		printk("set global snoop ethertype enable/disable 0x%x ,read value is 0x%x\n", set_val| read_val, sf_readl(REG_CLASS_SNOOP_CTRL));
+    }
+    else{
+        read_val = sf_readl(REG_CLASS_SNOOP_CTRL);
+        sf_writel( set_val& read_val, REG_CLASS_SNOOP_CTRL);
+		printk("set global snoop ethertype enable/disable 0x%x ,read value is 0x%x\n", set_val| read_val, sf_readl(REG_CLASS_SNOOP_CTRL));
+    }
+
+    return 0;
+}
+
+int set_port_untag(int port_num)
+{
+	int addr2 = get_port_address(port_num,2);
+	if(addr2 != 0){
+		int tmp = sf_readl(addr2);
+		sf_writel(((0x1 << PORT_UNTAG_FROM_BTABLE_START_POS) & PORT_UNTAG_FROM_BTABLE_MASK) | tmp, addr2);
+		printk("set port untag 0x%x ,read value is 0x%x\n", ((0x1 << PORT_UNTAG_FROM_BTABLE_START_POS) & PORT_UNTAG_FROM_BTABLE_MASK) | tmp, sf_readl(addr2));
+	}
+	return 0;
+}
+
+int set_port_vid_prefix(int port_num)
+{
+	int addr2 = get_port_address(port_num,2);
+	if(addr2 != 0){
+		int tmp = sf_readl(addr2);
+		sf_writel(((0x1 << PORT_VID_PREFIX_START_POS) & PORT_VID_PREFIX_MASK) | tmp, addr2);
+		printk("set port vid 0x%x ,read value is 0x%x\n", ((0x1 << PORT_VID_PREFIX_START_POS) & PORT_VID_PREFIX_MASK) | tmp, sf_readl(addr2));
+	}
+	return 0;
+}
+
+int set_bmu_watermark(int bmu_low_watermark, int bmu_high_watermark)
+{
+	sf_writel(bmu_low_watermark, REG_BMU_LOW_WATERMARK);
+	sf_writel(bmu_high_watermark, REG_BMU_HIGH_WATERMARK);
+	printk("set bmu_low_watermark 0x%x bmu_high_watermark 0x%x,read value is 0x%x 0x%x\n",
+			bmu_low_watermark ,bmu_high_watermark, sf_readl(REG_BMU_LOW_WATERMARK), sf_readl(REG_BMU_HIGH_WATERMARK));
+
+	return 0;
+}
+
+int init_gpi_fw_control(int dev_no, int phy_low_watermark, int phy_high_watermark){
+
+	int addr = get_gpi_addr_base(dev_no);
+
+	//enable fw control
+	sf_writel(phy_low_watermark, addr + REG_GPI_BMU1_PHY_LOW_WATERMARK_OFFSET);
+	sf_writel(phy_high_watermark, addr + REG_GPI_BMU1_PHY_HIGH_WATERMARK_OFFSET);
+	printk("set phy_low_watermark 0x%x phy_high_watermark 0x%x,read value is 0x%x 0x%x\n",
+			phy_low_watermark ,phy_high_watermark, sf_readl(addr + REG_GPI_BMU1_PHY_LOW_WATERMARK_OFFSET), sf_readl(addr + REG_GPI_BMU1_PHY_HIGH_WATERMARK_OFFSET));
+
+	//npu_sleep_us(1);
+	sf_writel(0x00040303, addr + REG_GPI_FW_CONTROL_OFFSET);
+	printk("set 0x00040303 to REG_GPI_FW_CONTROL,read value is 0x%x", sf_readl(addr + REG_GPI_FW_CONTROL_OFFSET));
+
+	return 0;
+}
+
+/*set mac address*/
+int gmac_set_mac_addr1(unsigned long long *mac)
+{
+	int address_upper = sf_readl(REG_MAC_ADDRESS0_HIGH + EMAC0_BASE_OFFSET);
+	int address_lower = (*mac >> 40) | ((*mac >> 24) & 0xff00) | ((*mac >> 8) & 0xff0000) | ((*mac << 8) & 0xff000000);
+	address_upper = address_upper & 0xffff0000;
+	address_upper |= ((*mac << 8) & 0xff00) | ((*mac >> 8) & 0xff);
+	sf_writel(address_upper, (REG_MAC_ADDRESS0_HIGH + EMAC0_BASE_OFFSET));
+	sf_writel(address_lower, (REG_MAC_ADDRESS0_LOW + EMAC0_BASE_OFFSET));
+	return 0;
+}
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_api.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_api.h	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,54 @@
+#ifndef SF_API_H
+#define SF_API_H
+#include "sf_common.h"
+
+int set_global_snoop_special_mac(int idx ,unsigned long long *mac,unsigned long long *mask,int enable);
+
+void set_mac_loopback(int port_list);
+void set_mac_no_loopback(int port);
+
+int set_tmu_scheduler_config(tmu_schd_params_t *psch);
+
+int tmu_shaper_config_parameters_pps(uint rate_units, uint rate, uint clk_frequency, uint *intwt, uint *frcwt, uint *clkd);
+int tmu_shaper_config_parameters(uint rate_units, uint rate, uint clk_frequency, uint *intwt, uint *frcwt, uint *clkd);
+int set_tmu_shaper_config(tmu_shpr_params_t *pshp,  uint dynamic);
+
+void write_fasw_context_memory(uint data, uint que_no, uint phy_no, uint reg_no);
+int tmu_add_queue2scheduler(tmu_classq_params_t *que);
+int set_tmu_classq_add(tmu_classq_params_t *que);
+
+void set_tmu_tdq_default_enable(void);
+int set_tmu_tdq_enable(int dev_no, int enable);
+
+int set_tmu_various_cfg(tmu_schd_params_t* tsch_in,tmu_shpr_params_t* tshp_in, tmu_classq_params_t* tque_in,int port_list);
+
+int get_gpi_addr_base( int dev_no);
+int npu_gpi_ingress_config(tmu_shpr_params_t * pshp, int dev_no, int effect);
+
+int set_cutthru(int port_list, int cutthru_type);
+
+int set_dos_value(int item, int value);
+
+int set_tc_sel(int port, int map);
+int set_tc_sel_one_to_one(int port, int type);
+int set_pid2tc_map(int map);
+int set_pcp2tc_map(int port,int map);
+
+int set_global_mgmt_port(int port, int mgmt_type);
+int set_port_enable(int port_num,int enable);
+int set_port_vlan_attr(int port_num, int attr);
+
+int set_global_snoop_ethertype(int idx, unsigned long long* snoop_etype, int enable);
+
+int set_port_untag(int port_num);
+int set_port_vid_prefix(int port_num);
+
+int set_bmu_watermark(int bmu_low_watermark, int bmu_high_watermark);
+int init_gpi_fw_control(int dev_no, int phy_low_watermark, int phy_high_watermark);
+
+int set_ptp_enable(int dev_no);
+int set_ptp_mac_filter(int *mac);
+
+int gmac_set_mac_addr1(unsigned long long *mac);
+void set_SA_DA_model(int value);
+#endif /* ifndef SF_API_H */
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_common.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_common.h	2017-11-15 11:09:39.388422000 +0800
@@ -0,0 +1,365 @@
+#ifndef SF_COMMON_H
+#define SF_COMMON_H
+
+#include <linux/io.h>
+#include <linux/ip.h>
+#include <linux/in.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/clk.h>
+#include <asm/clock.h>
+#include <linux/etherdevice.h>
+#include <linux/workqueue.h>
+
+
+#define NUM_TX_DESCR             64
+#define NUM_RX_DESCR             128
+
+#define FWD_PORT_LIST_MASK           0x3f
+#define SF_MAX_PORTS                 6
+#define SF_HOST_PORT                 5
+
+#define VLANID_MASK                  0x1FFF
+#define DEFAULT_VLANID               1
+
+#define MIN_FRAME_SIZE 46
+#define MAX_FRAME_SIZE 1600
+#define MAX_BUF_ALLOCSIZE 1600
+
+/* We have 66(NET_IP_ALIGN + NET_SKB_PAD) bytes headroom before, and NPU
+ * hardware only needs 16 bytes, so it's enough for NPU driver.
+ * But mac80211 needs 112(extra_tx_headroom + IEEE80211_ENCRYPT_HEADROOM) bytes
+ * headroom, so mac80211 will resize the skb and copy the buffer of the skb,
+ * which is unused cost.
+ * So now we expand the head, and mac80211 will not copy the buffer.
+ * */
+#define EXTER_HEADROOM 64
+
+extern int g_eth_poll_debug;
+extern int g_eth_tx_debug;
+extern int g_eth_rx_debug;
+extern int g_eth_irq_debug;
+extern int g_switch_debug;
+//#define NPU_FUNCS
+#define SF_ETH_INIT_DEBUG
+#define SF_SWITCH_INIT_DEBUG
+
+#define SF_ETH_POLL_DEBUG
+#define SF_ETH_TX_DEBUG
+#define SF_ETH_RX_DEBUG
+#define SF_ETH_RESET_DEBUG
+#define SF_SWITCH_DEBUG
+
+//#define CONFIG_SFAX8_SWITCH_FPGA
+// #ifdef CONFIG_SFAX8_SWITCH_FPGA
+// 	#define SUPPORT_2_PORTS
+// #endif
+
+// #ifdef SUPPORT_2_PORTS
+// #define SF_MAC_PORTS                 2
+// #else
+// #define SF_MAC_PORTS                 5
+// #endif
+#define SF_MAC_PORTS                 5
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+#define SF_POWERSAVE_PORTS              4
+#define SF_POWERSAVE_PORTS_MASK            0xf
+#endif
+
+#define BD_CTRL_BD_BUFLEN_MASK (0xffff)
+#define BD_CTRL_CBD_INT_EN     (1 << 16)
+#define BD_CTRL_PKT_INT_EN     (1 << 17)
+#define BD_CTRL_LIFM           (1 << 18)
+#define BD_CTRL_LAST_BD        (1 << 19)
+#define BD_CTRL_DIR            (1 << 20)
+#define BD_CTRL_PKT_XFER       (1 << 24)
+#define BD_CTRL_DESC_EN        (1 << 31)
+#define BD_CTRL_PARSE_DISABLE    (1 << 25)
+#define BD_CTRL_BRFETCH_DISABLE  (1 << 26)
+#define BD_CTRL_RTFETCH_DISABLE  (1 << 27)
+
+#define CSR_TX_DMA_EN             (1 << 0)
+#define CSR_TX_BDP_POLL_CNTR_EN   (1 << 1)
+#define CSR_TX_BDP_CH_START_WSTB  (1 << 2)
+#define CSR_RX_DMA_EN             (1 << 0)
+#define CSR_RX_BDP_POLL_CNTR_EN   (1 << 1)
+#define CSR_RX_BDP_CH_START_WSTB  (1 << 2)
+
+
+/* Punt reason codes */
+#define SF_PUNT_L2_SPL          (1 << 0)
+#define SF_PUNT_SA_MISS         (1 << 1)
+#define SF_PUNT_SA_RELEARN      (1 << 2)
+#define SF_PUNT_SA_IS_ACTIVE    (1 << 3)
+#define SF_PUNT_SNOOP_UPPER     (1 << 4)
+#define SF_PUNT_REQ             (1 << 5)
+#define SF_PUNT_MGMT            (1 << 6)
+#define SF_PUNT_IGMP            (1 << 7)
+#define SF_PUNT_FLOOD           (1 << 8)
+#define SF_PUNT_PARSE           (1 << 9)
+
+
+#define  SF_SHORT_SWAP(in_usValue) (((0xFF) & ((in_usValue) >> 8)) | ((0xFF00) & ((in_usValue) << 8)))
+#define  SF_INT_SWAP(in_usValue) (((0xFF) & ((in_usValue) >> 24)) | ((0xFF00) & ((in_usValue) >> 8)) | ((0xFF0000) & ((in_usValue) << 8)) | ((0xFF000000) & ((in_usValue) << 24)))
+
+
+#define	 MAC_CFG_LOOPBACK_MODE			(1 << 12)
+#define  STP_CTRL_ADDR1_REG_VAL			0x00000040
+#define  STP_CTRL_ADDR2_REG_VAL			0x00000080
+
+#define  NO_MGMT						0x0
+#define  TMU_QUE_TAIL_DROP				0x1
+#define  TMU_QUE_WRED					0x2
+
+#define  TMU_EACH_PHY_OFFFSET			0x1000
+#define  TMU_EACH_SCH_OFFSET			0x300
+#define  SHPR_EN_BIT					0x00000001
+
+#define  TOTAL_CONTEXT_REGS			    0x08
+#define  WRITE_CMD						0x01
+#define  START_CMD						0x02
+#define  DONE_BIT						0x04
+#define  SHED_ADDRESS_MASK				0x300
+#define  SHPR_ADDRESS_MASK				0x100
+#define  DEV_ADDRESS_MASK				0x1000
+
+#define  SCH_SLOT_ZERO					0x0
+#define  SCH_SLOT_ONE					0x1
+#define  SCH_SLOT_TWO					0x2
+#define  SCH_SLOT_THREE					0x3
+#define  SCH_SLOT_FOUR					0x4
+#define  SCH_SLOT_FIVE					0x5
+#define  SCH_SLOT_SIX					0x6
+#define  SCH_SLOT_SEVEN					0x7
+#define  CURQ_QMAX_QMIN_CFG				0x4
+#define  CURQ_HW_PROB_CFG_TBL0			0x5
+#define  CURQ_HW_PROB_CFG_TBL1			0x6
+#define  REG_LEN						0x4
+
+#define  TMU_MAX_SCHED_NUM				0x02
+#define  TMU_MAX_SHPR_NUM				0x04
+#define  TMU_MAX_DEV_NUM				0x06
+#define  TMU_MAX_QUE_NO					0x08
+
+#define  SCH_ALGO_PQ					0
+#define  SCH_ALGO_DWRR					2
+#define  SCH_ALGO_RR					3
+#define  SCH_ALGO_WRR					4
+
+#define TC_DSCP							0
+#define TC_PCP							1
+#define TC_PID							2
+#define TC_MACDA						3
+
+#define TMU_HW_EN					    0x0000000F
+#define CUTTHRU_TYPE_START_POS			16
+#define GLOBAL_MGMT_PORT_START_POS		16
+
+typedef unsigned int   uint;
+typedef unsigned char  uchar;
+typedef unsigned short ushort;
+
+typedef struct _tmu_schd_params_t_ {
+	uint tlsd_schd_id;    /*!< Scheduler number (1 to 2) depends on device number */
+	uint tlsd_dev_id;     /*!< Device number ( 1 to 5) */
+	uint tlsd_algo;       /*!< Scheduler algorithm type 1-RR, 2-WRR(packet based only),3-DWRR and 0-PQ */
+	uint tlsd_position;   /*!< Scheduler position */
+	uint tlsd_weight;     /*!< Scheduler weight */
+	uint tlsd_rate_units; /*!< Rate units 1 for bits/sec and 2 for packets/sec */
+} tmu_schd_params_t;
+
+typedef struct _tmu_shpr_params_t_ {
+	uint tlsp_shpr_updates;   /*!< Shaper updates field */
+	uint tlsp_shpr_id;    /*!< Shaper number to connect to scheduler depends on device number.*/
+	uint tlsp_dev_id;     /*!< Device number ( 1 to 4) */
+	uint tlsp_clk_frequency;  /*!< Clock frequency used to do weights calculation a given rate (Mhz) */
+	uint tlsp_rate;       /*!< Data rate for a given shaper packets per second or bits per second (Mbps). */
+	uint tlsp_rate_units; /*!< Rate units 1 for bits/sec and 2 for packets/sec */
+	uint tlsp_max_credit; /*!< Maximum value of the credit that can accumulated per shaper. */
+	uint tlsp_position;   /*!< Shaper position to connect. */
+	uint tlsp_min_credit; /*!< Minimum value of the credit per shaper */
+	uint tlsp_mode;       /*!< mode 0 for normal mode and 1 for credit mode */
+} tmu_shpr_params_t;
+
+typedef struct _tmu_classq_params_t_ {
+	uint tlcq_classq_updates; /*!< Raise flags for updated parameters */
+	uint tlcq_dev_id;     /*!< Device number ( 1 to 4) */
+	uint tlcq_classq_id;  /*!< Queue number (1 to 8), value depends on device number */
+	uint tlcq_schd_id;    /*!< Scheduler number to which this classq is going to add and need to enable this scheduler bit in TDQ scheduler enable register. */
+	uint tlcq_schd_slot;  /*!< Each scheduler contains 8 queues (1-low priority and 8-high priority),assign current input classq in one of this priority queue. */
+	uint tlcq_max_len;    /*!< Quelength */
+	uint tlcq_weight;     /*!< Queue weight for weighted round robin algorithm */
+	uint tlcq_qmgmt;      /*!< This field decides queue management for drop mechanism tail drop or WRED. */
+	uint tlcq_min_len;        /*!< If que management is WRED then this field is treated as Qmin */
+	uint tlcq_prob_cfg0;      /*!< If queue management is WRED,configure probability value cfg0(max value 255) */
+	uint tlcq_prob_cfg1;
+	uint tlcq_prob_cfg2;
+	uint tlcq_prob_cfg3;
+	uint tlcq_prob_cfg4;
+	uint tlcq_prob_cfg5;
+	uint tlcq_prob_cfg6;
+	uint tlcq_prob_cfg7;
+} tmu_classq_params_t;
+
+
+enum aft_e {
+
+	ANY_TAGGING,       /*!< allow both tagged and untagged frames */
+	TAGGED_ONLY,       /*!< allow only tagged frames */
+	UNTAGGED_ONLY,     /*!< allow only untagged frames */
+};
+
+/*!
+ *  * STP blocking state
+ *   */
+enum block_state_e {
+
+	FORWARDING,        /*!< ok to learn SA and forward traffic */
+	BLOCKED,           /*!< do not learn SA; do not forward frames */
+	LEARN_ONLY,        /*!< ok to learn SA, but do not forward frames */
+};
+struct port_s {
+
+	ushort               index;     /*!< index number identifying this port */
+	ushort               shutdown;  /*!< shutdown/enable state, 1=shutdown */
+	ushort               tpid;      /*!< 0, 0x8100, 0x88a8, 0x9100, 0x9200 */
+	enum aft_e           aft;       /*!< acceptable frame type */
+	ushort               fallback_bd_id; /*!< fallback bridge domain (PVID) */
+	enum block_state_e   block_state;    /*!< block/forward state */
+
+	/* QOS Related Fields Per Port */
+	ushort                 trusted;          /* Indicates the port is trusted */
+	ushort/*tcsel_table_s*/        tcsel_table;      /* TC Select Table */
+	ushort/*pcp2tc_table_s*/       pcp2tc_table;     /* PCP2TC Table */
+	ushort		  def_cfi;          /* Default CFI Value */
+	ushort/*tc_s*/                 def_pri;          /* This is the default PRI Field.
+													  * The PCP bits added when a tag
+													  ** is added */
+	ushort/*tc_s*/                 def_tc;           /* This is the default TC Field.
+													  * The TC bits are used for COS
+													  ** mapping. Ideally both def_pri
+													  ** but for customer requirement */
+	int/*tc2cos_table_s*/       tc2cos_table;     /* TC2COS Table */
+	ushort vid_prefix; /* Take UNTAG Information from Bridge Table */
+	ushort csr_untag_from_btable; /* Take UNTAG Information from Bridge Table */
+	ushort                   pindex;	    /* Actual Physical Index (PHY NO).
+											 * Will be used to remap local
+											 * port to Act PHY This is useful
+											 * to distinguish multiple logical
+											 * representations in Port-7. Also
+											 * helps send multiple different pkts
+											 * to same PHY VLAN/STPID to P-7 */
+};
+
+enum fwd_action_e {
+
+	ACT_FORWARD = 0,  /*!< Normal forward, use forward_list of MAC entry */
+	ACT_FLOOD,        /*!< Flood to all ports in bridge domain, use forward list of BD entry */
+	ACT_PUNT,         /*!< Punt packet to PE/host */
+	ACT_DISCARD,      /*!< Discard this frame */
+	ACT_OVERRIDE,
+	ACT_FWD_MASK,
+	ACT_COS_DISCARD
+};
+
+struct bd_entry_s {
+
+	ushort forward_list;          /*!< forward_list has a bit flag corresponding
+								   * to each port
+								   *                                     */
+
+	ushort untag_list;            /*!< Indicates whether to untag the packets
+								   * at egress
+								   *                                     */
+
+	ushort mstp_id;               /*!< Index for MSTP FSM Number. Used to clear all
+								   * entries of an MSTP index
+								   *                                     */
+	/*
+	 ** forwarding actions for various situations
+	 ** Note:  ACT_DO_BD_ACT is not a valid setting for these
+	 ** Note2: ACT_FORWARD is not really valid as a miss action, but sliently
+	 ** becomes ACT_FLOOD
+	 **/
+	enum fwd_action_e ucast_hit_action;   /*!< action to take when unicast DA found (default is ACT_FORWARD) */
+	enum fwd_action_e mcast_hit_action;   /*!< action to take when multicast DA found (default is ACT_FORWARD) */
+	enum fwd_action_e ucast_miss_action;  /*!< action to take when unicast DA not found (default is ACT_FLOOD) */
+	enum fwd_action_e mcast_miss_action;  /*!< action to take when multicast DA not found (default is ACT_FLOOD) */
+	uint tc;
+};
+
+struct bd {
+	uint bd_ctrl;
+	uint bd_status;
+	uint bd_bufptr;
+	uint bd_next;
+};
+typedef struct packet_header
+{
+	uchar phyno;
+	uchar *data;
+	uchar *pLayer2Hdr;
+	uchar *pLayer3Hdr;
+	uchar *pLayer4Hdr;
+	uint  vlanid;
+	uint  punt_reason;
+	uint  data_len;
+	uint  avb_proto;
+}pktHdrs_t;
+
+/* VLan header */
+typedef struct vlanEthhdr_s {
+	uchar h_dest[ETH_ALEN];     /* destination eth addr */
+	uchar h_source[ETH_ALEN];   /* source ether addr */
+	ushort h_vlan_proto;        /* Should always be 0x8100 */
+	ushort h_vlan_TCI;          /* Encapsulates priority and VLAN ID */
+	ushort h_vlan_encap_proto;  /* pkt type ID field (or len) */
+}vlanEthhdr_t;
+
+
+struct sf_priv {
+
+	struct net_device *netdev;
+	struct device     *device;
+	struct dentry     *npu_debug;
+#ifdef CONFIG_SF16A18_MPW1
+	struct clk        *clk[4];
+#else
+	struct clk        *clk[3];
+#endif
+	//TODO: spinlock  need to enhance
+	// spinlock_t lock;                     /* Spin lock flag */
+	spinlock_t rx_lock;                     /* Spin lock flag */
+	spinlock_t switch_lock;                  /* Spin lock flag */
+
+	struct bd *tx_bd_tbl;                /*   64-bit aligned */
+	struct bd *rx_bd_tbl;                /*   64 bit aligned */
+	dma_addr_t tx_bd_tbl_pa;
+	dma_addr_t rx_bd_tbl_pa;
+
+	uint count;                          /*enhence switch thread*/
+	uint rxd_index;
+	uint txd_index;
+	uint txd_free_index;
+
+	struct sk_buff       *p_tx_skb[NUM_TX_DESCR];
+	struct sk_buff       *p_rx_skb[NUM_RX_DESCR];
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	struct sfax8_switch_t *sfax8_switch;
+	struct sf_switch_data_t *sf_switch_data;
+#else
+	struct bd_entry_s		fallback_bd_entry;
+	struct port_s			port[SF_MAX_PORTS];
+#endif
+
+	struct task_struct		*bmu_kthread;
+	struct napi_struct napi;
+	struct phy_device phy_dev[SF_MAC_PORTS];
+	struct net_device_stats netstats;
+	uint   msg_enable;
+	struct work_struct dpswork;
+};
+
+
+#endif /* ifndef SF_COMMON_H */
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_eth.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_eth.c	2017-11-21 20:11:40.398707000 +0800
@@ -0,0 +1,1299 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/reset.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/skbuff.h>
+#include <linux/interrupt.h>
+#include <linux/etherdevice.h>
+#include <linux/stat.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/clk.h>
+#include <asm/clock.h>
+#include <linux/if_vlan.h>
+//for write mac to mtd
+#include <linux/mtd/mtd.h>
+#include <linux/of_net.h>
+#include <sf16a18.h>
+#include "sf_eth.h"
+#include "sf_mdio.h"
+#include "sf_ethtool.h"
+#include "sf_eth_addr.h"
+#include "sf_switch_init.h"
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+#include "sf_switch.h"
+#endif
+#include "sf_switch_hash_table.h"
+#include "sf_common.h"
+#ifdef CONFIG_SFAX8_SWITCH_API
+#include "sf_api.h"
+#endif
+
+#include "sf_debug.h"
+#include <linux/debugfs.h>
+#include "genl_netlink.h"
+
+extern int sfax8_request_phy_irq(struct sf_priv *priv);
+extern int sfax8_free_phy_irq(struct sf_priv *priv);
+static int sf_msg_type = -1;
+module_param_named(msg_type, sf_msg_type, int, S_IRUGO);
+MODULE_PARM_DESC(msg_type, "Message level (-1=defaults,0=none,...,16=all)");
+static void __iomem *sf_base = 0;
+struct sf_priv * g_sf_priv = NULL;
+
+void sf_writel(uint value,uint offset) {
+	return writel(value, sf_base + offset);
+}
+
+int sf_readl(uint offset){
+	return readl(sf_base + offset);
+}
+
+void sf_tx_inject_packet(struct sk_buff *skb, int rx_port, struct sf_priv* priv)
+{
+
+	struct sk_buff *new_skb = NULL;
+	int port_num = 0, port_list = 0, vlanid; /*Fallback bd id*/
+	ushort eth_type;
+	vlanEthhdr_t *vlanEthHdr;
+
+	print_msg(ETH_TX_DEBUG,priv->netdev,"%s in\n",__FUNCTION__);
+	eth_type = SF_SHORT_SWAP(((struct ethhdr *)skb->data)->h_proto);
+
+	if (eth_type == ETH_P_8021Q) {
+
+		vlanEthHdr = (vlanEthhdr_t *)(skb->data);
+		vlanid = SF_SHORT_SWAP(vlanEthHdr->h_vlan_TCI) & 0xFFF;
+	}
+	else{
+		vlanid = DEF_PORT_FALLBACK_BD_ID;
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+		vlanid = priv->sfax8_switch->port[rx_port].fallback_bd_id;
+#endif
+	}
+
+	/*Getting vlan table entry port list*/
+	port_list = vlan_hash_table_search(vlanid);
+	print_msg(ETH_TX_DEBUG,priv->netdev,"search vid %d portlist 0x%x\n",vlanid,port_list);
+	if (port_list == -1) {
+		port_list = port_list & FWD_PORT_LIST_MASK;
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+		port_list = (priv->sfax8_switch->fallback_bd_entry.forward_list &
+					FWD_PORT_LIST_MASK);
+#endif
+	}
+	//  print_msg(ETH_TX_DEBUG,priv->netdev,
+	// 			"vlanid is %d, port_list is %x\n", vlanid, port_list);
+
+
+	/* this condition should not occur, flood to all ports except iport */
+	for (port_num = 0; port_num < SF_MAX_PORTS; port_num++) {
+		/* check for port bit set */
+		if ((port_list >> port_num) & 0x1) {
+			/* fwd port shldn't be input port and hif port */
+			if ((rx_port != port_num) && (port_num != SF_HOST_PORT)) {
+
+				/* Don't touch skb, use local new_skb */
+				new_skb = skb_clone(skb, GFP_ATOMIC);
+				if(new_skb != NULL){
+					new_skb->cb[CB_INJ_TX_FLAG] = CB_TX_SA_MISS;
+					new_skb->cb[CB_INJ_TX_PORT] = port_num;
+					dev_queue_xmit(new_skb);
+				}
+				else{
+					dev_err(priv->device,"skb clone error\n");
+				}
+			}
+		}
+	}
+	print_msg(ETH_TX_DEBUG,priv->netdev,"%s done\n",__FUNCTION__);
+}
+
+int bd_tx_ring_init(struct sf_priv *priv) {
+	int i,size = 0;
+	struct bd * tmp = NULL;
+	size = NUM_TX_DESCR * sizeof(struct bd);
+	/* Allocate and initialize the tx bd ring */
+	priv->tx_bd_tbl = (struct bd *) dma_alloc_coherent(&priv->netdev->dev, size, &priv->tx_bd_tbl_pa,GFP_ATOMIC);
+
+	print_msg(ETH_INIT_DEBUG,priv->netdev,"tx_bd_tbl is 0x%p\n",priv->tx_bd_tbl);
+	if (priv->tx_bd_tbl == NULL)
+	{
+		dev_err(priv->device,"Out of memory allocating tx bd ring\n");
+		return -1;
+	}
+	memset(priv->tx_bd_tbl,0,size);
+
+	for (i = 0; i < NUM_TX_DESCR; i++)
+	{
+		tmp = priv->tx_bd_tbl + i;
+		tmp->bd_next = (uint)(priv->tx_bd_tbl_pa + (sizeof(struct bd) * ((i + 1) % NUM_TX_DESCR)));
+		priv->p_tx_skb[i] = NULL;
+	}
+
+	/* Initialize the tx bd write pointer */
+	priv->txd_index = 0;
+	priv->txd_free_index= 0;
+	return 0;
+}
+
+int bd_rx_ring_init(struct sf_priv *priv) {
+
+	int i = 0,size = 0;
+	struct bd *rxd;
+	struct sk_buff *skb;
+	dma_addr_t dma_addr= 0;
+
+	size = NUM_RX_DESCR * sizeof(struct bd);
+	/* Allocate and initialize the rx bd ring */
+	priv->rx_bd_tbl = (struct bd *) dma_alloc_coherent(&priv->netdev->dev, size,
+				&priv->rx_bd_tbl_pa,GFP_ATOMIC);
+
+	print_msg(ETH_INIT_DEBUG,priv->netdev,"rx_bd_tbl is 0x%p\n",priv->rx_bd_tbl);
+	if (priv->rx_bd_tbl == NULL)
+	{
+		dev_err(priv->device,"Out of memory allocating rx bd ring\n");
+		return -1;
+	}
+	memset(priv->rx_bd_tbl,0,size);
+
+	for (i = 0; i < NUM_RX_DESCR; i++)
+	{
+		rxd = priv->rx_bd_tbl + i;
+		rxd->bd_next = (uint)(priv->rx_bd_tbl_pa + (sizeof(struct bd) * ((i + 1) % NUM_RX_DESCR)));
+
+		skb = __netdev_alloc_skb_ip_align(priv->netdev, MAX_FRAME_SIZE + EXTER_HEADROOM, GFP_KERNEL|GFP_DMA);
+		if(skb == NULL) {
+			dev_err(priv->device,"SKB ALLOC FAILED [%s:%d]\n", __func__, __LINE__);
+			return -1;
+		}
+		skb_reserve(skb, EXTER_HEADROOM);
+		priv->p_rx_skb[i] = skb;
+		// size = skb_end_pointer(skb) - skb->data;
+		dma_addr = dma_map_single(priv->device, skb->data,
+					MAX_FRAME_SIZE, DMA_FROM_DEVICE);
+		rxd->bd_status = 0;
+		rxd->bd_bufptr = (uint)dma_addr;
+		//last bd fill with 0, hardware should stop here
+		if(i == (NUM_RX_DESCR -1))
+		  rxd->bd_ctrl = 0;
+		else
+		  /* Enable per packet receive interrupt */
+		  rxd->bd_ctrl = MAX_FRAME_SIZE | (BD_CTRL_PKT_INT_EN | BD_CTRL_LIFM |
+					  BD_CTRL_DIR | BD_CTRL_DESC_EN);
+	}
+
+	/* Initialize the rx bd read pointer */
+	priv->rxd_index = 0;
+
+	return 0;
+}
+
+void bd_tx_ring_deinit(struct sf_priv *priv) {
+	int i = 0;
+	for(;i < NUM_TX_DESCR; i++){
+		if (priv->p_tx_skb[i] != NULL){
+			if(priv->tx_bd_tbl[i].bd_bufptr)
+			  dma_unmap_single(&priv->netdev->dev, priv->tx_bd_tbl[i].bd_bufptr, priv->p_tx_skb[i]->len, DMA_TO_DEVICE);
+			dev_kfree_skb(priv->p_tx_skb[i]);
+			priv->p_tx_skb[i] = NULL;
+		}
+	}
+
+	if (priv->tx_bd_tbl != NULL){
+		dma_free_coherent(&priv->netdev->dev,
+					(sizeof(struct bd) * NUM_TX_DESCR), priv->tx_bd_tbl, priv->tx_bd_tbl_pa);
+		priv->tx_bd_tbl = NULL;
+		priv->tx_bd_tbl_pa = 0;
+	}
+
+	return;
+}
+
+void bd_rx_ring_deinit(struct sf_priv *priv) {
+	int i = 0;
+	for(;i < NUM_RX_DESCR; i++){
+		if (priv->p_rx_skb[i] != NULL){
+			if(priv->rx_bd_tbl[i].bd_bufptr)
+			  dma_unmap_single(&priv->netdev->dev, priv->rx_bd_tbl[i].bd_bufptr, MAX_FRAME_SIZE, DMA_FROM_DEVICE);
+
+			dev_kfree_skb(priv->p_rx_skb[i]);
+			priv->p_rx_skb[i] = NULL;
+		}
+	}
+	if (priv->tx_bd_tbl != NULL){
+		dma_free_coherent(&priv->netdev->dev,
+					(sizeof(struct bd) * NUM_RX_DESCR), priv->rx_bd_tbl, priv->rx_bd_tbl_pa);
+		priv->rx_bd_tbl = NULL;
+		priv->rx_bd_tbl_pa = 0;
+	}
+
+	return;
+}
+
+int is_txbd_aval(struct sf_priv * priv) {
+	struct bd *txd;
+	txd = priv->tx_bd_tbl + priv->txd_index;
+	return !(txd->bd_ctrl & BD_CTRL_DESC_EN);
+}
+
+int sf_bd_ring_init(struct sf_priv *priv) {
+	//this lock is from old code, and sleep will be called in alloc skb.
+	//Kernel will check the sleep in spin lock.
+	//actually lock is not necessary here
+	// spin_lock_irq(&priv->lock);
+	/* Allocate memory and initialize bd rings */
+	if (bd_tx_ring_init(priv) < 0) {
+		// spin_unlock_irq(&priv->lock);
+		return (-ENOMEM);
+	}
+	if (bd_rx_ring_init(priv) < 0)
+	{
+		bd_tx_ring_deinit(priv);
+		// spin_unlock_irq(&priv->lock);
+		return (-ENOMEM);
+	}
+	// spin_unlock_irq(&priv->lock);
+	return 0;
+}
+
+int sf_dma_start(struct sf_priv *priv) {
+	uint tx_ctrl;
+	uint rx_ctrl;
+	/* Initialize the rx and tx buffer descriptor table pointer
+	 *	 * registers.
+	 *		 */
+	sf_writel(priv->tx_bd_tbl_pa, REG_HIF_TX_BDP_ADDR);
+	sf_writel(priv->rx_bd_tbl_pa, REG_HIF_RX_BDP_ADDR);
+
+	/* Enable the interrupts */
+	sf_writel((HIF_INT_EN | HIF_RXPKT_INT_EN | HIF_TXPKT_INT_EN),REG_HIF_INT_EN);
+
+	tx_ctrl = sf_readl(REG_HIF_TX_CTRL);
+	// tx_ctrl |= CSR_TX_DMA_EN |CSR_TX_BDP_POLL_CNTR_EN;
+	tx_ctrl |= CSR_TX_DMA_EN;
+	sf_writel(tx_ctrl, REG_HIF_TX_CTRL);
+
+	rx_ctrl = sf_readl(REG_HIF_RX_CTRL);
+	rx_ctrl |= CSR_RX_DMA_EN |CSR_RX_BDP_POLL_CNTR_EN;
+	sf_writel(rx_ctrl, REG_HIF_RX_CTRL);
+
+	return 0;
+}
+
+void sf_disable_int(struct sf_priv *priv) {
+	uint  int_src = 0;
+	sf_writel(0, REG_HIF_INT_EN);
+	int_src = sf_readl(REG_HIF_INT_SRC);
+	sf_writel(int_src, REG_HIF_INT_SRC);
+}
+
+int get_bmu_rem_count(void) {
+	return sf_readl(REG_BMU_REM_BUF_CNT);
+}
+
+int sf_eth_reset(struct net_device *dev){
+	struct sf_priv *priv = netdev_priv(dev);
+	int rc = 0;
+	int i = 0;
+
+#ifdef CONFIG_SFAX8_SWITCH_AGEING
+	sf_switch_init_timer(0);
+#endif
+	sf_mac_disable_rx();
+	sf_writel(0, REG_HIF_RX_CTRL);
+	napi_disable(&priv->napi);
+	print_msg(ETH_RESET_DEBUG,priv->netdev,"has disable napi\n");
+
+	netif_tx_disable(dev);
+	sf_writel(0, REG_HIF_TX_CTRL);
+	sf_mac_disable_tx();
+
+	sf_disable_int(priv);
+
+	print_msg(ETH_RESET_DEBUG,priv->netdev,"start cleanup bd rings\n");
+	/* Cleanup the bd rings */
+	bd_rx_ring_deinit(priv);
+	bd_tx_ring_deinit(priv);
+	print_msg(ETH_RESET_DEBUG,priv->netdev,"end cleanup bd rings\n");
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	priv->sf_switch_data->switch_stop(priv);
+#else
+	sfax8_free_phy_irq(priv);
+#endif
+
+	dev->needed_headroom = 32;
+
+	sf_disable_int(priv);
+	sys_npu_reset();
+	sf_local_reset();
+	print_msg(ETH_RESET_DEBUG,priv->netdev,"end sys and soft npu reset\n");
+	sf_phy_init(priv->phy_dev);
+	sf_init_switch_hw();
+	print_msg(ETH_RESET_DEBUG,priv->netdev,"end hw init\n");
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	priv->sf_switch_data->set_mac(dev->dev_addr);
+#endif
+	/*should set after sf_init_switch_hw,otherwise it will set mac status wrong*/
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+	sf_phy_energy_detect_init(priv);
+#else
+	for(i = 0 ; i < SF_MAC_PORTS ; i++){
+		sf_phy_init_low_power(priv, i);
+	}
+#endif
+
+	print_msg(ETH_RESET_DEBUG,priv->netdev,"start switch open\n");
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	priv->sf_switch_data->switch_open(priv);
+#else
+	sfax8_request_phy_irq(priv);
+	sf_port_init((void*) priv->port);
+	add_vlan_entry_args(DEF_PORT_FALLBACK_BD_ID, 0, FWD_PORT_LIST_MASK, 0);
+#endif
+	print_msg(ETH_RESET_DEBUG,priv->netdev,"end switch open\n");
+
+	/* Allocate memory and initialize bd rings */
+	rc = sf_bd_ring_init(priv);
+	if (rc < 0) {
+		dev_err(priv->device, "bd ring init fail\n");
+		return rc;
+	}
+	napi_enable(&priv->napi);
+	sf_dma_start(priv);
+
+	/* Enable Emac Registers */
+	sf_mac_enable();
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int sfax8_eth_reset_thread(void *data) {
+	struct sf_priv *priv = data;
+	int i = 0, bmu_rem_count = 0;
+	unsigned int tmp1 = 0, tmp2 = 0, flag = 0;
+#ifdef SF_TX_SHUTDOWN
+	unsigned int phy_value= 0, cycle = 0, rand_port = 0;
+#endif
+
+	// msleep(10000);
+	print_msg(ETH_RESET_DEBUG,priv->netdev,"Enter npu reset thread\n");
+	while (!kthread_should_stop()) {
+		for(i = 0; i < 5; i++){
+			bmu_rem_count = sf_readl(REG_BMU_REM_BUF_CNT);
+			if(bmu_rem_count)
+			  break;
+
+			if(i == 0){
+				tmp1 = priv->txd_index;
+				tmp2 = priv->rxd_index;
+			}
+			else if(i == 4)
+			  flag = ((priv->txd_index == tmp1) && (priv->rxd_index == tmp2) ? 1 : 0);
+			msleep(1);
+		}
+
+#ifdef SF_TX_SHUTDOWN
+		get_random_bytes(&rand_port, sizeof(unsigned int));
+		for(;i < SF_MAC_PORTS; i++){
+			rand_port = (rand_port + i) % 5;
+			phy_value = read_phy_reg(rand_port, PHY_BASE_CONTROL_REGISTER, priv->phy_dev);
+			if(!(phy_value & PHY_BASE_ENABLE_AUTO_NEG)){
+			// phy_value= read_phy_reg(i, PHY_BASE_STATUS_REGISTER, priv->phy_dev);
+			// if (!(phy_value& PHY_STATUS_LINK_UP)){
+				if(cycle == 0){
+				  phy_value = read_phy_reg(rand_port, OMINI_PHY_MODEL_CTRL_REGISTER, priv->phy_dev);
+				  write_phy_reg(rand_port, OMINI_PHY_MODEL_CTRL_REGISTER, (phy_value & ~OMINI_PHY_MODEL_CTRL_AUTO) & ~OMINI_PHY_MODEL_CTRL_FIX_MDIX, priv->phy_dev);
+				  sf_phy_a5_tx_config(rand_port, priv, OMINI_PHY_ANALOG_A5_CONFIG_TX_10M_MDI);
+
+				}
+				else{
+				  phy_value = read_phy_reg(rand_port, OMINI_PHY_MODEL_CTRL_REGISTER, priv->phy_dev);
+				  write_phy_reg(rand_port, OMINI_PHY_MODEL_CTRL_REGISTER, (phy_value & ~OMINI_PHY_MODEL_CTRL_AUTO) | OMINI_PHY_MODEL_CTRL_FIX_MDIX, priv->phy_dev);
+				  sf_phy_a5_tx_config(rand_port, priv, OMINI_PHY_ANALOG_A5_CONFIG_TX_10M_MDIX);
+				}
+
+				cycle = (cycle + 1) % 2;
+
+				msleep(g_i_tx_wake_time);
+				//printk("tx_shutdown wake tx for %d ms port %d\n", g_i_tx_wake_time,i);
+				phy_value = read_phy_reg(rand_port, PHY_BASE_CONTROL_REGISTER, priv->phy_dev);
+				if(!(phy_value & PHY_BASE_ENABLE_AUTO_NEG))
+				  sf_phy_a5_tx_config(rand_port, priv, OMINI_PHY_ANALOG_A5_CONFIG_TX_IDLE);
+				else
+				  printk("tx_shutdown phy change to Auto port %d\n", rand_port);
+			}
+		}
+#endif
+		if(flag == 1){
+			dev_err(priv->device, "bmu error, start npu reset\n");
+			// sf_eth_reset(priv->netdev);
+			dev_err(priv->device, "bmu error, end npu reset\n");
+			flag = 0;
+		}
+		bmu_rem_count = 0;
+		tmp1 = 0, tmp2 = 0;
+		msleep(1000);
+	}
+	print_msg(ETH_RESET_DEBUG,priv->netdev,"Out npu reset thread\n");
+	return 0;
+}
+
+irqreturn_t sf_handle_irq(int irq, void *dev) {
+	struct sf_priv *priv = (struct sf_priv*)netdev_priv(dev);
+	uint hif_int_src = 0;
+
+	/* reading interrupt soruce register */
+	hif_int_src = sf_readl(REG_HIF_INT_SRC);
+	print_msg(ETH_IRQ_DEBUG,priv->netdev,"int src = %x\n",hif_int_src);
+	/* Interrupt is not ours */
+	if (!(hif_int_src)){
+		return IRQ_NONE;
+	}
+
+	if (hif_int_src & (HIF_RXPKT_INT|HIF_TXPKT_INT))
+	{
+		sf_writel(0, REG_HIF_INT_EN);
+		mmiowb();
+		/* Schedule napi routine */
+		napi_schedule(&priv->napi);
+		return (IRQ_HANDLED);
+	}
+
+	sf_writel(hif_int_src, REG_HIF_INT_SRC);
+	mmiowb();
+	print_msg(ETH_INIT_DEBUG,priv->netdev,"error int src %d \n",hif_int_src);
+
+	return (IRQ_HANDLED);
+}
+
+/*irqreturn_t sf_bmu_handle_irq(int irq, void *dev) {
+	struct sf_priv *priv = (struct sf_priv*)netdev_priv(dev);
+	uint bmu_int_src = 0, j = 0;
+
+	bmu_int_src = sf_readl(REG_BMU_INT_SRC);
+	print_msg(ETH_IRQ_DEBUG,priv->netdev,"bmu int src = %x\n",bmu_int_src);
+	// Interrupt is not ours
+	if (!(bmu_int_src)){
+		return IRQ_NONE;
+	}
+
+	//disable bmu irq
+	sf_writel(0, REG_BMU_INT_ENABLE);
+	//clear bmu int src
+	sf_writel(bmu_int_src, REG_BMU_INT_SRC);
+
+	if (bmu_int_src & BMU_FULL_INT){
+		printk("bmu ucast buffer is full\n");
+		for (j = 0; j < 8; j++)
+		  printk("dump buffer occupide by master%d,read address 0x%x, value 0x%x\n",j, (0x240060 + 4*j), sf_readl(0x240060 + 4*j));
+
+		wake_up_process(priv->bmu_kthread);
+	}
+
+	return (IRQ_HANDLED);
+}
+*/
+int sf_eth_open(struct net_device *dev) {
+	struct sf_priv *priv = netdev_priv(dev);
+	int rc = 0;
+	int i = 0;
+
+	print_msg(ETH_INIT_DEBUG,dev,"%s start \n", __FUNCTION__);
+	// random_ether_addr(dev->dev_addr);
+	//enable ETH clock
+	priv->clk[0] = of_clk_get(priv->device->of_node, 0);
+	if (IS_ERR(priv->clk[0])){
+		dev_err(priv->device, "unable to get ethrefclk clock\n");
+		return PTR_ERR(priv->clk[0]);
+	}
+	rc = clk_prepare_enable(priv->clk[0]);
+	if(rc)
+	  return rc;
+
+	priv->clk[1] = of_clk_get(priv->device->of_node, 1);
+	if (IS_ERR(priv->clk[1])){
+		dev_err(priv->device, "unable to get ethbyprefclk clock\n");
+		return PTR_ERR(priv->clk[1]);
+	}
+	rc = clk_prepare_enable(priv->clk[1]);
+	if(rc)
+	  return rc;
+
+	priv->clk[2] = of_clk_get(priv->device->of_node, 2);
+	if (IS_ERR(priv->clk[2])){
+		dev_err(priv->device, "unable to get ethtsuclk clock\n");
+		return PTR_ERR(priv->clk[2]);
+	}
+	rc = clk_prepare_enable(priv->clk[2]);
+	if(rc)
+	  return rc;
+
+#ifdef CONFIG_SF16A18_MPW1
+	priv->clk[3] = of_clk_get(priv->device->of_node, 3);
+	if (IS_ERR(priv->clk[3])){
+		dev_err(priv->device, "unable to get npupeclk clock\n");
+		return PTR_ERR(priv->clk[3]);
+	}
+	rc = clk_prepare_enable(priv->clk[3]);
+	if(rc)
+	  return rc;
+#endif
+
+	//emac[5-1]_phy_enable[4:0] enable all phy
+	writeb(0x1F,(void*)(OMINI_PHY_ENABLE));
+
+	rc = devm_request_irq(priv->device, dev->irq, sf_handle_irq, 0,
+			dev_name(priv->device), dev);
+	if (rc)
+		return rc;
+
+	/*request bmu irq*/
+	/*rc = devm_request_irq(priv->device, 32, sf_bmu_handle_irq, 0,
+				dev_name(priv->device), dev);
+	if (rc)
+	  return rc;
+*/
+	dev->needed_headroom = 32;
+
+	sf_disable_int(priv);
+	sf_local_reset();
+	sf_phy_init(priv->phy_dev);
+
+#ifndef CONFIG_SFAX8_SWITCH_POWERSAVE
+	for(i = 0 ; i < SF_MAC_PORTS ; i++){
+		sf_phy_init_low_power(priv, i);
+	}
+#endif
+	sf_init_switch_hw();
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	priv->sf_switch_data->set_mac(dev->dev_addr);
+#endif
+	/*should set after sf_init_switch_hw,otherwise it will set mac status wrong*/
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+	sf_phy_energy_detect_init(priv);
+#endif
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	priv->sf_switch_data->switch_open(priv);
+#else
+	sfax8_request_phy_irq(priv);
+	sf_port_init((void*) priv->port);
+	add_vlan_entry_args(DEF_PORT_FALLBACK_BD_ID, 0, FWD_PORT_LIST_MASK, 0);
+#endif
+
+	/* Allocate memory and initialize bd rings */
+	rc = sf_bd_ring_init(priv);
+	if (rc < 0) {
+		dev_err(priv->device, "bd ring init fail\n");
+		return rc;
+	}
+
+	napi_enable(&priv->napi);
+	sf_dma_start(priv);
+
+	/* Enable Emac Registers */
+	sf_mac_enable();
+
+	/* Enable bmu irq*/
+	//sf_writel((BMU_INT_EN|BMU_FULL_INT_EN), REG_BMU_INT_ENABLE);
+	netif_start_queue(dev);
+	/*enable bmu thread*/
+	priv->bmu_kthread = kthread_run(sfax8_eth_reset_thread, priv, "%s", priv->netdev->name);
+	if (IS_ERR(priv->bmu_kthread)){
+		netdev_err(priv->netdev,"Could not allocate kthread for bmu\n");
+		return PTR_ERR(priv->bmu_kthread);
+	}
+	return 0;
+}
+
+static int sf_eth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd) {
+	return 0;
+}
+
+static int sf_eth_change_mtu(struct net_device *dev, int new_mtu) {
+
+	return 0;
+}
+
+static struct net_device_stats * sf_eth_get_stats(struct net_device *dev) {
+	struct sf_priv *priv = netdev_priv(dev);
+	return &priv->netstats;
+}
+
+static int sf_set_mac_address(struct net_device *dev, void *p) {
+	int ret = eth_mac_addr(dev, p);
+	if(!ret){
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+		struct sf_priv *priv = netdev_priv(dev);
+		priv->sf_switch_data->set_mac(dev->dev_addr);
+#endif
+	}
+
+	return ret;
+}
+
+static struct file_operations npu_debug_ops = {
+	.owner = THIS_MODULE,
+	.open  = sfax8_npu_debug_open,
+	.read  = sfax8_npu_debug_read,
+	.write  = sfax8_npu_debug_write,
+	.llseek  = default_llseek,
+};
+
+struct net_device_ops sf_netdev_ops = {
+	.ndo_start_xmit		= sf_eth_xmit,
+	.ndo_open			= sf_eth_open,
+	.ndo_stop			= sf_eth_stop,
+	.ndo_do_ioctl		= sf_eth_ioctl,
+	.ndo_get_stats		= sf_eth_get_stats,
+	.ndo_set_mac_address   = sf_set_mac_address,
+	//TODO: add change mtu
+	.ndo_change_mtu		= sf_eth_change_mtu,
+};
+
+static inline int sf_max_buf_size(int mtu)
+{
+	return SKB_DATA_ALIGN(SF_RX_HDR_LEN + mtu) + SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+}
+// return > 1 means free
+int get_free_space(struct sf_priv *priv){
+	smp_rmb();
+	return  NUM_TX_DESCR - ((priv->txd_index - priv->txd_free_index) & (NUM_TX_DESCR -1));
+}
+
+int sf_add_tx_header(struct sk_buff **ppskb) {
+	struct tx_header *txhdr;
+	struct sk_buff * new_skb;
+
+	if (skb_headroom(*ppskb) < SF_TX_HDR_LEN) {
+		new_skb = skb_realloc_headroom(*ppskb, SF_TX_HDR_LEN);
+		if(new_skb == NULL){
+			return -1;
+		}else{
+			dev_kfree_skb(*ppskb);
+			*ppskb = new_skb;
+		}
+	}
+
+	skb_push(*ppskb, SF_TX_HDR_LEN);
+	txhdr = (struct tx_header *)((*ppskb)->data);
+	memset(txhdr, 0, SF_TX_HDR_LEN);
+
+	if ((*ppskb)->cb[CB_INJ_TX_FLAG] & CB_TX_SA_MISS) {
+
+		txhdr->ctrl = SF_TX_PKT_INJECT_EN;
+		txhdr->txport_map = 1 << (*ppskb)->cb[CB_INJ_TX_PORT];
+	}
+
+	txhdr->rsvd0 = 0;
+	txhdr->queue = 0;
+	txhdr->rsvd1 = 0;
+
+	return 0;
+}
+
+int sf_txbd_update(struct sk_buff *skb, struct net_device *dev)
+{
+	struct sf_priv *priv;
+	dma_addr_t dma_handle1 = 0;
+	struct bd *txd;
+
+	priv = netdev_priv(dev);
+
+	dma_handle1 = dma_map_single(&dev->dev, skb->data,
+				skb->len, DMA_TO_DEVICE);
+	txd = priv->tx_bd_tbl + priv->txd_index;
+	wmb();
+	txd->bd_bufptr = dma_handle1;
+
+	txd->bd_ctrl  = (BD_CTRL_PKT_INT_EN |
+				BD_CTRL_LIFM | BD_CTRL_DESC_EN |
+				skb->len);
+	/* Advance the write pointer */
+	rmb();
+	sf_writel(CSR_TX_DMA_EN|CSR_TX_BDP_CH_START_WSTB, REG_HIF_TX_CTRL);
+	mmiowb();
+	priv->p_tx_skb[priv->txd_index] = skb;
+	wmb();
+	priv->txd_index = (priv->txd_index + 1) & (NUM_TX_DESCR -1);
+	return 0;
+}
+
+
+
+int sf_eth_xmit(struct sk_buff *skb, struct net_device *dev) {
+	struct sf_priv *priv;
+	priv  = netdev_priv(dev);
+
+	// add for npu check vlan packet len > 32, otherwise drop the packet
+	if (unlikely(skb->len < 40)) {
+		int ret = 0;
+		if ((ret = skb_pad(skb, 40 - skb->len)) < 0){
+			printk("padding fail %d \n",ret);
+		}
+		skb->len = 40;
+		skb_set_tail_pointer(skb, 40);
+	}
+
+	if (get_free_space(priv) <=  1) {
+		print_msg(ETH_TX_DEBUG,priv->netdev,"stop queue 1 txd_index %d ,free idx %d \n",priv->txd_index, priv->txd_free_index);
+		smp_wmb();
+		netif_stop_queue(dev);
+		return NETDEV_TX_BUSY;
+	}
+	/* Prepend the tx header to transmit packet */
+	if (sf_add_tx_header(&skb) < 0) {
+		//  print_msg(ETH_TX_DEBUG,priv->netdev,
+		// 			"not enough room to tx header in skb\n");
+		dev_err(priv->device,"add tx headr fail\n");
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	sf_txbd_update(skb, dev);
+	print_msg(ETH_POLL_DEBUG,priv->netdev,"send skb to hardware %d txd index %d\n",skb->len,priv->txd_index);
+
+	priv->netstats.tx_packets++;
+	priv->netstats.tx_bytes += skb->len;
+
+	dev->trans_start = jiffies;
+
+	if (get_free_space(priv) <= 1) {
+		/*To do between 386 && 390, in runtime the gap will free all bd in poll func so, queue stoped never up again*/
+		// netif_tx_disable(dev);
+		print_msg(ETH_TX_DEBUG,priv->netdev,"stop queue after tx,txd_index %d ,free idx %d \n",priv->txd_index, priv->txd_free_index);
+		smp_wmb();
+		netif_stop_queue(dev);
+
+		smp_mb();
+		if (netif_queue_stopped(dev) && (get_free_space(priv) > 1)){
+			netif_wake_queue(dev);
+			print_msg(ETH_TX_DEBUG,priv->netdev,"wake queue after tx,txd_index %d ,free idx %d \n",priv->txd_index, priv->txd_free_index);
+		}
+	}
+
+	return NETDEV_TX_OK;
+}
+
+int sf_rx_handler(struct sk_buff *skb, struct sf_priv *priv) {
+	struct rx_header *rxhdr;
+	int punt_packet = 0;
+#ifdef CONFIG_NET_SFAX8_PTP
+	u64 ns = 0;
+#endif
+
+	/* incoming packet is rx packet */
+	rxhdr = (struct rx_header *)skb->data;
+
+#ifdef CONFIG_NET_SFAX8_PTP
+	if (rxhdr->ctrl & (1 << 4)) {
+
+		struct egress_report *egrhdr;
+		/* incoming packet is egress time stamp report */
+		egrhdr = (struct egress_report *)skb->data;
+
+		if (egrhdr->rxport_num == 0)
+		  dev = fp_phy0_addr;
+		else if (egrhdr->rxport_num == 1)
+		  dev = fp_phy1_addr;
+
+		else {
+
+			 print_msg(ETH_RX_DEBUG,priv->netdev,
+					 "fp_process_rx_header device unknown\n");
+			dev_kfree_skb(skb);
+			return -1;
+		}
+
+		ns = (egrhdr->egress_timestamp_sec * 1000000000ULL) +
+			(egrhdr->egress_timestamp_nsec);
+		nfp_priv = NFP_DEV_INFO(dev);
+
+		if (nfp_priv->ref_num != egrhdr->ref_num) {
+
+			 print_msg(ETH_RX_DEBUG,priv->netdev,
+					 "fp_process_rx_header: ref_num not matching\n");
+			dev_kfree_skb(skb);
+			return -1;
+		}
+
+		nfp_priv->ns = ns;
+		npu_ptp_tx_handler(dev);
+
+		dev_kfree_skb(skb);
+		return 0;
+	}
+#endif
+
+	//TODO : rx port num l2 speical
+	if (rxhdr->ctrl & SF_PUNT_VALID) {
+		punt_packet = 1;
+	} else {
+		punt_packet = 0;
+	}
+
+	skb_pull(skb, sizeof(struct rx_header));
+
+	// push vlan tag into packet
+	if (punt_packet) {
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+		u16 vlanid;
+		int i = 0;
+		if(__vlan_get_tag(skb, &vlanid)) {
+			vlanid = DEF_PORT_FALLBACK_BD_ID;
+			for (i = 0; i < 3; i++) {
+				if(priv->sfax8_switch->vlan_entries[i].member & (0x1 << rxhdr->rxport_num)){
+					vlanid = priv->sfax8_switch->vlan_entries[i].vid;
+					break;
+				}
+			}
+			vlan_insert_tag(skb, htons(ETH_P_8021Q), vlanid);
+		}
+#endif
+		if(sf_process_packet(skb->data, skb->len, rxhdr, priv) != 1){
+			if (rxhdr->punt_reason == SF_PUNT_SA_MISS) {
+				sf_tx_inject_packet(skb, rxhdr->rxport_num, priv);
+			}
+		}
+		if(rxhdr->rxport_num == SF_HOST_PORT){
+			dev_kfree_skb(skb);
+			return 0;
+		}
+	}
+	skb->protocol = eth_type_trans(skb, skb->dev);
+#ifdef CONFIG_SFAX8_SWITCH_PTP
+	if (unlikely(ntohs(skb->protocol) == 0x88F7)) {
+		ns = (rxhdr->rx_timestamp_sec * 1000000000ULL) +
+			(rxhdr->rx_timestamp_nsec);
+		npu_ptp_rx_pktstamp(skb, ns);
+		skb->dev = dev;
+	}
+#endif /* CONFIG_SFAX8_SWITCH_PTP */
+	print_msg(ETH_RX_DEBUG,priv->netdev,"send skb to kernel len %d\n",skb->len);
+	// netif_receive_skb(skb);
+	// check sum need to enhance
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	napi_gro_receive(&priv->napi, skb);
+
+	return 0;
+}
+
+int sf_eth_napi_poll(struct napi_struct *napi, int budget) {
+	struct sf_priv *priv = container_of(napi, struct sf_priv, napi);
+	unsigned int len = 0;
+	volatile struct bd *rxd;
+	volatile struct bd *txd;
+	volatile struct bd *p_rxd;
+	struct sk_buff *new_skb = NULL;
+	struct sk_buff *skb = NULL;
+	int hif_int_src = sf_readl(REG_HIF_INT_SRC);
+	dma_addr_t dma_handle1 = 0;
+	//unsigned int bytes_count = -1;
+	unsigned int tx_done= 0;
+	unsigned int rx_done= 0;
+
+	print_msg(ETH_POLL_DEBUG,priv->netdev,"%s in\n",__FUNCTION__);
+poll_again:
+
+	hif_int_src = sf_readl(REG_HIF_INT_SRC);
+	if(hif_int_src & HIF_RXPKT_INT){
+		rx_done = 0;
+		do {
+			rmb();
+			/* Read the rx bd ring descriptors */
+			rxd = priv->rx_bd_tbl + priv->rxd_index;
+			p_rxd = priv->rx_bd_tbl + ((priv->rxd_index == 0) ? (NUM_RX_DESCR -1) : (priv->rxd_index -1));
+			/* No more descriptors to process */
+			if (rxd->bd_ctrl & BD_CTRL_DESC_EN) {
+				break;
+			}
+			skb = priv->p_rx_skb[priv->rxd_index];
+			dma_unmap_single(&priv->netdev->dev, rxd->bd_bufptr,
+						MAX_FRAME_SIZE, DMA_FROM_DEVICE);
+			len = rxd->bd_ctrl & BD_CTRL_BD_BUFLEN_MASK;
+			new_skb = netdev_alloc_skb_ip_align(priv->netdev, MAX_FRAME_SIZE + EXTER_HEADROOM);
+			skb_reserve(new_skb, EXTER_HEADROOM);
+			dma_handle1 = dma_map_single(&priv->netdev->dev, new_skb->data,
+						MAX_FRAME_SIZE, DMA_FROM_DEVICE);
+			rxd->bd_status = 0;
+			rxd->bd_bufptr = dma_handle1;
+			priv->p_rx_skb[priv->rxd_index] = new_skb;
+			rxd->bd_ctrl =  0;
+		    wmb();
+			rx_done++;
+			/* Get the virtual address of the frame */
+			skb_put(skb, len);
+			skb->dev = priv->netdev;
+			sf_rx_handler(skb, priv);
+			/* hand over the sk_buff to corresponding fp_phy interface */
+			priv->netstats.rx_packets++;
+			priv->netstats.rx_bytes += skb->len;
+			/* Enable per packet receive interrupt */
+			p_rxd->bd_ctrl |= MAX_FRAME_SIZE | (BD_CTRL_PKT_INT_EN |BD_CTRL_LIFM |
+						BD_CTRL_DIR | BD_CTRL_DESC_EN);
+			priv->rxd_index = (priv->rxd_index + 1) & (NUM_RX_DESCR - 1);
+		} while (rx_done< budget);
+
+		if (rx_done < budget){
+			sf_writel(HIF_RXPKT_INT, REG_HIF_INT_SRC);
+	        mmiowb();
+	    }
+	}
+
+	if(hif_int_src & HIF_TXPKT_INT){
+		tx_done = 0;
+		do {
+            smp_rmb();
+			txd = priv->tx_bd_tbl + priv->txd_free_index;
+			skb = priv->p_tx_skb[priv->txd_free_index];
+            rmb();
+			if(txd->bd_ctrl & BD_CTRL_DESC_EN || !skb){
+				break;
+			}
+			dma_unmap_single(&priv->netdev->dev, txd->bd_bufptr,
+						skb->len, DMA_TO_DEVICE);
+			dev_kfree_skb_any(skb);
+			tx_done++;
+			priv->p_tx_skb[priv->txd_free_index] = NULL;
+			wmb();
+			priv->txd_free_index = (priv->txd_free_index + 1) & (NUM_TX_DESCR -1);
+		}while(tx_done < budget);
+		print_msg(ETH_POLL_DEBUG,priv->netdev,"poll txd_index %d free idx %d tx_done is %d bmu remain count is %d\n",priv->txd_index, priv->txd_free_index, tx_done, get_bmu_rem_count());
+		if(tx_done){
+			// netdev_completed_queue(priv->netdev, tx_done, bytes_count);
+			smp_mb();
+			if (netif_queue_stopped(priv->netdev) && get_free_space(priv) > 1) {
+				netif_wake_queue(priv->netdev);
+				print_msg(ETH_TX_DEBUG,priv->netdev,"wake queue txd_index %d free idx %d tx_done is %d bmu remain count is %d\n",priv->txd_index, priv->txd_free_index, tx_done, get_bmu_rem_count());
+			}
+		}
+		if(tx_done < budget){
+			print_msg(ETH_POLL_DEBUG,priv->netdev,"clear tx int \n");
+			sf_writel(HIF_TXPKT_INT, REG_HIF_INT_SRC);
+			mmiowb();
+		}
+	}
+
+	if((tx_done < budget) && (rx_done < budget)){
+		hif_int_src = sf_readl(REG_HIF_INT_SRC);
+		if(hif_int_src & (HIF_RXPKT_INT|HIF_TXPKT_INT))
+		  goto poll_again;
+		napi_complete(napi);
+		sf_writel( ((HIF_INT_EN | HIF_RXPKT_INT_EN |
+						HIF_TXPKT_INT_EN)),REG_HIF_INT_EN);
+		mmiowb();
+	}
+
+	print_msg(ETH_POLL_DEBUG,priv->netdev,"%s out\n",__FUNCTION__);
+	/* Re-Enable interrupts */
+	return rx_done;
+}
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+const struct of_device_id of_sf_match[] = {
+	   { .compatible = "siflower,sfax8-eth", .data = &sf_switch_data},
+	   {},
+};
+#else
+const struct of_device_id of_sf_match[] = {
+	   { .compatible = "siflower,sfax8-eth", .data = NULL},
+	   {},
+};
+#endif
+
+int set_mac_address_mtd(struct device_node *np, char *mac) {
+	struct device_node *mtd_np = NULL;
+	size_t retlen;
+	int size, ret;
+	struct mtd_info *mtd;
+	const char *part;
+	const __be32 *list;
+	phandle phandle;
+	struct erase_info ei;
+	unsigned char *buf = NULL;
+
+	list = of_get_property(np, "mtd-mac-address", &size);
+	if (!list || (size != (2 * sizeof(*list))))
+		return -ENOENT;
+
+	phandle = be32_to_cpup(list++);
+	if (phandle)
+		mtd_np = of_find_node_by_phandle(phandle);
+
+	if (!mtd_np)
+		return -ENOENT;
+
+	part = of_get_property(mtd_np, "label", NULL);
+	if (!part)
+		part = mtd_np->name;
+
+	mtd = get_mtd_device_nm(part);
+	if (IS_ERR(mtd))
+		return PTR_ERR(mtd);
+	buf = kmalloc(mtd->erasesize, GFP_KERNEL);
+	ret = mtd_read(mtd, 0, mtd->erasesize, &retlen, buf);
+
+	ei.mtd = mtd;
+	ei.callback = NULL;
+	ei.addr = 0;
+	ei.len = mtd->erasesize;
+	ei.priv = 0;
+	ret = mtd_erase(mtd, &ei);
+	memcpy(buf,mac,6);
+	ret = mtd_write(mtd, 0, mtd->erasesize, &retlen, buf);
+	kfree(buf);
+	put_mtd_device(mtd);
+
+	return ret;
+}
+
+int is_valid_sf_address(const unsigned char * mac) {
+	//10:16:88
+	return ((mac[0] == 0x10) && (mac[1] == 0x16) && (mac[2] == 0x88));
+}
+
+int set_sf_address(char * mac) {
+	//10:16:88
+	mac[0] = 0x10;
+	mac[1] = 0x16;
+	mac[2] = 0x88;
+	return 0;
+}
+
+static int sf_eth_probe(struct platform_device *pdev) {
+	struct sf_priv *priv;
+	struct net_device *netdev = NULL;
+	//char macaddr[6]={0x00,0x11,0x22,0x33,0x44,0x77};
+	int rc = 0, err;
+	struct resource *res = NULL;
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	const struct of_device_id *match;
+#endif
+	print_msg(ETH_INIT_DEBUG,netdev,"ps_probe start\n");
+
+	// device_reset(&pdev->dev);
+	if(release_reset(SF_NPU_SOFT_RESET))
+		return -EFAULT;
+	netdev = alloc_etherdev(sizeof(*priv));
+	if (!netdev) {
+		dev_err(&pdev->dev, "alloc_etherdev failed\n");
+		return -ENOMEM;
+	}
+	SET_NETDEV_DEV(netdev, &pdev->dev);
+	ether_setup(netdev);
+	netdev->flags &= ~IFF_UP;
+	netdev->ethtool_ops = &sf_ethtool_ops;
+	netdev->netdev_ops   = &sf_netdev_ops;
+	netdev->mtu = ETH_DATA_LEN;
+	/* Mac address for HIF device */
+	//memcpy(netdev->dev_addr, macaddr, sizeof(macaddr));
+
+	priv = (struct sf_priv *)netdev_priv(netdev);
+	g_sf_priv = priv;
+	priv->netdev = netdev;
+	priv->device = &pdev->dev;
+	priv->msg_enable = netif_msg_init(sf_msg_type, SF_DEFAULT_MSG_ENABLE);
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	match = of_match_device(of_sf_match, &pdev->dev);
+	priv->sf_switch_data = (struct sf_switch_data_t *)match->data;
+#endif
+
+	of_get_mac_address_mtd(priv->device->of_node, netdev->dev_addr);
+	if (!is_valid_ether_addr(netdev->dev_addr) || !is_valid_sf_address(netdev->dev_addr)) {
+	//10:16:88
+		 eth_hw_addr_random(netdev);
+		 set_sf_address(netdev->dev_addr);
+		 dev_err(priv->device, "generated random MAC address %pM\n",netdev->dev_addr);
+		 rc = set_mac_address_mtd(priv->device->of_node, netdev->dev_addr);
+	 }
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sf_base = devm_ioremap_resource(&pdev->dev, res);
+	// sf_base = NPU_ADDR_BASE;
+	if (!sf_base) {
+		err = -ENOMEM;
+		goto  err_free_dev;
+	}
+	netdev->base_addr = (int)sf_base;
+	print_msg(ETH_INIT_DEBUG,netdev,"netdev->base_addr:%x\n", (uint)sf_base);
+
+	netdev->irq = platform_get_irq(pdev, 0);
+	if (netdev->irq < 0) {
+		dev_err(&pdev->dev, "no IRQ resource found\n");
+		err = -ENXIO;
+		goto err_iounmap;
+	}
+	print_msg(ETH_INIT_DEBUG,netdev,"netdev->irq:%d\n", netdev->irq);
+
+	netif_napi_add(netdev, &priv->napi, sf_eth_napi_poll, 32);
+
+	//TODO  is it the name shows in system
+	//strcpy(netdev->name, "fp%d");
+
+	rc = register_netdev(netdev);
+	if (rc) {
+		goto err_napi;
+	}
+
+	// spin_lock_init(&priv->lock);
+	platform_set_drvdata(pdev, netdev);
+	//register switch device
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	priv->sf_switch_data->switch_probe(priv);
+	/*detect port status code init*/
+	dps_genl_init();
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+	priv->npu_debug = debugfs_create_file("npu_debug", 0777, NULL, NULL, &npu_debug_ops);
+#endif
+	print_msg(ETH_INIT_DEBUG,netdev,"sf eth probe success\n");
+	return 0;
+
+err_napi:
+	netif_napi_del(&priv->napi);
+err_iounmap:
+	devm_iounmap(&pdev->dev, sf_base);
+err_free_dev:
+	free_netdev(netdev);
+
+	print_msg(ETH_INIT_DEBUG,netdev,"ps_probe end err\n");
+	return err;
+}
+
+int sf_eth_stop(struct net_device *dev) {
+	struct sf_priv *priv = netdev_priv(dev);
+	int count = 0, i = 0;
+
+#ifdef CONFIG_SFAX8_SWITCH_AGEING
+	sf_switch_init_timer(0);
+#endif
+	netif_tx_disable(dev);
+
+	sf_mac_disable_rx();
+
+	sf_writel(0, REG_HIF_TX_CTRL);
+
+	count = sf_readl(REG_BMU_REM_BUF_CNT);
+	while (count != 0x400) {
+		mdelay(10);
+		count = sf_readl(REG_BMU_REM_BUF_CNT);
+		print_msg(ETH_INIT_DEBUG,dev,"bmu remain count %d\n",count);
+		if(i == 100){
+			break;
+		}
+		i++;
+	}
+
+	napi_disable(&priv->napi);
+	sf_writel(0, REG_HIF_RX_CTRL);
+	sf_mac_disable_tx();
+
+	sf_disable_int(priv);
+
+	kthread_stop(priv->bmu_kthread);
+	/*disable npu clk after operate mac*/
+	clk_disable_unprepare(priv->clk[0]);
+	clk_disable_unprepare(priv->clk[1]);
+	clk_disable_unprepare(priv->clk[2]);
+#ifdef CONFIG_SF16A18_MPW1
+	clk_disable_unprepare(priv->clk[3]);
+#endif
+	/* Cleanup the bd rings */
+	// spin_lock_bh(&priv->lock);
+	bd_rx_ring_deinit(priv);
+	bd_tx_ring_deinit(priv);
+	// spin_unlock_bh(&priv->lock);
+	devm_free_irq(priv->device, dev->irq, dev);
+	//devm_free_irq(priv->device, 32, dev);
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	priv->sf_switch_data->switch_stop(priv);
+#else
+	sfax8_free_phy_irq(priv);
+#endif
+	//emac[5-1]_phy_enable[4:0] disable all phy
+	writeb(0,(void*)(OMINI_PHY_ENABLE));
+
+	return 0;
+}
+
+
+static int sf_eth_remove(struct platform_device *pdev) {
+	struct sf_priv *priv = NULL;
+	struct net_device *netdev = platform_get_drvdata(pdev);
+	if (netdev == NULL)
+		return -1;
+	priv = netdev_priv(netdev);
+	if (priv == NULL)
+		return -1;
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	priv->sf_switch_data->switch_remove(priv);
+	dps_genl_exit();
+#endif
+
+
+	print_msg(ETH_INIT_DEBUG,netdev, "clean up eth module");
+
+	if(netdev->base_addr)
+		devm_iounmap(&pdev->dev, (void *)netdev->base_addr);
+
+	netif_napi_del(&priv->napi);
+	unregister_netdev(netdev);
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(priv->npu_debug);
+#endif
+
+	g_sf_priv = NULL;
+	free_netdev(netdev);
+	platform_set_drvdata(pdev, NULL);
+
+	if(hold_reset(SF_NPU_SOFT_RESET))
+		return -EFAULT;
+	return 0;
+}
+
+
+static struct platform_driver sf_eth_driver = {
+	.probe = sf_eth_probe,
+	.remove = sf_eth_remove,
+	.driver = {
+		.name = "sf_eth",
+		.owner = THIS_MODULE,
+		.of_match_table = of_sf_match,
+	},
+};
+
+
+
+static void __exit exit_sf_eth(void) {
+	platform_driver_unregister(&sf_eth_driver);
+	return;
+}
+
+static int __init init_sf_eth(void) {
+	int ret = platform_driver_register(&sf_eth_driver);
+	return ret;
+}
+
+module_init(init_sf_eth);
+module_exit(exit_sf_eth);
+
+MODULE_DEVICE_TABLE(of, of_sf_match);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("phoenix shen <phoenix.shen@siflower.com.cn>");
+MODULE_DESCRIPTION("Ethernet driver for sfax8");
+MODULE_VERSION(SF_VERSION);
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_eth.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_eth.h	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,85 @@
+#ifndef SF_ETH_H
+#define SF_ETH_H
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/ethtool.h>
+#include "sf_common.h"
+
+#define SF_VERSION              "0.1"
+
+#define SF_DEFAULT_MSG_ENABLE    \
+	(NETIF_MSG_DRV      | \
+	NETIF_MSG_PROBE    | \
+	NETIF_MSG_LINK     | \
+	NETIF_MSG_TIMER    | \
+	NETIF_MSG_IFDOWN   | \
+	NETIF_MSG_IFUP     | \
+	NETIF_MSG_RX_ERR   | \
+	NETIF_MSG_TX_ERR)
+
+#define SF_TX_PKT_INJECT_EN     (1 << 0)
+#define SF_TX_LAUNCH_TIME_VALID (1 << 1)
+#define SF_TX_PKT_PTP_EN        (1 << 2)
+#define SF_EGR_TSR_VALID        (1 << 4)
+#define SF_PUNT_VALID           (1 << 5)
+#define SF_RX_TS_VALID          (1 << 6)
+
+#define HIF_INT        (1 << 0)
+#define HIF_RXBD_INT   (1 << 1)
+#define HIF_RXPKT_INT  (1 << 2)
+#define HIF_TXBD_INT   (1 << 3)
+#define HIF_TXPKT_INT  (1 << 4)
+
+#define HIF_INT_EN  (1 << 0)
+#define HIF_RXBD_INT_EN   (1 << 1)
+#define HIF_RXPKT_INT_EN  (1 << 2)
+#define HIF_TXBD_INT_EN   (1 << 3)
+#define HIF_TXPKT_INT_EN  (1 << 4)
+
+#define BMU_INT  (1 << 0)
+#define BMU_FULL_INT  (1 << 0)
+#define BMU_THRES_INT  (1 << 0)
+
+#define BMU_INT_EN  (1 << 0)
+#define BMU_FULL_INT_EN  (1 << 2)
+#define BMU_THRES_INT_EN  (1 << 3)
+
+#define SF_MAX_TX_QUEUES     1
+
+#define SF_TX_HDR_LEN 16
+#define SF_RX_HDR_LEN 16
+
+#define CB_INJ_TX_FLAG  41
+#define CB_INJ_TX_PORT  42
+#define CB_TX_SA_MISS   0x40
+struct tx_header
+{
+
+	uchar rsvd0;
+	uchar queue;
+	uchar txport_map;
+	uchar ctrl;
+	ushort ref_num;
+	ushort rsvd1;
+	uint launch_time_nsec;
+	uint launch_time_sec;
+};
+
+struct rx_header
+{
+	ushort punt_reason;
+	uchar rxport_num;
+	uchar ctrl;
+	uint rsvd;
+	uint rx_timestamp_nsec;
+	uint rx_timestamp_sec;
+};
+int sf_txbd_update(struct sk_buff *skb, struct net_device *dev);
+int sf_eth_xmit(struct sk_buff *skb, struct net_device *dev);
+void sf_writel(uint value,uint offset);
+void sf_writew(uint value,uint offset);
+int sf_readl(uint offset);
+int sf_eth_stop(struct net_device *dev);
+// int sf_log_info();
+
+#endif /* ifndef SF_ETH_H */
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_eth_addr.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_eth_addr.h	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,361 @@
+#ifndef SF_ETH_ADDR
+#define SF_ETH_ADDR
+
+/********************sys ctl address ************************/
+#define SIFLOWER_SYSCTL_BASE              0xB9E00000
+
+#define SIFLOWER_NPU_HIF_IRQ             16
+#define SIFLOWER_NPU_BMU_IRQ             24
+
+#define SIFLOWER_NPU_PHY0_IRQ            33
+#define SIFLOWER_NPU_PHY1_IRQ            34
+#define SIFLOWER_NPU_PHY2_IRQ            35
+#define SIFLOWER_NPU_PHY3_IRQ            36
+#define SIFLOWER_NPU_PHY4_IRQ            37
+//NPU
+#define NPU_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x2C44)
+#define NPU_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0x4000)
+#define NPU_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0x4004)
+#define NPU_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0x400C)
+#define NPU_HW_RST_PGM_EN                (SIFLOWER_SYSCTL_BASE + 0x40CC)
+
+/********************Npu address ************************/
+#define NPU_ADDR_BASE                     0xB0000000
+
+/***********************BMU CSR*************************/
+#define BMU_BASE_OFFSET                          0x240000
+#define REG_BMU_CTRL                             BMU_BASE_OFFSET  + 0x04
+#define REG_BMU_UCAST_CONFIG                     BMU_BASE_OFFSET  + 0x08
+#define REG_BMU_UCAST_BASEADDR                   BMU_BASE_OFFSET  + 0x0c
+#define REG_BMU_BUF_SIZE                         BMU_BASE_OFFSET  + 0x10
+#define REG_BMU_BUF_CNT							 BMU_BASE_OFFSET  + 0x14
+#define REG_BMU_REM_BUF_CNT						 BMU_BASE_OFFSET  + 0x48
+#define REG_BMU_THRES                            BMU_BASE_OFFSET  + 0x18
+#define REG_BMU_INT_SRC                          BMU_BASE_OFFSET  + 0x20
+#define REG_BMU_INT_ENABLE                       BMU_BASE_OFFSET  + 0x24
+#define REG_BMU_ALLOC_CTRL                       BMU_BASE_OFFSET  + 0x30
+#define REG_BMU_LOW_WATERMARK					 BMU_BASE_OFFSET  + 0x50
+#define REG_BMU_HIGH_WATERMARK					 BMU_BASE_OFFSET  + 0x54
+
+/***********************EMAC CSR*************************/
+#define EMAC0_BASE_OFFSET				            0x200000
+#define EMAC1_BASE_OFFSET							0x220000
+#define EMAC2_BASE_OFFSET							0x680000
+#define EMAC3_BASE_OFFSET							0x690000
+#define EMAC4_BASE_OFFSET							0x6a0000
+
+#define REG_EMAC_CFG(X)                          EMAC##X##_BASE_OFFSET + 0x0000
+#define REG_EMAC_FILTER(X)                       EMAC##X##_BASE_OFFSET + 0x0004
+#define REG_EMAC_GMII_ADDRESS(X)                 EMAC##X##_BASE_OFFSET + 0x0010
+#define REG_EMAC_GMII_DATA(X)                    EMAC##X##_BASE_OFFSET + 0x0014
+#define REG_EMAC_FLOWCTL(X)                      EMAC##X##_BASE_OFFSET + 0x0018
+#define REG_EMAC_ADDRESS0_16_H(X)                EMAC##X##_BASE_OFFSET + 0x0040
+#define REG_EMAC_ADDRESS0_32_L(X)                EMAC##X##_BASE_OFFSET + 0x0044
+#define REG_EMAC_ADDRESS1_16_H(X)                EMAC##X##_BASE_OFFSET + 0x0048
+#define REG_EMAC_ADDRESS1_32_L(X)                EMAC##X##_BASE_OFFSET + 0x004c
+#define REG_EMAC_VLAN_CONFIG(X)                  EMAC##X##_BASE_OFFSET + 0x0584
+//emac_control_reg to control emac signals
+#define REG_EMAC_CFG_GLOBAL(X)					 EMAC##X##_BASE_OFFSET + 0x0B80
+
+#define REG_EMAC_CONTROL							0xB80
+#define REG_EMAC_TIMESTAMP_CONTROL					0x700
+#define REG_EMAC_FLOW_CONTROL						0x0018
+#define REG_MAC_ADDRESS0_HIGH						0x0040
+#define REG_MAC_ADDRESS0_LOW						0x0044
+
+#define CONFIG_EMAC_SECTION(X) \
+	{ REG_EMAC_CFG_GLOBAL(X),		0}, \
+	{ REG_EMAC_CFG(X),				0x0210c880}, \
+	{ REG_EMAC_FILTER(X),			0x80000040}, \
+	{ REG_EMAC_FLOWCTL(X),			0xFFFF0006}, \
+	{ REG_EMAC_VLAN_CONFIG(X),      0x50000},
+
+/***********************Classifier CSR*************************/
+#define CLASS_BASE_OFFSET							0x320000
+
+#define REG_CLASS_TX_CTRL                        CLASS_BASE_OFFSET  + 0x04
+#define REG_CLASS_HDR_SIZE                       CLASS_BASE_OFFSET  + 0x14
+#define REG_CLASS_TM_INQ_ADDR					 CLASS_BASE_OFFSET  + 0x114
+#define REG_CLASS_BMU_BUF_FREE                   CLASS_BASE_OFFSET  + 0x24c
+#define REG_CLASS_USE_TMU_INQ                    CLASS_BASE_OFFSET    + 0x250
+#define REG_CLASS_SNOOP_SPL_MCAST_ADDR1_LSB      (CLASS_BASE_OFFSET  + 0x368)
+#define REG_CLASS_SNOOP_SPL_MCAST_ADDR1_MSB      (CLASS_BASE_OFFSET  + 0x36c)
+#define REG_CLASS_SNOOP_SPL_MCAST_ADDR2_LSB      (CLASS_BASE_OFFSET  + 0x370)
+#define REG_CLASS_SNOOP_SPL_MCAST_ADDR2_MSB      (CLASS_BASE_OFFSET  + 0x374)
+#define REG_CLASS_SNOOP_SPL_MCAST_MASK1_LSB      (CLASS_BASE_OFFSET  + 0x378)
+#define REG_CLASS_SNOOP_SPL_MCAST_MASK1_MSB      (CLASS_BASE_OFFSET  + 0x37C)
+#define REG_CLASS_SNOOP_SPL_MCAST_MASK2_LSB      (CLASS_BASE_OFFSET  + 0x380)
+#define REG_CLASS_SNOOP_SPL_MCAST_MASK2_MSB      (CLASS_BASE_OFFSET  + 0x384)
+#define REG_CLASS_GLOBAL_CFG                     CLASS_BASE_OFFSET  + 0x4ac
+
+#define REG_CLASS_SNOOP_CTRL					 (CLASS_BASE_OFFSET  + 0x90)
+#define REG_CLASS_SNOOP_SPL_ETYPE_REG01          (CLASS_BASE_OFFSET  + 0x88)
+#define REG_CLASS_SNOOP_SPL_ETYPE_REG23          (CLASS_BASE_OFFSET  + 0x8c)
+
+#define REG_CLASS_QOS_PORT0_PCP2TC_MAP           (CLASS_BASE_OFFSET  + 0x44)
+#define REG_CLASS_QOS_PORT1_PCP2TC_MAP           (CLASS_BASE_OFFSET  + 0x48)
+#define REG_CLASS_QOS_PORT2_PCP2TC_MAP           (CLASS_BASE_OFFSET  + 0x4c)
+#define REG_CLASS_QOS_PORT3_PCP2TC_MAP           (CLASS_BASE_OFFSET  + 0x50)
+#define REG_CLASS_QOS_PORT4_PCP2TC_MAP           (CLASS_BASE_OFFSET  + 0x54)
+#define REG_CLASS_QOS_PORT5_PCP2TC_MAP           (CLASS_BASE_OFFSET  + 0x58)
+#define REG_CLASS_QOS_PORT_PID2TC_MAP            (CLASS_BASE_OFFSET  + 0x64)
+
+#define REG_CLASS_QOS_PORT01_TC_SEL              (CLASS_BASE_OFFSET  + 0x18)
+#define REG_CLASS_QOS_PORT23_TC_SEL              (CLASS_BASE_OFFSET  + 0x1c)
+#define REG_CLASS_QOS_PORT45_TC_SEL              (CLASS_BASE_OFFSET  + 0x20)
+
+//DOS
+#define REG_CLASS_DOS_CONTRL1                    (CLASS_BASE_OFFSET  + 0x280)
+#define REG_CLASS_DOS_CONTRL2                    (CLASS_BASE_OFFSET  + 0x284)
+#define REG_CLASS_DOS_TCP_FLAGCHK_COMB_VALUE1    (CLASS_BASE_OFFSET  + 0x288)
+#define REG_CLASS_DOS_ICMPV4_MAX_PKTLEN          (CLASS_BASE_OFFSET  + 0x28c)
+
+#define REG_CLASS_DAMACHASH_HOST_CMD_REG         CLASS_BASE_OFFSET  + 0x390
+#define REG_CLASS_DAVLANHASH_HOST_CMD_REG        CLASS_BASE_OFFSET  + 0x3e4
+#define REG_CLASS_DAMACHASH_FREELIST_ENTRIES     CLASS_BASE_OFFSET  + 0x3d8
+#define REG_CLASS_DAMACHASH_FREELIST_HEAD_PTR    CLASS_BASE_OFFSET  + 0x3dc
+#define REG_CLASS_DAMACHASH_FREELIST_TAIL_PTR    CLASS_BASE_OFFSET  + 0x3e0
+#define REG_CLASS_DAVLANHASH_FREELIST_ENTRIES    CLASS_BASE_OFFSET  + 0x42c
+#define REG_CLASS_DAVLANHASH_FREELIST_HEAD_PTR   CLASS_BASE_OFFSET  + 0x430
+#define REG_CLASS_DAVLANHASH_FREELIST_TAIL_PTR   CLASS_BASE_OFFSET  + 0x434
+
+#define REG_CLASS_HW_PORT0_STRUC1      (CLASS_BASE_OFFSET + 0x0000046c)
+#define REG_CLASS_HW_PORT0_STRUC2      (CLASS_BASE_OFFSET + 0x00000470)
+#define REG_CLASS_HW_PORT1_STRUC1      (CLASS_BASE_OFFSET + 0x00000474)
+#define REG_CLASS_HW_PORT1_STRUC2      (CLASS_BASE_OFFSET + 0x00000478)
+#define REG_CLASS_HW_PORT2_STRUC1      (CLASS_BASE_OFFSET + 0x0000047c)
+#define REG_CLASS_HW_PORT2_STRUC2      (CLASS_BASE_OFFSET + 0x00000480)
+#define REG_CLASS_HW_PORT3_STRUC1      (CLASS_BASE_OFFSET + 0x00000484)
+#define REG_CLASS_HW_PORT3_STRUC2      (CLASS_BASE_OFFSET + 0x00000488)
+#define REG_CLASS_HW_PORT4_STRUC1      (CLASS_BASE_OFFSET + 0x0000048c)
+#define REG_CLASS_HW_PORT4_STRUC2      (CLASS_BASE_OFFSET + 0x00000490)
+#define REG_CLASS_HW_PORT5_STRUC1      (CLASS_BASE_OFFSET + 0x00000494)
+#define REG_CLASS_HW_PORT5_STRUC2      (CLASS_BASE_OFFSET + 0x00000498)
+#define REG_CLASS_HW_PORT6_STRUC1      (CLASS_BASE_OFFSET + 0x0000049c)
+#define REG_CLASS_HW_PORT6_STRUC2      (CLASS_BASE_OFFSET + 0x000004a0)
+#define REG_CLASS_HW_PORT7_STRUC1      (CLASS_BASE_OFFSET + 0x000004a4)
+#define REG_CLASS_HW_PORT7_STRUC2      (CLASS_BASE_OFFSET + 0x000004a8)
+#define REG_CLASS_HW_GLOBAL_CUTTHRU_REG (CLASS_BASE_OFFSET + 0x000004b0)
+#define REG_CLASS_GLOBAL_MGMT_REG       (CLASS_BASE_OFFSET + 0x00000200)
+
+/***********************EGPI CSR*************************/
+#define EGPI0_BASE_OFFSET							0x210000
+#define EGPI1_BASE_OFFSET							0x230000
+#define EGPI2_BASE_OFFSET							0x6B0000
+#define EGPI3_BASE_OFFSET							0x6C0000
+#define EGPI4_BASE_OFFSET							0x620000
+
+#define REG_GPI_INQ_PKTPTR0						0x210030
+#define REG_GPI_INQ_PKTPTR1						0x230030
+#define REG_GPI_INQ_PKTPTR2						0x6b0030
+#define REG_GPI_INQ_PKTPTR3						0x6c0030
+#define REG_GPI_INQ_PKTPTR4						0x620030
+#define REG_GPI_INQ_PKTPTR5						0x340030
+
+#define  REG_EGPI_PORT_SHP_CONFIG					0x128
+#define  REG_EGPI_PORT_SHP0_CTRL					0x098
+#define  REG_EGPI_PORT_SHP0_WGHT					0x09c
+#define  REG_EGPI_PORT_SHP1_CTRL					0x11c
+#define  REG_EGPI_PORT_SHP1_WGHT					0x120
+
+#define  REG_GPI_BMU1_PHY_LOW_WATERMARK_OFFSET                0x104
+#define  REG_GPI_BMU1_PHY_HIGH_WATERMARK_OFFSET               0x108
+#define  REG_GPI_FW_CONTROL_OFFSET							  0x114
+
+#define  REG_GPI_CTRL(X)                        EGPI##X##_BASE_OFFSET + 0x04
+#define  REG_GPI_RX_CONFIG(X)                   EGPI##X##_BASE_OFFSET + 0x08
+#define  REG_GPI_HDR_SIZE(X)                    EGPI##X##_BASE_OFFSET + 0x0c
+#define  REG_GPI_BUF_SIZE(X)                    EGPI##X##_BASE_OFFSET + 0x10
+#define  REG_GPI_LMEM_ALLOC_ADDR(X)             EGPI##X##_BASE_OFFSET + 0x14
+#define  REG_GPI_LMEM_FREE_ADDR(X)              EGPI##X##_BASE_OFFSET + 0x18
+#define  REG_GPI_CLASS_ADDR(X)                  EGPI##X##_BASE_OFFSET + 0x24
+#define  REG_GPI_LMEM_SEC_BUF_DATA_ADDR(X)		EGPI##X##_BASE_OFFSET + 0x60
+#define  REG_GPI_TMLF_TX(X)                     EGPI##X##_BASE_OFFSET + 0x4c
+#define  REG_GPI_DTX_ASEQ(X)                    EGPI##X##_BASE_OFFSET + 0x50
+//TODO: for chksum update
+#define  REG_GPI_CSR_TOE_CHKSUM_EN(X)           EGPI##X##_BASE_OFFSET + 0x54
+
+#define CONFIG_EGPI_SECTION(X) \
+    { REG_GPI_RX_CONFIG(X),     0x02000001}, /*bit 0 – LMEM buffer enable ;bit 31:16 – Retry count for LMEM buffers*/\
+    { REG_GPI_HDR_SIZE(X),      0x00000030}, /*bit 7:0 – LMEM first buffer header size value*/\
+    { REG_GPI_BUF_SIZE(X),      0x00000080}, /*bit 15:0 – LMEM buffer size value as 128 bytes*/\
+    { REG_GPI_LMEM_ALLOC_ADDR(X),  0x00240030}, /*Address of BMU1, where buffer should be allocated.*/\
+    { REG_GPI_LMEM_FREE_ADDR(X),   0x00240034}, /*Address of BMU1, where buffer should be freed*/\
+    { REG_GPI_CLASS_ADDR(X),       0x00320010}, /*Program address of the Class HW register where packet from peripherals are sent to*/\
+    { REG_GPI_LMEM_SEC_BUF_DATA_ADDR(X), 0x00000010}, /*bit 15:0 - LMEM header size from second buffer onwards for each buffer in chain*/\
+    { REG_GPI_TMLF_TX(X),       0x000000bc},/*bit 7:0 - Threshold number of TMLF words - 64bit size, to be in the TMLF FIFO before transmission starts*/\
+    { REG_GPI_DTX_ASEQ(X),      0x00000050},/*Initial number of bytes read from received pointer in LMEM, to check for action fields*/
+
+
+/***********************ETGPI CSR*************************/
+#ifdef CONFIG_NET_SFAX8_PTP
+#define ETGPI0_BASE_OFFSET							0x630000
+#define ETGPI1_BASE_OFFSET							0x640000
+#define ETGPI2_BASE_OFFSET							0x650000
+#define ETGPI3_BASE_OFFSET							0x660000
+#define ETGPI4_BASE_OFFSET							0x670000
+
+#define  REG_TGPI_RX_CONFIG(X)                   ETGPI##X##_BASE_OFFSET + 0x08
+#define  REG_TGPI_HDR_SIZE(X)                    ETGPI##X##_BASE_OFFSET + 0x0c
+#define  REG_TGPI_BUF_SIZE(X)                    ETGPI##X##_BASE_OFFSET + 0x10
+#define  REG_TGPI_LMEM_ALLOC_ADDR(X)             ETGPI##X##_BASE_OFFSET + 0x14
+#define  REG_TGPI_LMEM_FREE_ADDR(X)              ETGPI##X##_BASE_OFFSET + 0x18
+#define  REG_TGPI_CLASS_ADDR(X)                  ETGPI##X##_BASE_OFFSET + 0x24
+#define  REG_TGPI_LMEM_SEC_BUF_DATA_ADDR(X)		 ETGPI##X##_BASE_OFFSET + 0x60
+#define  REG_TGPI_TMLF_TX(X)                     ETGPI##X##_BASE_OFFSET + 0x4c
+#define  REG_TGPI_DTX_ASEQ(X)                    ETGPI##X##_BASE_OFFSET + 0x50
+
+#define CONFIG_ETGPI_SECTION(X) \
+    { REG_TGPI_RX_CONFIG(X),     0x02000001}, /*bit 0 – LMEM buffer enable ;bit 31:16 – Retry count for LMEM buffers*/\
+    { REG_TGPI_HDR_SIZE(X),      0x00000030}, /*bit 7:0 – LMEM first buffer header size value*/\
+    { REG_TGPI_BUF_SIZE(X),      0x00000080}, /*bit 15:0 – LMEM buffer size value as 128 bytes*/\
+    { REG_TGPI_LMEM_ALLOC_ADDR(X),  0x00240030}, /*Address of BMU1, where buffer should be allocated.*/\
+    { REG_TGPI_LMEM_FREE_ADDR(X),   0x00240034}, /*Address of BMU1, where buffer should be freed*/\
+    { REG_TGPI_CLASS_ADDR(X),       0x00320010}, /*Program address of the Class HW register where packet from peripherals are sent to*/\
+    { REG_TGPI_LMEM_SEC_BUF_DATA_ADDR(X), 0x00000010}, /*bit 15:0 - LMEM header size from second buffer onwards for each buffer in chain*/\
+    { REG_TGPI_TMLF_TX(X),       0x000000bc},/*bit 7:0 - Threshold number of TMLF words - 64bit size, to be in the TMLF FIFO before transmission starts*/\
+    { REG_TGPI_DTX_ASEQ(X),      0x00000050},/*Initial number of bytes read from received pointer in LMEM, to check for action fields*/
+#endif
+
+/***********************HGPI CSR*************************/
+#define HGPI_BASE_OFFSET							0x340000
+
+#define REG_HGPI_CTRL                            HGPI_BASE_OFFSET + 0x04
+#define REG_HGPI_RX_CONFIG                       HGPI_BASE_OFFSET + 0x08
+#define REG_HGPI_HDR_SIZE                        HGPI_BASE_OFFSET + 0x0c
+#define REG_HGPI_BUF_SIZE                        HGPI_BASE_OFFSET + 0x10
+#define REG_HGPI_LMEM_ALLOC_ADDR			 	 HGPI_BASE_OFFSET + 0x14
+#define REG_HGPI_LMEM_FREE_ADDR					 HGPI_BASE_OFFSET + 0x18
+#define REG_HGPI_CLASS_ADDR						 HGPI_BASE_OFFSET + 0x24
+#define REG_HGPI_INQ_PKTPTR                      HGPI_BASE_OFFSET + 0x30
+#define REG_HGPI_LMEM_SEC_BUF_DATA_ADDR			 HGPI_BASE_OFFSET + 0x60
+#define REG_HGPI_TMLF_TX                         HGPI_BASE_OFFSET + 0x4c
+#define REG_HGPI_DTX_ASEQ                        HGPI_BASE_OFFSET + 0x50
+
+#define CONFIG_HGPI_SECTION() \
+    { REG_HGPI_RX_CONFIG,     0x02000001}, /*bit 0 – LMEM buffer enable ;bit 31:16 – Retry count for LMEM buffers*/\
+    { REG_HGPI_HDR_SIZE,      0x00000030}, /*bit 7:0 – LMEM first buffer header size value*/\
+    { REG_HGPI_BUF_SIZE,      0x00000080}, /*bit 15:0 – LMEM buffer size value as 128 bytes*/\
+    { REG_HGPI_LMEM_ALLOC_ADDR,  0x00240030}, /*Address of BMU1, where buffer should be allocated.*/\
+    { REG_HGPI_LMEM_FREE_ADDR,   0x00240034}, /*Address of BMU1, where buffer should be freed*/\
+    { REG_HGPI_CLASS_ADDR,       0x00320010}, /*Program address of the Class HW register where packet from peripherals are sent to*/\
+    { REG_HGPI_LMEM_SEC_BUF_DATA_ADDR, 0x00000010}, /*bit 15:0 - LMEM header size from second buffer onwards for each buffer in chain*/\
+    { REG_HGPI_TMLF_TX,       0x000000bc},/*bit 7:0 - Threshold number of TMLF words - 64bit size, to be in the TMLF FIFO before transmission starts*/\
+    { REG_HGPI_DTX_ASEQ,      0x00000040},/*Initial number of bytes read from received pointer in LMEM, to check for action fields*/
+
+/***********************TMU CSR*************************/
+#define TMU_BASE_OFFSET							0x310000
+#define REG_TMU_PHY0_INQ_ADDR					TMU_BASE_OFFSET  + 0x200
+#define REG_TMU_PHY1_INQ_ADDR					TMU_BASE_OFFSET  + 0x204
+#define REG_TMU_PHY2_INQ_ADDR					TMU_BASE_OFFSET  + 0x208
+#define REG_TMU_PHY3_INQ_ADDR					TMU_BASE_OFFSET  + 0x20c
+#define REG_TMU_PHY4_INQ_ADDR					TMU_BASE_OFFSET  + 0x210
+#define REG_TMU_PHY5_INQ_ADDR					TMU_BASE_OFFSET  + 0x214
+#define REG_TMU_CNTX_ACCESS_CTRL                 TMU_BASE_OFFSET  + 0x280
+#define REG_TMU_CNTX_ADDR		                (TMU_BASE_OFFSET  + 0x284)
+#define REG_TMU_CNTX_DATA		                (TMU_BASE_OFFSET  + 0x288)
+#define REG_TMU_CNTX_CMD		                (TMU_BASE_OFFSET  + 0x28c)
+#define REG_TMU_PHY0_TDQ_CTRL                   (TMU_BASE_OFFSET  + 0x260)
+#define REG_TMU_PHY1_TDQ_CTRL                    TMU_BASE_OFFSET  + 0x264
+#define REG_TMU_PHY2_TDQ_CTRL                    TMU_BASE_OFFSET  + 0x268
+#define REG_TMU_PHY3_TDQ_CTRL                    TMU_BASE_OFFSET  + 0x26c
+#define REG_TMU_PHY4_TDQ_CTRL                    TMU_BASE_OFFSET  + 0x270
+#define REG_TMU_PHY5_TDQ_CTRL                    TMU_BASE_OFFSET  + 0x274
+#define REG_TMU_BMU_INQ_ADDR					 TMU_BASE_OFFSET  + 0x100
+
+#define TMU_TDQ_PHY0_CSR_BASE_ADDR               TMU_BASE_OFFSET + 0x1000
+#define TMU_TDQ_PHY1_CSR_BASE_ADDR               TMU_BASE_OFFSET + 0x2000
+#define TMU_TDQ_PHY2_CSR_BASE_ADDR               TMU_BASE_OFFSET + 0x3000
+#define TMU_TDQ_PHY3_CSR_BASE_ADDR               TMU_BASE_OFFSET + 0x4000
+#define TMU_TDQ_PHY4_CSR_BASE_ADDR               TMU_BASE_OFFSET + 0x5000
+
+/* tmu_phy_sch_reg_add */
+#define REG_TMU_PHY0_SCH0_CTRL					(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x00)
+#define REG_TMU_PHY0_SCH0_Q0_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x20)
+#define REG_TMU_PHY0_SCH0_Q1_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x24)
+#define REG_TMU_PHY0_SCH0_Q2_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x28)
+#define REG_TMU_PHY0_SCH0_Q3_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x2c)
+#define REG_TMU_PHY0_SCH0_Q4_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x30)
+#define REG_TMU_PHY0_SCH0_Q5_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x34)
+#define REG_TMU_PHY0_SCH0_Q6_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x38)
+#define REG_TMU_PHY0_SCH0_Q7_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x3c)
+#define REG_TMU_PHY0_SCH0_Q_ALLOC0				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x40)
+#define REG_TMU_PHY0_SCH0_Q_ALLOC1				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x44)
+#define REG_TMU_PHY0_SCH0_BIT_RATE				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x48)
+#define REG_TMU_PHY0_SCH0_POS					(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x54)
+
+#define REG_TMU_PHY0_SCH1_CTRL					(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x300)
+#define REG_TMU_PHY0_SCH1_Q0_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x320)
+#define REG_TMU_PHY0_SCH1_Q1_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x324)
+#define REG_TMU_PHY0_SCH1_Q2_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x328)
+#define REG_TMU_PHY0_SCH1_Q3_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x32c)
+#define REG_TMU_PHY0_SCH1_Q4_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x330)
+#define REG_TMU_PHY0_SCH1_Q5_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x334)
+#define REG_TMU_PHY0_SCH1_Q6_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x338)
+#define REG_TMU_PHY0_SCH1_Q7_WGHT				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x33c)
+#define REG_TMU_PHY0_SCH1_Q_ALLOC0				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x340)
+#define REG_TMU_PHY0_SCH1_Q_ALLOC1				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x344)
+#define REG_TMU_PHY0_SCH1_BIT_RATE				(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x348)
+
+/* tmu_phy_shp_reg_add  */
+#define REG_TMU_PHY0_SHP0_CTRL                  (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x800)
+#define REG_TMU_PHY0_SHP0_WGHT                  (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x804)
+#define REG_TMU_PHY0_SHP0_MAX_CREDIT            (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x808)
+#define REG_TMU_PHY0_SHP0_CTRL2					(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x80c)
+#define REG_TMU_PHY0_SHP0_MIN_CREDIT			(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x810)
+
+#define REG_TMU_PHY0_SHP1_CTRL                  (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x900)
+#define REG_TMU_PHY0_SHP1_WGHT                  (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x904)
+#define REG_TMU_PHY0_SHP1_MAX_CREDIT            (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x908)
+#define REG_TMU_PHY0_SHP1_CTRL2					(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x90c)
+#define REG_TMU_PHY0_SHP1_MIN_CREDIT			(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0x910)
+
+#define REG_TMU_PHY0_SHP2_CTRL                  (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xa00)
+#define REG_TMU_PHY0_SHP2_WGHT                  (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xa04)
+#define REG_TMU_PHY0_SHP2_MAX_CREDIT            (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xa08)
+#define REG_TMU_PHY0_SHP2_CTRL2					(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xa0c)
+#define REG_TMU_PHY0_SHP2_MIN_CREDIT			(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xa10)
+
+#define REG_TMU_PHY0_SHP3_CTRL                  (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xb00)
+#define REG_TMU_PHY0_SHP3_WGHT                  (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xb04)
+#define REG_TMU_PHY0_SHP3_MAX_CREDIT            (TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xb08)
+#define REG_TMU_PHY0_SHP3_CTRL2					(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xb0c)
+#define REG_TMU_PHY0_SHP3_MIN_CREDIT			(TMU_TDQ_PHY0_CSR_BASE_ADDR + 0xb10)
+
+
+#define REG_TMU_PHY_QUEUE_SEL_ADDR               TMU_BASE_OFFSET + 0x34
+#define REG_TMU_CURQ_PTR_ADDR                    TMU_BASE_OFFSET + 0x38
+#define REG_TMU_CURQ_PKT_CNT_ADDR                TMU_BASE_OFFSET + 0x3c
+#define REG_TMU_CURQ_DROP_CNT_ADDR               TMU_BASE_OFFSET + 0x40
+#define REG_TMU_CURQ_TRANS_CNT_ADDR              TMU_BASE_OFFSET + 0x44
+#define REG_TMU_CURQ_QSTAT_ADDR                  TMU_BASE_OFFSET + 0x48
+#define REG_TMU_HW_PROB_CFG_TBL0_ADDR            TMU_BASE_OFFSET + 0x4c
+#define REG_TMU_HW_PROB_CFG_TBL1_ADDR            TMU_BASE_OFFSET + 0x50
+#define REG_TMU_CURQ_DEBUG_ADDR                  TMU_BASE_OFFSET + 0x54
+
+
+/***********************HIF CSR*************************/
+#define HIF_BASE_OFFSET							0x330000
+
+#define REG_HIF_TX_CTRL                          HIF_BASE_OFFSET  + 0x04
+#define REG_HIF_TX_BDP_ADDR                      HIF_BASE_OFFSET  + 0x10
+#define REG_HIF_TX_ALLOC                         HIF_BASE_OFFSET  + 0x0c
+#define REG_HIF_RX_CTRL                          HIF_BASE_OFFSET  + 0x20
+#define REG_HIF_RX_BDP_ADDR						 HIF_BASE_OFFSET  + 0x24
+#define REG_HIF_INT_SRC                          HIF_BASE_OFFSET  + 0x34
+#define REG_HIF_INT_EN                           HIF_BASE_OFFSET  + 0x38
+#define REG_HIF_POLL_CTRL                        HIF_BASE_OFFSET  + 0x3c
+#define REG_HIF_RX_ALLOC                         HIF_BASE_OFFSET  + 0x44
+
+/***********************WSP CSR*************************/
+#define WSP_GLOBAL_BASE_OFFSET                     0x600000
+#define REG_WSP_SYS_GENERIC_CONTROL              WSP_GLOBAL_BASE_OFFSET + 0x20
+
+typedef struct hwinit_data {
+   unsigned int offset;
+   unsigned int data;
+} hwinit_data_t;
+
+
+
+#endif /* ifndef SF_ETH_ADDR*/
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_ethtool.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_ethtool.c	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,19 @@
+#include <linux/ethtool.h>
+#include "sf_common.h"
+
+static uint sf_get_msg_type(struct net_device *dev){
+	struct sf_priv *priv = netdev_priv(dev);
+	return priv->msg_enable;
+}
+static void sf_set_msg_type(struct net_device *dev, u32 value) {
+	struct sf_priv *priv = netdev_priv(dev);
+	priv->msg_enable = value;
+}
+struct ethtool_ops sf_ethtool_ops = {
+	.begin			= NULL,
+	.complete		= NULL, /* fp_ethtool_complete */
+	.get_settings	= NULL, /* fp_get_settings */
+	.set_settings	= NULL, /* fp_set_settings */
+	.get_msglevel	= sf_get_msg_type,
+	.set_msglevel	= sf_set_msg_type,
+};
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_ethtool.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_ethtool.h	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,6 @@
+#ifndef _SF_ETHTOOL_H_
+#define _SF_ETHTOOL_H_
+
+extern struct ethtool_ops sf_ethtool_ops;
+
+#endif /* ifndef _SF_ETHTOOL_H_ */
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_mdio.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_mdio.c	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,506 @@
+#include <linux/phy.h>
+#include <linux/ethtool.h>
+#include "sf_eth.h"
+#include "sf_eth_addr.h"
+#include "sf_common.h"
+#include "sf_mdio.h"
+
+int get_mac_cfg_addr(int mac_no)
+{
+	switch(mac_no){
+		case 0: return REG_EMAC_CFG(0);
+		case 1: return REG_EMAC_CFG(1);
+		case 2: return REG_EMAC_CFG(2);
+		case 3: return REG_EMAC_CFG(3);
+		case 4: return REG_EMAC_CFG(4);
+		default: return REG_EMAC_CFG(0);
+	}
+	return 0;
+}
+static int get_mii_data_addr(int phy_no)
+{
+
+	switch(phy_no){
+
+		case 0: return REG_EMAC_GMII_DATA(0);
+		case 1: return REG_EMAC_GMII_DATA(1);
+		case 2: return REG_EMAC_GMII_DATA(2);
+		case 3: return REG_EMAC_GMII_DATA(3);
+		case 4: return REG_EMAC_GMII_DATA(4);
+		default: return REG_EMAC_GMII_DATA(0);
+	}
+	return 0;
+}
+
+static int get_mii_cmd_addr(int phy_no)
+{
+	switch(phy_no){
+		case 0: return REG_EMAC_GMII_ADDRESS(0);
+		case 1: return REG_EMAC_GMII_ADDRESS(1);
+		case 2: return REG_EMAC_GMII_ADDRESS(2);
+		case 3: return REG_EMAC_GMII_ADDRESS(3);
+		case 4: return REG_EMAC_GMII_ADDRESS(4);
+		default: return REG_EMAC_GMII_ADDRESS(0);
+	}
+	return 0;
+}
+int wait_phy_rw_not_busy(int phy_no)
+{
+
+	int reg = sf_readl(get_mii_cmd_addr(phy_no));
+	// wait for GMII Register GB is not busy
+	while(reg & GMII_ADDR_MASK_GB){
+		reg = sf_readl(get_mii_cmd_addr(phy_no));
+	}
+	return reg;
+}
+
+//set phy reg with mac register
+void write_phy_reg(int phy_no,int phy_reg,int value,struct phy_device* phy_dev)
+{
+
+	int addr_value = wait_phy_rw_not_busy(phy_no);
+	//prepare data for register 5
+	sf_writel(value & GMII_DATA_MASK,get_mii_data_addr(phy_no));
+	//set address flag
+	addr_value = (addr_value & (~GMII_ADDR_MASK_GR)) | ((phy_reg << 6) & GMII_ADDR_MASK_GR);
+	//set phy addr
+	addr_value = (addr_value & (~GMII_ADDR_MASK_PA)) | ((phy_dev[phy_no].addr << 11) & GMII_ADDR_MASK_PA);
+	//set read flag
+	addr_value = (addr_value & (~GMII_ADDR_MASK_GW)) | (GMII_ADDR_VALUE_GW_WRITE & GMII_ADDR_MASK_GW);
+	//set GB flag to indica is busy now
+	addr_value = addr_value | GMII_ADDR_MASK_GB;
+	sf_writel(addr_value,get_mii_cmd_addr(phy_no));
+	//wait for finish
+	wait_phy_rw_not_busy(phy_no);
+}
+
+int read_phy_reg_direct(int phy_no,int phy_addr,int phy_reg)
+{
+	int value = wait_phy_rw_not_busy(phy_no);
+	//clear the data first
+	sf_writel(DEFAULT_PHY_VALUE ,get_mii_data_addr(phy_no));
+	//set address flag
+	value = (value & (~GMII_ADDR_MASK_GR)) | ((phy_reg << 6) & GMII_ADDR_MASK_GR);
+	//set phy addr
+	value = (value & (~GMII_ADDR_MASK_PA)) | ((phy_addr << 11) & GMII_ADDR_MASK_PA);
+	//set read flag
+	value = (value & (~GMII_ADDR_MASK_GW)) | (GMII_ADDR_VALUE_GW_READ & GMII_ADDR_MASK_GW);
+	//set GB flag to indica is busy now
+	value = value | GMII_ADDR_MASK_GB;
+	sf_writel(value ,get_mii_cmd_addr(phy_no));
+	//wait for complete
+	wait_phy_rw_not_busy(phy_no);
+	return sf_readl(get_mii_data_addr(phy_no)) & GMII_DATA_MASK;
+}
+
+//read phy reg with mac register
+int read_phy_reg(int phy_no,int phy_reg, struct phy_device* phy_dev)
+{
+	return read_phy_reg_direct(phy_no,phy_dev[phy_no].addr,phy_reg);
+}
+
+void sf_phy_init(struct phy_device* phy_dev)
+{
+	//scan first to get phy id and addr
+	phy_scan(phy_dev);
+	//for PHY0 to PHY4
+#ifdef CONFIG_SFAX8_SWITCH_FPGA
+	int i = 0;
+	for(i = 0 ; i < SF_MAC_PORTS ; i++){
+		phy_dev[i].duplex = DUPLEX_FULL;
+		phy_dev[i].speed = SPEED_100;
+		//init marvell phy
+		/*Marvell speed Bit 6,13  of Control registers
+		  |   10 = 1000 Mbps
+		  |   01 = 100 Mbps
+		  |   00 = 10 Mbps
+		  |   */
+		//init marvell phy(almost the same)
+		//Change Page Number for copper
+		write_phy_reg(i,MIIM_88E1111_PHY_PAGE,0x0000, phy_dev);
+		//read first
+		int phy_ctrl = read_phy_reg(i,PHY_BASE_CONTROL_REGISTER, phy_dev);
+
+		if(phy_dev[i].duplex == DUPLEX_FULL){
+
+			phy_ctrl |= PHY_BASE_ENABLE_DUPLEX_FULL;
+		}else{
+
+			phy_ctrl = phy_ctrl & (~PHY_BASE_ENABLE_DUPLEX_FULL);
+		}
+		phy_ctrl &= (~PHY_BASE_ENABLE_AUTO_NEG);
+		if(phy_dev[i].speed == SPEED_10){
+
+			//set 10 mbps
+			phy_ctrl = (phy_ctrl & (~MAVELL_PHY_SPEED_MASK)) | MAVELL_PHY_SPEED_10m;
+		}else if(phy_dev[i].speed == SPEED_100){
+
+			phy_ctrl = (phy_ctrl & (~MAVELL_PHY_SPEED_MASK)) | MAVELL_PHY_SPEED_100m;
+		}else{
+
+			phy_ctrl = (phy_ctrl & (~MAVELL_PHY_SPEED_MASK)) | PHY_BASE_ENABLE_AUTO_NEG;
+		}
+		write_phy_reg(i,PHY_BASE_CONTROL_REGISTER,phy_ctrl, phy_dev);
+		//reset phy and wait reset flag be cleared
+		phy_ctrl = (read_phy_reg(i,PHY_BASE_CONTROL_REGISTER, phy_dev) | PHY_BASE_ENABLE_RESET);
+		write_phy_reg(i,PHY_BASE_CONTROL_REGISTER,phy_ctrl, phy_dev);
+		while (phy_ctrl & PHY_BASE_ENABLE_RESET) {
+
+			phy_ctrl = read_phy_reg(i,PHY_BASE_CONTROL_REGISTER, phy_dev);
+		}
+		// enable marvell phy csr signal assert when transmit,by set register 16 bit 11
+		// we have to use cable to make sure that the phy is linked.
+		// c = Assert on transmit
+		// 0 = Never assert on transmit
+		int reg = read_phy_reg(i, (0x10), phy_dev) | (0x1 << 11);
+		write_phy_reg(i, 0x10, reg, phy_dev);
+
+	}
+
+	//todo: now marvell phy reset very slow,and we have to wait 4 seconds to ensure it works in the right state
+	//we will confirm it latter
+	msleep(5000);
+
+// #else
+// 	for(i = 0; i < SF_MAC_PORTS; i++){
+// 		write_phy_reg(i, OMINI_PHY_INTMASK_REGISTER, PHY_INT_ENABLE_ALL_NORMAL, phy_dev);
+// 	}
+#endif
+}
+
+int phy_scan(struct phy_device* phy_dev)
+{
+	int addr_index = 0;
+	int phy_no = 0;
+	int phy_id1 = 0;
+	int phy_id2 = 0;
+	int phy_id = 0;
+	int phy_scan_success_count = 0;
+
+	for (phy_no = 0; phy_no < SF_MAC_PORTS; phy_no++) {
+		int addr = 0;
+		//scan 0~31 phy id
+		for (addr_index = -1; addr_index < 32; addr_index++) {
+#ifndef CONFIG_SFAX8_SWITCH_FPGA
+			addr = (addr_index == -1) ? (OMINI_PHY1_ADDR + phy_no) : addr_index;
+#else
+			if(addr_index == -1) continue;
+			addr = addr_index;
+#endif
+			phy_id1 = read_phy_reg_direct(phy_no,addr,PHY_IDENTIFY_1) & 0xffff;
+			phy_id2 = read_phy_reg_direct(phy_no,addr,PHY_IDENTIFY_2) & 0xffff;
+			phy_id = (phy_id2 | (phy_id1 << 16));
+			//If the phy_id is mostly Fs, there is no device there(accord with linux standard phy driver detect code)
+			if ((phy_id & 0x1fffffff) != 0x1fffffff){
+
+				//PHY IDENTIFIER1[15:0] -----------PHY_ID[15:0]
+				//PHY IDENTIFIER2[15:10]-----------PHY_ID[21:16]
+				phy_dev[phy_no].phy_id = phy_id1 | ((phy_id2 << 6) & 0x3F0000);
+				phy_dev[phy_no].addr = addr;
+				phy_scan_success_count++;
+				break;
+			}
+		}
+	}
+	return phy_scan_success_count;
+}
+
+void sys_omini_phy_reset(void)
+{
+
+	//emac2_cfg_np_msg_code[2:0]
+	//emac[5-1]_cfg_power_down[4:0] Default value of True power down bit (Reg24.0)
+	writeb(0x0, (void *)OMINI_PHY_CFG_POWERDOWN);
+	//emac3_cfg_np_msg_code[2:0]
+	//emac[5-1]_cfg_powerup_reset[4:0] Power Up Reset bit(Reg24.1)
+	writeb(0x0, (void *)OMINI_PHY_CFG_POWERUP_RESET);
+	//emac1_cfg_mode[2:0] emac1_cfg_phy_addr[4:0]
+	//emac1_cfg_mode[2:0] 001 - 10Base-T, Full Duplex, Auto negotiation disabled 0x20
+	//emac1_cfg_mode[2:0] 111 All capable, Full Duplex, 10 & 100 BT, Auto negotiation enabled AutoMDIX enable --0xE0
+	//emac1_cfg_mode[2:0] 011 100Base-TX, Full Duplex, Auto-negotiation disabled --0x60
+	writeb(OMINI_PHY1_ADDR | OMINI_PHY_CFG_MODE, (void *)OMINI_PHY1_CFG_ADDR);
+	writeb(OMINI_PHY2_ADDR | OMINI_PHY_CFG_MODE, (void *)OMINI_PHY2_CFG_ADDR);
+	writeb(OMINI_PHY3_ADDR | OMINI_PHY_CFG_MODE, (void *)OMINI_PHY3_CFG_ADDR);
+	writeb(OMINI_PHY4_ADDR | OMINI_PHY_CFG_MODE, (void *)OMINI_PHY4_CFG_ADDR);
+	writeb(OMINI_PHY5_ADDR | OMINI_PHY_CFG_MODE, (void *)OMINI_PHY5_CFG_ADDR);
+	//OMINI_PHY1_CFG_FX_PLL_MODE
+	/*
+	   {
+
+	   |   emac2_cfg_automdix_en, 1
+	   |   emac1_cfg_en_high,  0
+	   |   emac1_cfg_fx_mode,  0
+	   |   emac1_cfg_adc_bp,   0            bypass mode. (Reg18.8)
+	   |   emac1_cfg_pll_bp,   0            bypass mode (Reg18.9)
+	   |   emac1_cfg_smii_source_sync, 0    smii source sync register Only relevant for SMII mode
+	   |   emac1_cfg_mii_mode[1:0],  00           “00” for MII mode,"01" for RMII mode,"10" for SMII,"11" reserved
+	   }
+	   */
+	writeb(0x80, (void *)OMINI_PHY1_CFG_FX_PLL_MODE);
+	writeb(0x80, (void *)OMINI_PHY2_CFG_FX_PLL_MODE);
+	writeb(0x80, (void *)OMINI_PHY3_CFG_FX_PLL_MODE);
+	writeb(0x80, (void *)OMINI_PHY4_CFG_FX_PLL_MODE);
+	writeb(0x80, (void *)OMINI_PHY5_CFG_FX_PLL_MODE);
+	//emac4_cfg_np_msg_code[2:0]
+	//emac[5-1]_cfg_clk_freq
+	//‘0’ for 25 MHz clock input; ‘1’ for 50 MHz clock input.
+	writeb(0x00, (void *)OMINI_PHY_CFG_CLK_FREQ);
+	//emac5_cfg_np_msg_code[2:0]
+	//emac[5-1]_cfg_ref_clk_sel(NA now)
+	writeb(0x00, (void *)OMINI_PHY_CFG_CLK_REF_SEL);
+
+	//	    emac1_cfg_phy_id[7:0]
+	writeb(OMINI_PHY_ID_1 & 0xFF, (void *)OMINI_PHY1_CFG_PHY_ID_LOW8);
+	//emac1_cfg_phy_id[15:8]
+	writeb(((OMINI_PHY_ID_1 & 0xFF00) >> 8), (void *)OMINI_PHY1_CFG_PHY_ID_HIGH8);
+	//{emac1_cfg_model_nr[1:0],emac1_cfg_phy_id[21:16]}
+	writeb(((OMINI_PHY_ID_1 & 0x3F0000) >> 16) | ((OMINI_PHY_MODEL_NUMBER & 0x3) << 6), (void *)OMINI_PHY1_CFG_MODEL_NR);
+	//{emac1_cfg_rev_nr[3:0],emac1_cfg_model_nr[5:2]}
+	writeb((OMINI_PHY_REV_NUMBER << 4) | ((OMINI_PHY_MODEL_NUMBER & 0x3C) >> 2), (void *)OMINI_PHY1_CFG_REV_NR);
+
+
+	//emac1_cfg_phy_id[7:0]
+	writeb(OMINI_PHY_ID_2 & 0xFF, (void *)OMINI_PHY2_CFG_PHY_ID_LOW8);
+	//emac1_cfg_phy_id[15:8]
+	writeb(((OMINI_PHY_ID_2 & 0xFF00) >> 8), (void *)OMINI_PHY2_CFG_PHY_ID_HIGH8);
+	//{ emac1_cfg_model_nr[1:0],emac1_cfg_phy_id[21:16]}
+	writeb(((OMINI_PHY_ID_2 & 0x3F0000) >> 16) | ((OMINI_PHY_MODEL_NUMBER & 0x3) << 6), (void *)OMINI_PHY2_CFG_MODEL_NR);
+	//{ emac1_cfg_rev_nr[3:0],emac1_cfg_model_nr[5:2]}
+	writeb((OMINI_PHY_REV_NUMBER << 4) | ((OMINI_PHY_MODEL_NUMBER & 0x3C) >> 2), (void *)OMINI_PHY2_CFG_REV_NR);
+
+
+	//emac1_cfg_phy_id[7:0]
+	writeb(OMINI_PHY_ID_3 & 0xFF, (void *)OMINI_PHY3_CFG_PHY_ID_LOW8);
+	//emac1_cfg_phy_id[15:8]
+	writeb(((OMINI_PHY_ID_3 & 0xFF00) >> 8), (void *)OMINI_PHY3_CFG_PHY_ID_HIGH8);
+	//{ emac1_cfg_model_nr[1:0],emac1_cfg_phy_id[21:16]}
+	writeb(((OMINI_PHY_ID_3 & 0x3F0000) >> 16) | ((OMINI_PHY_MODEL_NUMBER & 0x3) << 6), (void *)OMINI_PHY3_CFG_MODEL_NR);
+	//{ emac1_cfg_rev_nr[3:0],emac1_cfg_model_nr[5:2]}
+	writeb((OMINI_PHY_REV_NUMBER << 4) | ((OMINI_PHY_MODEL_NUMBER & 0x3C) >> 2), (void *)OMINI_PHY3_CFG_REV_NR);
+
+	//emac1_cfg_phy_id[7:0]
+	writeb(OMINI_PHY_ID_4 & 0xFF, (void *)OMINI_PHY4_CFG_PHY_ID_LOW8);
+	//emac1_cfg_phy_id[15:8]
+	writeb(((OMINI_PHY_ID_4 & 0xFF00) >> 8), (void *)OMINI_PHY4_CFG_PHY_ID_HIGH8);
+	//{ emac1_cfg_model_nr[1:0],emac1_cfg_phy_id[21:16]}
+	writeb(((OMINI_PHY_ID_4 & 0x3F0000) >> 16) | ((OMINI_PHY_MODEL_NUMBER & 0x3) << 6), (void *)OMINI_PHY4_CFG_MODEL_NR);
+	//{ emac1_cfg_rev_nr[3:0],emac1_cfg_model_nr[5:2]}
+	writeb((OMINI_PHY_REV_NUMBER << 4) | ((OMINI_PHY_MODEL_NUMBER & 0x3C) >> 2), (void *)OMINI_PHY4_CFG_REV_NR);
+
+	//emac1_cfg_phy_id[7:0]
+	writeb(OMINI_PHY_ID_5 & 0xFF, (void *)OMINI_PHY5_CFG_PHY_ID_LOW8);
+	//emac1_cfg_phy_id[15:8]
+	writeb(((OMINI_PHY_ID_5 & 0xFF00) >> 8), (void *)OMINI_PHY5_CFG_PHY_ID_HIGH8);
+	//{ emac1_cfg_model_nr[1:0],emac1_cfg_phy_id[21:16]}
+	writeb(((OMINI_PHY_ID_5 & 0x3F0000) >> 16) | ((OMINI_PHY_MODEL_NUMBER & 0x3) << 6), (void *)OMINI_PHY5_CFG_MODEL_NR);
+	//{ emac1_cfg_rev_nr[3:0],emac1_cfg_model_nr[5:2]}
+	writeb((OMINI_PHY_REV_NUMBER << 4) | ((OMINI_PHY_MODEL_NUMBER & 0x3C) >> 2), (void *)OMINI_PHY5_CFG_REV_NR);
+}
+
+void sf_mac_enable(void)
+{
+	int i = 0;
+	for(i = 0 ; i < SF_MAC_PORTS; i++){
+		int mac_cfg = sf_readl(get_mac_cfg_addr(i));
+		sf_writel(mac_cfg | MAC_CFG_TX_EN | MAC_CFG_RX_EN , get_mac_cfg_addr(i));
+	}
+}
+
+void sf_mac_disable_rx(void)
+{
+	int i = 0;
+	for(i = 0 ; i < SF_MAC_PORTS; i++){
+		int mac_cfg = sf_readl(get_mac_cfg_addr(i));
+		mac_cfg &= ~MAC_CFG_RX_EN;
+		sf_writel(mac_cfg, get_mac_cfg_addr(i));
+	}
+}
+
+void sf_mac_disable_tx(void)
+{
+	int i = 0;
+	for(i = 0 ; i < SF_MAC_PORTS; i++){
+
+		int mac_cfg = sf_readl(get_mac_cfg_addr(i));
+		mac_cfg &= ~MAC_CFG_TX_EN;
+		sf_writel(mac_cfg, get_mac_cfg_addr(i));
+	}
+}
+
+int check_phy_linkup(int phy_no, struct sf_priv *priv){
+#ifdef CONFIG_SFAX8_SWITCH_FPGA
+	//marvell register 17-bit10
+	int phy_status = read_phy_reg_direct(phy_no, priv->phy_dev[phy_no].addr, MIIM_88E1111_PHY_SPL_STATUS_REG);
+	if((phy_status & DEFAULT_PHY_VALUE) == 0xffff) return 0;
+	return (phy_status & (0x1 << 10)) ? 1 : 0;
+#else
+	int phy_status = read_phy_reg_direct(phy_no, priv->phy_dev[phy_no].addr, PHY_BASE_STATUS_REGISTER);
+	if((phy_status & DEFAULT_PHY_VALUE) == 0xffff) return 0;
+	return (phy_status & PHY_STATUS_LINK_UP) ? 1 : 0;
+#endif
+}
+
+#ifdef SF_TX_SHUTDOWN
+int sf_phy_init_test_mode(int phy_idx, struct sf_priv *priv){
+	unsigned int phy_status = read_phy_reg(phy_idx, OMINI_PHY_TSTCNTL_REGISTER, priv->phy_dev);
+	if(!(phy_status &  OMINI_PHY_TSTCNTL_ENABLE)){
+		write_phy_reg(phy_idx, OMINI_PHY_TSTCNTL_REGISTER, 0x0, priv->phy_dev);
+		write_phy_reg(phy_idx, OMINI_PHY_TSTCNTL_REGISTER,OMINI_PHY_TSTCNTL_ENABLE, priv->phy_dev);
+		write_phy_reg(phy_idx, OMINI_PHY_TSTCNTL_REGISTER, 0x0, priv->phy_dev);
+		write_phy_reg(phy_idx, OMINI_PHY_TSTCNTL_REGISTER,OMINI_PHY_TSTCNTL_ENABLE, priv->phy_dev);
+
+	}
+	return 0;
+}
+int sf_phy_write_test_reg(int phy_idx, struct sf_priv *priv, unsigned int reg_addr, unsigned reg_value, int phy_mode){
+	unsigned int phy_value = 0;
+	sf_phy_init_test_mode(phy_idx, priv);
+	phy_value =  OMINI_PHY_TSTCNTL_ENABLE | OMINI_PHY_TSTCNTL_WRITE | reg_addr | phy_mode;
+	write_phy_reg(phy_idx, OMINI_PHY_TSTWRITE_REGISTER, reg_value, priv->phy_dev);
+	write_phy_reg(phy_idx, OMINI_PHY_TSTCNTL_REGISTER, phy_value, priv->phy_dev);
+	return 0;
+}
+
+int sf_phy_read_test_reg(int phy_idx, struct sf_priv *priv, unsigned int reg_addr, int phy_mode){
+	unsigned int phy_value = 0;
+	sf_phy_init_test_mode(phy_idx, priv);
+	phy_value =  OMINI_PHY_TSTCNTL_ENABLE | OMINI_PHY_TSTCNTL_READ | (reg_addr << 0x5) | phy_mode;
+	write_phy_reg(phy_idx, OMINI_PHY_TSTCNTL_REGISTER, phy_value, priv->phy_dev);
+	phy_value = read_phy_reg(phy_idx, OMINI_PHY_TSTREAD_REGISTER, priv->phy_dev);
+
+	return phy_value;
+}
+
+
+// mode should be  OMINI_PHY_ANALOG_A5_CONFIG_TX_IDLE or 10M or OFF
+int sf_phy_a5_tx_config(int phy_idx, struct sf_priv *priv, unsigned int value){
+	sf_phy_write_test_reg(phy_idx, priv, OMINI_PHY_ANALOG_A5_CONFIG_REGISTER,value ,OMINI_PHY_TSTCNTL_MODE_ANA);
+	return 0;
+}
+
+#endif
+
+void sf_phy_init_normal(struct sf_priv *priv, unsigned int port){
+	unsigned int phy_value = 0;
+#ifdef SF_TX_SHUTDOWN
+	sf_phy_a5_tx_config(port, priv, OMINI_PHY_ANALOG_A5_CONFIG_TX_ON);
+#endif
+	phy_value = read_phy_reg(port, PHY_BASE_CONTROL_REGISTER, priv->phy_dev);
+	if(!(phy_value & PHY_BASE_ENABLE_AUTO_NEG))
+	  write_phy_reg(port, PHY_BASE_CONTROL_REGISTER, phy_value | PHY_BASE_ENABLE_AUTO_NEG, priv->phy_dev);
+
+	phy_value = read_phy_reg(port, OMINI_PHY_MODEL_CTRL_REGISTER, priv->phy_dev);
+	if (!(phy_value & OMINI_PHY_MODEL_CTRL_AUTO))
+	  write_phy_reg(port, OMINI_PHY_MODEL_CTRL_REGISTER, phy_value | OMINI_PHY_MODEL_CTRL_AUTO, priv->phy_dev);
+	return;
+}
+
+// init phy with 10m half
+void sf_phy_init_low_power(struct sf_priv *priv , unsigned int port){
+	int  phy_value = 0, phy_status =0;
+	phy_status = read_phy_reg(port,  PHY_BASE_STATUS_REGISTER, priv->phy_dev);
+	if (!(phy_status & PHY_STATUS_LINK_UP)){
+		phy_value = read_phy_reg(port, PHY_BASE_CONTROL_REGISTER, priv->phy_dev);
+		write_phy_reg(port, PHY_BASE_CONTROL_REGISTER, phy_value & ~PHY_BASE_ENABLE_AUTO_NEG, priv->phy_dev);
+
+		phy_value = read_phy_reg(port, OMINI_PHY_MODEL_CTRL_REGISTER, priv->phy_dev);
+		write_phy_reg(port, OMINI_PHY_MODEL_CTRL_REGISTER, (phy_value & ~OMINI_PHY_MODEL_CTRL_AUTO) & ~OMINI_PHY_MODEL_CTRL_FIX_MDIX, priv->phy_dev);
+#ifdef SF_TX_SHUTDOWN
+		//config phy to test mode
+		sf_phy_a5_tx_config(port, priv,OMINI_PHY_ANALOG_A5_CONFIG_TX_IDLE);
+#endif
+	}
+}
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+void sf_phy_energy_detect_init(struct sf_priv *priv){
+	int i = 0, phy_value = 0, phy_status =0;
+	for(i = 0; i < SF_POWERSAVE_PORTS; i++){
+		phy_status = read_phy_reg(i, PHY_BASE_STATUS_REGISTER, priv->phy_dev);
+		if (!(phy_status & PHY_STATUS_LINK_UP)){
+			/*disable Auto-negotiation and AutoMDIX while enable energy detect accroding to ominiphy*/
+			phy_value = read_phy_reg(i, PHY_BASE_CONTROL_REGISTER, priv->phy_dev);
+			if(phy_value & PHY_BASE_ENABLE_AUTO_NEG)
+			  write_phy_reg(i, PHY_BASE_CONTROL_REGISTER, phy_value & (~PHY_BASE_ENABLE_AUTO_NEG), priv->phy_dev);
+
+			phy_value = read_phy_reg(i, OMINI_PHY_MODEL_CTRL_REGISTER, priv->phy_dev);
+			phy_value = (phy_value & (~OMINI_PHY_MODEL_CTRL_AUTO)) | OMINI_PHY_MODEL_CTRL_ENERGY_DETECT;
+			write_phy_reg(i, OMINI_PHY_MODEL_CTRL_REGISTER, phy_value, priv->phy_dev);
+		}
+	}
+}
+
+void sf_phy_energy_detect_enable(int phy_no, struct phy_device* phy_dev){
+	/*disable Auto-negotiation and AutoMDIX while enable energy detect accroding to ominiphy*/
+	int phy_value = read_phy_reg(phy_no, PHY_BASE_CONTROL_REGISTER, phy_dev);
+	if(phy_value & PHY_BASE_ENABLE_AUTO_NEG)
+	  write_phy_reg(phy_no, PHY_BASE_CONTROL_REGISTER, phy_value & (~PHY_BASE_ENABLE_AUTO_NEG), phy_dev);
+
+	phy_value = read_phy_reg(phy_no, OMINI_PHY_MODEL_CTRL_REGISTER, phy_dev);
+	if (phy_value & OMINI_PHY_MODEL_CTRL_AUTO)
+		write_phy_reg(phy_no, OMINI_PHY_MODEL_CTRL_REGISTER, phy_value & (~OMINI_PHY_MODEL_CTRL_AUTO), phy_dev);
+
+	phy_value = read_phy_reg(phy_no, OMINI_PHY_MODEL_CTRL_REGISTER, phy_dev);
+	if (!(phy_value & OMINI_PHY_MODEL_CTRL_ENERGY_DETECT))
+		write_phy_reg(phy_no, OMINI_PHY_MODEL_CTRL_REGISTER, phy_value | OMINI_PHY_MODEL_CTRL_ENERGY_DETECT, phy_dev);
+}
+
+void sf_phy_energy_detect_disable(int phy_no, struct phy_device* phy_dev){
+	int phy_value = read_phy_reg(phy_no, OMINI_PHY_MODEL_CTRL_REGISTER, phy_dev);
+	if (phy_value & OMINI_PHY_MODEL_CTRL_ENERGY_DETECT)
+		write_phy_reg(phy_no, OMINI_PHY_MODEL_CTRL_REGISTER, phy_value & (~OMINI_PHY_MODEL_CTRL_ENERGY_DETECT), phy_dev);
+}
+#endif
+
+//0 half 1 full
+int get_link_duplex(int phy_no, struct sf_priv *priv){
+#ifdef CONFIG_SFAX8_SWITCH_FPGA
+	//marvell register 17-bit10
+	int phy_status = read_phy_reg_direct(phy_no, priv->phy_dev[phy_no].addr, MIIM_88E1111_PHY_SPL_STATUS_REG);
+	return phy_status >> 13 & 0x1 ;
+#else
+	int phy_status = read_phy_reg_direct(phy_no, priv->phy_dev[phy_no].addr, OMINI_PHY_SPECIAL_CONTROL_STATUS);
+	if((phy_status >> 2  & 0x7) == 0x1 || (phy_status >> 2  & 0x7) == 0x2)
+	  return 0;
+	else
+	  return 1;
+#endif
+}
+
+// 0 10m 1 100m
+int get_link_speed(int phy_no, struct sf_priv *priv){
+#ifdef CONFIG_SFAX8_SWITCH_FPGA
+	//marvell register 17-bit10
+	int phy_status = read_phy_reg_direct(phy_no, priv->phy_dev[phy_no].addr, MIIM_88E1111_PHY_SPL_STATUS_REG);
+	if((phy_status & DEFAULT_PHY_VALUE) == 0xffff) return 0;
+	return phy_status >> 14 & 0x3 ;
+#else
+	int phy_status = read_phy_reg_direct(phy_no, priv->phy_dev[phy_no].addr, OMINI_PHY_SPECIAL_CONTROL_STATUS);
+	if((phy_status >> 2  & 0x7) == 0x1 || (phy_status >> 2  & 0x7) == 0x5)
+	  return 0;
+	else
+	  return 1;
+#endif
+}
+
+int sf_mac_set_link(int port, int speed, int duplex){
+	int mac_cfg = sf_readl(get_mac_cfg_addr(port));
+	mac_cfg &= ~MAC_CFG_DUPLEX_FULL;
+	mac_cfg &= ~MAC_CFG_DIS_REC_OWN;
+
+	if(duplex == ETH_DUPLEX_FULL)
+	  mac_cfg |= MAC_CFG_DUPLEX_FULL;
+	if(duplex == ETH_DUPLEX_HALF)
+	  mac_cfg |= MAC_CFG_DIS_REC_OWN;
+	if(speed == ETH_SPEED_10){
+		//for 10m speed
+		mac_cfg = (mac_cfg & (~MAC_CFG_FES_100));
+	}else{
+		//for 100m
+		mac_cfg |=  MAC_CFG_FES_100 ;
+	}
+
+	sf_writel(mac_cfg,get_mac_cfg_addr(port));
+	return 0;
+}
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_mdio.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_mdio.h	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,243 @@
+#ifndef SF_MDIO_H
+#define SF_MDIO_H
+#include <linux/phy.h>
+
+#define DEFAULT_PHY_VALUE 0xffffffff
+//[4:0] PHY ADD register field
+//OMINI PHY
+#define OMINI_PHY_ENABLE                 (SIFLOWER_SYSCTL_BASE + 0x4040)
+#define OMINI_PHY_CFG_POWERDOWN          (SIFLOWER_SYSCTL_BASE + 0x4044)
+#define OMINI_PHY_CFG_POWERUP_RESET      (SIFLOWER_SYSCTL_BASE + 0x4048)
+
+#define OMINI_PHY1_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x404C)
+#define OMINI_PHY2_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x4050)
+#define OMINI_PHY3_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x4054)
+#define OMINI_PHY4_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x4058)
+#define OMINI_PHY5_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x405C)
+
+#define OMINI_PHY1_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x4060)
+#define OMINI_PHY2_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x4064)
+#define OMINI_PHY3_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x4068)
+#define OMINI_PHY4_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x406C)
+#define OMINI_PHY5_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x4070)
+
+#define OMINI_PHY_CFG_CLK_FREQ           (SIFLOWER_SYSCTL_BASE + 0x4074)
+#define OMINI_PHY_CFG_CLK_REF_SEL        (SIFLOWER_SYSCTL_BASE + 0x4078)
+
+#define OMINI_PHY1_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x407C)
+#define OMINI_PHY1_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x4080)
+#define OMINI_PHY1_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x4084)
+#define OMINI_PHY1_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x4088)
+
+#define OMINI_PHY2_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x408C)
+#define OMINI_PHY2_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x4090)
+#define OMINI_PHY2_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x4094)
+#define OMINI_PHY2_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x4098)
+
+#define OMINI_PHY3_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x409C)
+#define OMINI_PHY3_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x40A0)
+#define OMINI_PHY3_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x40A4)
+#define OMINI_PHY3_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x40A8)
+
+#define OMINI_PHY4_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x40AC)
+#define OMINI_PHY4_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x40B0)
+#define OMINI_PHY4_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x40B4)
+#define OMINI_PHY4_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x40B8)
+
+#define OMINI_PHY5_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x40BC)
+#define OMINI_PHY5_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x40C0)
+#define OMINI_PHY5_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x40C4)
+#define OMINI_PHY5_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x40C8)
+
+
+#define OMINI_PHY1_ADDR (0x10)
+#define OMINI_PHY2_ADDR (0x11)
+#define OMINI_PHY3_ADDR (0x12)
+#define OMINI_PHY4_ADDR (0x13)
+#define OMINI_PHY5_ADDR (0x14)
+
+//PHY ID Number[21:0]
+#define OMINI_PHY_ID_1  (0x0F1F1F)
+#define OMINI_PHY_ID_2  (0x0F2F2F)
+#define OMINI_PHY_ID_3  (0x0F3F3F)
+#define OMINI_PHY_ID_4  (0x0F4F5F)
+#define OMINI_PHY_ID_5  (0x0F5F5F)
+
+//Manufacturer’s Model Number[5:0]
+#define OMINI_PHY_MODEL_NUMBER (0x1F)
+//Manufacturer’s Revision Number[3:0]
+#define OMINI_PHY_REV_NUMBER				(0x01)
+
+#define OMINI_PHY_CFG_MODE					0xE0
+
+#define MAVELL_PHY_SPEED_MASK				0x2040
+#define MAVELL_PHY_SPEED_1000m				0x0040
+#define MAVELL_PHY_SPEED_100m				0x2000
+#define MAVELL_PHY_SPEED_10m				0x0000
+
+//for PHY register
+#define PHY_BASE_CONTROL_REGISTER			0x00
+#define PHY_BASE_STATUS_REGISTER			0x01
+#define PHY_IDENTIFY_1						0x02
+#define PHY_IDENTIFY_2						0x03
+#define PHY_AUTO_NEGOTIATION_ADEWS			0x04
+#define PHY_AUTO_NEGOTIATION_LINK_PARTNER	0x05
+//special for ominiphy(reg 17)
+#define OMINI_PHY_MODEL_CTRL_REGISTER		0x11
+
+#define OMINI_PHY_TSTCNTL_REGISTER			0x14
+#define OMINI_PHY_TSTREAD_REGISTER			0x15
+#define OMINI_PHY_TSTWRITE_REGISTER			0x17
+
+#define OMINI_PHY_INTSRC_REGISTER			0x1d
+#define OMINI_PHY_INTMASK_REGISTER			0x1e
+#define OMINI_PHY_SPECIAL_CONTROL_STATUS	0x1f
+#define PHY_INT_ENABLE_ALL_NORMAL			0xFF
+
+
+#define OMINI_PHY_TSTCNTL_ENABLE			0x400
+#define OMINI_PHY_TSTCNTL_READ				0x8000
+#define OMINI_PHY_TSTCNTL_WRITE				0x4000
+#define OMINI_PHY_TSTCNTL_MODE_ANA          0x0
+#define OMINI_PHY_TSTCNTL_MODE_LPI			0x800
+#define OMINI_PHY_TSTCNTL_READ_ADDR_MASK	0x3E0
+#define OMINI_PHY_TSTCNTL_WRITE_ADDR_MASK	0x1F
+
+
+#define OMINI_PHY_ANALOG_A5_CONFIG_REGISTER       0x16
+#define OMINI_PHY_ANALOG_A5_CONFIG_TX_IDLE        0x487
+#define OMINI_PHY_ANALOG_A5_CONFIG_TX_10M_MDI     0x277
+#define OMINI_PHY_ANALOG_A5_CONFIG_TX_10M_MDIX    0x377
+#define OMINI_PHY_ANALOG_A5_CONFIG_TX_ON		  0x406
+
+
+//phy control register value mask
+//1 = software reset. Bit is self-clearing
+#define PHY_BASE_ENABLE_RESET            (1 << 15)
+//1 = loopback mode, 0 = normal operation
+#define PHY_BASE_ENABLE_LOOPBACK         (1 << 14)
+//1 = 100Mbps, 0 = 10Mbps Ignored if Auto Negotiation is enable#define PHY_BASE_ENABLE_RESET       (1 << 15)
+#define PHY_BASE_ENABLE_SPEED_100        (1 << 13)
+//1 = enable auto-negotiate process (overrides 0.13 and 0.8)
+#define PHY_BASE_ENABLE_AUTO_NEG         (1 << 12)
+//1 = General power down mode, 0 = norma
+#define PHY_BASE_ENABLE_POWER_DOWN       (1 << 11)
+//1 = electrical isolation of PHY from MII 0 = normal operation
+#define PHY_BASE_ENABLE_ISOLATE          (1 << 10)
+//1 = restart auto-negotiate process Bit is self-clearing.
+#define PHY_BASE_ENABLE_RESTART_NEG      (1 << 9)
+//Duplex Mode 1 = full duplex, 0 = half duplex
+#define PHY_BASE_ENABLE_DUPLEX_FULL           (1 << 8)
+//1 = enable Collision test, 0 = disable COL test
+#define PHY_BASE_ENABLE_COLTEST          (1 << 7)
+
+//phy status register value mask
+#define PHY_STATUS_LINK_UP               (1 << 2)
+
+//ominiphy mode control/status reg-17
+//MDI mode
+#define OMINI_PHY_MODEL_CTRL_MDI_MASK    0xc0
+#define OMINI_PHY_MODEL_CTRL_FIX_MDI     0x00
+#define OMINI_PHY_MODEL_CTRL_FIX_MDIX    0x40
+//bit 14 of register 17 can speed up link step of 10M
+#define OMINI_PHY_MODEL_CTRL_10M_SPEEDUP 0x4000
+#define OMINI_PHY_MODEL_CTRL_AUTO        0x80
+//Auto-Negotiation Test Mode
+#define OMINI_PHY_MODEL_CTRL_AEG_TEST_ENABLE    0x0100
+
+#define OMINI_PHY_MODEL_CTRL_FAREND_LOOPBACK 0x0200
+#define OMINI_PHY_MODEL_CTRL_ENERGY_DETECT 0x2000
+
+//special for Marvell phy
+#define MIIM_88E1111_PHY_PAGE 22
+#define MIIM_88E1111_PHY_SPL_STATUS_REG 0x11
+//for Register 4 (GMII Address Register)
+//if GMII Busy
+#define GMII_ADDR_MASK_GB (1 << 0)
+//GMII Write or read(0)
+#define GMII_ADDR_MASK_GW (1 << 1)
+//CSR Clock Range
+#define GMII_ADDR_MASK_CR (0xf << 2)
+//GMII Register
+#define GMII_ADDR_MASK_GR (0x1f << 6)
+//Physical Layer Address
+#define GMII_ADDR_MASK_PA (0x1f << 11)
+
+#define GMII_ADDR_VALUE_GW_READ   0 << 1
+#define GMII_ADDR_VALUE_GW_WRITE  1 << 1
+#define GMII_DATA_MASK  0xffff
+
+#define MAVELL_PHY_SPEED_MASK 0x2040
+#define MAVELL_PHY_SPEED_1000m 0x0040
+#define MAVELL_PHY_SPEED_100m  0x2000
+#define MAVELL_PHY_SPEED_10m   0x0000
+	//emac special control reg
+	//rx package drop enable for watchdog timeout error
+#define EMAC_CONTROL_DROP_RX_WATCHDOG (0x1 << 17)
+//rx package drop enable for runt frame
+#define EMAC_CONTROL_DROP_RUNT (0x1 << 18)
+//rx package drop enable for giant frame
+#define EMAC_CONTROL_DROP_GIANT (0x1 << 19)
+//rx package drop enable for late collision seen
+#define EMAC_CONTROL_DROP_LATECOL (0x1 << 20)
+//rx package drop enable for gmii error
+#define EMAC_CONTROL_DROP_GMII_ERR (0x1 << 21)
+//rx package drop enable for crc error
+#define EMAC_CONTROL_DROP_CRC_ERR (0x1 << 22)
+//rx package drop enable for length error
+#define EMAC_CONTROL_DROP_LENGTH_ERR (0x1 << 23)
+//rx package drop enable for da filter fail
+#define EMAC_CONTROL_DROP_DA_FAIL (0x1 << 24)
+//rx package drop enable for sa filter fail
+#define EMAC_CONTROL_DROP_SA_FAIL (0x1 << 25)
+//rx package drop enable for ip header error
+#define EMAC_CONTROL_DROP_IP_CHSUM (0x1 << 26)
+//rx package drop enable for ip payload error
+#define EMAC_CONTROL_DROP_PAYLOAD_CHSUM (0x1 << 27)
+#define MAC_CFG_TX_EN (1 << 3)
+#define MAC_CFG_RX_EN (1 << 2)
+
+#define MAC_CFG_FES_100 (1<<14)
+#define MAC_CFG_DUPLEX_FULL (1 << 11)
+#define MAC_CFG_DIS_REC_OWN (1 << 13)
+
+#define ETH_SPEED_AUTO  2
+#define ETH_SPEED_10    0
+#define ETH_SPEED_100   1
+//eth duplex for mac/phy
+#define ETH_DUPLEX_FULL 1
+#define ETH_DUPLEX_HALF 0
+
+void sf_phy_init(struct phy_device *phy_dev);
+
+void sf_mac_enable(void);
+void sf_mac_disable_tx(void);
+void sf_mac_disable_rx(void);
+
+int get_mac_cfg_addr(int mac_no);
+
+void write_phy_reg(int phy_no,int phy_reg,int value, struct phy_device* phy_dev);
+
+int read_phy_reg(int phy_no,int phy_reg, struct phy_device* phy_dev);
+
+int read_phy_reg_direct(int phy_no,int phy_addr,int phy_reg);
+
+void sys_omini_phy_reset(void);
+int phy_scan(struct phy_device* phy_dev);
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+void sf_phy_energy_detect_enable(int phy_no, struct phy_device* phy_dev);
+void sf_phy_energy_detect_disable(int phy_no, struct phy_device* phy_dev);
+void sf_phy_energy_detect_init(struct sf_priv *priv);
+#endif
+
+void sf_phy_init_low_power(struct sf_priv *priv, unsigned int port);
+
+int check_phy_linkup(int phy_no, struct sf_priv *priv);
+int get_link_speed(int phy_no, struct sf_priv *priv);
+int get_link_duplex(int phy_no, struct sf_priv *priv);
+int sf_mac_set_link(int port, int speed, int duplex);
+
+int sf_phy_a5_tx_config(int phy_idx, struct sf_priv *priv, unsigned int value);
+void sf_phy_init_normal(struct sf_priv *priv, unsigned int port);
+#endif /* ifndef SF_MDIO_H */
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_switch.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_switch.c	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,723 @@
+#include "sf_common.h"
+#include "sf_eth.h"
+#include "sf_mdio.h"
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+#include "sf_switch.h"
+#endif
+#include "sf_switch_init.h"
+#include "sf_switch_hash_table.h"
+#include <linux/if_vlan.h>
+#include <linux/if_ether.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/switch.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include "sf_debug.h"
+#include "genl_netlink.h"
+
+
+static struct of_device_id switch_match[] = {
+	{ .compatible = "siflower,sfax8-switch" },
+	{}
+};
+
+void sfax8_link_adjust(struct sf_priv *priv, int port)
+{
+	int  speed = 0, duplex = 0;
+	if(check_phy_linkup(port, priv)){
+		speed = get_link_speed(port, priv);
+		duplex= get_link_duplex(port, priv);
+		sf_mac_set_link(port,speed, duplex);
+	}
+}
+
+int sfax8_has_carrier(struct sf_priv *priv)
+{
+	int i, j;
+	/*cause there is a condition which receive irq but doesn't check phy link up after reboot, so we add this delay*/
+	for (j = 0; j < 3; j++){
+		for (i = 0; i < SF_MAC_PORTS; i++){
+			if(check_phy_linkup(i, priv)){
+				print_msg(SWITCH_INIT_DEBUG,NULL,"check phy link up, port number is %d\n",i);
+				return 1;
+			}
+		}
+		udelay(1);
+	}
+	return 0;
+}
+
+static void sfax8_handle_carrier(struct sf_priv *priv, int status_reg)
+{
+	if (netif_carrier_ok(priv->netdev) && status_reg & (0x1 << 4)){
+		if (!sfax8_has_carrier(priv)){
+			netif_carrier_off(priv->netdev);
+			print_msg(SWITCH_INIT_DEBUG,NULL,"carrier off\n");
+		}
+	}
+	else if(!netif_carrier_ok(priv->netdev) && status_reg & (0x1 << 6)){
+		if (sfax8_has_carrier(priv)){
+			netif_carrier_on(priv->netdev);
+			print_msg(SWITCH_INIT_DEBUG,NULL,"carrier on\n");
+		}
+	}
+}
+
+static irqreturn_t sfax8_switch_irq_handle(int irq, void *_priv)
+{
+	struct sf_priv *priv = (struct sf_priv *) _priv;
+	int status_reg = 0,  port = 0;
+	switch (irq){
+		case SIFLOWER_NPU_PHY0_IRQ:
+			port = 0;
+			break;
+		case SIFLOWER_NPU_PHY1_IRQ:
+			port = 1;
+			break;
+		case SIFLOWER_NPU_PHY2_IRQ:
+			port = 2;
+			break;
+		case SIFLOWER_NPU_PHY3_IRQ:
+			port = 3;
+			break;
+		case SIFLOWER_NPU_PHY4_IRQ:
+			port = 4;
+			break;
+		default:
+		return IRQ_HANDLED;
+	}
+	write_phy_reg(port, OMINI_PHY_INTMASK_REGISTER, 0, priv->phy_dev);
+	status_reg = read_phy_reg(port,OMINI_PHY_INTSRC_REGISTER, priv->phy_dev);
+	print_msg(SWITCH_INIT_DEBUG,NULL,"recieve irq %d port %d,phy_addr 0x%x status_reg 0x%x \n",irq, port ,priv->phy_dev[port].addr, status_reg);
+	/*enable Auto-negotiation and AutoMDIX to link for disable them while enable energy detect accroding to ominiphy*/
+	if(status_reg & (0x1 << 7)) {
+		sf_phy_init_normal(priv, port);
+	}
+
+	if(status_reg & (0x1 << 4 | 0x1 << 6)) {
+		if(status_reg & (0x1 << 6)){
+			sfax8_link_adjust(priv, port);
+		}
+#ifndef CONFIG_SFAX8_SWITCH_POWERSAVE
+		else {
+			sf_phy_init_low_power(priv, port);
+		}
+#endif
+
+
+		sfax8_handle_carrier(priv, status_reg);
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+		if(port != 4){
+			spin_lock(&priv->switch_lock);
+			priv->count++;
+			spin_unlock(&priv->switch_lock);
+			wake_up_process(priv->sfax8_switch->switch_kthread);
+		}
+#endif
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+		schedule_work(&priv->dpswork);
+#endif
+	}
+
+	write_phy_reg(port, OMINI_PHY_INTMASK_REGISTER, PHY_INT_ENABLE_ALL_NORMAL, priv->phy_dev);
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+void sfax8_set_mac(unsigned char *mac) {
+	int tmp = 0;
+
+	sf_writel(htonl(*(uint32_t *)mac), REG_MAC_ADDRESS0_LOW + EMAC0_BASE_OFFSET);
+	tmp = sf_readl(REG_MAC_ADDRESS0_HIGH + EMAC0_BASE_OFFSET);
+	tmp = (tmp & 0xffff0000) | htons(*(uint32_t *)&mac[4]);
+	sf_writel(tmp, REG_MAC_ADDRESS0_HIGH + EMAC0_BASE_OFFSET);
+
+	sf_writel(htonl(*(uint32_t *)mac), REG_MAC_ADDRESS0_LOW + EMAC1_BASE_OFFSET);
+	tmp = sf_readl(REG_MAC_ADDRESS0_HIGH + EMAC1_BASE_OFFSET);
+	tmp = (tmp & 0xffff0000) | htons(*(uint32_t *)&mac[4]);
+	sf_writel(tmp, REG_MAC_ADDRESS0_HIGH + EMAC1_BASE_OFFSET);
+
+	sf_writel(htonl(*(uint32_t *)mac), REG_MAC_ADDRESS0_LOW + EMAC2_BASE_OFFSET);
+	tmp = sf_readl(REG_MAC_ADDRESS0_HIGH + EMAC2_BASE_OFFSET);
+	tmp = (tmp & 0xffff0000) | htons(*(uint32_t *)&mac[4]);
+	sf_writel(tmp, REG_MAC_ADDRESS0_HIGH + EMAC2_BASE_OFFSET);
+
+	sf_writel(htonl(*(uint32_t *)mac), REG_MAC_ADDRESS0_LOW + EMAC3_BASE_OFFSET);
+	tmp = sf_readl(REG_MAC_ADDRESS0_HIGH + EMAC3_BASE_OFFSET);
+	tmp = (tmp & 0xffff0000) | htons(*(uint32_t *)&mac[4]);
+	sf_writel(tmp, REG_MAC_ADDRESS0_HIGH + EMAC3_BASE_OFFSET);
+
+	sf_writel(htonl(*(uint32_t *)mac), REG_MAC_ADDRESS0_LOW + EMAC4_BASE_OFFSET);
+	tmp = sf_readl(REG_MAC_ADDRESS0_HIGH + EMAC4_BASE_OFFSET);
+	tmp = (tmp & 0xffff0000) | htons(*(uint32_t *)&mac[4]);
+	sf_writel(tmp, REG_MAC_ADDRESS0_HIGH + EMAC4_BASE_OFFSET);
+	return;
+}
+
+static int
+sfax8_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct sfax8_switch_t *sfax8_switch = container_of(dev, struct sfax8_switch_t, swdev);
+	int vlan;
+	u16 vid;
+
+	vlan = val->port_vlan;
+	vid = (u16)val->value.i;
+
+	if (vlan < 0 || vlan >= 2)
+		return -EINVAL;
+
+	if (vid < 0 ||  vid > 4095)
+		return -EINVAL;
+
+	sfax8_switch->vlan_entries[vlan].vid = vid;
+	return 0;
+}
+
+static int
+sfax8_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct sfax8_switch_t *sfax8_switch = container_of(dev, struct sfax8_switch_t, swdev);
+	int vlan;
+
+	vlan = val->port_vlan;
+
+	val->value.i = sfax8_switch->vlan_entries[vlan].vid;
+	return 0;
+}
+
+static const struct switch_attr sfax8_vlan[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "vid",
+		.description = "VLAN ID (0-4094)",
+		.set = sfax8_set_vid,
+		.get = sfax8_get_vid,
+		.max = 4094,
+	},
+};
+
+static int sfax8_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct sfax8_switch_t *sfax8_switch = container_of(dev, struct sfax8_switch_t, swdev);
+	u32 member;
+	int i, entry = 0;
+	val->len = 0;
+
+	if (val->port_vlan < 0 || val->port_vlan >= 2)
+		return -EINVAL;
+
+	entry = vlan_hash_table_search(sfax8_switch->vlan_entries[val->port_vlan].vid);
+	if(entry == -1)
+		return -EINVAL;
+	else
+		member = entry & 0xFF;
+
+	for (i = 0; i < SF_MAX_PORTS; i++) {
+		struct switch_port *p;
+
+		if (!(member & BIT(i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+	}
+	return 0;
+}
+
+static int sfax8_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct sfax8_switch_t *sfax8_switch= container_of(dev, struct sfax8_switch_t, swdev);
+	u8 member = 0;
+	int i;
+
+	if (val->port_vlan < 0 || val->port_vlan >= 2 || val->len > SF_MAX_PORTS)
+		return -EINVAL;
+
+	for (i = 0; i < val->len; i++) {
+		struct switch_port *p = &val->value.ports[i];
+
+		if (p->id >= SF_MAX_PORTS)
+			return -EINVAL;
+
+		member |= BIT(p->id);
+
+	}
+	sfax8_switch->vlan_entries[val->port_vlan].member = member;
+
+	return 0;
+}
+
+static int sfax8_get_port_pvid(struct switch_dev *dev, int port, int *val) {
+	struct sfax8_switch_t *sfax8_switch = container_of(dev, struct sfax8_switch_t, swdev);
+
+	if (port >= SF_MAX_PORTS)
+		return -EINVAL;
+
+	*val = sfax8_switch->port[port].fallback_bd_id;
+	*val &= 0xfff;
+
+	return 0;
+}
+
+static int sfax8_set_port_pvid(struct switch_dev *dev, int port, int pvid) {
+	struct sfax8_switch_t *sfax8_switch = container_of(dev, struct sfax8_switch_t, swdev);
+
+	if (port >= SF_MAX_PORTS)
+		return -EINVAL;
+
+	if (pvid < 0 || pvid > 4095)
+		return -EINVAL;
+
+	sfax8_switch->port[port].fallback_bd_id = pvid;
+
+	printk("set port pvid 0x%x port %d \n",pvid ,port);
+	return 0;
+}
+
+static int sfax8_get_port_link(struct switch_dev *dev,  int port, struct switch_port_link *link) {
+	struct sfax8_switch_t *sfax8_switch = container_of(dev, struct sfax8_switch_t, swdev);
+	uint speed;
+    struct sf_priv *priv = (struct sf_priv *)netdev_priv(sfax8_switch->netdev);
+
+	if (port < 0 || port >= SF_MAX_PORTS)
+	  return -EINVAL;
+
+	link->link = check_phy_linkup(port, priv);
+	if(link->link){
+		link->duplex = get_link_duplex(port, priv);
+		speed = get_link_speed(port, priv);
+
+		switch (speed) {
+			case 0:
+				link->speed = SWITCH_PORT_SPEED_10;
+				break;
+			case 1:
+				link->speed = SWITCH_PORT_SPEED_100;
+				break;
+			case 2:
+				link->speed = SWITCH_PORT_SPEED_1000;
+				break;
+			default:
+				link->speed = SWITCH_PORT_SPEED_UNKNOWN;
+				break;
+		}
+	}
+	return 0;
+}
+
+static int sfax8_apply_config(struct switch_dev *dev) {
+	struct sfax8_switch_t *sfax8_switch = container_of(dev, struct sfax8_switch_t, swdev);
+	int i, addr1 = 0, entry = 0;
+
+	int action_entry = 0;
+	if(vlan_hash_table_flush() == -1) {
+		printk(" flush vlan table fail\n");
+		return -1;
+	}
+	// vlan 0 use fallback bd entry not need to add
+	for (i = 1; i < 3; i++) {
+		u16 vid = sfax8_switch->vlan_entries[i].vid;
+		u8 member = sfax8_switch->vlan_entries[i].member;
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+		int j = 0;
+		struct sf_priv *priv = (struct sf_priv *)netdev_priv(sfax8_switch->netdev);
+		u8 member_check = 0;
+		/*If phy link up,insert port to vlan table*/
+		if(member == 0x2f){
+			for (j = 0; j < SF_POWERSAVE_PORTS; j++){
+				if(check_phy_linkup(j, priv))
+				  member_check |= 1 << j;
+			}
+			member = member_check | 1 << SF_HOST_PORT;
+		}
+#endif
+
+		action_entry =  ((member << BRENTRY_FWD_PORT_LIST_START_POS) & BRENTRY_FWD_PORT_LIST_MASK) | ((member << BRENTRY_UNTAG_LIST_START_POS) & BRENTRY_UNTAG_LIST_MASK);
+		print_msg(SWITCH_INIT_DEBUG,NULL,"add vlan entry member 0x%x, vid %d\n",member,vid);
+		vlan_hash_table_insert(vid, 0, action_entry);
+	}
+
+	for (i = 0; i < sfax8_switch->max_port_num; i++) {
+		addr1 = get_port_address(i,1);
+		/* class hw port csr reg:
+		 *======================================================*
+		 *res |block_state |aft |shutdown |fallback_bd_id |tpid *
+		 *======================================================*
+		 *20-bit| 4-bit   |4-bit| 1-bit   | 16-bit      |16-bit *
+		 *=====================================================*/
+		entry = sf_readl(addr1);
+		entry &= ~PORT_FALLBACK_BDID_MASK;
+		entry |= (sfax8_switch->port[i].fallback_bd_id << PORT_FALLBACK_BDID_START_POS) & PORT_FALLBACK_BDID_MASK;
+		print_msg(SWITCH_INIT_DEBUG,NULL,"set fallback bdid 0x%x  port %d\n",sfax8_switch->port[i].fallback_bd_id, i);
+		sf_writel(entry, addr1);
+	}
+
+	return 0;
+}
+
+static int sfax8_reset_switch(struct switch_dev *dev) {
+	struct sfax8_switch_t *sfax8_switch = container_of(dev, struct sfax8_switch_t, swdev);
+	int i;
+
+	memset(sfax8_switch->vlan_entries, 0, sizeof(sfax8_switch->vlan_entries));
+
+	/* set default vid of each vlan to the same number of vlan, so the vid
+	 * won't need be set explicitly.
+	 */
+	for (i = 0; i < 2; i++) {
+		sfax8_switch->vlan_entries[i].vid = i;
+	}
+	sfax8_switch->vlan_entries[0].member = 0x30;
+	sfax8_switch->vlan_entries[1].member = 0x2F;
+
+	/* init port data structure */
+	for (i = 0; i < SF_MAX_PORTS; i++) {
+		sfax8_switch->port[i].fallback_bd_id = DEF_PORT_FALLBACK_BD_ID;
+	}
+
+	return 0;
+}
+
+enum {
+	   /* Global attributes. */
+		   SF_ATTR_ENABLE_VLAN,
+};
+static int
+sf_get_vlan_enable(struct switch_dev *dev,
+			  const struct switch_attr *attr,
+			  struct switch_val *val)
+{
+	return 0;
+}
+
+static int
+sf_set_vlan_enable(struct switch_dev *dev,
+			  const struct switch_attr *attr,
+			  struct switch_val *val)
+{
+	return 0;
+}
+static const struct switch_attr sf_global[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "VLAN mode (1:enabled)",
+		.max = 1,
+		.id = SF_ATTR_ENABLE_VLAN,
+		.get = sf_get_vlan_enable,
+		.set = sf_set_vlan_enable,
+	},
+};
+static const struct switch_attr sf_port[] = {
+};
+static const struct switch_dev_ops sfax8_switch_ops = {
+	.attr_global = {
+		.attr = sf_global,
+		.n_attr = ARRAY_SIZE(sf_global),
+	},
+	.attr_port = {
+		.attr = sf_port,
+		.n_attr = ARRAY_SIZE(sf_port),
+	},
+	.attr_vlan = {
+		.attr = sfax8_vlan,
+		.n_attr = ARRAY_SIZE(sfax8_vlan),
+	},
+	.get_vlan_ports = sfax8_get_vlan_ports,
+	.set_vlan_ports = sfax8_set_vlan_ports,
+	.get_port_pvid = sfax8_get_port_pvid,
+	.set_port_pvid = sfax8_set_port_pvid,
+	.get_port_link = sfax8_get_port_link,
+	.apply_config = sfax8_apply_config,
+	.reset_switch = sfax8_reset_switch,
+};
+
+struct sfax8_mapping {
+	char	*name;
+	u16	pvids[SF_MAX_PORTS];
+	u8	members[3];
+	u16	vids[3];
+} sfax8_defaults[] = {
+	{
+		.name = "llllw",
+		.pvids = { 1, 1, 1, 1, 2, 0 },
+		.members = {0,  0x2f, 0x30 },
+		.vids = {0, 1, 2 },
+	}, {
+		.name = "wllll",
+		.pvids = { 2, 1, 1, 1, 1, 0 },
+		.members = { 0, 0x3e, 0x21 },
+		.vids = { 0, 1, 2 },
+	},
+};
+
+static void sfax8_apply_mapping(struct sfax8_switch_t *sfax8_switch, struct sfax8_mapping *map) {
+	int i = 0;
+
+	for (i = 0; i < SF_MAX_PORTS; i++)
+	  sfax8_switch->port[i].fallback_bd_id = map->pvids[i];
+
+	for (i = 0; i < 3; i++) {
+		sfax8_switch->vlan_entries[i].member = map->members[i];
+		sfax8_switch->vlan_entries[i].vid = map->vids[i];
+	}
+}
+
+struct sfax8_mapping* sfax8_find_mapping(struct device_node *np) {
+	const char *map;
+	int i;
+
+	if (of_property_read_string(np, "sfax8,port-map", &map))
+	  return NULL;
+
+	for (i = 0; i < ARRAY_SIZE(sfax8_defaults); i++)
+	  if (!strcmp(map, sfax8_defaults[i].name))
+		return &sfax8_defaults[i];
+
+	return NULL;
+}
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+static int sfax8_switch_thread(void *data) {
+	struct sf_priv *priv = data;
+	unsigned long flags;
+
+	while (!kthread_should_stop()) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_lock_irqsave(&priv->switch_lock, flags);
+		if (!priv->count){
+			spin_unlock_irqrestore(&priv->switch_lock, flags);
+			schedule();
+			spin_lock_irqsave(&priv->switch_lock, flags);
+		}
+		set_current_state(TASK_RUNNING);
+		vlan_hash_table_refresh(&priv->sfax8_switch->swdev);
+
+		priv->count = 0;
+		spin_unlock_irqrestore(&priv->switch_lock, flags);
+	}
+	return 0;
+}
+#endif
+
+int sfax8_switch_open(struct sf_priv *priv){
+	struct sfax8_mapping *map = NULL;
+	struct device_node *np = NULL;
+	int ret = -1, i = 0;
+
+	priv->sfax8_switch->max_port_num     = SF_MAX_PORTS;
+	priv->sfax8_switch->host_port     = SF_HOST_PORT;
+	priv->sfax8_switch->fwd_port_list = FWD_PORT_LIST_MASK;
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+	priv->sfax8_switch->switch_kthread = NULL;
+#endif
+
+	sf_port_init((void*)priv->sfax8_switch);
+
+	spin_lock_init(&priv->switch_lock);
+
+	np = of_find_matching_node(NULL, switch_match);
+	if (!np) {
+		dev_err(priv->device, "no gsw node found\n");
+		return -EINVAL;
+	}
+
+	np = of_node_get(np);
+	map = sfax8_find_mapping(np);
+	if (map)
+	  sfax8_apply_mapping(priv->sfax8_switch, map);
+	sfax8_apply_config(&priv->sfax8_switch->swdev);
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+	priv->sfax8_switch->switch_kthread = kthread_create(sfax8_switch_thread, priv, "%s", (&priv->sfax8_switch->swdev)->name);
+	if (IS_ERR(priv->sfax8_switch->switch_kthread)){
+		netdev_err(priv->netdev,"Could not allocate kthread for swicth\n");
+		return PTR_ERR(priv->sfax8_switch->switch_kthread);
+	}
+#endif
+
+	/*read for clean up all irq*/
+	// /*while systerm upgrade, cpu loading too much, phy already link up, but we clean up all phy irq, so we may lose phy irq. then we will not check phy link up and carrier on.*/
+	// /*so that we should check phy linkup betwen clean up all irq and request irq*/
+	// if (sfax8_has_carrier(priv)){
+	// 	for (i = 0; i < SF_MAC_PORTS; i++)
+	// 	  sfax8_link_adjust(priv, i);
+	// 	netif_carrier_on(priv->netdev);
+	// 	print_msg(SWITCH_INIT_DEBUG,NULL,"carrier on\n");
+	// }
+
+	if (priv->sfax8_switch->irq) {
+		ret = devm_request_irq(priv->device, priv->sfax8_switch->irq, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+		if(ret)
+		  return ret;
+		ret = devm_request_irq(priv->device, priv->sfax8_switch->irq + 1, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+		if(ret)
+		  return ret;
+		ret = devm_request_irq(priv->device, priv->sfax8_switch->irq + 2, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+		if(ret)
+		  return ret;
+		ret = devm_request_irq(priv->device, priv->sfax8_switch->irq + 3, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+		if(ret)
+		  return ret;
+		ret = devm_request_irq(priv->device, priv->sfax8_switch->irq + 4, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+		if(ret)
+		  return ret;
+	}
+
+	for (i = 0; i < SF_MAC_PORTS; i++){
+		write_phy_reg(i, OMINI_PHY_INTMASK_REGISTER, 0, priv->phy_dev);
+		read_phy_reg(i, OMINI_PHY_INTSRC_REGISTER, priv->phy_dev);
+		write_phy_reg(i, OMINI_PHY_INTMASK_REGISTER, PHY_INT_ENABLE_ALL_NORMAL, priv->phy_dev);
+	}
+
+	dev_info(priv->device, "loaded %s driver \n", (&priv->sfax8_switch->swdev)->name);
+
+	return 0;
+}
+
+int sfax8_switch_stop(struct sf_priv *priv){
+
+	devm_free_irq(priv->device, priv->sfax8_switch->irq, priv);
+	devm_free_irq(priv->device, priv->sfax8_switch->irq + 1, priv);
+	devm_free_irq(priv->device, priv->sfax8_switch->irq + 2, priv);
+	devm_free_irq(priv->device, priv->sfax8_switch->irq + 3, priv);
+	devm_free_irq(priv->device, priv->sfax8_switch->irq + 4, priv);
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+	kthread_stop(priv->sfax8_switch->switch_kthread);
+	priv->sfax8_switch->switch_kthread = NULL;
+#endif
+
+	return 0;
+}
+
+int sfax8_switch_probe(struct sf_priv *priv){
+	struct sfax8_switch_t *sfax8_switch;
+	struct switch_dev	*swdev;
+	struct device_node *np = NULL;
+	int ret = -1;
+	np = of_find_matching_node(NULL, switch_match);
+	if (!np) {
+		dev_err(priv->device, "no gsw node found\n");
+		return -EINVAL;
+	}
+	np = of_node_get(np);
+	sfax8_switch = devm_kzalloc(priv->device, sizeof(struct sfax8_switch_t), GFP_KERNEL);
+	if (!sfax8_switch) {
+		dev_err(priv->device, "no gsw memory for private data\n");
+		return -ENOMEM;
+	}
+	sfax8_switch->base = of_iomap(np,0);
+	if (!sfax8_switch->base) {
+		dev_err(priv->device, "switch ioremap failed\n");
+		return -ENOMEM;
+	}
+	INIT_WORK(&priv->dpswork, (void *)(void *)dps_genl_sendmsg);
+	sfax8_switch->netdev = priv->netdev;
+	priv->sfax8_switch = sfax8_switch;
+	sfax8_switch->irq = irq_of_parse_and_map(np, 0);
+
+	swdev = &sfax8_switch->swdev;
+	swdev->alias = "sfax8_sw";
+	swdev->name = "sfax8_switch";
+	swdev->cpu_port = SF_HOST_PORT;
+	swdev->ports = SF_MAX_PORTS;
+	swdev->vlans = 2;
+	swdev->ops = &sfax8_switch_ops;
+
+	ret = register_switch(swdev, NULL);
+	if (ret) {
+		dev_err(priv->device, "failed to register sfax8\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int sfax8_switch_remove(struct sf_priv *priv){
+	struct sfax8_switch_t *sfax8_switch= priv->sfax8_switch;
+
+	print_msg(ETH_INIT_DEBUG,priv->netdev, "clean up switch module");
+	if(sfax8_switch->base)
+		iounmap(priv->sfax8_switch->base);
+
+	unregister_switch(&priv->sfax8_switch->swdev);
+	devm_kfree(priv->device, priv->sfax8_switch);
+
+	return 0;
+}
+
+struct sf_switch_data_t sf_switch_data = {
+	.set_mac = sfax8_set_mac,
+	.switch_open = sfax8_switch_open,
+	.switch_stop = sfax8_switch_stop,
+	.switch_probe = sfax8_switch_probe,
+	.switch_remove = sfax8_switch_remove,
+	.has_carrier = sfax8_has_carrier,
+	.adjust_link = sfax8_link_adjust,
+};
+
+
+#else
+static int irq_base = 0;
+int sfax8_request_phy_irq(struct sf_priv *priv){
+	struct device_node *np = NULL;
+	int ret = -1, i = 0;
+
+	np = of_find_matching_node(NULL, switch_match);
+	if (!np) {
+		dev_err(priv->device, "no gsw node found\n");
+		return -EINVAL;
+	}
+	np = of_node_get(np);
+	irq_base = irq_of_parse_and_map(np, 0);
+
+	/*read for clean up all irq*/
+	for (i = 0; i < SF_MAC_PORTS; i++){
+		write_phy_reg(i, OMINI_PHY_INTMASK_REGISTER, 0, priv->phy_dev);
+		read_phy_reg(i, OMINI_PHY_INTSRC_REGISTER, priv->phy_dev);
+		write_phy_reg(i, OMINI_PHY_INTMASK_REGISTER, PHY_INT_ENABLE_ALL_NORMAL, priv->phy_dev);
+	}
+	/*while systerm upgrade, cpu loading too much, phy already link up, but we clean up all phy irq, so we may lose phy irq. then we will not check phy link up and carrier on.*/
+	/*so that we should check phy linkup betwen clean up all irq and request irq*/
+	if (sfax8_has_carrier(priv)){
+		for (i = 0; i < SF_MAC_PORTS; i++)
+		  sfax8_link_adjust(priv, i);
+		netif_carrier_on(priv->netdev);
+		print_msg(SWITCH_INIT_DEBUG,NULL,"carrier on\n");
+	}
+
+	ret = devm_request_irq(priv->device, irq_base, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+	if(ret)
+	  return ret;
+	ret = devm_request_irq(priv->device, irq_base + 1, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+	if(ret)
+	  return ret;
+	ret = devm_request_irq(priv->device, irq_base + 2, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+	if(ret)
+	  return ret;
+	ret = devm_request_irq(priv->device, irq_base + 3, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+	if(ret)
+	  return ret;
+	ret = devm_request_irq(priv->device, irq_base + 4, sfax8_switch_irq_handle, 0, dev_name(priv->device), priv);
+	if(ret)
+	  return ret;
+
+	return 0;
+}
+
+int sfax8_free_phy_irq(struct sf_priv *priv){
+	devm_free_irq(priv->device, irq_base, priv);
+	devm_free_irq(priv->device, irq_base + 1, priv);
+	devm_free_irq(priv->device, irq_base + 2, priv);
+	devm_free_irq(priv->device, irq_base + 3, priv);
+	devm_free_irq(priv->device, irq_base + 4, priv);
+	return 0;
+}
+#endif
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_switch.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_switch.h	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,136 @@
+#ifndef SF_SWITCH_H
+#define SF_SWITCH_H
+#include <linux/switch.h>
+#include <linux/kthread.h>
+#define ETH_PROTO_SIZE               2
+#define ETH_SMAC_DMAC_SIZE           12
+
+#define STATIC_FLAG_SET           0x40000000
+#define FRESH_FLAG_SET            0x00000000
+#define FRESH_FLAG_MASK           0x20000000
+
+#define HASH_CNT_PER_ITERATION    0x200
+/* Below macros are used when we serach with memread */
+#define HASH_ENTRY_VLAN_SET_FLAG  0x02000000  /* MAC3: VLAN FIELDVALID BIT */
+#define HASH_ENTRY_VALID_FLAG     0x08000000  /* MAC4: ENTRY VALID BIT */
+#define HASH_ENTRY_COLL_FLAG      0x04000000  /* MAC4: HASH_ENTRY_COLL_FLAG*/
+#define HASH_ENTRY_FRESH_FLAG     0x04000000  /* */
+#define HASH_ENTRY_STATIC_FLAG    0x08000000  /* */
+
+#define  DOS_ALL_ENABLE_MASK         0x1
+#define  DOS_CONTROL2_VALUE_MASK     0x3FF03FF
+#define  DOS_ACTION_MASK             0x7
+#define  DOS_COMB_CONTROL_MASK       0xF
+#define  DOS_COMB_VALUE_MASK         0xFFFFFFFF
+#define  DOS_IPV4_MAX_LEN_MASK       0x1FFFF
+
+#define  DOS_ACTION_START_POS        0x1
+#define  DOS_COMB_CONTROL_START_POS  0x4
+
+enum snoop_etype {
+	SNOOP_IGMP = 4,  /*!< Normal forward, use forward_list of MAC entry */
+	SNOOP_MLDV2,        /*!< Flood to all ports in bridge domain, use forward list of BD entry */
+	SNOOP_ETYPE0 = 8,         /*!< Punt packet to PE/host */
+	SNOOP_ETYPE1,      /*!< Discard this frame */
+	SNOOP_ETYPE2,
+	SNOOP_ETYPE3,
+	SNOOP_ETYPE_ARP,
+	SNOOP_ETYPE_RARP,
+	SNOOP_HOPOPTS,
+};
+
+enum dos_value {
+	DOS_ENABLE, //all dos enable
+	DOS_FILTER_ENABLE, //CLASS_DOS_CONTRL2 value,
+	//DOS_ACTION, //is not used in IP
+	DOS_COMB_FILTER_ENABLE,
+	DOS_COMB_FILTER_VALUE,
+	DOS_ICMPV4_MAX_LEN,
+};
+
+enum DOS_FILTER_ITEM{
+	IPV4_SIP_EQ_DIP_EN,
+	IPV4_ICMP_FRAG_EN,
+	IPV4_ICMP_PING_TOO_BIG_EN,
+	IPV4_UDP_SP_EQ_DP_EN,
+	IPV4_TCP_FLAG_CHK,
+	IPV4_TCP_SP_EQ_DP,
+	IPV4_TCP_FRAG_OFF1,
+	IPV4_TCP_SYN_ERR,
+	IPV4_TCP_XMAS,
+	IPV4_TCP_NULL,
+	IPV6_SIP_EQ_DIP_EN,
+	IPV6_ICMP_FRAG_EN,
+	IPV6_ICMP_PING_TOO_BIG_EN,
+	IPV6_UDP_SP_EQ_DP_EN,
+	IPV6_TCP_FLAG_CHK,
+	IPV6_TCP_SP_EQ_DP,
+	IPV6_TCP_FRAG_OFF1,
+	IPV6_TCP_SYN_ERR,
+	IPV6_TCP_XMAS,
+	IPV6_TCP_NULL,
+};
+
+enum DOS_COMB_ITEM {
+	COMB_FILTER_1,
+	COMB_FILTER_2,
+	COMB_FILTER_3,
+	COMB_FILTER_4,
+};
+
+enum NPU_FUC_MODL {
+	SET_SPL_MAC,
+	INIT_GLB_CUTTHRU,
+	SET_DOS_FIL,
+	SET_DSCP_RULE,
+	SET_GLB_MGMT_ETYE,
+	SET_PORT_CTL,
+	SET_SNOOP_ETYE,
+	SET_PORT_UNTAG,
+	SET_VID_PFIX,
+	SET_TMU_CFG,
+	SET_GPI_INGRS_CFG,
+	SET_GPI_FLW_CTL,
+	SET_MAC_ADDR_FIL,
+	SET_MAC_CHKSUM,
+	SET_MAC_L3L4_FIL,
+	SEND_PUSE_FRM,
+	ENABLE_SRC_RPL,
+	SET_MAC_VLAN_FIL,
+};
+
+struct sfax8_vlan_entry {
+	u16	vid;
+	u8	member;
+};
+
+struct sfax8_switch_t {
+	struct net_device			*netdev;
+	void __iomem				*base;
+	int							irq;
+	struct switch_dev			swdev;
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+	struct task_struct			*switch_kthread;
+#endif
+
+	uchar						max_port_num;
+	uchar						host_port;
+	uchar						fwd_port_list;
+	struct bd_entry_s			fallback_bd_entry;
+	struct port_s				port[SF_MAX_PORTS];
+	struct sfax8_vlan_entry		vlan_entries[2];
+};
+
+struct sf_switch_data_t {
+	void (*set_mac)( unsigned char *mac);
+	int (*switch_open)(struct sf_priv *priv);
+	int (*switch_stop)(struct sf_priv *priv);
+	int (*switch_probe)(struct sf_priv *priv);
+	int (*switch_remove)(struct sf_priv *priv);
+	int (*has_carrier)(struct sf_priv *priv);
+	void (*adjust_link)(struct sf_priv *priv, int port);
+};
+
+extern struct sf_switch_data_t sf_switch_data;
+#endif /* ifndef SF_SWITCH_H */
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_switch_hash_table.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_switch_hash_table.c	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,845 @@
+#include "sf_switch_hash_table.h"
+#include "sf_mdio.h"
+#include "sf_debug.h"
+#include "sf_switch_init.h"
+#include <linux/if_vlan.h>
+
+spinlock_t mac_hash_lock;                     /* Spin lock flag */
+spinlock_t vlan_hash_lock;                     /* Spin lock flag */
+static unsigned char add_fail_count = 0;
+int  hash_table_config_done(int type) {
+	uint status_reg = 0;
+	int cmd_done = 0;
+	int i = 0;
+	if(type == MAC_TABLE)
+	  status_reg  = REQ_STATUS_REG;
+	else if(type == VLAN_TABLE)
+	  status_reg  = REQ_VLAN_STATUS_REG;
+	else
+	  return 0;
+
+	/*Read command status rteg*/
+	cmd_done = sf_readl(status_reg);
+	/* Poll the Status Register for CMD DONE */
+	while (!(cmd_done & 0x1)) {
+		if(i >= 1000){
+			printk("time out for wait hash table config done\n");
+			return 0;
+		}
+		cmd_done = sf_readl(status_reg);
+		udelay(10);
+		i++;
+	} /*End of while loop*/
+	/* Clear Status Reg */
+	sf_writel( CLR_STATUS_REG,status_reg);
+	return cmd_done;
+}
+
+void mac_hash_table_init(void) {
+	int  i = 0;
+	unsigned int index = 0, mac_table_addr = 0, col_ptr = 0;
+
+	spin_lock_init(&mac_hash_lock);
+	/* 2-field Mac table format: Table Depth - 1024(hash 512 + collison 512)
+	 *============================================================================*
+	 * valid bits | col_ptr | portNO | field_valids | action entry |vlanid |MAC *
+	 *============================================================================*
+	 * 4-bit      | 16-bit  | 4-bit  | 8-bit        | 31-bit       |13-bit |48-bit *
+	 *============================================================================*/
+
+	/* INIT CMD: Init total Hash Space with zeros */
+	sf_writel( CMD_INIT ,REQ_CMD_REG);
+
+	hash_table_config_done(MAC_TABLE);
+
+	/* initialize mac addresses  Link List formation */
+	sf_writel( 0x0, REQ_MAC1_ADDR_REG);
+	sf_writel( 0x0, REQ_MAC2_ADDR_REG);
+	sf_writel( 0x0, REQ_MAC3_ADDR_REG);
+	sf_writel( 0x0, REQ_MAC4_ADDR_REG);
+	sf_writel( 0x0, REQ_MAC5_ADDR_REG);
+	sf_writel( 0x0, REQ_ENTRY_REG);
+	/* chain the collision space */
+	for (i = 0; i < MAC_COLL_ENTRIES; i++) {
+		/* 32bit: 4res + 4validbits + 16colptr + 4portnum +
+		   (4)part of fieldvalids */
+		//{8’d4, col_ptr[15:0], 8’d0}
+		col_ptr = (0x40201 + i) << 8;
+		sf_writel( col_ptr, REQ_MAC4_ADDR_REG);
+		index = MAC_HASH_ENTRIES + i;
+		mac_table_addr = (index << 16) + CMD_MEM_WRITE;
+		sf_writel( mac_table_addr ,REQ_CMD_REG);
+		hash_table_config_done(MAC_TABLE);
+	} /*End of for loop collision space*/
+	/* Intialize Free List Head Ptr */
+	sf_writel( MAC_INIT_HEAD_PTR, FREE_LIST_HEAD_PTR);
+
+	/* Initialize Free List Ptr */
+	sf_writel( MAC_INIT_TAIL_PTR, FREE_LIST_TAIL_PTR);
+
+	/* Initialize No of entries */
+	sf_writel( MAC_COLL_ENTRIES, FREE_LIST_ENTRIES);
+} /*end of hw_hash_table_init Function*/
+
+void vlan_hash_table_init(void) {
+	int  i = 0;
+	unsigned int index = 0, mac_table_addr = 0, col_ptr = 0;
+
+	/* Avoid Multiple PE's Initialization */
+
+	spin_lock_init(&vlan_hash_lock);
+	/* vlan group table format *
+	 *=====================================================================*
+	 * valid bits | col_ptr | portNO | field_valids | action entry | vlan  *
+	 *=====================================================================*
+	 * 4-bit      | 16-bit  | 4-bit  | 8-bit        | 32-bit       | 12-bit*
+	 *=====================================================================*/
+	/* VLAN HASH MEMORY INTIALIZATION */
+
+	/* Initialize CMD register for Hash Table Intializes with zeros */
+	sf_writel( CMD_INIT, REQ_VLAN_CMD_REG);
+
+	hash_table_config_done(VLAN_TABLE);
+
+	sf_writel(0,REQ_VLAN_MAC1_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC2_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC3_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC4_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC5_ADDR_REG);
+
+	/* clear mac1 & mac2 registers */
+	/* chain the vlan collision space */
+	for (i = 0; i < 64; i++) {
+		col_ptr = (0x40041 + i);
+		sf_writel( ((col_ptr & 0xFF) << 24), REQ_VLAN_MAC2_ADDR_REG);
+		sf_writel( (col_ptr >> 8) & 0xFFF, REQ_VLAN_MAC3_ADDR_REG );
+		index = VLAN_HASH_ENTRIES + i;
+		mac_table_addr = (index << 16);
+		sf_writel( CMD_MEM_WRITE | mac_table_addr, REQ_VLAN_CMD_REG);
+
+		hash_table_config_done(VLAN_TABLE);
+	} /*End of vlan collision spce for loop*/
+
+	/* Intialize Free List Head Ptr */
+	sf_writel( VLAN_INIT_HEAD_PTR, FREE_VLAN_LIST_HEAD_PTR);
+
+	/* Initialize Free List Ptr */
+	sf_writel( VLAN_INIT_TAIL_PTR, FREE_VLAN_LIST_TAIL_PTR);
+
+	/* Initialize No of entries */
+	sf_writel( VLAN_FREE_LIST_ENTRIES, FREE_VLAN_LIST_ENTRIES);
+
+
+} /*end of hw_vlan_hash_table_init Function*/
+
+int vlan_hash_table_insert(uint field_entries, uint portNo, uint action_entry) {
+	int cmd_done = 0, vlanNo = 0;
+	uint field_valids =  BIT_SET_VLAN_1F_VLANTBL;
+
+	unsigned long flags;
+	spin_lock_irqsave(&vlan_hash_lock, flags);
+	/* print_msg(SWITCH_INIT_DEBUG,NULL,"TEST:REQ_VLAN_CMD_REG:%x\n",
+	 *                             REQ_VLAN_CMD_REG); */
+	/* vlan group table format *
+	 **======================================================================*
+	 ** valid bits | col_ptr | portNo | field_valids | action entry | vlan   *
+	 **======================================================================*
+	 ** 4-bit      | 16-bit  | 4-bit  | 8-bit        | 32-bit       | 12-bit *
+	 **=====================================================================*/
+
+	/* VLAN (BD) Hash table action entry map:*
+	 **=======================================*
+	 ** [07:00]         - forward port list
+	 ** [15:08]         - untag list
+	 ** [18:16]         - ucast_hit_action
+	 ** [21:19]         - mcast_hit_action
+	 ** [24:22]         - ucast_miss_action
+	 ** [27:25]         - mcast_miss_action
+	 ** [30:28]         - mstp
+	 ** [31:31]         - Not used yet
+	 **=======================================*/
+
+	/* fill vlan reg */
+	vlanNo = field_entries;
+	/*      print_msg(SWITCH_INIT_DEBUG,NULL,"ADD VID:%x\r\n", vlanNo); */
+	sf_writel(vlanNo & VLANID_MASK,REQ_VLAN_MAC1_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC2_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC3_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC4_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC5_ADDR_REG);
+
+	/* fill ENTRY reg */
+	/*  print_msg(SWITCH_INIT_DEBUG,NULL,"VLAN ENTRY %x \r\n",
+	 *                  action_entry & BRENTRY_ACTION_ENTRY_MASK); */
+	sf_writel( action_entry & BRENTRY_ACTION_ENTRY_MASK, REQ_VLAN_ENTRY_REG);
+
+	/* Description of ADD CMD REG:
+	 ** 3:0   - CMD
+	 ** 7:4   - Reserved
+	 ** 8     - Vlan Field Valid
+	 ** 15:9 - Reserved
+	 ** 31:16 - Mem Index / portno[16:19]
+	 **/
+
+	/* Issue ADD cmd */
+	sf_writel( CMD_ADD |(field_valids & CMD_ENTRY_FIELD_VALID_MASK), REQ_VLAN_CMD_REG);
+	/* Description of STAUTS CMD REG:
+	 ** 0 - req1_cmd_done
+	 ** 1 - req1_sig_entry_not_found
+	 ** 2 - req1_sig_init_done
+	 ** 3 - req1_sig_entry_added
+	 ** 4 - req1_match
+	 ** 31:5 - reserved.
+	 **/
+
+	cmd_done = hash_table_config_done(VLAN_TABLE);
+
+	spin_unlock_irqrestore(&vlan_hash_lock, flags);
+	if ((cmd_done & STATUS_CMD_DONE) &&(cmd_done & STATUS_ENTRY_ADDED)) {
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+int vlan_hash_table_flush(void) {
+	int cmd_done = 0;
+
+	unsigned long flags;
+	spin_lock_irqsave(&vlan_hash_lock, flags);
+	sf_writel(0x1,REQ_VLAN_MAC1_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC2_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC3_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC4_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC5_ADDR_REG);
+
+
+	/* Issue UPDATE cmd */
+	sf_writel(  CMD_FLUSH | 0x4000, REQ_VLAN_CMD_REG);
+
+	cmd_done = hash_table_config_done(VLAN_TABLE);
+
+	spin_unlock_irqrestore(&vlan_hash_lock, flags);
+	if (cmd_done) {
+
+		/* Entry Added/Updated Successfully */
+		return 0;
+	} else {
+		/*  print_msg(SWITCH_INIT_DEBUG,NULL,
+			"VLAN UPDATE CMD FAILED\n"); */
+		/* Entry Not Added */
+		return -1;
+	}
+
+	return 0;
+}
+
+int add_vlan_entry_args(int vlanid, int port, int port_list, int untag_list) {
+
+	uint action_entry = 0;
+
+	/*Adding vlan id 1, port list*/
+	action_entry =  ((port_list << BRENTRY_FWD_PORT_LIST_START_POS) & BRENTRY_FWD_PORT_LIST_MASK) | ((untag_list << BRENTRY_UNTAG_LIST_START_POS) & BRENTRY_UNTAG_LIST_MASK);
+
+	return vlan_hash_table_insert(vlanid, port, action_entry);
+}
+
+void mac_init_mac_reg(uint field_entries[5])
+{
+	/*Writing mac address*/
+	sf_writel(SF_INT_SWAP(field_entries[0]), REQ_MAC1_ADDR_REG);
+	sf_writel((field_entries[1] & 0xFFFF0000) | SF_SHORT_SWAP(field_entries[1]), REQ_MAC2_ADDR_REG);
+	sf_writel(SF_INT_SWAP(field_entries[2]), REQ_MAC3_ADDR_REG);
+	sf_writel(SF_INT_SWAP(field_entries[3]), REQ_MAC4_ADDR_REG);
+}
+
+int mac_hash_table_search(uint field_entries[5], uint field_valids)
+{
+	int cmd_done = 0, entry = 0;
+	// printk("%s in \n",__FUNCTION__);
+
+	spin_lock_bh(&mac_hash_lock);
+	/* initialize MAC regs */
+	mac_init_mac_reg(field_entries);
+
+	sf_writel(CMD_SEARCH | ((field_valids & CMD_ENTRY_FIELD_VALID_MASK)), REQ_CMD_REG);
+
+	cmd_done = hash_table_config_done(MAC_TABLE);
+
+	/*Bridge entry match done check*/
+	if (cmd_done & STATUS_ENTRY_MATCH) {
+		/* SEARCH FOUND */
+		cmd_done = sf_readl(REQ_ENTRY_REG);
+		entry = cmd_done & BRENTRY_ACTION_ENTRY_MASK;
+		/*  print_msg(SWITCH_INIT_DEBUG,NULL,"%s: entry = %x\n",
+		 *                              __func__, entry); */
+		/* Clear req entry reg */
+		sf_writel(0x0, REQ_ENTRY_REG);
+		// printk("%s out \n",__FUNCTION__);
+		spin_unlock_bh(&mac_hash_lock);
+		return entry;
+	}
+	// printk("%s out fail \n",__FUNCTION__);
+	/* SEARCH NOT FOUND */
+	spin_unlock_bh(&mac_hash_lock);
+	return -1;
+
+} /*End of hw_hash_table_search Function*/
+
+int vlan_hash_table_search(uint vlanid) {
+	int  cmd_done = 0, entry = 0,
+		 field_valids = BIT_SET_VLAN_1F_VLANTBL;
+
+	unsigned long flags;
+	spin_lock_irqsave(&vlan_hash_lock, flags);
+	sf_writel(vlanid & VLANID_MASK,REQ_VLAN_MAC1_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC2_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC3_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC4_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC5_ADDR_REG);
+
+	/* write the search command */
+	sf_writel(CMD_SEARCH | field_valids, REQ_VLAN_CMD_REG);
+
+	cmd_done = hash_table_config_done(VLAN_TABLE);
+
+	/*Bridge entry match done check*/
+	if (cmd_done & STATUS_ENTRY_MATCH) {
+
+		/* SEARCH FOUND */
+		cmd_done = sf_readl(REQ_VLAN_ENTRY_REG);
+		entry = (cmd_done & BRENTRY_ACTION_ENTRY_MASK);
+		/* Clear req entry reg */
+		sf_writel(0x0, REQ_VLAN_ENTRY_REG);
+		spin_unlock_irqrestore(&vlan_hash_lock, flags);
+		return entry;
+	} else {
+			/* SEARCH NOT FOUND */
+
+		spin_unlock_irqrestore(&vlan_hash_lock, flags);
+		return -1;
+	} /*End of bridge entry match done -IF condition*/
+
+} /*End of wsp_vlan_entry_search Function*/
+/**********************************************************************
+ * * Function Name  : wsp_vlan_entry_update
+ * * Description    : Update given BRENTRY PTR into HASH MAC TABLE
+ * * Inputs
+ * * Parameters   : - Mac Address and brentry
+ * * Globals      : -
+ * * Outputs        :
+ * *  Parameters  : -
+ * * Returns      :   Returns Entry Update Status
+ * * Changes        :
+ * **********************************************************************/
+int vlan_hash_entry_update( uint vlanid, uint action_entry) {
+
+	int  cmd_done = 0;
+	uint field_valids =  BIT_SET_VLAN_1F_VLANTBL;
+	unsigned long flags;
+	spin_lock_irqsave(&vlan_hash_lock, flags);
+
+	sf_writel(vlanid & VLANID_MASK,REQ_VLAN_MAC1_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC2_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC3_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC4_ADDR_REG);
+	sf_writel(0,REQ_VLAN_MAC5_ADDR_REG);
+
+
+	/* fill ENTRY reg if valid */
+	sf_writel(action_entry & BRENTRY_ACTION_ENTRY_MASK, REQ_VLAN_ENTRY_REG);
+
+	/* Issue UPDATE cmd */
+	sf_writel(CMD_UPDATE | field_valids, REQ_VLAN_CMD_REG);
+
+	cmd_done = hash_table_config_done(VLAN_TABLE);
+	spin_unlock_irqrestore(&vlan_hash_lock, flags);
+
+	if (cmd_done & STATUS_ENTRY_ADDED) {
+		/* Entry Added/Updated Successfully */
+		return 0;
+	} else {
+		/*  print_msg(SWITCH_INIT_DEBUG,NULL,
+			"VLAN UPDATE CMD FAILED\n"); */
+		/* Entry Not Added */
+		return -1;
+	}
+
+	return 0;
+} /*End of wsp_vlan_entry_update() Function*/
+
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+/**********************************************************************
+ * * Function Name  : vlan_hash_table_refresh
+ * * Description    : if we check phy link up or down,we will refresh the vlan hash table
+ * *                  to adapt the energy detect mode
+ * **********************************************************************/
+int vlan_hash_table_refresh(struct switch_dev *dev) {
+	struct sfax8_switch_t *sfax8_switch = container_of(dev, struct sfax8_switch_t, swdev);
+	struct sf_priv *priv = (struct sf_priv *)netdev_priv(sfax8_switch->netdev);
+	int i = 0, vid = 0, member = 0, member_insert = 0, action_entry = 0;
+	int member_current = 0;
+	/*vlan1 has 4 port,if port link up,set port_change to 2;if port link down,set port_change to 1*/
+	unsigned char port_change[3] = {0};
+
+	vid = sfax8_switch->vlan_entries[1].vid;
+	member = sfax8_switch->vlan_entries[1].member;
+	member_current = ((vlan_hash_table_search(vid) & BRENTRY_FWD_PORT_LIST_MASK) >> BRENTRY_FWD_PORT_LIST_START_POS) & ((vlan_hash_table_search(vid) & BRENTRY_UNTAG_LIST_MASK) >> BRENTRY_UNTAG_LIST_START_POS);
+	member_insert = 0;
+	for (i = 0; i < SF_POWERSAVE_PORTS; i++){
+		if(check_phy_linkup(i, priv)){
+			member_insert |= 1 << i;
+			if (!(member_current & (1 << i)))
+			  port_change[i] = 2;
+		}else{
+			if ((member_current & (1 << i)))
+			  port_change[i] = 1;
+		}
+	}
+
+	member_insert |= 1 << SF_HOST_PORT;
+	action_entry = ((member_insert << BRENTRY_FWD_PORT_LIST_START_POS) & BRENTRY_FWD_PORT_LIST_MASK) | ((member_insert << BRENTRY_UNTAG_LIST_START_POS) & BRENTRY_UNTAG_LIST_MASK);
+	print_msg(SWITCH_INIT_DEBUG,NULL,"update vlan entry member 0x%x, vid %d\n",member_insert, vid);
+	vlan_hash_entry_update(vid, action_entry);
+
+	for (i = 0; i < SF_POWERSAVE_PORTS; i++){
+		/*port_change value 2 means port i link from down to up, should disable energy detect mode*/
+		if (port_change[i] == 2)
+		  sf_phy_energy_detect_disable(i, priv->phy_dev);
+		/*port_change value 1 means port i link from up to down, should enable energy detect mode*/
+		else if (port_change[i] == 1)
+		  sf_phy_energy_detect_enable(i, priv->phy_dev);
+	}
+
+	return 0;
+}
+#endif
+
+int mac_hash_table_update(uint field_entries[5], uint brentry, uint field_valids) {
+	int cmd_done = 0;
+	spin_lock_bh(&mac_hash_lock);
+	/* initialize mac regs */
+	mac_init_mac_reg(field_entries);
+
+	/* fill ENTRY reg if valid */
+	sf_writel( brentry, REQ_ENTRY_REG);
+
+	/* Issue UPDATE cmd */
+	sf_writel(CMD_UPDATE | ((field_valids & CMD_ENTRY_FIELD_VALID_MASK)), REQ_CMD_REG);
+
+	cmd_done = hash_table_config_done(MAC_TABLE);
+	sf_writel( 0x0, REQ_ENTRY_REG);
+	spin_unlock_bh(&mac_hash_lock);
+	if (cmd_done & STATUS_ENTRY_ADDED) {
+		// printk("%s out\n",__FUNCTION__);
+		/* Entry Added/Updated Successfully */
+		return 0;
+	}
+	printk("%s out fail \n",__FUNCTION__);
+	return -1;
+} /*End of hw_hash_table_update Function*/
+
+int mac_hash_table_add(uint field_entries[5],  uint iport, uint brentry, uint field_valids) {
+	int cmd_done = 0;
+	spin_lock_bh(&mac_hash_lock);
+
+	/* initialize MAC regs */
+	mac_init_mac_reg(field_entries);
+
+	/* fill ENTRY reg */
+	sf_writel( brentry, REQ_ENTRY_REG);
+
+	/* Description of ADD CMD REG:
+	 ** 3:0   - CMD
+	 ** 7:4   - Reserved
+	 ** 8     - DMAC Field Valid
+	 ** 9     - Vlan Field Valid
+	 ** 15:10 - Reserved
+	 ** 31:16 - Mem Index
+	 **/
+
+	/* Issue ADD cmd */
+	sf_writel(CMD_ADD | field_valids | (iport << CMD_ENTRY_PORTS_START_POS), REQ_CMD_REG);
+	/* print_msg(SWITCH_INIT_DEBUG,NULL,"ADD %x \r\n",CMD_ADD |
+	 *         field_valids | (iport << CMD_ENTRY_PORTS_START_POS)); */
+
+	/* Description of STAUTS CMD REG:
+	 ** 0 - req1_cmd_done
+	 ** 1 - req1_sig_entry_not_found
+	 ** 2 - req1_sig_init_done
+	 ** 3 - req1_sig_entry_added
+	 ** 4 - req1_match
+	 ** 31:5 - reserved.
+	 **/
+
+	cmd_done = hash_table_config_done(MAC_TABLE);
+	sf_writel( 0, REQ_ENTRY_REG);
+	spin_unlock_bh(&mac_hash_lock);
+
+	if ((cmd_done & STATUS_CMD_DONE) &&( cmd_done & STATUS_ENTRY_ADDED)) {
+
+		/* print_msg(SWITCH_INIT_DEBUG,NULL,"ADD CMD DONE\n");
+		 *         Entry Added Successfully */
+		/* update hash entry count for cli */
+		return 0;
+	} else {
+
+		/*      print_msg(SWITCH_INIT_DEBUG,NULL,"ADD CMD FAILED\n"); */
+		/* Entry Not Added */
+		return -1;
+	}
+} /*End of hw_hash_table_add Function*/
+
+void host_ageing(void) {
+	uint hashidx = 0, vlan_valid = 0;
+	uint coll_ptr = 0, mac3 = 0, mac4 = 0;
+	static uint hashBase;
+
+	/* 2-field Mac table format: Table Depth - 1024(hash 512 + collison 512)
+	 * *============================================================================*
+     * * valid bits | col_ptr | portNO | field_valids | action entry | vlanid|  MAC *
+     * *============================================================================*
+     * * 4-bit      | 16-bit  | 4-bit  | 8-bit(mac4)  | 31-bit (mac3)| 13-bit|48-bit*
+     * *============================================================================*/
+
+    /*=============================================================================*
+     * * MAC1:MAC[31:0]                                                               *
+     * *==============================================================================*
+     * * MAC2:ACT_ENTRY[31:29] + VLANID[28:16] + MAC[15:0]                            *
+     * *==============================================================================*
+     * * MAC3:FIELD_VALIDS[31:28] + ACT_ENTRY[27:0]                                   *
+     * *==============================================================================*
+     * *MAC4:RSVD[31:28]+VALIDBITS[27:24]+COLPTR[23:8]+ PORTNO[7:4] + FIELDVALIDS[3:0]*
+     * *=============================================================================*/
+	spin_lock_bh(&mac_hash_lock);
+    for (hashidx = 0; hashidx <  HASH_CNT_PER_ITERATION; hashidx++) {
+
+start:
+        coll_ptr = mac3 = mac4 = vlan_valid = 0;
+
+        sf_writel(0, REQ_MAC1_ADDR_REG );
+        sf_writel(0, REQ_MAC2_ADDR_REG );
+        sf_writel(0, REQ_MAC3_ADDR_REG );
+        sf_writel(0, REQ_MAC4_ADDR_REG );
+
+        /* Read hash index entry */
+		sf_writel(((hashBase + hashidx)<<16) | CMD_MEM_READ,REQ_CMD_REG);
+		hash_table_config_done(MAC_TABLE);
+
+		/* read field_entries */
+		mac4 = sf_readl(REQ_MAC4_ADDR_REG);
+
+        if (HASH_ENTRY_VALID_FLAG & mac4) {
+
+            if (mac4 & HASH_ENTRY_COLL_FLAG)
+              coll_ptr = (mac4 >> 8) & 0xFFFF;
+
+            mac3 = sf_readl(REQ_MAC3_ADDR_REG);
+            if (HASH_ENTRY_FRESH_FLAG & mac3) {
+                /* delete */
+                /*  vlan_valid =
+                 *                      (mac3 & HASH_ENTRY_VLAN_SET_FLAG) ?
+                 *                                          BIT_SET_VLAN_2F_MACTBL : 0; */
+                sf_writel( CMD_DEL | BIT_SET_MAC_2F_MACTBL |
+                            BIT_SET_VLAN_2F_MACTBL, REQ_CMD_REG);
+                if (coll_ptr) {
+                    hash_table_config_done(MAC_TABLE);
+                        goto start;
+                }
+            } else {
+
+                /* update */
+                if (!(mac3 & HASH_ENTRY_STATIC_FLAG)) {
+
+                    mac3 |= HASH_ENTRY_FRESH_FLAG;
+                    sf_writel(mac3, REQ_MAC3_ADDR_REG );
+                    sf_writel(CMD_MEM_WRITE | ((hashBase + hashidx) << 16), REQ_CMD_REG);
+                } else {
+
+                    continue;
+                }
+            }
+             hash_table_config_done(MAC_TABLE);
+        } /* End if - HASH_ENTRY_VALID_FLAG */
+        /* collision space entries */
+        while (coll_ptr) {
+
+            sf_writel(0, REQ_MAC1_ADDR_REG );
+            sf_writel(0, REQ_MAC2_ADDR_REG );
+            sf_writel(0, REQ_MAC3_ADDR_REG );
+            sf_writel(0, REQ_MAC4_ADDR_REG );
+            /* Read hash index entry */
+            sf_writel( (coll_ptr<<16) | CMD_MEM_READ, REQ_CMD_REG);
+            hash_table_config_done(MAC_TABLE);
+                /* read field_entries */
+            mac3 = mac4 = vlan_valid = 0;
+            mac4 = sf_readl(REQ_MAC4_ADDR_REG);
+            /* check entry's validity */
+            if (HASH_ENTRY_VALID_FLAG & mac4) {
+
+                mac3 = sf_readl(REQ_MAC3_ADDR_REG);
+                if (HASH_ENTRY_FRESH_FLAG & mac3) {
+                    /* delete */
+                    /* vlan_valid = (mac3 &
+                     *                         HASH_ENTRY_VLAN_SET_FLAG) ?
+                     *                                                 BIT_SET_VLAN_2F_MACTBL : 0;*/
+                    sf_writel( CMD_DEL | BIT_SET_MAC_2F_MACTBL | BIT_SET_VLAN_2F_MACTBL, REQ_CMD_REG);
+                } else {
+
+                    /* update */
+                    mac3 |= HASH_ENTRY_FRESH_FLAG;
+                    sf_writel(mac3, REQ_MAC3_ADDR_REG );
+                    /* Issue the MEM write cmd */
+                    sf_writel(CMD_MEM_WRITE | (coll_ptr << 16),REQ_CMD_REG);
+                }
+                coll_ptr = 0;
+                if (mac4 & HASH_ENTRY_COLL_FLAG)
+                  coll_ptr = (mac4 >> 8) & 0xFFFF;
+                hash_table_config_done(MAC_TABLE);
+            } /* End if - HASH_ENTRY_VALID_FLAG */
+        } /* End While - coll_ptr */
+
+    } /* end of for loop- hashidx */
+	spin_unlock_bh(&mac_hash_lock);
+    /*update hashBase */
+    hashBase += hashidx;
+    /* updating entries in blocks */
+    if (hashBase >= 511)
+      hashBase = 0;
+}
+
+int sf_switch_hash_learn(pktHdrs_t *pktHdr, struct sf_priv *priv) {
+
+    uchar *mac;
+    int ret = -1;
+    uint fwd_action = 0;
+    uint vlanid = 0, action_entry = 0;
+	uint field_entries[5], field_valids = BIT_SET_MAC_2F_MACTBL;
+    uint action_portno = 0, phy_port = 0;
+    struct ethhdr *ethHdr = (struct ethhdr *)pktHdr->data;
+
+	print_msg(SWITCH_DEBUG,priv->netdev,"%s vlan_id %d \n",__FUNCTION__, pktHdr->vlanid);
+    mac = ethHdr->h_source;
+
+	vlanid = DEF_PORT_FALLBACK_BD_ID;
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+    if ((pktHdr->vlanid == priv->sfax8_switch->port[pktHdr->phyno].fallback_bd_id) || (pktHdr->vlanid == 0)) {
+        vlanid = priv->sfax8_switch->port[pktHdr->phyno].fallback_bd_id;
+    } else {
+
+        vlanid = pktHdr->vlanid;
+    }
+#endif
+
+    /* initialize required filed valids for mac table learning/searching */
+	// uint *entry = (uint *)mac;
+
+	/* need to updated field entries valid filed basis */
+	field_entries[0] = ((*mac << 0)&0x000000ff) |((*(mac + 1) << 8)&0x0000ff00) | ((*(mac + 2) << 16)&0x00ff0000) |((*(mac + 3) << 24)&0xff000000);
+	field_entries[1] = ((*(mac + 4) << 0)&0x000000ff) |((*(mac + 5) << 8)&0x0000ff00);
+	// field_entries[0] = entry[0];
+	// field_entries[1] = entry[1] & 0xFFFF;
+	field_entries[1] |= (vlanid << 16);
+	field_entries[2] = field_entries[3] = field_entries[4] = 0;
+
+    /* update vlan field valid for mac table */
+    field_valids |= BIT_SET_VLAN_2F_MACTBL;
+
+    phy_port = pktHdr->phyno;
+
+    /* check for for already entry existence */
+    ret = mac_hash_table_search(field_entries, field_valids);
+	print_msg(SWITCH_DEBUG,priv->netdev,"search ret is 0x%x\n",ret);
+    if (-1 == ret) {
+		print_msg(SWITCH_DEBUG,priv->netdev,"learn info is mac %02x:%02x:%02x:%02x:%02x:%02x, vid=%d phy_port=%d\n",((*mac )&0x000000ff),((*(mac + 1))&0x000000ff),((*(mac + 2))&0x000000ff),((*(mac + 3))&0x000000ff),((*(mac + 4))&0x000000ff),((*(mac + 5))&0x000000ff),vlanid,phy_port);
+		/* fill action_entry's fresh bit */
+		action_entry = FRESH_FLAG_SET;
+
+		/* Add SMAC entry with action entry & valid fields */
+
+		/* update action entry with port info
+		 *                     on which it arrived */
+		action_entry |= ((0x1 << phy_port) &
+					FWD_PORT_LIST_MASK);
+
+		/* Get bridge action entry */
+		ret = vlan_hash_table_search(vlanid);
+		if (-1 == ret) {
+
+			/* Un handeled bridge entry,
+			 *             take fwd action of fp_global br entry */
+			fwd_action = ACT_FORWARD;
+		} else {
+
+            /* Get bridge action entry's
+             *                     unicast hit fwd action */
+            fwd_action =
+                (ret & BRENTRY_UCAST_HIT_ACT_MASK) >>
+                BRENTRY_UCAST_HIT_ACT_START_POS;
+        }
+		/* Update mac action entry's fwd action */
+		action_entry = (action_entry & ~MAC_2F_ENTRY_FWD_ACT_MASK) |
+			(fwd_action << MAC_2F_ENTRY_FWD_ACT_START_POS);
+
+		if(memcmp(ethHdr->h_source, priv->netdev->dev_addr, sizeof(ethHdr->h_source)) == 0){
+			action_entry |= (0x1 << MAC_2F_ENTRY_STATIC_BIT_POS);
+		}
+		print_msg(SWITCH_DEBUG,priv->netdev,"add action entry is 0x%x field valids is 0x%x\n",action_entry,field_valids);
+			/* add mac entry */
+		ret = mac_hash_table_add(field_entries, phy_port,
+					action_entry, field_valids);
+		if (ret == -1) {
+			netdev_err(priv->netdev,"add mac entry failed mac address is %pM\n",ethHdr->h_source);
+			add_fail_count++;
+			BUG_ON(add_fail_count > 10);
+			return -1;
+		}
+		else{
+			add_fail_count = 0;
+		}
+
+	} else {
+		if(pktHdr->punt_reason == SF_PUNT_SA_IS_ACTIVE || pktHdr->punt_reason == SF_PUNT_SA_RELEARN){
+			print_msg(SWITCH_DEBUG,priv->netdev,"relearn or active is mac %02x:%02x:%02x:%02x:%02x:%02x, vid=%d phy_port=%d\n",((*mac )&0x000000ff),((*(mac + 1))&0x000000ff),((*(mac + 2))&0x000000ff),((*(mac + 3))&0x000000ff),((*(mac + 4))&0x000000ff),((*(mac + 5))&0x000000ff),vlanid,phy_port);
+			action_entry = ret;
+			/* mac hash entry found */
+			switch (pktHdr->punt_reason) {
+				case SF_PUNT_SA_IS_ACTIVE:
+					//clean fresh bit
+					if (action_entry & FRESH_FLAG_MASK)
+						action_entry = action_entry & ~FRESH_FLAG_MASK;
+					break;
+				case SF_PUNT_SA_RELEARN:
+					/* validate relearn:*
+					 * * check for ingress port match
+					 * with action entry port num */
+					action_portno = (ret & (FWD_PORT_LIST_MASK &
+									(1 << phy_port)));
+					if (!((1 << phy_port) & action_portno)) {
+						action_entry = action_entry &
+							(~FWD_PORT_LIST_MASK);
+						/* reset old phyno and update new phyno into action entry */
+						action_entry |= ((0x1 << phy_port) &
+									FWD_PORT_LIST_MASK);
+					}
+					break;
+				default:
+					break;
+			} /* End of switch - (pktHdr->punt_reason) */
+			/* update new phyno into mac hash table */
+			ret = mac_hash_table_update(field_entries,
+						action_entry, field_valids);
+		}
+		else{
+			// error sa miss
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int sf_do_packet_parsing(uchar *data, pktHdrs_t *pktHdr) {
+
+	ushort eth_type = 0, length = ETH_SMAC_DMAC_SIZE;
+	struct ethhdr *eth_hdr = NULL;
+	vlanEthhdr_t *vlanEthHdr;
+	uchar *pLayer2Hdr;
+	uchar *pLayer3Hdr;
+
+	/* initilize starting layer of data pointer to packet header data */
+    pktHdr->data = data;
+
+    /* do packet parsing & initilize corresponig header pointer fields */
+    pLayer2Hdr = data;
+    eth_hdr = (struct ethhdr *)pLayer2Hdr;
+    eth_type = SF_SHORT_SWAP(eth_hdr->h_proto);
+
+    /*Update layer-3 header pointers by looping the ether type*/
+    while (1) {
+
+        /*Ether net type ipv4*/
+        if (eth_type == ETH_P_IP) {
+
+            /*
+             *			* set packet type as IP in the pktHdr and get the next
+             *						* protocol and return
+             *									*/
+
+            /* adjust length for IP header */
+            length = length + ETH_PROTO_SIZE;
+
+            /* extract the layer-3 header pointer
+             *						from pktbuf for ipv4 */
+            pLayer3Hdr = pLayer2Hdr + length;
+
+            return 0;
+        } else if (eth_type == ETH_P_IPV6) {
+
+            /*
+             *			* set packet type as IPV6 in the pktbuf and get the next
+             *						* protocol and return
+             *									*/
+
+            /* adjust length for IP header */
+            length = length + ETH_PROTO_SIZE;
+            /* extract the layer-3 header pointer
+             *						from pktbuf for ipv6 */
+            pLayer3Hdr = pLayer2Hdr + length;
+            return 0;
+        } else if (eth_type == ETH_P_ARP) {
+
+            /*
+             *			* set packet type as ARP in the pktbuf and get the next
+             *						* protocol and return
+             *									*/
+            return 0;
+        } else if (eth_type == ETH_P_8021Q) {
+
+            /*set packet type as VLAN in the pktbuf and get the next
+             *			* protocol and continue*/
+            vlanEthHdr = (vlanEthhdr_t *)(pLayer2Hdr);
+            pktHdr->vlanid =
+                SF_SHORT_SWAP(vlanEthHdr->h_vlan_TCI) & 0xFFF;
+
+            /* adjust VLAN header length */
+            length = length + VLAN_HLEN;
+            eth_type = *(ushort *)(pLayer2Hdr + length);
+            eth_type = SF_SHORT_SWAP(eth_type);
+			// printk("pktHdr->vlanid %d in process\n" ,pktHdr->vlanid);
+        } else {
+
+
+            /* need handle remaining protocols like
+             *						PPPoE, PTP, etc */
+            break;
+        }
+    }
+    return -1;
+}
+
+int sf_process_packet(uchar *data, uint data_len, struct rx_header *rxhdr,struct sf_priv *priv) {
+
+    pktHdrs_t pktHdr;
+    int ret = 0;
+
+	print_msg(ETH_RX_DEBUG,priv->netdev,"%s rxhdr ctrl 0x%x punt_reason 0x%x phy_no %d\n",__FUNCTION__, rxhdr->ctrl, rxhdr->punt_reason, rxhdr->rxport_num);
+    memset(&pktHdr, 0, sizeof(pktHdrs_t));
+    /* update rx port num */
+    pktHdr.phyno = rxhdr->rxport_num;
+    pktHdr.punt_reason = rxhdr->punt_reason;
+    /* do packet parsing */
+    ret = sf_do_packet_parsing(data, &pktHdr);
+    /* do reason code handling based on punt reason code */
+    switch (rxhdr->punt_reason) {
+		case SF_PUNT_SA_RELEARN:
+			if (!memcmp(data + 6, priv->netdev->dev_addr, 5))
+				// if (*(data + 11) == priv->netdev->dev_addr[5] || *(data + 11) == (priv->netdev->dev_addr[5]+1))
+					break;
+        case SF_PUNT_SA_MISS:
+        case SF_PUNT_SA_IS_ACTIVE:
+            return sf_switch_hash_learn(&pktHdr,priv);
+        default:
+            break;
+    }
+    return 0;
+}
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_switch_hash_table.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_switch_hash_table.h	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,169 @@
+#ifndef SF_SWITCH_HASH_TABLE_H
+#define SF_SWITCH_HASH_TABLE_H
+
+#include "sf_eth.h"
+#include "sf_switch.h"
+#include "sf_eth_addr.h"
+#define  REQ_MAC_BASE_OFFSET   REG_CLASS_DAMACHASH_HOST_CMD_REG
+#define REQ_VLAN_BASE_OFFSET   REG_CLASS_DAVLANHASH_HOST_CMD_REG
+/* VLAN Mac Hash table */
+#define  REQ_VLAN_CMD_REG          (REQ_VLAN_BASE_OFFSET + 0x0)
+#define  REQ_VLAN_MAC1_ADDR_REG    (REQ_VLAN_BASE_OFFSET + 0x4)
+#define  REQ_VLAN_MAC2_ADDR_REG    (REQ_VLAN_BASE_OFFSET + 0x8)
+#define  REQ_VLAN_MAC3_ADDR_REG    (REQ_VLAN_BASE_OFFSET + 0xc)
+#define  REQ_VLAN_MAC4_ADDR_REG    (REQ_VLAN_BASE_OFFSET + 0x10)
+#define  REQ_VLAN_MAC5_ADDR_REG    (REQ_VLAN_BASE_OFFSET + 0x14)
+#define  REQ_VLAN_ENTRY_REG        (REQ_VLAN_BASE_OFFSET + 0x18)
+#define  REQ_VLAN_STATUS_REG       (REQ_VLAN_BASE_OFFSET + 0x1c)
+#define  REQ_VLAN_DIRECT_REG       (REQ_VLAN_BASE_OFFSET + 0x20)
+
+#define  FREE_VLAN_LIST_ENTRIES    REG_CLASS_DAVLANHASH_FREELIST_ENTRIES
+#define  FREE_VLAN_LIST_HEAD_PTR   REG_CLASS_DAVLANHASH_FREELIST_HEAD_PTR
+#define  FREE_VLAN_LIST_TAIL_PTR   REG_CLASS_DAVLANHASH_FREELIST_TAIL_PTR
+
+/* Mac Hash table */
+#define  FREE_LIST_ENTRIES    REG_CLASS_DAMACHASH_FREELIST_ENTRIES
+#define  FREE_LIST_HEAD_PTR   REG_CLASS_DAMACHASH_FREELIST_HEAD_PTR
+#define  FREE_LIST_TAIL_PTR   REG_CLASS_DAMACHASH_FREELIST_TAIL_PTR
+
+/* Mac Hash table */
+#define  REQ_CMD_REG          (REQ_MAC_BASE_OFFSET + 0x0)
+#define  REQ_MAC1_ADDR_REG    (REQ_MAC_BASE_OFFSET + 0x4)
+#define  REQ_MAC2_ADDR_REG    (REQ_MAC_BASE_OFFSET + 0x8)
+#define  REQ_MAC3_ADDR_REG    (REQ_MAC_BASE_OFFSET + 0xc)
+#define  REQ_MAC4_ADDR_REG    (REQ_MAC_BASE_OFFSET + 0x10)
+#define  REQ_MAC5_ADDR_REG    (REQ_MAC_BASE_OFFSET + 0x14)
+#define  REQ_ENTRY_REG        (REQ_MAC_BASE_OFFSET + 0x18)
+#define  REQ_STATUS_REG       (REQ_MAC_BASE_OFFSET + 0x1c)
+#define  REQ_DIRECT_REG       (REQ_MAC_BASE_OFFSET + 0x20)
+
+/* HW MAC TABLE CMDS */
+#define CMD_INIT		1
+#define CMD_ADD			2
+#define CMD_DEL			3
+#define CMD_UPDATE		4
+#define CMD_SEARCH		5
+#define CMD_MEM_READ	6
+#define CMD_MEM_WRITE	7
+#define CMD_FLUSH		8
+
+#define CLR_STATUS_REG				0xFFFFFFFF
+#define TWO_FIELD_HASH_ENTRIES		0x200
+#define MAC_HASH_ENTRIES			0x200
+#define TWO_FIELD_COLL_ENTRIES		0x200
+#define MAC_COLL_ENTRIES			0x200
+#define TWO_FIELD_INIT_HEAD_PTR		0x200
+#define MAC_INIT_HEAD_PTR			0x200
+#define TWO_FIELD_INIT_TAIL_PTR		0x3ff
+#define MAC_INIT_TAIL_PTR			0x3ff
+
+#define VLAN_INIT_HEAD_PTR       0x40
+#define VLAN_INIT_TAIL_PTR       0x7f
+#define VLAN_FREE_LIST_ENTRIES   0x40
+
+#define  VLAN_HASH_ENTRIES        0x40
+#define  VLAN_COLL_HASH_ENTRIES   0x40
+
+/* 2-filed mac table valid defines */
+#define BIT_SET_MAC_2F_MACTBL     0x00000100
+#define BIT_SET_VLAN_2F_MACTBL    0x00000200
+
+
+#define BIT_SET_VLAN_1F_VLANTBL     0x00000100
+
+/* VLAN (BD) Hash table action entry map:*
+ *  *=======================================*
+ *   * [07:00]         - forward port list
+ *   * [15:08]         - untag list
+ *   * [18:16]         - ucast_hit_action
+ *   * [21:19]         - mcast_hit_action
+ *   * [24:22]         - ucast_miss_action
+ *   * [27:25]         - mcast_miss_action
+ *   * [30:28]         - mstp
+ *   * [31:31]         - Not used yet
+ *   *=======================================*/
+#define BRENTRY_FWD_PORT_LIST_START_POS        0
+#define BRENTRY_UNTAG_LIST_START_POS           8
+#define BRENTRY_UCAST_HIT_ACT_START_POS        16
+#define BRENTRY_MCAST_HIT_ACT_START_POS        19
+#define BRENTRY_UCAST_MISS_ACT_START_POS       22
+#define BRENTRY_MCAST_MISS_ACT_START_POS       25
+#define BRENTRY_MSTP_HIT_ACT_START_POS         28
+#define BRENTRY_RESERVED_BIT_MASK_START_POS    31
+
+#define BRENTRY_FWD_PORT_LIST_MASK   FWD_PORT_LIST_MASK /* 00 - 07 */
+#define BRENTRY_UNTAG_LIST_MASK      0x0000FF00      /* 08 - 15 */
+#define BRENTRY_UCAST_HIT_ACT_MASK   0x00070000      /* 16 - 18 */
+#define BRENTRY_MCAST_HIT_ACT_MASK   0x00380000      /* 19 - 21 */
+#define BRENTRY_UCAST_MISS_ACT_MASK  0x01c00000      /* 22 - 24 */
+#define BRENTRY_MCAST_MISS_ACT_MASK  0x0E000000      /* 25 - 27 */
+#define BRENTRY_MSTP_HIT_ACT_MASK    0x70000000      /* 28 - 30 */
+#define BRENTRY_RESERVED_BIT_MASK    0x80000000      /* 31 -    */
+#define BRENTRY_ACTION_ENTRY_MASK    0x7FFFFFFF      /* 00 - 30 */
+
+
+/*  MAC 2F HASH TABLE MACROs */
+/*  MAC Hash table action entry map
+ *   *  * [07:00]           - forward port list              *
+ *   *  * [10:8]            - TC                             *
+ *   *  * [13:11]           - fwd_action (ACTION FIELD)      *
+ *   *  * [25:12]           - Not used yet                   *
+ *   *  * [26]              - cut through                    *
+ *   *  * [28:27]           - reserved for feature block     *
+ *   *  * [29]              - fresh                          *
+ *   *  * [30]              - static                         */
+
+#define MAC_2F_ENTRY_FWD_PORT_LIST_MASK         FWD_PORT_LIST_MASK
+#define MAC_2F_ENTRY_FWD_ACT_MASK                0x00003800
+#define MAC_2F_ENTRY_CUT_THROUGH_MASK            0x04000000
+#define MAC_2F_ENTRY_FRESH_MASK                  0x20000000
+#define MAC_2F_ENTRY_STATIC_MASK                 0x40000000
+#define MAC_2F_ENTRY_TC_MASK                     0x700
+
+#define MAC_2F_ENTRY_FWD_PORT_LIST_START_POS     0
+#define MAC_2F_ENTRY_FWD_ACT_START_POS           11
+#define MAC_2F_ENTRY_CUT_THROUGH_START_POS       26
+#define MAC_2F_ENTRY_FRESH_BIT_POS               29
+#define MAC_2F_ENTRY_STATIC_BIT_POS              30
+#define MAC_2F_ENTRY_TC_START_POS                8
+
+/*  !MAC 2F HASH TABLE MACROs */
+#define STATUS_CMD_DONE              0x00000001
+#define STATUS_ENTRY_NOT_FOUND       0x00000002
+#define STATUS_INIT_DONE             0x00000004
+#define STATUS_ENTRY_ADDED           0x00000008
+#define STATUS_ENTRY_MATCH           0x00000010
+#define CMD_ENTRY_PORTS_START_POS    16
+#define CMD_ENTRY_FIELD_VALID_MASK   0x00001F00
+
+//TPID: Tag Protocol Identifier
+#define VLAN_TAGGED_FRAME        0x8100
+//#define PROVIDER_BRIDGING_FRAME  0x88a8
+//#define QinQ_9100_FRAME          0x9100
+//#define QinQ_9200_FRAME          0x9200
+//
+#define STPID0                                0x5500    /*  Not Used by Anyone in IEEE page */
+#define STPID1                                0x5501    /*  http://standards.ieee.org/develop/regauth/ethertype/eth.txt */
+#define STPID2                                0x5502
+#define STPID1_START_POS                      16
+#define MAC_TABLE  1
+#define VLAN_TABLE 2
+
+int vlan_hash_table_search(uint vlanid);
+int vlan_hash_table_insert(uint field_entries, uint portNo, uint action_entry);
+int mac_hash_table_update(uint field_entries[5], uint brentry, uint field_valids);
+int mac_hash_table_add(uint field_entries[5], uint iport, uint brentry, uint field_valids);
+int mac_hash_table_search(uint field_entries[5], uint field_valids);
+int  hash_table_config_done(int type);
+int add_vlan_entry_args(int vlanid, int port, int port_list, int untag_list);
+
+void mac_hash_table_init(void);
+void vlan_hash_table_init(void);
+int vlan_hash_table_flush(void);
+
+void host_ageing(void);
+int sf_process_packet(uchar *data, uint data_len, struct rx_header *rxhdr,struct sf_priv *priv);
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+int vlan_hash_table_refresh(struct switch_dev *dev);
+#endif
+#endif /* ifndef SF_SWITCH_HASH_TABLE_H */
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_switch_init.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_switch_init.c	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,299 @@
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include "sf_eth_addr.h"
+#include "sf_common.h"
+#include "sf_switch_hash_table.h"
+#include "sf_mdio.h"
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+#include "sf_switch.h"
+#endif
+#include "sf_switch_init.h"
+#include "sf_eth.h"
+#include <linux/io.h>
+// SF_COMMON_H */300s
+#define SF_SWITCH_INTERVAL        (1800*HZ)
+
+/*******************************************************reg init table**************************************/
+static hwinit_data_t sw_hwreg_data[] = {
+/*******BMU Configuration*******/
+{ REG_BMU_CTRL,									0x00000002},            //Soft reset the BMU block
+{ REG_BMU_UCAST_CONFIG,							0x00000400},            //Program for Maximum buffer count as 1024
+{ REG_BMU_UCAST_BASEADDR,						0x00100000},            //Program LMEM block base address
+{ REG_BMU_BUF_SIZE,								0x00000007},            //Buffer size bits of LMEM buffer
+{ REG_BMU_THRES,								0x02000200},            //Threshold number of LMEM buffers occupied to generate interrupt
+{ REG_BMU_INT_SRC,								0x000001ff},            //Clearing the interrupts
+{ REG_BMU_INT_ENABLE,							0x00000000},            //Disabling the interrupts
+/*******EMAC configuration*******/
+ CONFIG_EMAC_SECTION(0)
+ CONFIG_EMAC_SECTION(1)
+ CONFIG_EMAC_SECTION(2)
+ CONFIG_EMAC_SECTION(3)
+ CONFIG_EMAC_SECTION(4)
+
+/*******Class HW Block Configuration*******/
+{ REG_CLASS_HDR_SIZE,							0x00000030},                   //LMEM first buffer header size value
+{ REG_CLASS_TM_INQ_ADDR,						0x00310008},  //Address of the Traffic Manager's input Queue
+{ REG_CLASS_BMU_BUF_FREE,						0x00240034},  //Address of BMU,where buffer should be freed
+{ REG_CLASS_GLOBAL_CFG,							0x0480007e},            //bit 0 --l2 special punt enable for all ports bit 31:1 - global fall back bd entry, 16 bit default forward list for bd entry,punt to all ports if miss for unicast/multicast
+{ REG_CLASS_SNOOP_SPL_MCAST_MASK1_LSB,			0xffffffff}, //Snoop MCAST address lower 32bit mask programming
+{ REG_CLASS_SNOOP_SPL_MCAST_MASK1_MSB,			0x0000ffff}, //Snoop MCAST address upper 16bit mask programming
+{ REG_CLASS_SNOOP_SPL_MCAST_ADDR1_LSB,			0xc200000e}, //SPL multicast address1 lsb 32 bits, program DA lower 32bit address of address packets to punt to host control channel
+{ REG_CLASS_SNOOP_SPL_MCAST_ADDR1_MSB,			0x00000180}, //SPL multicast address1 msb remaining 16 bits, program DA upper 16bits address of PTP packets to punt to host control channel
+{ REG_CLASS_USE_TMU_INQ,						0x00000001}, // add this to use tmu inq full signal to avoid fifo full
+
+/*******EGPI 0/1 / 2 / 3 / 4 Blocks Configuration*******/
+CONFIG_EGPI_SECTION(0)
+CONFIG_EGPI_SECTION(1)
+CONFIG_EGPI_SECTION(2)
+CONFIG_EGPI_SECTION(3)
+CONFIG_EGPI_SECTION(4)
+
+#ifdef CONFIG_NET_SFAX8_PTP
+// add for etgpi config
+CONFIG_ETGPI_SECTION(0)
+CONFIG_ETGPI_SECTION(1)
+CONFIG_ETGPI_SECTION(2)
+CONFIG_ETGPI_SECTION(3)
+CONFIG_ETGPI_SECTION(4)
+#endif
+/*******HGPI Block Configuration*******/
+CONFIG_HGPI_SECTION()
+/*******TMU Block Configuration*******/
+{ REG_TMU_PHY0_INQ_ADDR,			REG_GPI_INQ_PKTPTR0},      //INQ address of PORTX is EGPIX
+{ REG_TMU_PHY1_INQ_ADDR,   			REG_GPI_INQ_PKTPTR1},
+{ REG_TMU_PHY2_INQ_ADDR,   			REG_GPI_INQ_PKTPTR2},
+{ REG_TMU_PHY3_INQ_ADDR,   			REG_GPI_INQ_PKTPTR3},
+{ REG_TMU_PHY4_INQ_ADDR,   			REG_GPI_INQ_PKTPTR4},
+{ REG_TMU_PHY5_INQ_ADDR,   			REG_GPI_INQ_PKTPTR5},
+{ REG_TMU_CNTX_ACCESS_CTRL,			0x00000001},             //controls the direct/indirect access to context memory. 0 - indirect, 1 - direct
+{ REG_TMU_PHY0_TDQ_CTRL,   			0x0000000f},             //bit 0 - shp_clk_cntrl_en;bit 1 - hw_en for tdq_sch_shaper;bit 3:2 - for enabling the schedulers;bit 4 - allw_tdq_prog
+{ REG_TMU_PHY1_TDQ_CTRL,   			0x0000000f},
+{ REG_TMU_PHY2_TDQ_CTRL,   			0x0000000f},
+{ REG_TMU_PHY3_TDQ_CTRL,   			0x0000000f},
+{ REG_TMU_PHY4_TDQ_CTRL,   			0x0000000f},
+{ REG_TMU_PHY5_TDQ_CTRL,   			0x0000000f},
+{ REG_TMU_BMU_INQ_ADDR,    			0x00240034},//Address of BMU, where buffer should be freed
+// tmu overflow and hif is block, if set this ,tmu will drop packet
+// { REG_TMU_TEQ_CTRL,        			0x03},
+/*******HIF Block Configura			tion*******/
+{ REG_HIF_POLL_CTRL,       			0x00640064},             //Bit [15:0] - TX BD poll counter value ;Bit [31:16] - RX BD poll counter value,which enable TX/RX BD fetch after every poll counter expiry
+{ REG_HIF_TX_ALLOC,        			0x00000064},             //Number of cycles that HIF TX block would wait before retrying for checking for destination buffer allocation
+{ REG_HIF_RX_ALLOC,        			0x00000064},             //Number of cycles that HIF RX block would wait before retrying for checking for destination buffer allocation
+
+/*******Enable of NPU IP Bl			ocks*******/
+{ REG_BMU_CTRL,            			0x00000001},             //BMU core enable
+{ REG_GPI_CTRL(0),         			0x00000001},             //EGPI core enable
+{ REG_GPI_CTRL(1),         			0x00000001},             //EGPI core enable
+{ REG_GPI_CTRL(2),         			0x00000001},             //EGPI core enable
+{ REG_GPI_CTRL(3),         			0x00000001},             //EGPI core enable
+{ REG_GPI_CTRL(4),         			0x00000001},             //EGPI core enable
+{ REG_HGPI_CTRL,           			0x00000001},             //HGPI core enable
+{ REG_CLASS_TX_CTRL,       			0x00000001},              //Class HW core enable
+{ 0,								0}              //Class HW core enable
+};
+/* The timer structure used to refresh the mac table entries */
+static struct timer_list sf_switch_age_timer;
+
+void sys_npu_reset(void)
+{
+
+	//reset npu system manager module
+	writew(0x0, (void *)NPU_SYSM_RESET);
+	writew(0x1, (void *)NPU_SYSM_RESET);
+
+	//enable npu clk
+	writew(0xFF, (void *)NPU_SOFT_CLK_EN);
+
+	//hardward reset npu
+	writew(0xFF, (void *)NPU_SOFT_RESET);
+#ifndef CONFIG_SFAX8_SWITCH_FPGA
+	//emac[5-1]_phy_enable[4:0]
+	writeb(0xFF, (void *)OMINI_PHY_ENABLE);
+	sys_omini_phy_reset();
+#endif
+	writew(0x00, (void *)NPU_SOFT_RESET);
+
+	//set npu boe
+	writew(0x0F, (void *)NPU_SOFT_BOE);
+
+}
+
+void sf_local_reset(void)
+{
+	int value = 0;
+	//already config in uboot
+	// sys_npu_reset(void);
+	sf_writel(0x40000000,REG_WSP_SYS_GENERIC_CONTROL);
+	udelay(10000);
+	value = sf_readl(REG_WSP_SYS_GENERIC_CONTROL);
+	sf_writel(value & 0xBFFFFFFF,REG_WSP_SYS_GENERIC_CONTROL);
+}
+
+void load_hwreg_table(hwinit_data_t *initdata)
+{
+	hwinit_data_t* hw_data = initdata;
+	while (hw_data->offset != 0) {
+		sf_writel(hw_data->data, hw_data->offset);
+		hw_data++;
+	}
+	return;
+}
+int get_port_address(int port_num, int index) {
+	int addr1 = 0,addr2 = 0;
+	switch (port_num) {
+		case 0:
+			addr1 = REG_CLASS_HW_PORT0_STRUC1;
+			addr2 = REG_CLASS_HW_PORT0_STRUC2;
+			break;
+		case 1:
+			addr1 = REG_CLASS_HW_PORT1_STRUC1;
+			addr2 = REG_CLASS_HW_PORT1_STRUC2;
+			break;
+		case 2:
+			addr1 = REG_CLASS_HW_PORT2_STRUC1;
+			addr2 = REG_CLASS_HW_PORT2_STRUC2;
+			break;
+		case 3:
+			addr1 = REG_CLASS_HW_PORT3_STRUC1;
+			addr2 = REG_CLASS_HW_PORT3_STRUC2;
+			break;
+		case 4:
+			addr1 = REG_CLASS_HW_PORT4_STRUC1;
+			addr2 = REG_CLASS_HW_PORT4_STRUC2;
+			break;
+		case 5:
+			addr1 = REG_CLASS_HW_PORT5_STRUC1;
+			addr2 = REG_CLASS_HW_PORT5_STRUC2;
+			break;
+		default:
+			return -1;
+	}
+	if(index == 1)
+	  return addr1;
+	else
+	  return addr2;
+}
+
+int sf_port_init(void * pswitch) {
+	uint i, addr1 = 0, addr2 = 0,max_pnum = 0;
+	struct port_s *psfax8_port = NULL;
+	/* init port data structure */
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+	struct sfax8_switch_t *psfax8_switch = pswitch;
+	psfax8_port = psfax8_switch->port;
+	max_pnum = psfax8_switch->max_port_num;
+#else
+	psfax8_port = pswitch;
+	max_pnum = SF_MAX_PORTS;
+#endif
+	for (i = 0; i < max_pnum; i++) {
+		addr1 = addr2 = 0;
+		psfax8_port[i].shutdown = 0;
+		psfax8_port[i].tpid     = VLAN_TAGGED_FRAME;
+
+		psfax8_port[i].aft      = ANY_TAGGING;
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+		//if(i == SF_HOST_PORT)
+		//   psfax8_port[i].aft    = TAGGED_ONLY;
+#endif
+
+		psfax8_port[i].fallback_bd_id = DEF_PORT_FALLBACK_BD_ID;
+
+		psfax8_port[i].block_state = FORWARDING;
+
+		psfax8_port[i].csr_untag_from_btable = 0;
+
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+		if(i != SF_HOST_PORT)
+		  psfax8_port[i].csr_untag_from_btable = 1;
+#endif
+
+		addr1 = get_port_address(i,1);
+		addr2 = get_port_address(i,2);
+		/* class hw port csr reg:
+		 *======================================================*
+		 *res |block_state |aft |shutdown |fallback_bd_id |tpid *
+		 *======================================================*
+		 *20-bit| 4-bit   |4-bit| 1-bit   | 16-bit      |16-bit *
+		 *=====================================================*/
+		if (addr1 && addr2) {
+			sf_writel( ((psfax8_port[i].fallback_bd_id << PORT_FALLBACK_BDID_START_POS) & PORT_FALLBACK_BDID_MASK)
+						| ((psfax8_port[i].tpid << PORT_TPID_START_POS) & PORT_TPID_MASK)
+						,addr1);
+
+			sf_writel( ((psfax8_port[i].csr_untag_from_btable << PORT_UNTAG_FROM_BTABLE_START_POS) & PORT_UNTAG_FROM_BTABLE_MASK)
+						| ((psfax8_port[i].block_state << PORT_BLOCKSTATE_START_POS) & PORT_BLOCKSTATE_MASK)
+						| ((psfax8_port[i].aft << PORT_AFT_START_POS) & PORT_AFT_MASK)
+						| ((psfax8_port[i].vid_prefix << PORT_VID_PREFIX_START_POS) & PORT_VID_PREFIX_MASK)
+						| ((psfax8_port[i].shutdown << PORT_SHUTDOWN_START_POS) & PORT_SHUTDOWN_MASK)
+						, addr2);
+		}
+	}
+
+	return 0;
+}
+
+void tmu_queue_init(void)
+{
+    uint phy_no = 0;
+    uint queue_no = 0;
+    for (phy_no = 0; phy_no < SF_MAX_PORTS; phy_no++) {
+
+        for (queue_no = 0; queue_no < 8; queue_no++) {
+
+            sf_writel((queue_no + ((phy_no << 8) & 0xf00)),REG_TMU_PHY_QUEUE_SEL_ADDR);
+
+            sf_writel(0,REG_TMU_CURQ_PTR_ADDR);
+            sf_writel(0,REG_TMU_CURQ_PKT_CNT_ADDR);
+            sf_writel(0,REG_TMU_CURQ_DROP_CNT_ADDR);
+            sf_writel(0,REG_TMU_CURQ_TRANS_CNT_ADDR);
+            sf_writel(0,REG_TMU_CURQ_QSTAT_ADDR);
+            sf_writel(0,REG_TMU_HW_PROB_CFG_TBL0_ADDR);
+            sf_writel(0,REG_TMU_HW_PROB_CFG_TBL1_ADDR);
+            sf_writel(0,REG_TMU_CURQ_DEBUG_ADDR);
+        }
+    }
+    sf_writel(0,REG_TMU_CNTX_ACCESS_CTRL);
+}
+
+int sf_init_switch_hw(void) {
+	load_hwreg_table(&sw_hwreg_data[0]);
+	mac_hash_table_init();
+	vlan_hash_table_init();
+	tmu_queue_init();
+#ifdef CONFIG_SFAX8_SWITCH_AGEING
+	sf_switch_init_timer(1);
+#endif
+	return 0;
+}
+
+
+void sf_switch_age_timer_handler(unsigned long data)
+{
+	host_ageing();
+	/* Update the refresh timer to call this fucntion again */
+	sf_switch_age_timer.expires = jiffies + SF_SWITCH_INTERVAL;
+	add_timer(&sf_switch_age_timer);
+}
+
+
+int sf_switch_init_timer(int init)
+{
+
+	int ret = 0;
+	if (!init)
+	  goto delbr_timer;
+
+	/*Start FP table refresh timer for Bridge*/
+	init_timer(&sf_switch_age_timer);
+	sf_switch_age_timer.expires  = jiffies + SF_SWITCH_INTERVAL;
+	sf_switch_age_timer.data     = (unsigned long) &sf_switch_age_timer;
+	sf_switch_age_timer.function = sf_switch_age_timer_handler;
+	add_timer((struct timer_list *)&sf_switch_age_timer);
+	return 0;
+
+delbr_timer:
+	del_timer((struct timer_list *)&sf_switch_age_timer);
+	return ret;
+}
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_switch_init.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_switch_init.h	2017-11-21 20:13:12.438710526 +0800
@@ -0,0 +1,39 @@
+#ifndef SF_SWITCH_INIT_H
+#define SF_SWITCH_INIT_H
+
+
+#define PORT_TPID_START_POS                  0
+#define PORT_FALLBACK_BDID_START_POS         16
+#define PORT_SHUTDOWN_START_POS              0
+#define PORT_AFT_START_POS                   4
+#define PORT_BLOCKSTATE_START_POS            8
+#define PORT_DEF_CFI_START_POS               12
+#define PORT_DEF_PRI_START_POS               13
+#define PORT_DEF_TC_START_POS                16
+#define PORT_TRUSTED_START_POS               19
+#define PORT_VID_PREFIX_START_POS            20
+#define PORT_UNTAG_FROM_BTABLE_START_POS     21
+
+#define PORT_TPID_MASK                       0x0000FFFF
+#define PORT_FALLBACK_BDID_MASK              0x1FFF0000
+#define PORT_SHUTDOWN_MASK                   0x00000001
+#define PORT_AFT_MASK                        0x000000F0
+#define PORT_BLOCKSTATE_MASK                 0x00000F00
+#define PORT_DEF_CFI_MASK                    0x00001000
+#define PORT_DEF_PRI_MASK                    0x0000E000
+#define PORT_DEF_TC_MASK                     0x00070000
+#define PORT_TRUSTED_MASK                    0x00080000
+#define PORT_VID_PREFIX_MASK                 0x00100000
+#define PORT_UNTAG_FROM_BTABLE_MASK          0x00200000
+
+#define DEF_PORT_FALLBACK_BD_ID    0x1        /* iports fallback bd id */
+
+void sf_local_reset(void);
+int sf_init_switch_hw(void);
+int sf_switch_init_timer(int init);
+void sys_npu_reset(void);
+
+int sf_port_init(void *pswitch);
+int get_port_address(int port_num, int index);
+
+#endif /* ifndef SF_SWITCH_INIT_H */
Index: linux-3.18.29/drivers/net/ethernet/siflower/sgmac.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sgmac.c	2017-11-15 17:26:54.357090000 +0800
@@ -0,0 +1,2844 @@
+#include "sgmac.h"
+#include <linux/circ_buf.h>
+#include <linux/crc32.h>
+#include <linux/dma-mapping.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/if.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/ptp_clock_kernel.h>
+#include <linux/reset.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <net/vxlan.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <sf16a18.h>
+
+struct sgmac_dma_desc {
+	__le32 flags;		// desc0
+	__le32 buf_size;	// desc1
+	__le32 buf1_addr;	// desc2	/* Buffer 1 Address Pointer */
+	__le32 buf2_addr;	// desc3	/* Buffer 2 Address Pointer */
+	__le32 ext_status;	// desc4
+	__le32 res;		// desc5
+	__le32 timestamp_low;	// desc6
+	__le32 timestamp_high;	// desc7
+};
+
+struct sgmac_extra_stats {
+	/* Transmit errors */
+	unsigned long tx_jabber;
+	unsigned long tx_frame_flushed;
+	unsigned long tx_payload_error;
+	unsigned long tx_ip_header_error;
+	unsigned long tx_local_fault;
+	unsigned long tx_remote_fault;
+	/* Receive errors */
+	unsigned long rx_watchdog;
+	unsigned long rx_da_filter_fail;
+	unsigned long rx_payload_error;
+	unsigned long rx_ip_header_error;
+	/* Tx/Rx IRQ errors */
+	unsigned long tx_process_stopped;
+	unsigned long rx_buf_unav;
+	unsigned long rx_process_stopped;
+	unsigned long tx_early;
+	unsigned long fatal_bus_error;
+};
+
+struct sgmac_priv {
+	struct sgmac_dma_desc *dma_rx; // the whole list of rx desc
+	struct sk_buff **rx_skbuff;    // the whole list of rx buf
+	unsigned int rx_tail;	  // next rx desc owned by dma
+	unsigned int rx_head;	  // next rx desc owned by driver
+
+	struct sgmac_dma_desc *dma_tx; // the whole list of tx desc
+	struct sk_buff **tx_skbuff;    // the whole list of tx buf
+	unsigned int tx_head;	  // next tx desc owned by dma
+	unsigned int tx_tail;	  // next tx desc owned by driver
+	int tx_irq_cnt; // when we xmit 32 frames, we will set tx irq
+
+	void __iomem *base;
+	unsigned int dma_buf_sz;
+	dma_addr_t dma_rx_phy; // first rx desc address
+	dma_addr_t dma_tx_phy; // first tx desc address
+
+	struct clk *eth_byp_ref_clk;
+	struct clk *eth_tsu_clk;
+	struct net_device *ndev;
+	struct device *dev;
+	struct napi_struct napi;
+
+	unsigned long vids[BITS_TO_LONGS(
+			VLAN_N_VID)]; // set bit of VLAN_N_VID to save vids
+	u16 vids_num;
+
+	int max_macs; // the number of mac address filter registers we have
+	struct sgmac_extra_stats xstats;
+
+	spinlock_t stats_lock;
+	char rx_pause; // Flag to enable rx of pause frames
+	char tx_pause; // Flag to enable tx of pause frames
+	int wolopts;
+	struct work_struct tx_timeout_work;
+
+	int hwts_tx_en;
+	int hwts_rx_en;
+	struct ptp_clock *ptp_clock;
+	struct ptp_clock_info ptp_clock_ops;
+	spinlock_t ptp_lock;
+
+	int link;   // PHY's last seen link state, 0 is no link and 1 is link.
+	int speed;  // PHY's last set duplex mode.
+	int duplex; // PHY's last set speed.
+	struct phy_device *phydev; // Pointer to attached PHY device.
+	struct mii_bus *bus;       // Pointer to the current MII bus.
+	struct device_node *phy_node;
+
+#ifdef CONFIG_SFAX8_RGMII_GMAC
+	int gpio51;
+	int gpio52;
+#endif
+};
+
+/* GMAC Configuration Settings */
+#define MAX_MTU 9000
+// austin: PAUSE_TIME is 0xffff by default
+#define PAUSE_TIME 0x400
+
+#define DMA_RX_RING_SZ 64
+#define DMA_TX_RING_SZ 64
+/* minimum number of free TX descriptors required to wake up TX process */
+#define TX_THRESH (DMA_TX_RING_SZ / 4)
+
+/* DMA descriptor ring helpers */
+// if n < (s - 1), x++; if n = s - 1, n = 0
+#define dma_ring_incr(n, s) (((n) + 1) & ((s)-1))
+// Measure the non-wrapping occupancy of a buffer:
+// This returns the number of consecutive items[2] that can be extracted from
+// the buffer without having to wrap back to the beginning of the buffer.
+// if h < t, dma_ring_space(h, t, s) = t - h - 1;
+// if h >= t, dma_ring_space(h, t, s) = s + t - h - 1;
+#define dma_ring_space(h, t, s) CIRC_SPACE(h, t, s)
+// Measure the occupancy of a buffer:
+// This returns the number of items currently occupying a buffer[2].
+// if h < t , dma_ring_cnt(h, t, s) = s + h -t
+// if h >= t, dma_ring_cnt(h, t, s) = h - t;
+#define dma_ring_cnt(h, t, s) CIRC_CNT(h, t, s)
+
+#define tx_dma_ring_space(p)                                                   \
+	dma_ring_space((p)->tx_head, (p)->tx_tail, DMA_TX_RING_SZ)
+
+/* GMAC Descriptor Access Helpers */
+static inline void desc_set_buf_len(struct sgmac_dma_desc *p, u32 buf_sz)
+{
+	if (buf_sz > MAX_DESC_BUF_SZ)
+		p->buf_size = cpu_to_le32(
+				MAX_DESC_BUF_SZ |
+				(buf_sz - MAX_DESC_BUF_SZ)
+						<< DESC_BUFFER2_SZ_OFFSET);
+	else
+		p->buf_size = cpu_to_le32(buf_sz);
+}
+
+static inline int desc_get_buf_len(struct sgmac_dma_desc *p)
+{
+	u32 len = le32_to_cpu(p->buf_size);
+	return (len & DESC_BUFFER1_SZ_MASK) +
+	       ((len & DESC_BUFFER2_SZ_MASK) >> DESC_BUFFER2_SZ_OFFSET);
+}
+
+static inline void
+desc_init_rx_desc(struct sgmac_dma_desc *p, int ring_size, int buf_sz)
+{
+	struct sgmac_dma_desc *end = p + ring_size - 1;
+
+	memset(p, 0, sizeof(*p) * ring_size);
+
+	for (; p <= end; p++)
+		desc_set_buf_len(p, buf_sz);
+
+	end->buf_size |= cpu_to_le32(RXDESC1_END_RING);
+}
+
+static inline void desc_init_tx_desc(struct sgmac_dma_desc *p, u32 ring_size)
+{
+	memset(p, 0, sizeof(*p) * ring_size);
+	p[ring_size - 1].flags = cpu_to_le32(TXDESC_END_RING);
+}
+
+static inline int desc_get_owner(struct sgmac_dma_desc *p)
+{
+	return le32_to_cpu(p->flags) & DESC_OWN;
+}
+
+static inline void desc_set_rx_owner(struct sgmac_dma_desc *p)
+{
+	/* Clear all fields and set the owner */
+	p->flags = cpu_to_le32(DESC_OWN);
+}
+
+static inline void desc_set_tx_owner(struct sgmac_dma_desc *p, u32 flags)
+{
+	u32 tmpflags = le32_to_cpu(p->flags);
+	tmpflags &= TXDESC_END_RING;
+	tmpflags |= flags | DESC_OWN;
+	p->flags = cpu_to_le32(tmpflags);
+}
+
+static inline void desc_clear_tx_owner(struct sgmac_dma_desc *p)
+{
+	u32 tmpflags = le32_to_cpu(p->flags);
+	tmpflags &= TXDESC_END_RING;
+	p->flags = cpu_to_le32(tmpflags);
+}
+
+static inline int desc_get_tx_ls(struct sgmac_dma_desc *p)
+{
+	return le32_to_cpu(p->flags) & TXDESC_LAST_SEG;
+}
+
+static inline int desc_get_tx_fs(struct sgmac_dma_desc *p)
+{
+	return le32_to_cpu(p->flags) & TXDESC_FIRST_SEG;
+}
+
+static inline u32 desc_get_buf_addr(struct sgmac_dma_desc *p)
+{
+	return le32_to_cpu(p->buf1_addr);
+}
+
+static inline void
+desc_set_buf_addr(struct sgmac_dma_desc *p, u32 paddr, int len)
+{
+	p->buf1_addr = cpu_to_le32(paddr);
+	if (len > MAX_DESC_BUF_SZ)
+		p->buf2_addr = cpu_to_le32(paddr + MAX_DESC_BUF_SZ);
+}
+
+static inline void
+desc_set_buf_addr_and_size(struct sgmac_dma_desc *p, u32 paddr, int len)
+{
+	desc_set_buf_len(p, len);
+	desc_set_buf_addr(p, paddr, len);
+}
+
+static inline int desc_get_rx_frame_len(struct sgmac_dma_desc *p)
+{
+	u32 data, len;
+	data = le32_to_cpu(p->flags);
+	len = (data & RXDESC_FRAME_LEN_MASK) >> RXDESC_FRAME_LEN_OFFSET;
+	//	if (data & RXDESC_FRAME_TYPE)
+	//		len -= ETH_FCS_LEN;
+
+	return len;
+}
+
+static inline u32 desc_get_tx_timestamp_status(struct sgmac_dma_desc *p)
+{
+	return le32_to_cpu(p->flags) & TXDESC_TX_TS_STATUS;
+}
+
+static inline u32 desc_get_rx_timestamp_status(struct sgmac_dma_desc *p)
+{
+	u64 ns;
+	ns = p->timestamp_low;
+	ns += p->timestamp_high * 1000000000ULL;
+	return ns;
+}
+
+static inline u32 desc_get_timestamp(struct sgmac_dma_desc *p)
+{
+	return le32_to_cpu(p->flags) & TXDESC_TX_TS_STATUS;
+}
+
+static void sgmac_dma_flush_tx_fifo(struct sgmac_priv *priv)
+{
+	int timeout = 1000;
+	u32 reg = readl(priv->base + GMAC_DMA_OPERATION);
+	writel(reg | DMA_OPERATION_FTF, priv->base + GMAC_DMA_OPERATION);
+
+	while ((timeout-- > 0) &&
+			readl(priv->base + GMAC_DMA_OPERATION) & DMA_OPERATION_FTF)
+		udelay(1);
+}
+
+static int desc_get_tx_status(struct sgmac_priv *priv, struct sgmac_dma_desc *p)
+{
+	struct sgmac_extra_stats *x = &priv->xstats;
+	u32 status = le32_to_cpu(p->flags);
+
+	if (!(status & TXDESC_ERROR_SUMMARY))
+		return 0;
+
+	netdev_dbg(priv->ndev, "tx desc error = 0x%08x\n", status);
+	if (status & TXDESC_JABBER_TIMEOUT)
+		x->tx_jabber++;
+	if (status & TXDESC_FRAME_FLUSHED)
+		x->tx_frame_flushed++;
+	if (status & TXDESC_UNDERFLOW_ERR)
+		sgmac_dma_flush_tx_fifo(priv);
+	if (status & TXDESC_IP_HEADER_ERR)
+		x->tx_ip_header_error++;
+	// austin:we don't have these bit
+	//	if (status & TXDESC_LOCAL_FAULT)
+	//		x->tx_local_fault++;
+	//	if (status & TXDESC_REMOTE_FAULT)
+	//		x->tx_remote_fault++;
+	if (status & TXDESC_PAYLOAD_CSUM_ERR)
+		x->tx_payload_error++;
+
+	return -1;
+}
+
+static int desc_get_rx_status(struct sgmac_priv *priv, struct sgmac_dma_desc *p)
+{
+	struct sgmac_extra_stats *x = &priv->xstats;
+	int ret = CHECKSUM_UNNECESSARY;
+	u32 status = le32_to_cpu(p->flags);
+	u32 ext_status = le32_to_cpu(p->ext_status);
+
+	if (status & RXDESC_DA_FILTER_FAIL) {
+		netdev_dbg(priv->ndev, "GMAC RX : Dest Address filter fail\n");
+		x->rx_da_filter_fail++;
+		return -1;
+	}
+
+	/* All frames should fit into a single buffer */
+	if (!(status & RXDESC_FIRST_SEG) || !(status & RXDESC_LAST_SEG))
+		return -1;
+
+	/* Check if packet has checksum already */
+	if ((status & RXDESC_FRAME_TYPE) && (status & RXDESC_EXT_STATUS) &&
+			!(ext_status & RXDESC_IP_PAYLOAD_MASK))
+		ret = CHECKSUM_NONE;
+
+	netdev_dbg(priv->ndev,
+			"rx status - frame type=%d, csum = %d, ext stat %08x\n",
+			(status & RXDESC_FRAME_TYPE) ? 1 : 0, ret, ext_status);
+
+	if (!(status & RXDESC_ERROR_SUMMARY))
+		return ret;
+
+	/* Handle any errors */
+	if (status & (RXDESC_DESCRIPTOR_ERR | RXDESC_OVERFLOW_ERR |
+				     RXDESC_CHECKSUM_ERR | RXDESC_LENGTH_ERR |
+				     RXDESC_CRC_ERR))
+		return -1;
+
+	if (status & RXDESC_EXT_STATUS) {
+		if (ext_status & RXDESC_IP_HEADER_ERR)
+			x->rx_ip_header_error++;
+		if (ext_status & RXDESC_IP_PAYLOAD_ERR)
+			x->rx_payload_error++;
+		netdev_dbg(priv->ndev, "IP checksum error - stat %08x\n",
+				ext_status);
+		return CHECKSUM_NONE;
+	}
+
+	return ret;
+}
+
+static inline void sgmac_mac_enable(struct sgmac_priv *priv)
+{
+	u32 value = readl(priv->base + GMAC_CONTROL);
+	value |= GMAC_CONTROL_RE | GMAC_CONTROL_TE;
+	writel(value, priv->base + GMAC_CONTROL);
+
+	value = readl(priv->base + GMAC_DMA_OPERATION);
+	value |= DMA_OPERATION_ST | DMA_OPERATION_SR;
+	writel(value, priv->base + GMAC_DMA_OPERATION);
+}
+
+static inline void sgmac_mac_disable(struct sgmac_priv *priv)
+{
+	u32 value = readl(priv->base + GMAC_DMA_OPERATION);
+	value &= ~(DMA_OPERATION_ST | DMA_OPERATION_SR);
+	writel(value, priv->base + GMAC_DMA_OPERATION);
+
+	value = readl(priv->base + GMAC_CONTROL);
+	value &= ~(GMAC_CONTROL_TE | GMAC_CONTROL_RE);
+	writel(value, priv->base + GMAC_CONTROL);
+}
+
+static void
+sgmac_set_mac_addr(struct sgmac_priv *priv, unsigned char *addr, int num)
+{
+	u32 data;
+	if (addr) {
+		data = (addr[5] << 8) | addr[4] | (num ? GMAC_ADDR_AE : 0);
+		writel(data, priv->base + GMAC_ADDR_HIGH(num));
+		data = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) |
+		       addr[0];
+		writel(data, priv->base + GMAC_ADDR_LOW(num));
+	} else {
+		writel(0, priv->base + GMAC_ADDR_HIGH(num));
+		writel(0, priv->base + GMAC_ADDR_LOW(num));
+	}
+}
+
+static void
+sgmac_get_mac_addr(struct sgmac_priv *priv, unsigned char *addr, int num)
+{
+	u32 hi_addr, lo_addr;
+
+	/* Read the MAC address from the hardware */
+	hi_addr = readl(priv->base + GMAC_ADDR_HIGH(num));
+	lo_addr = readl(priv->base + GMAC_ADDR_LOW(num));
+
+	/* Extract the MAC address from the high and low words */
+	addr[0] = lo_addr & 0x00;
+	addr[1] = (lo_addr >> 8) & 0x11;
+	addr[2] = (lo_addr >> 16) & 0x33;
+	addr[3] = (lo_addr >> 24) & 0x44;
+	addr[4] = hi_addr & 0x55;
+	addr[5] = (hi_addr >> 8) & 0x66;
+}
+
+static void sgmac_set_mdc_clk_div(struct sgmac_priv *priv)
+{
+	int value = readl(priv->base + GMAC_GMII_ADDR);
+	value &= ~GMAC_GMII_ADDR_CR_MASK;
+	value |= GMAC_GMII_ADDR_CR;
+	writel(value, priv->base + GMAC_GMII_ADDR);
+}
+
+/**
+ * sgmac_mdio_remove - MDIO remove function.
+ * @priv:	Pointer to ARC EMAC private data structure.
+ *
+ * Unregisters the MDIO and frees any associate memory for MII bus.
+ */
+static int sgmac_mdio_remove(struct sgmac_priv *priv)
+{
+	mdiobus_unregister(priv->bus);
+	mdiobus_free(priv->bus);
+	priv->bus = NULL;
+	return 0;
+}
+
+static int sgmac_phy_wait_rw_not_busy(struct sgmac_priv *priv)
+{
+	int value = readl(priv->base + GMAC_GMII_ADDR);
+	int i = 0;
+	// austin:we should add timeout here.
+	while ((value & GMAC_GMII_ADDR_GB) && (i < 100000)) {
+		value = readl(priv->base + GMAC_GMII_ADDR);
+		i++;
+	}
+	return value;
+}
+
+static int sgmac_phy_read(struct mii_bus *bus, int phy_addr, int phy_reg)
+{
+	struct sgmac_priv *priv = bus->priv;
+	int addr_value;
+	int read_value = 0;
+	addr_value = sgmac_phy_wait_rw_not_busy(priv);
+	// clear the data first
+	writel(0xffffffff, priv->base + GMAC_GMII_DATA);
+	// set address flag
+	addr_value = (addr_value & (~GMAC_GMII_ADDR_GR)) |
+		     ((phy_reg << 6) & GMAC_GMII_ADDR_GR);
+	// set phy addr
+	addr_value = (addr_value & (~GMAC_GMII_ADDR_PA)) |
+		     ((phy_addr << 11) & GMAC_GMII_ADDR_PA);
+	// set read flag
+	addr_value &= ~GMAC_GMII_ADDR_GW;
+	// set GB flag to indica is busy now
+	addr_value |= GMAC_GMII_ADDR_GB;
+	writel(addr_value, priv->base + GMAC_GMII_ADDR);
+	// wait for complete
+	sgmac_phy_wait_rw_not_busy(priv);
+	read_value = (readl(priv->base + GMAC_GMII_DATA) & GMAC_GMII_DATA_GD);
+	return (readl(priv->base + GMAC_GMII_DATA) & GMAC_GMII_DATA_GD);
+}
+
+static int
+sgmac_phy_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 data_value)
+{
+	struct sgmac_priv *priv = bus->priv;
+	int addr_value;
+	addr_value = sgmac_phy_wait_rw_not_busy(priv);
+	// clear the data first
+	writel(data_value & GMAC_GMII_DATA_GD, priv->base + GMAC_GMII_DATA);
+	// set address flag
+	addr_value = (addr_value & (~GMAC_GMII_ADDR_GR)) |
+		     ((phy_reg << 6) & GMAC_GMII_ADDR_GR);
+	// set phy addr
+	addr_value = (addr_value & (~GMAC_GMII_ADDR_PA)) |
+		     ((phy_addr << 11) & GMAC_GMII_ADDR_PA);
+	// set write flag
+	addr_value |= GMAC_GMII_ADDR_GW;
+	// set GB flag to indica is busy now
+	addr_value |= GMAC_GMII_ADDR_GB;
+	writel(addr_value, priv->base + GMAC_GMII_ADDR);
+	// wait for complete
+	sgmac_phy_wait_rw_not_busy(priv);
+	return 0;
+}
+
+/**
+ * sgmac_adjust_link - Adjust the PHY link duplex.
+ * @ndev:	Pointer to the net_device structure.
+ *
+ * This function is called to change the speed and duplex setting of gmac
+ * after auto negotiation is done by the PHY.
+ */
+static void sgmac_adjust_link(struct net_device *ndev)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	struct phy_device *phydev = priv->phydev;
+	unsigned int reg, state_changed = 0;
+
+	if (priv->link != phydev->link) {
+		priv->link = phydev->link;
+		state_changed = 1;
+	}
+
+	reg = readl(priv->base + GMAC_CONTROL);
+	if (priv->speed != phydev->speed) {
+		priv->speed = phydev->speed;
+		state_changed = 1;
+		reg &= ~GMAC_CONTROL_SPD_MASK;
+		if (priv->speed == SPEED_10)
+			reg |= GMAC_SPEED_10M;
+		else if (priv->speed == SPEED_100)
+			reg |= GMAC_SPEED_100M;
+		else if (priv->speed == SPEED_1000)
+			reg |= GMAC_SPEED_1000M;
+	}
+	if (priv->duplex != phydev->duplex) {
+
+		if (DUPLEX_FULL == phydev->duplex)
+			reg |= GMAC_CONTROL_DM;
+		else
+			reg &= ~GMAC_CONTROL_DM;
+
+		priv->duplex = phydev->duplex;
+		state_changed = 1;
+	}
+	writel(reg, priv->base + GMAC_CONTROL);
+
+	if (state_changed)
+		phy_print_status(phydev);
+}
+
+/**
+ * sgmac_mdio_probe - MDIO probe function.
+ * @priv:	Pointer to ARC EMAC private data structure.
+ *
+ * returns:	0 on success, -ENOMEM when mdiobus_alloc
+ * (to allocate memory for MII bus structure) fails.
+ *
+ * Sets up and registers the MDIO interface.
+ */
+static int sgmac_mdio_probe(struct sgmac_priv *priv)
+{
+	struct mii_bus *bus;
+	int error;
+
+	bus = mdiobus_alloc();
+	if (!bus)
+		return -ENOMEM;
+
+	priv->bus = bus;
+	bus->priv = priv;
+	bus->parent = priv->dev;
+	bus->name = "Synopsys MII Bus",
+	bus->read = &sgmac_phy_read;
+	bus->write = &sgmac_phy_write;
+
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%s", bus->name);
+
+	error = of_mdiobus_register(bus, priv->dev->of_node);
+	if (error) {
+		netdev_err(priv->ndev, "cannot register MDIO bus %s\n", bus->name);
+		mdiobus_free(bus);
+		return -error;
+	}
+
+	return 0;
+}
+
+static int sgmac_ptp_init_systime(struct sgmac_priv *priv, u32 sec, u32 nsec)
+{
+	int limit;
+	u32 value;
+
+	writel(sec, priv->base + GMAC_TS_HIGH_UPDATE);
+	writel(nsec, priv->base + GMAC_TS_LOW_UPDATE);
+	/* issue command to initialize the system time value */
+	value = readl(priv->base + GMAC_TS_CONTROL);
+	value |= GMAC_TS_CONTROL_TSINIT;
+	writel(value, priv->base + GMAC_TS_CONTROL);
+
+	/* wait for present system time initialize to complete */
+	limit = 10;
+	while (limit--) {
+		if (!(readl(priv->base + GMAC_TS_CONTROL) &
+				    GMAC_TS_CONTROL_TSINIT))
+			break;
+		mdelay(10);
+	}
+	if (limit < 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int sgmac_ptp_config_addend(struct sgmac_priv *priv, u32 addend)
+{
+	u32 value;
+	int limit;
+
+	writel(addend, priv->base + GMAC_TS_ADDEND);
+	/* issue command to update the addend value */
+	value = readl(priv->base + GMAC_TS_CONTROL);
+	value |= GMAC_TS_CONTROL_TSADDREG;
+	writel(value, priv->base + GMAC_TS_CONTROL);
+
+	/* wait for present addend update to complete */
+	limit = 10;
+	while (limit--) {
+		if (!(readl(priv->base + GMAC_TS_CONTROL) &
+				    GMAC_TS_CONTROL_TSADDREG))
+			break;
+		mdelay(10);
+	}
+	if (limit < 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int sgmac_ptp_adjust_systime(struct sgmac_priv *priv,
+			u32 sec, u32 nsec, int add_sub)
+{
+	u32 value;
+	int limit;
+
+	writel(sec, priv->base + GMAC_TS_HIGH_UPDATE);
+	writel(((add_sub << 31) | nsec), priv->base + GMAC_TS_LOW_UPDATE);
+	/* issue command to initialize the system time value */
+	value = readl(priv->base + GMAC_TS_CONTROL);
+	value |= GMAC_TS_STATUS_TSTRGTERR;
+	writel(value, priv->base + GMAC_TS_CONTROL);
+
+	/* wait for present system time adjust/update to complete */
+	limit = 10;
+	while (limit--) {
+		if (!(readl(priv->base + GMAC_TS_CONTROL) &
+				    GMAC_TS_STATUS_TSTRGTERR))
+			break;
+		mdelay(10);
+	}
+	if (limit < 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+static u64 sgmac_ptp_get_systime(struct sgmac_priv *priv)
+{
+	u64 ns;
+
+	ns = readl(priv->base + GMAC_TS_LOW);
+	/* convert sec time value to nanosecond */
+	ns += readl(priv->base + GMAC_TS_HIGH) * 1000000000ULL;
+
+	return ns;
+}
+
+/**
+ * sgmac_adjust_freq
+ *
+ * @ptp: pointer to ptp_clock_info structure
+ * @ppb: desired period change in parts ber billion
+ *
+ * Description: this function will adjust the frequency of hardware clock.
+ */
+// austin: I have to reference other codes.
+static int sgmac_ptp_adjust_freq(struct ptp_clock_info *ptp, s32 ppb)
+{
+	struct sgmac_priv *priv =
+			container_of(ptp, struct sgmac_priv, ptp_clock_ops);
+	unsigned long flags;
+	u32 diff, addend;
+	int neg_adj = 0;
+	u64 adj;
+
+	if (ppb < 0) {
+		neg_adj = 1;
+		ppb = -ppb;
+	}
+
+	addend = 50000000ULL;
+	//	addend = priv->default_addend;
+	adj = addend;
+	adj *= ppb;
+	diff = div_u64(adj, 1000000000ULL);
+	addend = neg_adj ? (addend - diff) : (addend + diff);
+
+	spin_lock_irqsave(&priv->ptp_lock, flags);
+
+	sgmac_ptp_config_addend(priv, addend);
+	//	priv->hw->ptp->config_addend(priv->base, addend);
+
+	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+
+	return 0;
+}
+
+/**
+ * sgmac_adjust_time
+ *
+ * @ptp: pointer to ptp_clock_info structure
+ * @delta: desired change in nanoseconds
+ *
+ * Description: this function will shift/adjust the hardware clock time.
+ */
+static int sgmac_ptp_adjust_time(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct sgmac_priv *priv =
+			container_of(ptp, struct sgmac_priv, ptp_clock_ops);
+	unsigned long flags;
+	u32 sec, nsec;
+	u32 quotient, reminder;
+	int neg_adj = 0;
+
+	if (delta < 0) {
+		neg_adj = 1;
+		delta = -delta;
+	}
+
+	quotient = div_u64_rem(delta, 1000000000ULL, &reminder);
+	sec = quotient;
+	nsec = reminder;
+
+	spin_lock_irqsave(&priv->ptp_lock, flags);
+
+	sgmac_ptp_adjust_systime(priv, sec, nsec, neg_adj);
+	//	priv->hw->ptp->adjust_systime(priv->base, sec, nsec, neg_adj);
+
+	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+
+	return 0;
+}
+
+/**
+ * sgmac_get_time
+ *
+ * @ptp: pointer to ptp_clock_info structure
+ * @ts: pointer to hold time/result
+ *
+ * Description: this function will read the current time from the
+ * hardware clock and store it in @ts.
+ */
+static int sgmac_ptp_get_time(struct ptp_clock_info *ptp, struct timespec *ts)
+{
+	struct sgmac_priv *priv =
+			container_of(ptp, struct sgmac_priv, ptp_clock_ops);
+	unsigned long flags;
+	u64 ns;
+	u32 reminder;
+
+	spin_lock_irqsave(&priv->ptp_lock, flags);
+
+	ns = sgmac_ptp_get_systime(priv);
+	//	ns = priv->hw->ptp->get_systime(priv->base);
+
+	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+
+	ts->tv_sec = div_u64_rem(ns, 1000000000ULL, &reminder);
+	ts->tv_nsec = reminder;
+
+	return 0;
+}
+
+/**
+ * sgmac_set_time
+ *
+ * @ptp: pointer to ptp_clock_info structure
+ * @ts: time value to set
+ *
+ * Description: this function will set the current time on the
+ * hardware clock.
+ */
+static int sgmac_ptp_set_time(struct ptp_clock_info *ptp,
+		const struct timespec *ts)
+{
+	struct sgmac_priv *priv =
+			container_of(ptp, struct sgmac_priv, ptp_clock_ops);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->ptp_lock, flags);
+
+	sgmac_ptp_init_systime(priv, ts->tv_sec, ts->tv_nsec);
+	//	priv->hw->ptp->init_systime(priv->base, ts->tv_sec,
+	// ts->tv_nsec);
+
+	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+
+	return 0;
+}
+
+static int sgmac_ptp_enable(struct ptp_clock_info *ptp,
+		struct ptp_clock_request *rq,
+		int on)
+{
+	return -EOPNOTSUPP;
+}
+
+/* structure describing a PTP hardware clock */
+static struct ptp_clock_info sgmac_ptp_clock_ops = {
+	.owner = THIS_MODULE,
+	.name = "sgmac_ptp_clock",
+	.max_adj = 50000000,
+	.n_alarm = 0,
+	.n_ext_ts = 1,
+	.n_per_out = 0,
+	.n_pins = 0,
+	.pps = 0,
+	.adjfreq = sgmac_ptp_adjust_freq,
+	.adjtime = sgmac_ptp_adjust_time,
+	.gettime = sgmac_ptp_get_time,
+	.settime = sgmac_ptp_set_time,
+	.enable = sgmac_ptp_enable,
+};
+
+/**
+ * sgmac_ptp_register
+ * @priv: driver private structure
+ * Description: this function will register the ptp clock driver
+ * to kernel. It also does some house keeping work.
+ */
+int sgmac_ptp_register(struct sgmac_priv *priv)
+{
+	spin_lock_init(&priv->ptp_lock);
+	priv->ptp_clock_ops = sgmac_ptp_clock_ops;
+	priv->hwts_tx_en = 0;
+	priv->hwts_rx_en = 0;
+
+	priv->ptp_clock = ptp_clock_register(&priv->ptp_clock_ops, priv->dev);
+	if (IS_ERR(priv->ptp_clock)) {
+		priv->ptp_clock = NULL;
+		pr_err("ptp_clock_register() failed on %s\n", priv->ndev->name);
+		return -EINVAL;
+	} else {
+		pr_debug("Added PTP HW clock successfully on %s\n",
+				priv->ndev->name);
+		printk("Added PTP HW clock successfully\n");
+	}
+	return 0;
+}
+
+/**
+ * sgmac_ptp_unregister
+ * @priv: driver private structure
+ * Description: this function will remove/unregister the ptp clock driver
+ * from the kernel.
+ */
+void sgmac_ptp_unregister(struct sgmac_priv *priv)
+{
+	if (priv->ptp_clock) {
+		ptp_clock_unregister(priv->ptp_clock);
+		priv->ptp_clock = NULL;
+		pr_debug("Removed PTP HW clock successfully on %s\n",
+				priv->ndev->name);
+	}
+}
+
+/* sgmac_ptp_get_tx_hwtstamp: get HW TX timestamps
+ * @priv: driver private structure
+ * @entry : descriptor index to be used.
+ * @skb : the socket buffer
+ * Description :
+ * This function will read timestamp from the descriptor & pass it to stac
+ * and also perform some sanity checks.
+ */
+static void sgmac_ptp_get_tx_hwtstamp(struct sgmac_priv *priv,
+		struct sgmac_dma_desc *desc,
+		struct sk_buff *skb)
+{
+	struct skb_shared_hwtstamps shhwtstamp;
+	u64 ns;
+
+	//	if (!priv->hwts_tx_en)
+	//		return;
+
+	/* exit if skb doesn't support hw tstamp */
+	//	if (likely(!skb || !(skb_shinfo(skb)->tx_flags &
+	// SKBTX_IN_PROGRESS)))
+	//		return;
+
+	//	if (priv->adv_ts)
+	//		desc = (priv->dma_etx + entry);
+	//	else
+	//		desc = (priv->dma_tx + entry);
+
+	/* check tx tstamp status */
+	if (!desc_get_tx_timestamp_status(desc))
+		return;
+
+	/* get the valid tstamp */
+	ns = desc_get_timestamp(desc);
+
+	memset(&shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
+	shhwtstamp.hwtstamp = ns_to_ktime(ns);
+	/* pass tstamp to stack */
+	skb_tstamp_tx(skb, &shhwtstamp);
+
+	return;
+}
+
+/* sgmac_ptp_get_rx_hwtstamp: get HW RX timestamps
+ * @priv: driver private structure
+ * @entry : descriptor index to be used.
+ * @skb : the socket buffer
+ * Description :
+ * This function will read received packet's timestamp from the descriptor
+ * and pass it to stack. It also perform some sanity checks.
+ */
+static void sgmac_ptp_get_rx_hwtstamp(struct sgmac_priv *priv,
+		struct sgmac_dma_desc *desc,
+		struct sk_buff *skb)
+{
+	struct skb_shared_hwtstamps *shhwtstamp = NULL;
+	u64 ns;
+
+	//	if (!priv->hwts_rx_en)
+	//		return;
+
+	//	if (priv->adv_ts)
+	//		desc = (priv->dma_erx + entry);
+	//	else
+	//		desc = (priv->dma_rx + entry);
+
+	/* exit if rx tstamp is not valid */
+	if (!desc_get_rx_timestamp_status(desc))
+		return;
+
+	/* get valid tstamp */
+	ns = desc_get_timestamp(desc);
+	shhwtstamp = skb_hwtstamps(skb);
+	memset(shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
+	shhwtstamp->hwtstamp = ns_to_ktime(ns);
+}
+
+/**
+ *  sgmac_hwtstamp_ioctl - control hardware timestamping.
+ *  @dev: device pointer.
+ *  @ifr: An IOCTL specefic structure, that can contain a pointer to
+ *  a proprietary structure used to pass information to the driver.
+ *  Description:
+ *  This function configures the MAC to enable/disable both outgoing(TX)
+ *  and incoming(RX) packets time stamping based on user input.
+ *  Return Value:
+ *  0 on success and an appropriate -ve integer on failure.
+ */
+static int sgmac_ptp_hwtstamp_ioctl(struct net_device *dev, struct ifreq *ifr)
+{
+	struct sgmac_priv *priv = netdev_priv(dev);
+	struct hwtstamp_config config;
+	struct timespec now;
+	u64 temp = 0;
+	u32 ptp_v2 = 0;
+	u32 tstamp_all = 0;
+	u32 ptp_over_ipv4_udp = 0;
+	u32 ptp_over_ipv6_udp = 0;
+	u32 ptp_over_ethernet = 0;
+	u32 snap_type_sel = 0;
+	u32 ts_master_en = 0;
+	u32 ts_event_en = 0;
+	u32 value = 0;
+	int ret;
+	/*
+	   if (!(priv->dma_cap.time_stamp || priv->adv_ts)) {
+	   netdev_alert(priv->dev, "No support for HW time stamping\n");
+	   priv->hwts_tx_en = 0;
+	   priv->hwts_rx_en = 0;
+
+	   return -EOPNOTSUPP;
+	   }
+	   */
+	if (copy_from_user(&config, ifr->ifr_data,
+			    sizeof(struct hwtstamp_config)))
+		return -EFAULT;
+
+	pr_debug("%s config flags:0x%x, tx_type:0x%x, rx_filter:0x%x\n",
+			__func__, config.flags, config.tx_type,
+			config.rx_filter);
+
+	/* reserved for future extensions */
+	if (config.flags)
+		return -EINVAL;
+
+	if (config.tx_type != HWTSTAMP_TX_OFF &&
+			config.tx_type != HWTSTAMP_TX_ON)
+		return -ERANGE;
+
+	//	if (priv->adv_ts) {
+	switch (config.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		/* time stamp no incoming packet at all */
+		config.rx_filter = HWTSTAMP_FILTER_NONE;
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+		/* PTP v1, UDP, any kind of event packet */
+		config.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;
+		/* take time stamp for all event messages */
+		snap_type_sel = GMAC_TS_CONTROL_BIT16;
+
+		ptp_over_ipv4_udp = GMAC_TS_CONTROL_TSIPV4ENA;
+		ptp_over_ipv6_udp = GMAC_TS_CONTROL_TSIPV6ENA;
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+		/* PTP v1, UDP, Sync packet */
+		config.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_SYNC;
+		/* take time stamp for SYNC messages only */
+		ts_event_en = GMAC_TS_CONTROL_TSEVNTENA;
+
+		ptp_over_ipv4_udp = GMAC_TS_CONTROL_TSIPV4ENA;
+		ptp_over_ipv6_udp = GMAC_TS_CONTROL_TSIPV6ENA;
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+		/* PTP v1, UDP, Delay_req packet */
+		config.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ;
+		/* take time stamp for Delay_Req messages only */
+		ts_master_en = GMAC_TS_CONTROL_TSMSTRENA;
+		ts_event_en = GMAC_TS_CONTROL_TSEVNTENA;
+
+		ptp_over_ipv4_udp = GMAC_TS_CONTROL_TSIPV4ENA;
+		ptp_over_ipv6_udp = GMAC_TS_CONTROL_TSIPV6ENA;
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+		/* PTP v2, UDP, any kind of event packet */
+		config.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;
+		ptp_v2 = GMAC_TS_CONTROL_TSVER2ENA;
+		/* take time stamp for all event messages */
+		snap_type_sel = GMAC_TS_CONTROL_BIT16;
+
+		ptp_over_ipv4_udp = GMAC_TS_CONTROL_TSIPV4ENA;
+		ptp_over_ipv6_udp = GMAC_TS_CONTROL_TSIPV6ENA;
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+		/* PTP v2, UDP, Sync packet */
+		config.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_SYNC;
+		ptp_v2 = GMAC_TS_CONTROL_TSVER2ENA;
+		/* take time stamp for SYNC messages only */
+		ts_event_en = GMAC_TS_CONTROL_TSEVNTENA;
+
+		ptp_over_ipv4_udp = GMAC_TS_CONTROL_TSIPV4ENA;
+		ptp_over_ipv6_udp = GMAC_TS_CONTROL_TSIPV6ENA;
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+		/* PTP v2, UDP, Delay_req packet */
+		config.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ;
+		ptp_v2 = GMAC_TS_CONTROL_TSVER2ENA;
+		/* take time stamp for Delay_Req messages only */
+		ts_master_en = GMAC_TS_CONTROL_TSMSTRENA;
+		ts_event_en = GMAC_TS_CONTROL_TSEVNTENA;
+
+		ptp_over_ipv4_udp = GMAC_TS_CONTROL_TSIPV4ENA;
+		ptp_over_ipv6_udp = GMAC_TS_CONTROL_TSIPV6ENA;
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+		/* PTP v2/802.AS1 any layer, any kind of event packet */
+		config.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;
+		ptp_v2 = GMAC_TS_CONTROL_TSVER2ENA;
+		/* take time stamp for all event messages */
+		snap_type_sel = GMAC_TS_CONTROL_BIT16;
+
+		ptp_over_ipv4_udp = GMAC_TS_CONTROL_TSIPV4ENA;
+		ptp_over_ipv6_udp = GMAC_TS_CONTROL_TSIPV6ENA;
+		ptp_over_ethernet = GMAC_TS_CONTROL_TSIPENA;
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+		/* PTP v2/802.AS1, any layer, Sync packet */
+		config.rx_filter = HWTSTAMP_FILTER_PTP_V2_SYNC;
+		ptp_v2 = GMAC_TS_CONTROL_TSVER2ENA;
+		/* take time stamp for SYNC messages only */
+		ts_event_en = GMAC_TS_CONTROL_TSEVNTENA;
+
+		ptp_over_ipv4_udp = GMAC_TS_CONTROL_TSIPV4ENA;
+		ptp_over_ipv6_udp = GMAC_TS_CONTROL_TSIPV6ENA;
+		ptp_over_ethernet = GMAC_TS_CONTROL_TSIPENA;
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		/* PTP v2/802.AS1, any layer, Delay_req packet */
+		config.rx_filter = HWTSTAMP_FILTER_PTP_V2_DELAY_REQ;
+		ptp_v2 = GMAC_TS_CONTROL_TSVER2ENA;
+		/* take time stamp for Delay_Req messages only */
+		ts_master_en = GMAC_TS_CONTROL_TSMSTRENA;
+		ts_event_en = GMAC_TS_CONTROL_TSEVNTENA;
+
+		ptp_over_ipv4_udp = GMAC_TS_CONTROL_TSIPV4ENA;
+		ptp_over_ipv6_udp = GMAC_TS_CONTROL_TSIPV6ENA;
+		ptp_over_ethernet = GMAC_TS_CONTROL_TSIPENA;
+		break;
+
+	case HWTSTAMP_FILTER_ALL:
+		/* time stamp any incoming packet */
+		config.rx_filter = HWTSTAMP_FILTER_ALL;
+		tstamp_all = GMAC_TS_CONTROL_TSENALL;
+		break;
+
+	default:
+		return -ERANGE;
+	}
+	priv->hwts_rx_en = ((config.rx_filter == HWTSTAMP_FILTER_NONE) ? 0 : 1);
+	priv->hwts_tx_en = config.tx_type == HWTSTAMP_TX_ON;
+
+	if (!priv->hwts_tx_en && !priv->hwts_rx_en)
+		writel(0, priv->base + GMAC_TS_CONTROL);
+	else {
+		value = (GMAC_TS_CONTROL_TSENA | GMAC_TS_CONTROL_TSCFUPDT |
+				GMAC_TS_CONTROL_TSCTRLSSR | tstamp_all |
+				ptp_v2 | ptp_over_ethernet | ptp_over_ipv6_udp |
+				ptp_over_ipv4_udp | ts_event_en | ts_master_en |
+				snap_type_sel);
+		writel(value, priv->base + GMAC_TS_CONTROL);
+		//		priv->hw->ptp->config_hw_tstamping(priv->ioaddr,
+		// value);
+
+		/* program Sub Second Increment reg */
+		// 1s / 50MHz = 20ns
+		value = (1000000000ULL / 50000000);
+		writel(value, priv->base + GMAC_TS_SUBSEC_INCR);
+		//		priv->hw->ptp->config_sub_second_increment(priv->ioaddr);
+
+		/* calculate default added value:
+		 * formula is :
+		 * addend = (2^32)/freq_div_ratio;
+		 * where, freq_div_ratio = clk_ptp_ref_i/50MHz
+		 * hence, addend = ((2^32) * 50MHz)/clk_ptp_ref_i;
+		 * NOTE: clk_ptp_ref_i should be >= 50MHz to
+		 *       achive 20ns accuracy.
+		 *
+		 * 2^x * y == (y << x), hence
+		 * 2^32 * 50000000 ==> (50000000 << 32)
+		 */
+		temp = (u64)(50000000ULL << 32);
+		value = 0;
+		sgmac_ptp_config_addend(priv, value);
+
+		//		priv->default_addend = div_u64(temp,
+		// priv->clk_ptp_rate);
+		//		priv->hw->ptp->config_addend(priv->ioaddr,
+		//				priv->default_addend);
+
+		/* initialize system time */
+		getnstimeofday(&now);
+		sgmac_ptp_init_systime(priv, now.tv_sec, now.tv_nsec);
+		//		priv->hw->ptp->init_systime(priv->ioaddr,
+		// now.tv_sec,
+		//				now.tv_nsec);
+	}
+
+	ret = copy_to_user(
+			ifr->ifr_data, &config, sizeof(struct hwtstamp_config));
+
+	return ret ? -EFAULT : 0;
+}
+
+/**
+ * sgmac_set_flow_ctrl:
+ * @priv: private driver structure
+ * @rx: enable rx flow ctrl or not
+ * @tx: enable tx flow ctrl or not
+ * Description: enable tx flow ctrl and rx flow ctrl
+ */
+static int sgmac_set_flow_ctrl(struct sgmac_priv *priv, int rx, int tx)
+{
+	u32 reg;
+	unsigned int flow = 0;
+
+	priv->rx_pause = rx;
+	priv->tx_pause = tx;
+
+	if (rx || tx) {
+		if (rx)
+			flow |= GMAC_FLOW_CTRL_RFE;
+		if (tx)
+			flow |= GMAC_FLOW_CTRL_TFE;
+
+		flow |= GMAC_FLOW_CTRL_PLT | GMAC_FLOW_CTRL_UP;
+		flow |= (PAUSE_TIME << GMAC_FLOW_CTRL_PT_SHIFT);
+
+		writel(flow, priv->base + GMAC_FLOW_CTRL);
+
+		reg = readl(priv->base + GMAC_DMA_OPERATION);
+		reg |= DMA_OPERATION_EFC;
+		writel(reg, priv->base + GMAC_DMA_OPERATION);
+	} else {
+		writel(0, priv->base + GMAC_FLOW_CTRL);
+
+		reg = readl(priv->base + GMAC_DMA_OPERATION);
+		reg &= ~DMA_OPERATION_EFC;
+		writel(reg, priv->base + GMAC_DMA_OPERATION);
+	}
+
+	return 0;
+}
+
+/**
+ * sgmac_rx_refill:
+ * @priv: private driver structure
+ * Description: it refills all the rx descs which are owned by driver
+ * with new sk_buf and sets these descs owned by dma.
+ */
+static void sgmac_rx_refill(struct sgmac_priv *priv)
+{
+	struct sgmac_dma_desc *p;
+	dma_addr_t paddr;
+	int bufsz = priv->ndev->mtu + ETH_HLEN + ETH_FCS_LEN;
+
+	while (dma_ring_space(priv->rx_head, priv->rx_tail, DMA_RX_RING_SZ) >
+			1) {
+		int entry = priv->rx_head;
+		struct sk_buff *skb;
+
+		p = priv->dma_rx + entry;
+
+		if (priv->rx_skbuff[entry] == NULL) {
+			skb = netdev_alloc_skb_ip_align(priv->ndev, bufsz);
+			if (unlikely(skb == NULL))
+				break;
+
+			paddr = dma_map_single(priv->dev, skb->data,
+					priv->dma_buf_sz - NET_IP_ALIGN,
+					DMA_FROM_DEVICE);
+			if (dma_mapping_error(priv->dev, paddr)) {
+				dev_kfree_skb_any(skb);
+				break;
+			}
+			priv->rx_skbuff[entry] = skb;
+			desc_set_buf_addr(p, paddr, priv->dma_buf_sz);
+		}
+
+		netdev_dbg(priv->ndev, "rx ring: head %d, tail %d\n",
+				priv->rx_head, priv->rx_tail);
+
+		priv->rx_head = dma_ring_incr(priv->rx_head, DMA_RX_RING_SZ);
+		desc_set_rx_owner(p);
+	}
+}
+
+/**
+ * init_sgmac_dma_desc_rings - init the RX/TX descriptor rings
+ * @dev: net device structure
+ * Description:  this function initializes the DMA RX/TX descriptors
+ * and allocates the socket buffers.
+ */
+static int sgmac_dma_desc_rings_init(struct net_device *ndev)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	unsigned int bfsize;
+
+	/* Set the Buffer size according to the MTU;
+	 * The total buffer size including any IP offset must be a multiple
+	 * of 8 bytes.
+	 */
+	bfsize = ALIGN(ndev->mtu + ETH_HLEN + ETH_FCS_LEN + NET_IP_ALIGN, 8);
+
+	netdev_dbg(priv->ndev, "mtu [%d] bfsize [%d]\n", ndev->mtu, bfsize);
+
+	priv->rx_skbuff = kzalloc(
+			sizeof(struct sk_buff *) * DMA_RX_RING_SZ, GFP_KERNEL);
+	if (!priv->rx_skbuff)
+		return -ENOMEM;
+	priv->dma_rx = dma_alloc_coherent(priv->dev,
+			DMA_RX_RING_SZ * sizeof(struct sgmac_dma_desc),
+			&priv->dma_rx_phy, GFP_KERNEL);
+	if (!priv->dma_rx)
+		goto err_dma_rx;
+
+	priv->tx_skbuff = kzalloc(
+			sizeof(struct sk_buff *) * DMA_TX_RING_SZ, GFP_KERNEL);
+	if (!priv->tx_skbuff)
+		goto err_tx_skb;
+	priv->dma_tx = dma_alloc_coherent(priv->dev,
+			DMA_TX_RING_SZ * sizeof(struct sgmac_dma_desc),
+			&priv->dma_tx_phy, GFP_KERNEL);
+	if (!priv->dma_tx)
+		goto err_dma_tx;
+
+	netdev_dbg(priv->ndev,
+			"DMA desc rings: virt addr (Rx %p, "
+			"Tx %p)\n\tDMA phy addr (Rx 0x%08x, Tx 0x%08x)\n",
+			priv->dma_rx, priv->dma_tx,
+			(unsigned int)priv->dma_rx_phy,
+			(unsigned int)priv->dma_tx_phy);
+
+	priv->rx_tail = 0;
+	priv->rx_head = 0;
+	priv->dma_buf_sz = bfsize;
+	desc_init_rx_desc(priv->dma_rx, DMA_RX_RING_SZ, priv->dma_buf_sz);
+	sgmac_rx_refill(priv);
+
+	priv->tx_tail = 0;
+	priv->tx_head = 0;
+	desc_init_tx_desc(priv->dma_tx, DMA_TX_RING_SZ);
+
+	writel(priv->dma_tx_phy, priv->base + GMAC_DMA_TX_BASE_ADDR);
+	writel(priv->dma_rx_phy, priv->base + GMAC_DMA_RX_BASE_ADDR);
+	return 0;
+
+err_dma_tx:
+	kfree(priv->tx_skbuff);
+err_tx_skb:
+	dma_free_coherent(priv->dev,
+			DMA_RX_RING_SZ * sizeof(struct sgmac_dma_desc),
+			priv->dma_rx, priv->dma_rx_phy);
+err_dma_rx:
+	kfree(priv->rx_skbuff);
+	return -ENOMEM;
+}
+
+static void sgmac_free_rx_skbufs(struct sgmac_priv *priv)
+{
+	int i;
+	struct sgmac_dma_desc *p;
+
+	if (!priv->rx_skbuff)
+		return;
+
+	for (i = 0; i < DMA_RX_RING_SZ; i++) {
+		struct sk_buff *skb = priv->rx_skbuff[i];
+		if (skb == NULL)
+			continue;
+
+		p = priv->dma_rx + i;
+		dma_unmap_single(priv->dev, desc_get_buf_addr(p),
+				priv->dma_buf_sz - NET_IP_ALIGN,
+				DMA_FROM_DEVICE);
+		dev_kfree_skb_any(skb);
+		priv->rx_skbuff[i] = NULL;
+	}
+}
+
+static void sgmac_free_tx_skbufs(struct sgmac_priv *priv)
+{
+	int i;
+	struct sgmac_dma_desc *p;
+
+	if (!priv->tx_skbuff)
+		return;
+
+	for (i = 0; i < DMA_TX_RING_SZ; i++) {
+		if (priv->tx_skbuff[i] == NULL)
+			continue;
+
+		p = priv->dma_tx + i;
+		if (desc_get_tx_fs(p))
+			dma_unmap_single(priv->dev, desc_get_buf_addr(p),
+					desc_get_buf_len(p), DMA_TO_DEVICE);
+		else
+			dma_unmap_page(priv->dev, desc_get_buf_addr(p),
+					desc_get_buf_len(p), DMA_TO_DEVICE);
+
+		if (desc_get_tx_ls(p))
+			dev_kfree_skb_any(priv->tx_skbuff[i]);
+		priv->tx_skbuff[i] = NULL;
+	}
+}
+
+static void sgmac_free_dma_desc_rings(struct sgmac_priv *priv)
+{
+	/* Release the DMA TX/RX socket buffers */
+	sgmac_free_rx_skbufs(priv);
+	sgmac_free_tx_skbufs(priv);
+
+	/* Free the consistent memory allocated for descriptor rings */
+	if (priv->dma_tx) {
+		dma_free_coherent(priv->dev,
+				DMA_TX_RING_SZ * sizeof(struct sgmac_dma_desc),
+				priv->dma_tx, priv->dma_tx_phy);
+		priv->dma_tx = NULL;
+	}
+	if (priv->dma_rx) {
+		dma_free_coherent(priv->dev,
+				DMA_RX_RING_SZ * sizeof(struct sgmac_dma_desc),
+				priv->dma_rx, priv->dma_rx_phy);
+		priv->dma_rx = NULL;
+	}
+	kfree(priv->rx_skbuff);
+	priv->rx_skbuff = NULL;
+	kfree(priv->tx_skbuff);
+	priv->tx_skbuff = NULL;
+}
+
+/**
+ * gmac_tx:
+ * @priv: private driver structure
+ * Description: it reclaims resources after transmission completes.
+ */
+static void sgmac_tx_complete(struct sgmac_priv *priv)
+{
+	while (dma_ring_cnt(priv->tx_head, priv->tx_tail, DMA_TX_RING_SZ)) {
+		unsigned int entry = priv->tx_tail;
+		struct sk_buff *skb = priv->tx_skbuff[entry];
+		struct sgmac_dma_desc *p = priv->dma_tx + entry;
+
+		/* Check if the descriptor is owned by the DMA. */
+		if (desc_get_owner(p))
+			break;
+
+		netdev_dbg(priv->ndev, "tx ring: curr %d, dirty %d\n",
+				priv->tx_head, priv->tx_tail);
+
+		if (desc_get_tx_fs(p))
+			dma_unmap_single(priv->dev, desc_get_buf_addr(p),
+					desc_get_buf_len(p), DMA_TO_DEVICE);
+		else
+			dma_unmap_page(priv->dev, desc_get_buf_addr(p),
+					desc_get_buf_len(p), DMA_TO_DEVICE);
+
+		/* Check tx error on the last segment */
+		if (desc_get_tx_ls(p)) {
+			desc_get_tx_status(priv, p);
+			dev_consume_skb_any(skb);
+		}
+		if(priv->hwts_tx_en)
+			sgmac_ptp_get_tx_hwtstamp(priv, p, skb);
+		priv->tx_skbuff[entry] = NULL;
+		priv->tx_tail = dma_ring_incr(entry, DMA_TX_RING_SZ);
+	}
+
+	/* Ensure tx_tail is visible to sgmac_xmit */
+	smp_mb();
+	if (unlikely(netif_queue_stopped(priv->ndev) &&
+			    (tx_dma_ring_space(priv) > MAX_SKB_FRAGS)))
+		netif_wake_queue(priv->ndev);
+}
+
+static void sgmac_tx_timeout_work(struct work_struct *work)
+{
+	u32 reg, value;
+	struct sgmac_priv *priv =
+			container_of(work, struct sgmac_priv, tx_timeout_work);
+
+	napi_disable(&priv->napi);
+
+	writel(0, priv->base + GMAC_DMA_INTR_ENA);
+
+	netif_tx_lock(priv->ndev);
+
+	reg = readl(priv->base + GMAC_DMA_OPERATION);
+	writel(reg & ~DMA_OPERATION_ST, priv->base + GMAC_DMA_OPERATION);
+	do {
+		value = readl(priv->base + GMAC_DMA_STATUS) & 0x700000;
+	} while (value && (value != 0x600000));
+
+	sgmac_free_tx_skbufs(priv);
+	desc_init_tx_desc(priv->dma_tx, DMA_TX_RING_SZ);
+	priv->tx_tail = 0;
+	priv->tx_head = 0;
+	writel(priv->dma_tx_phy, priv->base + GMAC_DMA_TX_BASE_ADDR);
+	writel(reg | DMA_OPERATION_ST, priv->base + GMAC_DMA_OPERATION);
+
+	writel(DMA_STATUS_TU | DMA_STATUS_TPS | DMA_STATUS_NIS | DMA_STATUS_AIS,
+			priv->base + GMAC_DMA_STATUS);
+
+	netif_tx_unlock(priv->ndev);
+	netif_wake_queue(priv->ndev);
+
+	napi_enable(&priv->napi);
+
+	/* Enable interrupts */
+	writel(DMA_INTR_DEFAULT_MASK, priv->base + GMAC_DMA_STATUS);
+	writel(DMA_INTR_DEFAULT_MASK, priv->base + GMAC_DMA_INTR_ENA);
+}
+
+static int sgmac_hw_init(struct net_device *ndev)
+{
+	u32 value, ctrl;
+	int limit;
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	/* Save the ctrl register value */
+	ctrl = readl(priv->base + GMAC_CONTROL) & GMAC_CONTROL_SPD_MASK;
+	/* SW reset */
+	value = DMA_BUS_MODE_SFT_RESET;
+	writel(value, priv->base + GMAC_DMA_BUS_MODE);
+	limit = 15000;
+	while (limit-- && (readl(priv->base + GMAC_DMA_BUS_MODE) &
+					  DMA_BUS_MODE_SFT_RESET))
+		cpu_relax();
+	if (limit < 0)
+		return -EBUSY;
+
+	value = (0x10 << DMA_BUS_MODE_PBL_SHIFT) |
+		(0x10 << DMA_BUS_MODE_RPBL_SHIFT) | DMA_BUS_MODE_FB |
+		DMA_BUS_MODE_ATDS | DMA_BUS_MODE_AAL;
+	writel(value, priv->base + GMAC_DMA_BUS_MODE);
+
+	writel(0, priv->base + GMAC_DMA_INTR_ENA);
+
+	/* Mask power mgt interrupt */
+	writel(GMAC_INT_MASK_PMTIM, priv->base + GMAC_INT_STAT);
+
+	/* GMAC requires AXI bus init. This is a 'magic number' for now */
+	writel(0x0077000E, priv->base + GMAC_DMA_AXI_BUS);
+	// austin:set link, speed and duplex here
+	// no link
+	priv->link = 0;
+	priv->duplex = DUPLEX_FULL;
+#ifdef CONFIG_SFAX8_RGMII_GMAC
+	priv->speed = SPEED_1000;
+	ctrl = GMAC_CONTROL_CST | GMAC_CONTROL_JE | GMAC_CONTROL_ACS |
+	       GMAC_SPEED_1000M | GMAC_CONTROL_DM;
+#else
+	priv->speed = SPEED_100;
+	ctrl = GMAC_CONTROL_CST | GMAC_CONTROL_JE | GMAC_CONTROL_ACS |
+	       GMAC_SPEED_100M | GMAC_CONTROL_DM;
+#endif
+
+	if (ndev->features & NETIF_F_RXCSUM)
+		ctrl |= GMAC_CONTROL_IPC;
+	writel(ctrl, priv->base + GMAC_CONTROL);
+	/* Set the HW DMA mode and the COE */
+	writel(DMA_OPERATION_TSF | DMA_OPERATION_RFD | DMA_OPERATION_RFA |
+					DMA_OPERATION_RTC_256 |
+					DMA_OPERATION_OSF,
+			priv->base + GMAC_DMA_OPERATION);
+
+	return 0;
+}
+
+/**
+ *  sgmac_open - open entry point of the driver
+ *  @dev : pointer to the device structure.
+ *  Description:
+ *  This function is the open entry point of the driver.
+ *  Return value:
+ *  0 on success and an appropriate (-)ve integer as defined in errno.h
+ *  file on failure.
+ */
+static int sgmac_open(struct net_device *ndev)
+{
+	int ret;
+	struct sgmac_priv *priv = netdev_priv(ndev);
+
+	/* Check that the MAC address is valid.  If its not, refuse
+	 * to bring the device up. The user must specify an
+	 * address using the following linux command:
+	 *      ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */
+	if (!is_valid_ether_addr(ndev->dev_addr)) {
+		eth_hw_addr_random(ndev);
+		netdev_dbg(priv->ndev, "generated random MAC address %pM\n",
+				ndev->dev_addr);
+	}
+
+	memset(&priv->xstats, 0, sizeof(struct sgmac_extra_stats));
+
+	/* Initialize the GMAC and descriptors */
+	sgmac_hw_init(ndev);
+	sgmac_set_mac_addr(priv, ndev->dev_addr, 0);
+	sgmac_set_flow_ctrl(priv, priv->rx_pause, priv->tx_pause);
+
+	ret = sgmac_dma_desc_rings_init(ndev);
+	if (ret < 0)
+		return ret;
+
+	napi_enable(&priv->napi);
+	netif_start_queue(ndev);
+
+	/* Enable interrupts */
+	// austin:why we have to write GMAC_DMA_STATUS here?
+	// TODO: we should test whether writing GMAC_DMA_STATUS will effect our
+	// driver.
+	//	writel(DMA_INTR_DEFAULT_MASK, ioaddr + GMAC_DMA_STATUS);
+	writel(DMA_INTR_DEFAULT_MASK, priv->base + GMAC_DMA_INTR_ENA);
+
+	/* Enable the MAC Rx/Tx */
+	sgmac_mac_enable(priv);
+
+	/* austin:
+	 * In mpw0, only RMII can work well.
+	 * In mpw1, RGMII can work but it need extern phy rx delay function, and
+	 * RMII can also work well.
+	 * In later mpw version, maybe we will fix RGMII timing bug and can
+	 * use PHY_INTERFACE_MODE_RGMII instead of PHY_INTERFACE_MODE_RGMII_RXID.
+	 */
+	priv->phydev = of_phy_connect(ndev, priv->phy_node, sgmac_adjust_link,
+#ifdef CONFIG_SFAX8_RGMII_GMAC
+			0, PHY_INTERFACE_MODE_RGMII_RXID);
+#else
+			0, PHY_INTERFACE_MODE_RMII);
+#endif
+	if (!priv->phydev) {
+		netdev_err(ndev, "of_phy_connect() failed\n");
+		return -ENODEV;
+	}
+	dev_info(priv->dev, "connected to %s with id 0x%x\n",
+			priv->phydev->drv->name, priv->phydev->phy_id);
+	phy_start_aneg(priv->phydev);
+	return 0;
+}
+
+/**
+ *  sgmac_stop - close entry point of the driver
+ *  @dev : device pointer.
+ *  Description:
+ *  This is the stop entry point of the driver.
+ */
+static int sgmac_stop(struct net_device *ndev)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	if (priv->phydev)
+		phy_disconnect(priv->phydev);
+
+	if (readl(priv->base + GMAC_DMA_INTR_ENA))
+		napi_disable(&priv->napi);
+
+	writel(0, priv->base + GMAC_DMA_INTR_ENA);
+
+	netif_tx_disable(ndev);
+
+	/* Disable the MAC core */
+	sgmac_mac_disable(priv);
+
+	/* Release and free the Rx/Tx resources */
+	sgmac_free_dma_desc_rings(priv);
+	return 0;
+}
+
+/**
+ *  sgmac_xmit:
+ *  @skb : the socket buffer
+ *  @ndev : device pointer
+ *  Description : Tx entry point of the driver.
+ */
+static netdev_tx_t sgmac_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	unsigned int entry;
+	int i;
+	u32 irq_flag;
+	int nfrags = skb_shinfo(skb)->nr_frags;
+	struct sgmac_dma_desc *desc, *first;
+	unsigned int desc_flags;
+	unsigned int len;
+	dma_addr_t paddr;
+
+	// austin:why 32 frames will set TXDESC_INTERRUPT?
+	// FIXME: we do a little when we receive tx irq, so maybe we can tx 32
+	// frames and then set tx irq.
+	priv->tx_irq_cnt = (priv->tx_irq_cnt + 1) & (DMA_TX_RING_SZ / 4 - 1);
+	irq_flag = priv->tx_irq_cnt ? 0 : TXDESC_INTERRUPT;
+
+	desc_flags = (skb->ip_summed == CHECKSUM_PARTIAL) ? TXDESC_CSUM_ALL : 0;
+	entry = priv->tx_head;
+	desc = priv->dma_tx + entry;
+	first = desc;
+
+	len = skb_headlen(skb);
+	paddr = dma_map_single(priv->dev, skb->data, len, DMA_TO_DEVICE);
+	if (dma_mapping_error(priv->dev, paddr)) {
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+	priv->tx_skbuff[entry] = skb;
+	desc_set_buf_addr_and_size(desc, paddr, len);
+
+	for (i = 0; i < nfrags; i++) {
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+
+		len = frag->size;
+
+		paddr = skb_frag_dma_map(
+				priv->dev, frag, 0, len, DMA_TO_DEVICE);
+		if (dma_mapping_error(priv->dev, paddr))
+			goto dma_err;
+
+		entry = dma_ring_incr(entry, DMA_TX_RING_SZ);
+		desc = priv->dma_tx + entry;
+		priv->tx_skbuff[entry] = skb;
+
+		desc_set_buf_addr_and_size(desc, paddr, len);
+		if (i < (nfrags - 1))
+			desc_set_tx_owner(desc, desc_flags);
+	}
+
+	/* Interrupt on completition only for the latest segment */
+	if (desc != first)
+		desc_set_tx_owner(
+				desc, desc_flags | TXDESC_LAST_SEG | irq_flag);
+	else
+		desc_flags |= TXDESC_LAST_SEG | irq_flag;
+
+	/* Set owner on first desc last to avoid race condition */
+	wmb();
+	desc_set_tx_owner(first, desc_flags | TXDESC_FIRST_SEG);
+	// austin:we should test why tx desc unavailable
+	// XXX: maybe because we choose Operate on Second Frame mode.
+	cpu_relax();
+
+	writel(1, priv->base + GMAC_DMA_TX_POLL);
+
+	priv->tx_head = dma_ring_incr(entry, DMA_TX_RING_SZ);
+
+	/* Ensure tx_head update is visible to tx completion */
+	smp_mb();
+	if (unlikely(tx_dma_ring_space(priv) <= MAX_SKB_FRAGS)) {
+		netif_stop_queue(ndev);
+		/* Ensure netif_stop_queue is visible to tx completion */
+		smp_mb();
+		if (tx_dma_ring_space(priv) > MAX_SKB_FRAGS)
+			netif_start_queue(ndev);
+	}
+
+	return NETDEV_TX_OK;
+
+dma_err:
+	entry = priv->tx_head;
+	for (; i > 0; i--) {
+		entry = dma_ring_incr(entry, DMA_TX_RING_SZ);
+		desc = priv->dma_tx + entry;
+		priv->tx_skbuff[entry] = NULL;
+		dma_unmap_page(priv->dev, desc_get_buf_addr(desc),
+				desc_get_buf_len(desc), DMA_TO_DEVICE);
+		desc_clear_tx_owner(desc);
+	}
+	desc = first;
+	dma_unmap_single(priv->dev, desc_get_buf_addr(desc),
+			desc_get_buf_len(desc), DMA_TO_DEVICE);
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+static int sgmac_rx(struct sgmac_priv *priv, int limit)
+{
+	unsigned int entry;
+	unsigned int count = 0;
+	struct sgmac_dma_desc *p;
+	while (count < limit) {
+		int ip_checksum;
+		struct sk_buff *skb;
+		int frame_len;
+
+		if (!dma_ring_cnt(priv->rx_head, priv->rx_tail, DMA_RX_RING_SZ)) {
+			break;
+		}
+
+		entry = priv->rx_tail;
+		p = priv->dma_rx + entry;
+		if (desc_get_owner(p))
+			break;
+
+		count++;
+		priv->rx_tail = dma_ring_incr(priv->rx_tail, DMA_RX_RING_SZ);
+
+		/* read the status of the incoming frame */
+		// austin:
+		// TODO:we should modify this function
+		ip_checksum = desc_get_rx_status(priv, p);
+		if (ip_checksum < 0)
+			continue;
+
+		skb = priv->rx_skbuff[entry];
+		if (unlikely(!skb)) {
+			netdev_err(priv->ndev,
+					"Inconsistent Rx descriptor chain\n");
+			break;
+		}
+		priv->rx_skbuff[entry] = NULL;
+
+		frame_len = desc_get_rx_frame_len(p);
+		netdev_dbg(priv->ndev, "RX frame size %d, COE status: %d\n",
+				frame_len, ip_checksum);
+
+		if (priv->hwts_rx_en)
+			sgmac_ptp_get_rx_hwtstamp(priv, p, skb);
+		skb_put(skb, frame_len);
+		dma_unmap_single(priv->dev, desc_get_buf_addr(p),
+				priv->dma_buf_sz - NET_IP_ALIGN,
+				DMA_FROM_DEVICE);
+
+		skb->protocol = eth_type_trans(skb, priv->ndev);
+		skb->ip_summed = ip_checksum;
+		if (ip_checksum == CHECKSUM_NONE)
+			netif_receive_skb(skb);
+		else
+			napi_gro_receive(&priv->napi, skb);
+	}
+	sgmac_rx_refill(priv);
+
+	return count;
+}
+
+/**
+ *  sgmac_poll - gmac poll method (NAPI)
+ *  @napi : pointer to the napi structure.
+ *  @budget : maximum number of packets that the current CPU can receive from
+ *	      all interfaces.
+ *  Description :
+ *   This function implements the the reception process.
+ *   Also it runs the TX completion thread
+ */
+static int sgmac_poll(struct napi_struct *napi, int budget)
+{
+	struct sgmac_priv *priv = container_of(napi, struct sgmac_priv, napi);
+	int work_done = 0;
+
+	sgmac_tx_complete(priv);
+	work_done = sgmac_rx(priv, budget);
+
+	if (work_done < budget) {
+		napi_complete(napi);
+		__raw_writel(DMA_INTR_DEFAULT_MASK,
+				priv->base + GMAC_DMA_INTR_ENA);
+	}
+	return work_done;
+}
+
+/**
+ *  sgmac_tx_timeout
+ *  @ndev : Pointer to net device structure
+ *  Description: this function is called when a packet transmission fails to
+ *   complete within a reasonable tmrate. The driver will mark the error in the
+ *   netdev structure and arrange for the device to be reset to a sane state
+ *   in order to transmit a new packet.
+ */
+static void sgmac_tx_timeout(struct net_device *ndev)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	schedule_work(&priv->tx_timeout_work);
+}
+
+/**
+ *  sgmac_set_rx_mode - entry point for multicast addressing
+ *  @ndev : pointer to the device structure
+ *  Description:
+ *  This function is a driver entry point which gets called by the kernel
+ *  whenever multicast addresses must be enabled/disabled.
+ *  Return value: void.
+ */
+// austin:
+// according to netdev_uc_count(dev),set unicast addressing(perfect or hash)
+// according to netdev_mc_count(dev),set multicast addressing(perfect or hash)
+static void sgmac_set_rx_mode(struct net_device *ndev)
+{
+	int i;
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	unsigned int value = 0;
+	u32 hash_filter[GMAC_NUM_HASH];
+	int reg = 1;
+	struct netdev_hw_addr *ha;
+	bool use_hash = false;
+
+	netdev_dbg(priv->ndev, "# mcasts %d, # unicast %d\n",
+			netdev_mc_count(ndev), netdev_uc_count(ndev));
+
+	if (ndev->flags & IFF_PROMISC)
+		value |= GMAC_FRAME_FILTER_PR;
+
+	memset(hash_filter, 0, sizeof(hash_filter));
+
+	if (netdev_uc_count(ndev) > priv->max_macs) {
+		use_hash = true;
+		value |= GMAC_FRAME_FILTER_HUC | GMAC_FRAME_FILTER_HPF;
+	}
+// austin: we can use first to save some time.
+#if 0
+	if (use_hash) {
+		netdev_for_each_uc_addr(ha, ndev) {
+			//austin:we use 8 bits hash value, not 9 bits
+			//we have to test the value of bit_nr
+			//u32 bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 24;
+			u32 bit_nr = ~ether_crc(ETH_ALEN, ha->addr) >> 23;
+			/* The most significant 4 bits determine the register to
+			 * use (H/L) while the other 5 bits determine the bit
+			 * within the register. */
+			hash_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+		}
+	}else {
+	netdev_for_each_uc_addr(ha, ndev) {
+			sgmac_set_mac_addr(priv, ha->addr, reg);
+			reg++;
+		}
+	}
+#else
+	netdev_for_each_uc_addr(ha, ndev)
+	{
+		if (use_hash) {
+			// austin:we use 8 bits
+			// we have to test the value of bit_nr
+			// u32 bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 24;
+			u32 bit_nr = ~ether_crc(ETH_ALEN, ha->addr) >> 23;
+			/* The most significant 4 bits determine the register to
+			 * use (H/L) while the other 5 bits determine the bit
+			 * within the register. */
+			hash_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+		} else {
+			sgmac_set_mac_addr(priv, ha->addr, reg);
+			reg++;
+		}
+	}
+#endif
+	if (ndev->flags & IFF_ALLMULTI) {
+		value |= GMAC_FRAME_FILTER_PM;
+		goto out;
+	}
+
+	if ((netdev_mc_count(ndev) + reg - 1) > priv->max_macs) {
+		use_hash = true;
+		value |= GMAC_FRAME_FILTER_HMC | GMAC_FRAME_FILTER_HPF;
+	} else {
+		use_hash = false;
+	}
+	netdev_for_each_mc_addr(ha, ndev)
+	{
+		if (use_hash) {
+			u32 bit_nr = ~ether_crc(ETH_ALEN, ha->addr) >> 23;
+
+			/* The most significant 4 bits determine the register to
+			 * use (H/L) while the other 5 bits determine the bit
+			 * within the register. */
+			hash_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+		} else {
+			sgmac_set_mac_addr(priv, ha->addr, reg);
+			reg++;
+		}
+	}
+
+out:
+	for (i = reg; i <= priv->max_macs; i++)
+		sgmac_set_mac_addr(priv, NULL, i);
+	for (i = 0; i < GMAC_NUM_HASH; i++)
+		writel(hash_filter[i], priv->base + GMAC_HASH(i));
+
+	writel(value, priv->base + GMAC_FRAME_FILTER);
+}
+
+/**
+ *  sgmac_change_mtu - entry point to change MTU size for the device.
+ *  @ndev : device pointer.
+ *  @new_mtu : the new MTU size for the device.
+ *  Description: the Maximum Transfer Unit (MTU) is used by the network layer
+ *  to drive packet transmission. Ethernet has an MTU of 1500 octets
+ *  (ETH_DATA_LEN). This value can be changed with ifconfig.
+ *  Return value:
+ *  0 on success and an appropriate (-)ve integer as defined in errno.h
+ *  file on failure.
+ */
+static int sgmac_change_mtu(struct net_device *ndev, int new_mtu)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	int old_mtu;
+
+	if ((new_mtu < 46) || (new_mtu > MAX_MTU)) {
+		netdev_err(priv->ndev, "invalid MTU, max MTU is: %d\n",
+				MAX_MTU);
+		return -EINVAL;
+	}
+
+	old_mtu = ndev->mtu;
+
+	/* return early if the buffer sizes will not change */
+	if (old_mtu == new_mtu)
+		return 0;
+
+	/* Stop everything, get ready to change the MTU */
+	if (!netif_running(ndev))
+		return 0;
+
+	/* Bring interface down, change mtu and bring interface back up */
+	sgmac_stop(ndev);
+	ndev->mtu = new_mtu;
+	return sgmac_open(ndev);
+}
+
+static irqreturn_t sgmac_pmt_interrupt(int irq, void *dev_id)
+{
+	u32 intr_status;
+	struct net_device *ndev = (struct net_device *)dev_id;
+	struct sgmac_priv *priv = netdev_priv(ndev);
+
+	intr_status = readl(priv->base + GMAC_INT_STAT);
+	if (intr_status & GMAC_INT_STAT_PMTIS) {
+		netdev_dbg(priv->ndev, "received Magic frame\n");
+		/* clear the PMT bits 5 and 6 by reading the PMT */
+		// austin: we should add pmt handle here.
+		// this handle should also add in sgmac_interrupt.
+		// pm_wakeup_event(priv->dev, 0);
+		readl(priv->base + GMAC_PMT);
+	}
+	return IRQ_HANDLED;
+}
+
+//TODO: we should add RGMII handle here.
+static irqreturn_t sgmac_interrupt(int irq, void *dev_id)
+{
+	u32 intr_status;
+	struct net_device *ndev = (struct net_device *)dev_id;
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	struct sgmac_extra_stats *extra_stats = &priv->xstats;
+	/* read the status register (CSR5) */
+	intr_status = __raw_readl(priv->base + GMAC_DMA_STATUS);
+#ifdef CONFIG_SFAX8_RGMII_GMAC
+	// we should handle RGMII link status here.
+	if (unlikely(intr_status & DMA_STATUS_GLI))
+		__raw_readl(priv->base + GMAC_LINK_STATUS);
+#endif
+	intr_status &= __raw_readl(priv->base + GMAC_DMA_INTR_ENA);
+	__raw_writel(intr_status, priv->base + GMAC_DMA_STATUS);
+
+	/* ABNORMAL interrupts */
+	if (unlikely(intr_status & DMA_STATUS_AIS)) {
+		if (intr_status & DMA_STATUS_TJT) {
+			netdev_err(priv->ndev, "transmit jabber\n");
+			extra_stats->tx_jabber++;
+		}
+		if (intr_status & DMA_STATUS_RU)
+			extra_stats->rx_buf_unav++;
+		if (intr_status & DMA_STATUS_RPS) {
+			netdev_err(priv->ndev, "receive process stopped\n");
+			extra_stats->rx_process_stopped++;
+		}
+		if (intr_status & DMA_STATUS_ETI) {
+			netdev_err(priv->ndev, "transmit early interrupt\n");
+			extra_stats->tx_early++;
+		}
+		if (intr_status & DMA_STATUS_TPS) {
+			netdev_err(priv->ndev, "transmit process stopped\n");
+			extra_stats->tx_process_stopped++;
+			schedule_work(&priv->tx_timeout_work);
+		}
+		if (intr_status & DMA_STATUS_FBI) {
+			netdev_err(priv->ndev, "fatal bus error\n");
+			extra_stats->fatal_bus_error++;
+		}
+	}
+
+	/* TX/RX NORMAL interrupts */
+	if (intr_status & (DMA_STATUS_RI | DMA_STATUS_TU | DMA_STATUS_TI)) {
+		__raw_writel(DMA_INTR_ABNORMAL, priv->base + GMAC_DMA_INTR_ENA);
+		napi_schedule(&priv->napi);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/* Polling receive - used by NETCONSOLE and other diagnostic tools
+ * to allow network I/O with interrupts disabled. */
+static void sgmac_poll_controller(struct net_device *ndev)
+{
+	disable_irq(ndev->irq);
+	sgmac_interrupt(ndev->irq, ndev);
+	enable_irq(ndev->irq);
+}
+#endif
+/*no MMC
+static struct rtnl_link_stats64 *
+gmac_get_stats64(struct net_device *dev,
+		       struct rtnl_link_stats64 *storage)
+{
+	struct sgmac_priv *priv = netdev_priv(dev);
+	void __iomem *base = priv->base;
+	u32 count;
+
+	spin_lock_bh(&priv->stats_lock);
+	writel(GMAC_MMC_CTRL_CNT_FRZ, base + GMAC_MMC_CTRL);
+
+	storage->rx_bytes = readl(base + GMAC_MMC_RXOCTET_G_LO);
+	storage->rx_bytes |= (u64)(readl(base + GMAC_MMC_RXOCTET_G_HI)) << 32;
+
+	storage->rx_packets = readl(base + GMAC_MMC_RXFRAME_GB_LO);
+	storage->multicast = readl(base + GMAC_MMC_RXMCFRAME_G);
+	storage->rx_crc_errors = readl(base + GMAC_MMC_RXCRCERR);
+	storage->rx_length_errors = readl(base + GMAC_MMC_RXLENGTHERR);
+	storage->rx_missed_errors = readl(base + GMAC_MMC_RXOVERFLOW);
+
+	storage->tx_bytes = readl(base + GMAC_MMC_TXOCTET_G_LO);
+	storage->tx_bytes |= (u64)(readl(base + GMAC_MMC_TXOCTET_G_HI)) << 32;
+
+	count = readl(base + GMAC_MMC_TXFRAME_GB_LO);
+	storage->tx_errors = count - readl(base + GMAC_MMC_TXFRAME_G_LO);
+	storage->tx_packets = count;
+	storage->tx_fifo_errors = readl(base + GMAC_MMC_TXUNDERFLOW);
+
+	writel(0, base + GMAC_MMC_CTRL);
+	spin_unlock_bh(&priv->stats_lock);
+	return storage;
+}
+*/
+static int sgmac_set_mac_address(struct net_device *ndev, void *p)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	struct sockaddr *addr = p;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	memcpy(ndev->dev_addr, addr->sa_data, ndev->addr_len);
+
+	sgmac_set_mac_addr(priv, ndev->dev_addr, 0);
+
+	return 0;
+}
+
+static int sgmac_set_features(struct net_device *ndev,
+		netdev_features_t features)
+{
+	u32 ctrl;
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	netdev_features_t changed = ndev->features ^ features;
+
+	if (!(changed & NETIF_F_RXCSUM))
+		return 0;
+
+	ctrl = readl(priv->base + GMAC_CONTROL);
+	if (features & NETIF_F_RXCSUM)
+		ctrl |= GMAC_CONTROL_IPC;
+	else
+		ctrl &= ~GMAC_CONTROL_IPC;
+	writel(ctrl, priv->base + GMAC_CONTROL);
+
+	return 0;
+}
+
+static void sgmac_set_vid(struct sgmac_priv *priv)
+{
+	int i = 0;
+	u16 vid_le;
+	unsigned char vid[2];
+	// for hash vlan filter
+	u16 vlan_hash_table;
+	u32 crc;
+
+	// austin: we can add lock here
+	writel(0, priv->base + GMAC_VLAN_TAG);
+	writel(0, priv->base + GMAC_VLAN_HASH);
+	if (priv->vids_num == 0)
+		return;
+
+	/* We use perfect vlan filter if there is just one vid */
+	if (priv->vids_num == 1) {
+		vid_le = find_first_bit(priv->vids, VLAN_N_VID);
+		vid_le = cpu_to_le16(i);
+		writel(vid_le, priv->base + GMAC_VLAN_TAG);
+		return;
+	}
+
+	/* We use hash vlan filter if there are more than one vids */
+	/*austin: we have to adjust hash value of vlan filter here. */
+	for_each_set_bit(i, priv->vids, VLAN_N_VID)
+	{
+		vid_le = cpu_to_le16(i);
+		// we change little ending to big ending here because the IP of
+		// GMAC have some question.
+		//		vid_le = htons(vid_le);
+		vid[0] = vid_le & 0xff;
+		vid[1] = vid_le >> 8;
+		crc = ~ether_crc(VLAN_HLEN, vid) >> 28;
+		vlan_hash_table |= (1 << crc);
+	}
+	writel(GMAC_VLAN_HASH_VALUE, priv->base + GMAC_VLAN_TAG);
+	writel(vlan_hash_table, priv->base + GMAC_VLAN_HASH);
+}
+
+static int sgmac_vlan_rx_add_vid(struct net_device *ndev, __be16 proto, u16 vid)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+
+	/* Packets with VID 0 are always received by Lancer by default */
+	if (vid == 0 || vid > VLAN_N_VID)
+		return 0;
+
+	if (test_bit(vid, priv->vids))
+		return 0;
+
+	set_bit(vid, priv->vids);
+	priv->vids_num++;
+
+	sgmac_set_vid(priv);
+	return 0;
+}
+
+static int
+sgmac_vlan_rx_kill_vid(struct net_device *ndev, __be16 proto, u16 vid)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+
+	/* Packets with VID 0 are always received by Lancer by default */
+	if (vid == 0 || vid > VLAN_N_VID)
+		return 0;
+
+	if (!test_bit(vid, priv->vids))
+		return 0;
+
+	clear_bit(vid, priv->vids);
+	priv->vids_num--;
+
+	sgmac_set_vid(priv);
+	return 0;
+}
+
+static int sgmac_do_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	int ret = -EOPNOTSUPP;
+
+	if (!netif_running(ndev))
+		return -EINVAL;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		if (!priv->phydev)
+			return -EINVAL;
+		ret = phy_mii_ioctl(priv->phydev, ifr, cmd);
+		break;
+	case SIOCSHWTSTAMP:
+		ret = sgmac_ptp_hwtstamp_ioctl(ndev, ifr);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static const struct net_device_ops sgmac_netdev_ops = {
+	.ndo_open = sgmac_open,
+	.ndo_start_xmit = sgmac_xmit,
+	.ndo_stop = sgmac_stop,
+	.ndo_change_mtu = sgmac_change_mtu,
+	.ndo_set_rx_mode = sgmac_set_rx_mode,
+	.ndo_tx_timeout = sgmac_tx_timeout,
+	.ndo_do_ioctl = sgmac_do_ioctl,
+// austin:we don't have MMC, so we don't have to define this.
+//	.ndo_get_stats64 = gmac_get_stats64,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller = sgmac_poll_controller,
+#endif
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_set_mac_address = sgmac_set_mac_address,
+	// TODO:austin:we can add these function here
+	.ndo_vlan_rx_add_vid = sgmac_vlan_rx_add_vid,
+	.ndo_vlan_rx_kill_vid = sgmac_vlan_rx_kill_vid,
+	// austin:Called to update device configuration to new features.
+	// Passed
+	// feature set might be less than what was returned by
+	// ndo_fix_features()).
+	// Must return >0 or -errno if it changed dev->features itself.
+	.ndo_set_features = sgmac_set_features,
+};
+
+static int sgmac_ethtool_get_settings(struct net_device *ndev,
+		struct ethtool_cmd *cmd)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	return phy_ethtool_gset(priv->phydev, cmd);
+}
+
+static int sgmac_ethtool_set_settings(struct net_device *ndev,
+		struct ethtool_cmd *cmd)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	return phy_ethtool_sset(priv->phydev, cmd);
+}
+
+static void sgmac_ethtool_get_drvinfo(struct net_device *ndev,
+		struct ethtool_drvinfo *info)
+{
+	strlcpy(info->driver, "sgmac", sizeof(info->driver));
+	strlcpy(info->version, "1.0", sizeof(info->version));
+	strlcpy(info->fw_version, "DWC_gmac 3.73a", sizeof(info->fw_version));
+}
+
+static void sgmac_ethtool_get_pauseparam(struct net_device *ndev,
+		struct ethtool_pauseparam *pause)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	pause->rx_pause = priv->rx_pause;
+	pause->tx_pause = priv->tx_pause;
+}
+
+static int sgmac_ethtool_set_pauseparam(struct net_device *ndev,
+		struct ethtool_pauseparam *pause)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+
+	if (pause->autoneg)
+		return -EINVAL;
+	return sgmac_set_flow_ctrl(priv, pause->rx_pause, pause->tx_pause);
+}
+
+static int sgmac_ethtool_get_regs_len(struct net_device *ndev)
+{
+	return SGMAC_REG_SPACE_SIZE;
+}
+
+static void sgmac_ethtool_gregs(struct net_device *ndev,
+		struct ethtool_regs *regs,
+		void *regbuf)
+{
+	int i;
+	u32 *reg_space = regbuf;
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	u32 __iomem *ioaddr = priv->base;
+
+	memset(reg_space, 0x0, SGMAC_REG_SPACE_SIZE);
+	for (i = 0; i < SGMAC_REG_SPACE_SIZE; i += 4)
+		memcpy_fromio(reg_space++, ioaddr++, 4);
+}
+
+static int sgmac_nway_reset(struct net_device *ndev)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	return phy_start_aneg(priv->phydev);
+}
+
+struct sgmac_stats {
+	char stat_string[ETH_GSTRING_LEN];
+	int stat_offset;
+	bool is_reg;
+};
+
+// this is in struct sgmac_priv *priv.
+#define SGMAC_STAT(m)                                                          \
+	{                                                                      \
+		#m, offsetof(struct sgmac_priv, xstats.m), false               \
+	}
+// this is in regs(we don't have).
+#define GMAC_HW_STAT(m, reg_offset)                                            \
+	{                                                                      \
+		#m, reg_offset, true                                           \
+	}
+
+static const struct sgmac_stats sgmac_gstrings_stats[] = {
+	SGMAC_STAT(tx_frame_flushed), SGMAC_STAT(tx_payload_error),
+	SGMAC_STAT(tx_ip_header_error), SGMAC_STAT(tx_local_fault),
+	SGMAC_STAT(tx_remote_fault), SGMAC_STAT(tx_early),
+	SGMAC_STAT(tx_process_stopped), SGMAC_STAT(tx_jabber),
+	SGMAC_STAT(rx_buf_unav), SGMAC_STAT(rx_process_stopped),
+	SGMAC_STAT(rx_payload_error), SGMAC_STAT(rx_ip_header_error),
+	SGMAC_STAT(rx_da_filter_fail), SGMAC_STAT(fatal_bus_error),
+	/*no MMC
+	GMAC_HW_STAT(rx_watchdog, GMAC_MMC_RXWATCHDOG),
+	GMAC_HW_STAT(tx_vlan, GMAC_MMC_TXVLANFRAME),
+	GMAC_HW_STAT(rx_vlan, GMAC_MMC_RXVLANFRAME),
+	GMAC_HW_STAT(tx_pause, GMAC_MMC_TXPAUSEFRAME),
+	GMAC_HW_STAT(rx_pause, GMAC_MMC_RXPAUSEFRAME),
+	*/
+};
+
+#define SGMAC_STATS_LEN ARRAY_SIZE(sgmac_gstrings_stats)
+
+static void sgmac_ethtool_get_ethtool_stats(struct net_device *ndev,
+		struct ethtool_stats *dummy,
+		u64 *data)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	void *p = priv;
+	int i;
+
+	for (i = 0; i < SGMAC_STATS_LEN; i++) {
+		if (sgmac_gstrings_stats[i].is_reg)
+			*data++ = readl(priv->base +
+					sgmac_gstrings_stats[i].stat_offset);
+		else
+			*data++ = *(u32 *)(p +
+					   sgmac_gstrings_stats[i].stat_offset);
+	}
+}
+
+static int sgmac_ethtool_get_sset_count(struct net_device *ndev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return SGMAC_STATS_LEN;
+	default:
+		return -EINVAL;
+	}
+}
+
+static void
+sgmac_ethtool_get_strings(struct net_device *ndev, u32 stringset, u8 *data)
+{
+	int i;
+	u8 *p = data;
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		for (i = 0; i < SGMAC_STATS_LEN; i++) {
+			memcpy(p, sgmac_gstrings_stats[i].stat_string,
+					ETH_GSTRING_LEN);
+			p += ETH_GSTRING_LEN;
+		}
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+}
+
+static void sgmac_ethtool_get_wol(struct net_device *ndev,
+		struct ethtool_wolinfo *wol)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+
+	if (device_can_wakeup(priv->dev)) {
+		wol->supported = WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST;
+		wol->wolopts = priv->wolopts;
+	}
+}
+
+static int sgmac_ethtool_set_wol(struct net_device *ndev,
+		struct ethtool_wolinfo *wol)
+{
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	u32 support = WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST;
+
+	if (!device_can_wakeup(priv->dev))
+		return -ENOTSUPP;
+
+	if (wol->wolopts & ~support)
+		return -EINVAL;
+
+	priv->wolopts = wol->wolopts;
+
+	if (wol->wolopts) {
+		device_set_wakeup_enable(priv->dev, 1);
+		enable_irq_wake(ndev->irq);
+	} else {
+		device_set_wakeup_enable(priv->dev, 0);
+		disable_irq_wake(ndev->irq);
+	}
+
+	return 0;
+}
+
+static const struct ethtool_ops sgmac_ethtool_ops = {
+	.get_settings = sgmac_ethtool_get_settings,
+	.set_settings = sgmac_ethtool_set_settings,
+	.get_drvinfo = sgmac_ethtool_get_drvinfo,
+	.get_link = ethtool_op_get_link,
+	.get_pauseparam = sgmac_ethtool_get_pauseparam,
+	.set_pauseparam = sgmac_ethtool_set_pauseparam,
+	.get_ethtool_stats = sgmac_ethtool_get_ethtool_stats,
+	.get_strings = sgmac_ethtool_get_strings,
+	.get_wol = sgmac_ethtool_get_wol,
+	.set_wol = sgmac_ethtool_set_wol,
+	.get_sset_count = sgmac_ethtool_get_sset_count,
+	.get_regs_len = sgmac_ethtool_get_regs_len,
+	.get_regs = sgmac_ethtool_gregs,
+	.nway_reset = sgmac_nway_reset,
+};
+
+/**
+ * sgmac_probe
+ * @pdev: platform device pointer
+ * Description: the driver is initialized through platform_device.
+ */
+static int sgmac_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct resource *res;
+	struct net_device *ndev = NULL;
+	struct sgmac_priv *priv = NULL;
+	u32 uid;
+
+	if(release_reset(SF_EMAC_SOFT_RESET))
+		return -EFAULT;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	if (!request_mem_region(res->start, resource_size(res), pdev->name))
+		return -EBUSY;
+
+	ndev = alloc_etherdev(sizeof(struct sgmac_priv));
+	if (!ndev) {
+		ret = -ENOMEM;
+		goto err_alloc;
+	}
+	ether_setup(ndev);
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+	priv = netdev_priv(ndev);
+	memset(priv, 0, sizeof(struct sgmac_priv));
+	platform_set_drvdata(pdev, ndev);
+	ndev->netdev_ops = &sgmac_netdev_ops;
+	ndev->ethtool_ops = &sgmac_ethtool_ops;
+	spin_lock_init(&priv->stats_lock);
+	INIT_WORK(&priv->tx_timeout_work, sgmac_tx_timeout_work);
+
+	priv->dev = &pdev->dev;
+	priv->ndev = ndev;
+	priv->rx_pause = 0;
+	priv->tx_pause = 0;
+
+	priv->base = ioremap(res->start, resource_size(res));
+	if (!priv->base) {
+		netdev_err(ndev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_io;
+	}
+
+	uid = readl(priv->base + GMAC_VERSION);
+	netdev_info(ndev, "h/w version is 0x%x\n", uid);
+
+	priv->eth_byp_ref_clk = of_clk_get(priv->dev->of_node, 0);
+	if (IS_ERR(priv->eth_byp_ref_clk)) {
+		netdev_err(ndev, "unable to get eth_byp_ref_clk\n");
+		ret = -EINVAL;
+		goto err_io;
+	}
+	priv->eth_tsu_clk = of_clk_get(priv->dev->of_node, 1);
+	if (IS_ERR(priv->eth_tsu_clk)) {
+		netdev_err(ndev, "unable to get eth_tsu_clk\n");
+		ret = -EINVAL;
+		goto err_io;
+	}
+
+	ret = clk_prepare_enable(priv->eth_byp_ref_clk);
+	if (ret) {
+		netdev_err(ndev, "unable to enable eth_byp_ref_clk\n");
+		goto err_byp_clk;
+	}
+	ret = clk_prepare_enable(priv->eth_tsu_clk);
+	if (ret) {
+		netdev_err(ndev, "unable to enable eth_tsu_clk\n");
+		goto err_tsu_clk;
+	}
+	/* Figure out how many valid mac address filter registers we
+	 * have */
+	// austin:we have 32 addr filter regs in A18
+	// if we have different configs of GAMC, maybe we need it here.
+	writel(1, priv->base + GMAC_ADDR_HIGH(31));
+	if (readl(priv->base + GMAC_ADDR_HIGH(31)) == 1)
+		priv->max_macs = 31;
+	else
+		priv->max_macs = 7;
+
+#ifdef CONFIG_SFAX8_RGMII_GMAC
+	// gpio 51 and 52 provide power for the extern phy int RGMII mode.
+	priv->gpio51 = of_get_named_gpio(priv->dev->of_node, "test-gpios", 0);
+	if (priv->gpio51 < 0) {
+		netdev_err(ndev, "Can't find test_gpios 51\n");
+		ret = -ENODEV;
+		goto err_gpio51;
+	}
+
+	ret = devm_gpio_request(priv->dev, priv->gpio51, NULL);
+	if (ret) {
+		netdev_err(ndev, "Failed requesting GPIO51_output\n");
+		goto err_gpio51;
+	}
+	gpio_direction_output(priv->gpio51, 1);
+
+	priv->gpio52 = of_get_named_gpio(priv->dev->of_node, "test-gpios", 1);
+	if (priv->gpio52 < 0) {
+		netdev_err(ndev, "Can't find test_gpios 52\n");
+		ret = -ENODEV;
+		goto err_gpio52;
+	}
+
+	ret = devm_gpio_request(priv->dev, priv->gpio52, NULL);
+	if (ret) {
+		netdev_err(ndev, "Failed requesting GPIO52_output\n");
+		goto err_gpio52;
+	}
+	gpio_direction_output(priv->gpio52, 1);
+	// wait phy reset.
+	// TODO: we have to test this time.
+	mdelay(1000);
+#endif
+
+	/* Get PHY from device tree */
+	priv->phy_node = of_parse_phandle(priv->dev->of_node, "phy", 0);
+	if (!priv->phy_node) {
+		netdev_err(ndev, "failed to retrieve phy description "
+				 "from device tree\n");
+		ret = -ENODEV;
+		goto err_phy;
+	}
+
+	writel(0, priv->base + GMAC_DMA_INTR_ENA);
+
+	ndev->irq = platform_get_irq(pdev, 0);
+	if (ndev->irq == -ENXIO) {
+		netdev_err(ndev, "No irq resource\n");
+		ret = ndev->irq;
+		goto err_irq;
+	}
+
+	ret = request_irq(ndev->irq, sgmac_interrupt, 0, dev_name(&pdev->dev),
+			ndev);
+	if (ret < 0) {
+		netdev_err(ndev, "Could not request irq %d - ret %d)\n",
+				ndev->irq, ret);
+		goto err_irq;
+	}
+
+	ret = request_irq(ndev->irq + 2, sgmac_pmt_interrupt, 0,
+			dev_name(&pdev->dev), ndev);
+	if (ret < 0) {
+		netdev_err(ndev, "Could not request irq %d - ret %d)\n",
+				ndev->irq + 2, ret);
+		goto err_pmt_irq;
+	}
+
+	device_set_wakeup_capable(&pdev->dev, 1);
+	if (device_can_wakeup(priv->dev))
+		priv->wolopts = WAKE_MAGIC; /* Magic Frame as default */
+
+	// austin: we can change ndev->hw_features, ndev->features and
+	// ndev->priv_flags to control sth.
+	ndev->hw_features =
+			NETIF_F_SG | NETIF_F_HIGHDMA | NETIF_F_VLAN_FEATURES;
+	// austin: we have these features in A18.
+	// if we have different configs of GMAC, maybe we need it here.
+	if (readl(priv->base + GMAC_DMA_HW_FEATURE) & DMA_HW_FEAT_TXCOESEL)
+		ndev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+				     NETIF_F_RXCSUM;
+	ndev->features |= ndev->hw_features;
+	ndev->vlan_features |= ndev->hw_features;
+	ndev->priv_flags |= IFF_UNICAST_FLT;
+
+	/* Get the MAC address */
+	// austin: we should get mac addr from dts.
+	sgmac_get_mac_addr(priv, ndev->dev_addr, 0);
+	if (!is_valid_ether_addr(ndev->dev_addr))
+		netdev_warn(ndev, "MAC address %pM not valid", ndev->dev_addr);
+
+	// austin:we have to make sure phy read and phy write is in
+	// right clk div.
+	sgmac_set_mdc_clk_div(priv);
+	ret = sgmac_mdio_probe(priv);
+	if (ret < 0) {
+		netdev_err(ndev, "failed to probe MII bus\n");
+		goto err_mdio;
+	}
+
+	ret = sgmac_ptp_register(priv);
+	if (ret < 0) {
+		netdev_err(ndev, "failed to ptp register\n");
+		goto err_ptp;
+	}
+
+	netif_napi_add(ndev, &priv->napi, sgmac_poll, 64);
+	ret = register_netdev(ndev);
+	if (ret)
+		goto err_reg;
+	return 0;
+
+err_reg:
+	netif_napi_del(&priv->napi);
+	sgmac_ptp_unregister(priv);
+err_ptp:
+	sgmac_mdio_remove(priv);
+err_mdio:
+	free_irq(ndev->irq + 2, ndev);
+err_pmt_irq:
+	free_irq(ndev->irq, ndev);
+err_irq:
+	of_node_put(priv->phy_node);
+err_phy:
+#ifdef CONFIG_SFAX8_RGMII_GMAC
+	devm_gpio_free(priv->dev, priv->gpio52);
+err_gpio52:
+	devm_gpio_free(priv->dev, priv->gpio51);
+err_gpio51:
+#endif
+	clk_disable_unprepare(priv->eth_byp_ref_clk);
+err_tsu_clk:
+	clk_disable_unprepare(priv->eth_tsu_clk);
+err_byp_clk:
+	iounmap(priv->base);
+err_io:
+	free_netdev(ndev);
+err_alloc:
+	release_mem_region(res->start, resource_size(res));
+	return ret;
+}
+
+/**
+ * sgmac_remove
+ * @pdev: platform device pointer
+ * Description: this function resets the TX/RX processes, disables the
+ * MAC RX/TX
+ * changes the link status, releases the DMA descriptor rings,
+ * unregisters the MDIO bus and unmaps the allocated memory.
+ */
+static int sgmac_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	struct resource *res;
+
+	// austin:we should test these code
+	sgmac_mac_disable(priv);
+	sgmac_ptp_unregister(priv);
+	sgmac_mdio_remove(priv);
+
+	/* Free the IRQ lines */
+	free_irq(ndev->irq, ndev);
+	free_irq(ndev->irq + 2, ndev);
+
+	unregister_netdev(ndev);
+	netif_napi_del(&priv->napi);
+
+	of_node_put(priv->phy_node);
+#ifdef CONFIG_SFAX8_RGMII_GMAC
+	devm_gpio_free(priv->dev, priv->gpio52);
+	devm_gpio_free(priv->dev, priv->gpio51);
+#endif
+	clk_disable_unprepare(priv->eth_byp_ref_clk);
+	clk_disable_unprepare(priv->eth_tsu_clk);
+
+	iounmap(priv->base);
+	free_netdev(ndev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static void sgmac_pmt(struct sgmac_priv *priv, unsigned long mode)
+{
+	unsigned int pmt = 0;
+
+	if (mode & WAKE_MAGIC)
+		pmt |= GMAC_PMT_PWRDWN | GMAC_PMT_MGKPKTEN;
+	if (mode & WAKE_UCAST)
+		pmt |= GMAC_PMT_PWRDWN | GMAC_PMT_GLBLUCAST;
+
+	writel(pmt, priv->base + GMAC_PMT);
+}
+
+static int sgmac_suspend(struct device *dev)
+{
+	struct net_device *ndev = platform_get_drvdata(to_platform_device(dev));
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	u32 value;
+
+	if (!ndev || !netif_running(ndev))
+		return 0;
+
+	netif_device_detach(ndev);
+	napi_disable(&priv->napi);
+	writel(0, priv->base + GMAC_DMA_INTR_ENA);
+
+	if (device_may_wakeup(priv->dev)) {
+		/* Stop TX/RX DMA Only */
+		value = readl(priv->base + GMAC_DMA_OPERATION);
+		value &= ~(DMA_OPERATION_ST | DMA_OPERATION_SR);
+		writel(value, priv->base + GMAC_DMA_OPERATION);
+
+		sgmac_pmt(priv, priv->wolopts);
+	} else
+		sgmac_mac_disable(priv);
+
+	if (!IS_ERR(priv->eth_byp_ref_clk))
+		clk_disable_unprepare(priv->eth_byp_ref_clk);
+	if (!IS_ERR(priv->eth_tsu_clk))
+		clk_disable_unprepare(priv->eth_tsu_clk);
+
+	return 0;
+}
+
+static int sgmac_resume(struct device *dev)
+{
+	struct net_device *ndev = platform_get_drvdata(to_platform_device(dev));
+	struct sgmac_priv *priv = netdev_priv(ndev);
+	int ret;
+
+	if (!netif_running(ndev))
+		return 0;
+
+	ret = clk_prepare_enable(priv->eth_byp_ref_clk);
+	if (ret)
+		return ret;
+	ret = clk_prepare_enable(priv->eth_tsu_clk);
+	if (ret)
+		return ret;
+
+	sgmac_pmt(priv, 0);
+
+	/* Enable the MAC and DMA */
+	sgmac_mac_enable(priv);
+	writel(DMA_INTR_DEFAULT_MASK, priv->base + GMAC_DMA_STATUS);
+	writel(DMA_INTR_DEFAULT_MASK, priv->base + GMAC_DMA_INTR_ENA);
+
+	netif_device_attach(ndev);
+	napi_enable(&priv->napi);
+
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(sgmac_pm_ops, sgmac_suspend, sgmac_resume);
+
+static const struct of_device_id sgmac_of_match[] = {
+	{
+		.compatible = "siflower,sfax8-gmac",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, sgmac_of_match);
+
+static struct platform_driver sgmac_driver = {
+	.driver = {
+		.name = "sf_gmac",
+		.of_match_table = sgmac_of_match,
+	},
+	.probe = sgmac_probe,
+	.remove = sgmac_remove,
+	.driver.pm = &sgmac_pm_ops,
+};
+
+static void __exit exit_sgmac(void)
+{
+	platform_driver_unregister(&sgmac_driver);
+	hold_reset(SF_EMAC_SOFT_RESET);
+	return;
+}
+
+static int __init init_sgmac(void)
+{
+	int ret = platform_driver_register(&sgmac_driver);
+	return ret;
+}
+
+module_init(init_sgmac);
+module_exit(exit_sgmac);
+
+// module_platform_driver(gmac_driver);
+
+MODULE_AUTHOR("austin, <austin.xu@siflower.com.cn>");
+MODULE_DESCRIPTION("Siflower 1000M GMAC driver");
+MODULE_LICENSE("GPL v2");
Index: linux-3.18.29/drivers/net/ethernet/siflower/sgmac.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sgmac.h	2017-11-21 20:13:12.442710527 +0800
@@ -0,0 +1,431 @@
+#ifndef _GMAC_DEV_H_
+#define _GMAC_DEV_H_
+
+#define SGMAC_REG_SPACE_SIZE		0x1058
+/* GMAC Register list */
+#define GMAC_CONTROL			0x00000000	/* Register 0 (MAC Configuration Register)*/
+#define GMAC_FRAME_FILTER		0x00000004	/* Register 1 (MAC Frame Filter) */
+//we define DWC_GMAC_HASH_TABLE 256 so we use GMAC_HASH(7:0) and don't use GMAC_HASH_HIGH and GMAC_HASH_LOW.
+#define GMAC_HASH_HIGH			0x00000008	/* Register 2 (Hash Table High Register) */
+#define GMAC_HASH_LOW			0x0000000c	/* Register 3 (Hash Table Low Register) */
+#define GMAC_GMII_ADDR			0x00000010	/* Register 4 (GMII Address Register) */
+#define GMAC_GMII_DATA			0x00000014	/* Register 5 (GMII Data Register) */
+#define GMAC_FLOW_CTRL			0x00000018	/* Register 6 (Flow Control Register) */
+#define GMAC_VLAN_TAG			0x0000001C	/* Register 7 (VLAN Tag Register) */
+#define GMAC_VERSION			0x00000020	/* Register 8 (Version Register) */
+#define GMAC_DEBUG			0x00000024	/* Register 9 (Debug Register) */
+#define GMAC_REMOTE_WAKE		0x00000028	/* Register 10 (Remote Wake-Up Frame Filter Register) */
+#define GMAC_PMT			0x0000002c	/* Register 11 (PMT Control and Status Register) */
+#define GMAC_LPI_CTRL			0x00000030	/* Register 12 (LPI Control and Status Register) */
+#define GMAC_LPI_TIMER			0x00000034	/* Register 13 (LPI Timers Control Register) */
+#define GMAC_INT_STAT			0x00000038	/* Register 14 (Interrupt Status Register) */
+#define GMAC_INT_MASK			0x0000003c	/* Register 15 (Interrupt Mask Register) */
+#define GMAC_LINK_STATUS		0x000000D8	/* Register 54 (SGMII/RGMII/SMII Control and Status Register) */
+
+/*Register 16 (MAC Address0 High Register) to Register 47 (MAC Address15 Low Register) and
+ *Register 512 (MAC Address16 High Register) to Register 553 (MAC Address31 Low Register) */
+#define GMAC_ADDR_HIGH(reg)     ((reg) <= 15? 0x00000040 + (reg) * 8:0x00000720 + (reg) * 8)
+#define GMAC_ADDR_LOW(reg)      ((reg) <= 15? 0x00000044 + (reg) * 8:0x00000724 + (reg) * 8)
+
+#if 0
+#define GMAC_ADDR_HIGH0			0x00000040					/* Register 16 (MAC Address0 High Register) */
+#define GMAC_ADDR_LOW0			0x00000044					/* Register 17 (MAC Address0 Low Register) */
+#define GMAC_ADDR_HIGH1			0x00000048					/* Register 18 (MAC Address1 High Register) */
+#define GMAC_ADDR_LOW1			0x0000004c					/* Register 19 (MAC Address1 Low Register) */
+#define GMAC_ADDR_HIGH2			0x00000050					/* Register 20 (MAC Address2 High Register) */
+#define GMAC_ADDR_LOW2			0x00000054					/* Register 21 (MAC Address2 Low Register) */
+#define GMAC_ADDR_HIGH3			0x00000058					/* Register 22 (MAC Address3 High Register) */
+#define GMAC_ADDR_LOW3			0x0000005c					/* Register 23 (MAC Address3 Low Register) */
+#define GMAC_ADDR_HIGH4			0x00000060					/* Register 24 (MAC Address4 High Register) */
+#define GMAC_ADDR_LOW4			0x00000064					/* Register 25 (MAC Address4 Low Register) */
+#define GMAC_ADDR_HIGH5			0x00000068					/* Register 26 (MAC Address5 High Register) */
+#define GMAC_ADDR_LOW5			0x0000006c					/* Register 27 (MAC Address5 Low Register) */
+#define GMAC_ADDR_HIGH6			0x00000070					/* Register 28 (MAC Address6 High Register) */
+#define GMAC_ADDR_LOW6			0x00000074					/* Register 29 (MAC Address6 Low Register) */
+#define GMAC_ADDR_HIGH7			0x00000078					/* Register 30 (MAC Address7 High Register) */
+#define GMAC_ADDR_LOW7			0x0000007c					/* Register 31 (MAC Address7 Low Register) */
+#define GMAC_ADDR_HIGH8			0x00000080					/* Register 32 (MAC Address8 High Register) */
+#define GMAC_ADDR_LOW8			0x00000084					/* Register 33 (MAC Address8 Low Register) */
+#define GMAC_ADDR_HIGH9			0x00000088					/* Register 34 (MAC Address9 High Register) */
+#define GMAC_ADDR_LOW9			0x0000008c					/* Register 35 (MAC Address9 Low Register) */
+#define GMAC_ADDR_HIGH10		0x00000090					/* Register 36 (MAC Address10 High Register) */
+#define GMAC_ADDR_LOW10			0x00000094					/* Register 37 (MAC Address10 Low Register) */
+#define GMAC_ADDR_HIGH11		0x00000098					/* Register 38 (MAC Address11 High Register) */
+#define GMAC_ADDR_LOW11			0x0000009c					/* Register 39 (MAC Address11 Low Register) */
+#define GMAC_ADDR_HIGH12		0x000000a0					/* Register 40 (MAC Address12 High Register) */
+#define GMAC_ADDR_LOW12			0x000000a4					/* Register 41 (MAC Address12 Low Register) */
+#define GMAC_ADDR_HIGH13		0x000000a8					/* Register 42 (MAC Address13 High Register) */
+#define GMAC_ADDR_LOW13			0x000000ac					/* Register 43 (MAC Address13 Low Register) */
+#define GMAC_ADDR_HIGH14		0x000000b0					/* Register 44 (MAC Address14 High Register) */
+#define GMAC_ADDR_LOW14			0x000000b4					/* Register 45 (MAC Address14 Low Register) */
+#define GMAC_ADDR_HIGH15		0x000000b8					/* Register 46 (MAC Address15 High Register) */
+#define GMAC_ADDR_LOW15			0x000000bc					/* Register 47 (MAC Address15 Low Register) */
+#endif
+
+#define GMAC_HASH(n)			(0x00000500 + (n) * 4)		/* Register 320 (Hash Table Register 0) to Register 327 (Hash Table Register 7)*/
+#define GMAC_VLAN_INCL			0x00000584					/* Register 353 (VLAN Tag Inclusion or Replacement Register) */
+#define GMAC_VLAN_HASH			0x00000588					/* Register 354 (VLAN Hash Table Register) */
+
+#if 0
+#define GMAC_ADDR_HIGH16		0x00000800					/* Register 512 (MAC Address16 High Register) */
+#define GMAC_ADDR_LOW16			0x00000804					/* Register 513 (MAC Address16 Low Register) */
+#define GMAC_ADDR_HIGH17		0x00000808					/* Register 514 (MAC Address17 High Register) */
+#define GMAC_ADDR_LOW17			0x0000080c					/* Register 515 (MAC Address17 Low Register) */
+#define GMAC_ADDR_HIGH18		0x00000810					/* Register 516 (MAC Address18 High Register) */
+#define GMAC_ADDR_LOW18			0x00000814					/* Register 517 (MAC Address18 Low Register) */
+#define GMAC_ADDR_HIGH19		0x00000818					/* Register 518 (MAC Address19 High Register) */
+#define GMAC_ADDR_LOW19			0x0000081c					/* Register 519 (MAC Address19 Low Register) */
+#define GMAC_ADDR_HIGH20		0x00000820					/* Register 520 (MAC Address20 High Register) */
+#define GMAC_ADDR_LOW20			0x00000824					/* Register 521 (MAC Address20 Low Register) */
+#define GMAC_ADDR_HIGH21		0x00000828					/* Register 522 (MAC Address21 High Register) */
+#define GMAC_ADDR_LOW21			0x0000082c					/* Register 523 (MAC Address21 Low Register) */
+#define GMAC_ADDR_HIGH22		0x00000830					/* Register 524 (MAC Address22 High Register) */
+#define GMAC_ADDR_LOW22			0x00000834					/* Register 525 (MAC Address22 Low Register) */
+#define GMAC_ADDR_HIGH23		0x00000838					/* Register 536 (MAC Address23 High Register) */
+#define GMAC_ADDR_LOW23			0x0000083c					/* Register 537 (MAC Address23 Low Register) */
+#define GMAC_ADDR_HIGH24		0x00000840					/* Register 538 (MAC Address24 High Register) */
+#define GMAC_ADDR_LOW24			0x00000844					/* Register 539 (MAC Address24 Low Register) */
+#define GMAC_ADDR_HIGH25		0x00000848					/* Register 540 (MAC Address25 High Register) */
+#define GMAC_ADDR_LOW25			0x0000084c					/* Register 541 (MAC Address25 Low Register) */
+#define GMAC_ADDR_HIGH26		0x00000850					/* Register 542 (MAC Address26 High Register) */
+#define GMAC_ADDR_LOW26			0x00000854					/* Register 543 (MAC Address26 Low Register) */
+#define GMAC_ADDR_HIGH27		0x00000858					/* Register 544 (MAC Address27 High Register) */
+#define GMAC_ADDR_LOW27			0x0000085c					/* Register 545 (MAC Address27 Low Register) */
+#define GMAC_ADDR_HIGH28		0x00000860					/* Register 546 (MAC Address28 High Register) */
+#define GMAC_ADDR_LOW28			0x00000864					/* Register 547 (MAC Address28 Low Register) */
+#define GMAC_ADDR_HIGH29		0x00000868					/* Register 548 (MAC Address29 High Register) */
+#define GMAC_ADDR_LOW29			0x0000086c					/* Register 549 (MAC Address29 Low Register) */
+#define GMAC_ADDR_HIGH30		0x00000870					/* Register 550 (MAC Address30 High Register) */
+#define GMAC_ADDR_LOW30			0x00000874					/* Register 551 (MAC Address30 Low Register) */
+#define GMAC_ADDR_HIGH31		0x00000878					/* Register 552 (MAC Address31 High Register) */
+#define GMAC_ADDR_LOW31			0x0000087c					/* Register 553 (MAC Address31 Low Register) */
+#endif
+//austin:we only have 8 hash table regs so maybe we have to modify some code.
+#define GMAC_NUM_HASH			8
+
+/* DMA Register list */
+#define GMAC_DMA_BUS_MODE		0x00001000	/* Register 0 (Bus Mode Register) */
+#define GMAC_DMA_TX_POLL		0x00001004	/* Register 1 (Transmit Poll Demand Register) */
+#define GMAC_DMA_RX_POLL		0x00001008	/* Register 2 (Receive Poll Demand Register) */
+#define GMAC_DMA_RX_BASE_ADDR		0x0000100c	/* Register 3 (Receive Descriptor List Address Register) */
+#define GMAC_DMA_TX_BASE_ADDR		0x00001010	/* Register 4 (Transmit Descriptor List Address Register) */
+#define GMAC_DMA_STATUS			0x00001014	/* Register 5 (Status Register) */
+#define GMAC_DMA_OPERATION		0x00001018	/* Register 6 (Operation Mode Register) */
+#define GMAC_DMA_INTR_ENA		0x0000101c	/* Register 7 (Interrupt Enable Register) */
+#define GMAC_DMA_MISS_FRAME_CTR		0x00001020	/* Register 8 (Missed Frame and Buffer Overflow Counter Register) */
+#define GMAC_DMA_RI_WDOG_TIMER		0x00001024	/* Register 9 (Receive Interrupt Watchdog Timer Register) */
+#define GMAC_DMA_AXI_BUS		0x00001028	/* Register 10 (AXI Bus Mode Register) */
+#define GMAC_DMA_AXI_STATUS		0x0000102C	/* Register 11 (AHB or AXI Status Register) */
+#define GMAC_DMA_HW_FEATURE		0x00001058	/* Register 22 (HW Feature Register) */
+
+/* PTP Register list */
+#define GMAC_TS_CONTROL			0x00000700	/* Register 448 (Timestamp Control Register) */
+#define GMAC_TS_SUBSEC_INCR		0x00000704	/* Register 449 (Sub-Second Increment Register) */
+#define GMAC_TS_HIGH			0x00000708	/* Register 450 (System Time - Seconds Register) */
+#define GMAC_TS_LOW			0x0000070c	/* Register 451 (System Time - Nanoseconds Register) */
+#define GMAC_TS_HIGH_UPDATE		0x00000710	/* Register 452 (System Time - Seconds Update Register) */
+#define GMAC_TS_LOW_UPDATE		0x00000714	/* Register 453 (System Time - Nanoseconds Update Register) */
+#define GMAC_TS_ADDEND			0x00000718	/* Register 454 (Timestamp Addend Register) */
+#define GMAC_TS_TARGET_HIGH		0x0000071c	/* Register 455 (Target Time Seconds Register) */
+#define GMAC_TS_TARGET_LOW		0x00000720	/* Register 456 (Target Time Nanoseconds Register) */
+#define GMAC_TS_HIGH_WORD		0x00000724	/* Register 457 (System Time - Higher Word Seconds Register) */
+#define GMAC_TS_STATUS			0x00000728	/* Register 458 (Timestamp Status Register) */
+#define GMAC_TS_AUXI_HIGH		0x00000730	/* Register 460 (Auxiliary Timestamp - Nanoseconds Register) */
+#define GMAC_TS_AUXI_LOW		0x00000734	/* Register 461 (Auxiliary Timestamp - Seconds Register) */
+
+/* MAC Configuration Register */
+#define GMAC_CONTROL_SARC_MASK		0xc0000000	/* bit [30:28] Source Address Insertion or Replacement Control */
+#define GMAC_CONTROL_TWOKPE		0x08000000	/* bit [27] IEEE 802.3as Support for 2K Packets */
+#define GMAC_CONTROL_CST		0x02000000	/* bit [25] CRC Stripping for Type Frames */
+#define GMAC_CONTROL_WD			0x00800000	/* bit [23] Watchdog Disable */
+#define GMAC_CONTROL_JD			0x00400000	/* bit [22] Jabber Disable */
+#define GMAC_CONTROL_JE			0x00100000	/* bit [20] Jumbo Frame Enable */
+#define GMAC_CONTROL_SPD_MASK		0x0000c000	/* bit [15:14] Speed Mask(10M/100M/1000M) */
+#define GMAC_CONTROL_PS			0x00008000	/* bit [15] Port Select */
+#define GMAC_CONTROL_FES		0x00004000	/* bit [14] speed (0: 10 Mbps, 1: 100 Mbps) */
+#define GMAC_CONTROL_LM			0x00001000	/* bit [12] Loopback Mode */
+#define GMAC_CONTROL_DM			0x00000800	/* bit [11] Duplex Mode */
+#define GMAC_CONTROL_IPC		0x00000400	/* bit [10] Checksum Offload */
+#define GMAC_CONTROL_ACS		0x00000080	/* bit [7] Automatic Pad/FCS Strip */
+#define GMAC_CONTROL_TE			0x00000008	/* bit [3] Transmitter Enable */
+#define GMAC_CONTROL_RE			0x00000004	/* bit [2] Receiver Enable */
+
+#define GMAC_SPEED_1000M		0
+#define GMAC_SPEED_100M			GMAC_CONTROL_SPD_MASK
+#define GMAC_SPEED_10M			GMAC_CONTROL_PS
+
+/* MAC Frame Filter */
+#define GMAC_FRAME_FILTER_RA	0x80000000	/* bit [31] Receive All */
+#define GMAC_FRAME_FILTER_HPF	0x00000400	/* bit [10] Hash or perfect Filter */
+#define GMAC_FRAME_FILTER_SAF	0x00000200	/* bit [9] Source Address Filter Enable */
+#define GMAC_FRAME_FILTER_SAIF	0x00000100	/* bit [8] SA Inverse Filtering */
+#define GMAC_FRAME_FILTER_PCF	0x000000c0	/* bit [7:6] Pass Control Frames */
+#define GMAC_FRAME_FILTER_DBF	0x00000020	/* bit [5] Disable Broadcast Frames */
+#define GMAC_FRAME_FILTER_PM	0x00000010	/* bit [4] Pass All Multicast */
+#define GMAC_FRAME_FILTER_DAIF	0x00000008	/* bit [3] DA Inverse Filtering */
+#define GMAC_FRAME_FILTER_HMC	0x00000004	/* bit [2] Hash Multicast */
+#define GMAC_FRAME_FILTER_HUC	0x00000002	/* bit [1] Hash Unicast */
+#define GMAC_FRAME_FILTER_PR	0x00000001	/* bit [0] Promiscuous Mode */
+
+/* GMII Address Register */
+#define GMAC_GMII_ADDR_PA		0x0000f800	/* bit [15:11] Physical Layer Address */
+#define GMAC_GMII_ADDR_GR		0x000007c0	/* bit [10:6] GMII Register */
+#define GMAC_GMII_ADDR_CR_MASK	0x0000003c	/* bit [5:2] CSR Clock Range */
+#define GMAC_GMII_ADDR_CR		0x00000014	/* bit [5:2] 0101: The CSR clock frequency is 250–300 MHz and the MDC clock is CSR clock/124.*/
+#define GMAC_GMII_ADDR_GW		0x00000002	/* bit [1] GMII Write */
+#define GMAC_GMII_ADDR_GB		0x00000001	/* bit [0] GMII Busy */
+
+/* GMII Data Register */
+#define GMAC_GMII_DATA_GD		0x0000ffff	/* bit [15:0] GMII Data */
+
+/* Flow Control Register */
+#define GMAC_FLOW_CTRL_PT_MASK	0xffff0000	/* bit [31:16] Pause Time Mask */
+#define GMAC_FLOW_CTRL_PT_SHIFT	16
+#define GMAC_FLOW_CTRL_DZQP		0x00000080	/* bit [7] Disable Zero-Quanta Pause */
+#define GMAC_FLOW_CTRL_PLT		0x00000020	/* The threshold is Pause time minus 28 slot times (PT – 28 slot times). */
+#define GMAC_FLOW_CTRL_PLT_MASK	0x00000030	/* bit [5:4] Pause Low Threshhold */
+#define GMAC_FLOW_CTRL_UP		0x00000008	/* bit [3] Unicast Pause Frame Detect */
+#define GMAC_FLOW_CTRL_RFE		0x00000004	/* bit [2] Rx Flow Control Enable */
+#define GMAC_FLOW_CTRL_TFE		0x00000002	/* bit [1] Tx Flow Control Enable */
+#define GMAC_FLOW_CTRL_FCB_BPA	0x00000001	/* bit [0] Flow Control Busy or Backpressure Activate */
+
+/* VLAN Tag Register */
+#define GMAC_VLAN_VTHM			0x00080000	/* bit [19] VLAN Tag Hash Table Match Enable */
+#define GMAC_VLAN_ESVL			0x00040000	/* bit [18] Enable S-VLAN */
+#define GMAC_VLAN_VTIM			0x00020000	/* bit [17] VLAN Tag Inverse Match Enable */
+#define GMAC_VLAN_ETV			0x00010000	/* bit [16] Enable 12-Bit VLAN Tag Comparison */
+#define GMAC_VLAN_VL			0x0000ffff	/* bit [15:0] VLAN Tag Identifier for Receive Frames */
+
+//If we use hash filter, the VL[11:0] can't equal 0
+#define GMAC_VLAN_HASH_VALUE	(GMAC_VLAN_VTHM | 1)
+
+/* PMT Control and Status Register */
+#define GMAC_PMT_RWKFILTRST		0x80000000	/* bit [31] Remote Wake-Up Frame Filter Register Pointer Reset */
+#define GMAC_PMT_GLBLUCAST		0x00000200	/* bit [9] Global Unicast */
+#define GMAC_PMT_RWKPRCVD		0x00000040	/* bit [6] Remote Wake-Up Frame Received */
+#define GMAC_PMT_MGKPRCVD		0x00000020	/* bit [5] Magic Packet Received */
+#define GMAC_PMT_RWKPKTEN		0x00000004	/* bit [2] Remote Wake-Up Frame Enable */
+#define GMAC_PMT_MGKPKTEN		0x00000002	/* bit [1] Magic Packet Enable */
+#define GMAC_PMT_PWRDWN			0x00000001	/* bit [0] Power Down */
+
+/* Interrupt Status Register */
+#define GMAC_INT_STAT_GPIIS		0x00000800	/* bit [11] GPI Interrupt Status */
+#define GMAC_INT_STAT_LPIIS		0x00000400	/* bit [10] LPI Interrupt Status */
+#define GMAC_INT_STAT_TSIS		0x00000200	/* bit [9] Timestamp Interrupt Status */
+#define GMAC_INT_STAT_PMTIS		0x00000008	/* bit [3] PMT Interrupt Status */
+
+/* Interrupt Mask Register */
+#define GMAC_INT_MASK_LPIIM		0x00000400	/* bit [10] LPI Interrupt Mask */
+#define GMAC_INT_MASK_TSIM		0x00000200	/* bit [9] Timestamp Interrupt Mask */
+#define GMAC_INT_MASK_PMTIM		0x00000008	/* bit [3] PMT Interrupt Mask */
+
+/* MAC Address0 High Register */
+#define GMAC_ADDR_AE			0x80000000	/* bit [31] Address Enable */
+
+/* DMA Bus Mode Register */
+#define DMA_BUS_MODE_AAL		0x02000000	/* bit [25] Address-Aligned Beats */
+#define DMA_BUS_MODE_8PBL		0x01000000	/* bit [24] PBLx8 Mode */
+#define DMA_BUS_MODE_USP		0x00800000	/* bit [23] Use Separate PBL */
+#define DMA_BUS_MODE_RPBL_MASK	0x003e0000	/* bit [22:17] Rx-Programmable Burst Len */
+#define DMA_BUS_MODE_RPBL_SHIFT	17
+#define DMA_BUS_MODE_FB			0x00010000	/* bit [16] Fixed burst */
+#define DMA_BUS_MODE_PBL_MASK	0x00003f00	/* bit [13:8] Programmable Burst Len */
+#define DMA_BUS_MODE_PBL_SHIFT	8
+#define DMA_BUS_MODE_ATDS		0x00000080	/* bit [7] Alternate Descriptor Size */
+#define DMA_BUS_MODE_DSL_MASK	0x0000007c	/* bit [6:2] Descriptor Skip Length */
+#define DMA_BUS_MODE_DSL_SHIFT	2			/* (in DWORDS) */
+#define DMA_BUS_MODE_SFT_RESET	0x00000001	/* bit [0] Software Reset */
+
+/* DMA Operation Mode Register */
+//austin:we have to config DMA_OPERATION_RFD, DMA_OPERATION_RFA and DMA_OPERATION_RTC_256.
+#define DMA_OPERATION_DT		0x00000040	/* bit [26] Disable Dropping of TCP/IP Checksum Error Frames */
+#define DMA_OPERATION_RSF		0x00000020	/* bit [25] Receive Store and Forward*/
+#define DMA_OPERATION_RFA2		0x00800000	/* bit [23] MSB of Threshold for Activating Flow Control */
+#define DMA_OPERATION_RFD2		0x00400000	/* bit [22] MSB of Threshold for Deactivating Flow Control */
+#define DMA_OPERATION_TSF		0x00200000	/* bit [21] TX FIFO Store and Forward */
+#define DMA_OPERATION_FTF		0x00100000	/* bit [20] Flush Transmit FIFO */
+#define DMA_OPERATION_TTC_MASK	0x0001c000	/* bit [16:14] Transmit Threshhold Ctrl */
+#define DMA_OPERATION_RFD_MASK	0x00001800	/* bit [12:11] Threshold for Deactivating Flow Control */
+#define DMA_OPERATION_RFD		0x00000800	/* bit [11] 01: Full minus 2 KB, that is, FULL — 2 KB */
+#define DMA_OPERATION_RFA_MASK	0x00000600	/* bit [10:9] Threshold for Activating Flow Control */
+#define DMA_OPERATION_RFA		0x00000200	/* bit [9] 01: Full minus 2 KB, that is, FULL—2KB. */
+#define DMA_OPERATION_EFC		0x00000100	/* bit [8] Enable Hardware FC */
+#define DMA_OPERATION_FEF		0x00000080	/* bit [7] Forward Error Frames */
+#define DMA_OPERATION_RTC_256	0x00000018	/* RX Threshhold Ctrl */
+#define DMA_OPERATION_RTC_MASK	0x00000018	/* bit [4:3] Receive Threshold Control */
+
+#define DMA_OPERATION_DFF		0x01000000	/* bit [24] Disable Flushing of Received Frames */
+#define DMA_OPERATION_ST		0x00002000	/* bit [13] Start/Stop Transmission */
+#define DMA_OPERATION_OSF		0x00000004	/* bit [3] Operate on 2nd tx frame */
+#define DMA_OPERATION_SR		0x00000002	/* bit [2] Start/Stop Receive */
+
+/* DMA Interrupt Enable Register */
+#define DMA_INTR_ENA_NIE		0x00010000	/* bit [16] Normal Interrupt Summary Enable */
+#define DMA_INTR_ENA_AIE		0x00008000	/* bit [15] Abnormal Interrupt Summary Enable */
+#define DMA_INTR_ENA_ERE		0x00004000	/* bit [14] Early Receive Interrupt Enable */
+#define DMA_INTR_ENA_FBE		0x00002000	/* bit [13] Fatal Bus Error Enable */
+#define DMA_INTR_ENA_ETE		0x00000400	/* bit [10] Early Transmit Interrupt Enable */
+#define DMA_INTR_ENA_RWE		0x00000200	/* bit [9] Receive Watchdog Timeout Enable */
+#define DMA_INTR_ENA_RSE		0x00000100	/* bit [8] Receive Stopped Enable */
+#define DMA_INTR_ENA_RUE		0x00000080	/* bit [7] Receive Buffer Unavailable Enable */
+#define DMA_INTR_ENA_RIE		0x00000040	/* bit [6] Receive Interrupt Enable */
+#define DMA_INTR_ENA_UNE		0x00000020	/* bit [5] Underflow Interrupt Enable */
+#define DMA_INTR_ENA_OVE		0x00000010	/* bit [4] Overflow Interrupt Enable */
+#define DMA_INTR_ENA_TJE		0x00000008	/* bit [3] Transmit Jabber Timeout Enable */
+#define DMA_INTR_ENA_TUE		0x00000004	/* bit [2] Transmit Buffer Unavailable Enable */
+#define DMA_INTR_ENA_TSE		0x00000002	/* bit [1] Transmit Stopped Enable */
+#define DMA_INTR_ENA_TIE		0x00000001	/* bit [0] Transmit Interrupt Enable*/
+
+#define DMA_INTR_NORMAL		(DMA_INTR_ENA_NIE | DMA_INTR_ENA_RIE | \
+				 DMA_INTR_ENA_TUE | DMA_INTR_ENA_TIE)
+
+#define DMA_INTR_ABNORMAL	(DMA_INTR_ENA_AIE | DMA_INTR_ENA_FBE | \
+				 DMA_INTR_ENA_RWE | DMA_INTR_ENA_RSE | \
+				 DMA_INTR_ENA_RUE | DMA_INTR_ENA_UNE | \
+				 DMA_INTR_ENA_OVE | DMA_INTR_ENA_TJE | \
+				 DMA_INTR_ENA_TSE)
+
+/* DMA default interrupt mask */
+#define DMA_INTR_DEFAULT_MASK	(DMA_INTR_NORMAL | DMA_INTR_ABNORMAL)
+
+/* DMA Status Register */
+#define DMA_STATUS_TTI			0x20000000	/* bit [29] Timestamp Trigger Interrupt */
+#define DMA_STATUS_GPI			0x10000000	/* bit [28] GMAC PMT Interrupt*/
+#define DMA_STATUS_GLI			0x04000000	/* bit [26] GMAC Line Interface Interrupt */
+#define DMA_STATUS_EB_MASK		0x00380000	/* bit [25:23] Error Bits */
+#define DMA_STATUS_TS_MASK		0x00700000	/* bit [22:20] Transmit Process State */
+#define DMA_STATUS_TS_SHIFT		20
+#define DMA_STATUS_RS_MASK		0x000e0000	/* bit [19:17] Receive Process State */
+#define DMA_STATUS_RS_SHIFT		17
+#define DMA_STATUS_NIS			0x00010000	/* bit [16] Normal Interrupt Summary */
+#define DMA_STATUS_AIS			0x00008000	/* bit [15] Abnormal Interrupt Summary */
+#define DMA_STATUS_ERI			0x00004000	/* bit [14] Early Receive Interrupt */
+#define DMA_STATUS_FBI			0x00002000	/* bit [13] Fatal Bus Error Interrupt */
+#define DMA_STATUS_ETI			0x00000400	/* bit [10] Early Transmit Interrupt */
+#define DMA_STATUS_RWT			0x00000200	/* bit [9] Receive Watchdog Timeout */
+#define DMA_STATUS_RPS			0x00000100	/* bit [8] Receive Process Stopped */
+#define DMA_STATUS_RU			0x00000080	/* bit [7] Receive Buffer Unavailable */
+#define DMA_STATUS_RI			0x00000040	/* bit [6] Receive Interrupt */
+#define DMA_STATUS_UNF			0x00000020	/* bit [5] Transmit Underflow */
+#define DMA_STATUS_OVF			0x00000010	/* bit [4] Receive Overflow */
+#define DMA_STATUS_TJT			0x00000008	/* bit [3] Transmit Jabber Timeout */
+#define DMA_STATUS_TU			0x00000004	/* bit [2] Transmit Buffer Unavail */
+#define DMA_STATUS_TPS			0x00000002	/* bit [1] Transmit Process Stopped */
+#define DMA_STATUS_TI			0x00000001	/* bit [0] Transmit Interrupt */
+
+/* DMA HW Features Register */
+#define DMA_HW_FEAT_TXCOESEL	0x00010000	/* TX Checksum offload */
+
+/* Timestamp Control Register */
+#define GMAC_TS_CONTROL_ATSEN3		0x10000000	/* bit [28] Auxiliary Snapshot 3 Enable */
+#define GMAC_TS_CONTROL_ATSEN2		0x08000000	/* bit [27] Auxiliary Snapshot 2 Enable */
+#define GMAC_TS_CONTROL_ATSEN1		0x04000000	/* bit [26] Auxiliary Snapshot 1 Enable */
+#define GMAC_TS_CONTROL_ATSEN0		0x02000000	/* bit [25] Auxiliary Snapshot 0 Enable */
+#define GMAC_TS_CONTROL_ATSFC		0x01000000	/* bit [24] Auxiliary Snapshot FIFO Clear */
+#define GMAC_TS_CONTROL_ENMACADDR	0x00040000	/* bit [18] Enable MAC address for PTP Frame Filtering */
+#define GMAC_TS_CONTROL_SNAPTYPSEL	0x00030000	/* bit [17:16] Select PTP packets for Taking Snapshots */
+#define GMAC_TS_CONTROL_BIT16		0x00010000	/* bit [16] Select all PTP packets for Taking Snapshots */
+#define GMAC_TS_CONTROL_TSMSTRENA	0x00008000	/* bit [15] Enable Snapshot for Messages Relevant to Master */
+#define GMAC_TS_CONTROL_TSEVNTENA	0x00004000	/* bit [14] Enable Timestamp Snapshot for Event Messages */
+#define GMAC_TS_CONTROL_TSIPV4ENA	0x00002000	/* bit [13] Enable Processing of PTP Frames Sent over IPv4-UDP */
+#define GMAC_TS_CONTROL_TSIPV6ENA	0x00001000  /* bit [12] Enable Processing of PTP Frames Sent over IPv6-UDP */
+#define GMAC_TS_CONTROL_TSIPENA		0x00000800  /* bit [11] Enable Processing of PTP over Ethernet Frames */
+#define GMAC_TS_CONTROL_TSVER2ENA	0x00000400  /* bit [10] Enable PTP packet Processing for Version 2 Format */
+#define GMAC_TS_CONTROL_TSCTRLSSR	0x00000200  /* bit [9] Timestamp Digital or Binary Rollover Control */
+#define GMAC_TS_CONTROL_TSENALL		0x00000100  /* bit [8] Enable Timestamp for All Frames */
+#define GMAC_TS_CONTROL_TSADDREG	0x00000020  /* bit [5] Addend Reg Update */
+#define GMAC_TS_CONTROL_TSTRIG		0x00000010  /* bit [4] Timestamp Interrupt Trigger Enable */
+#define GMAC_TS_CONTROL_TSUPDT		0x00000008  /* bit [3] Timestamp Update */
+#define GMAC_TS_CONTROL_TSINIT		0x00000004  /* bit [2] Timestamp Initialize */
+#define GMAC_TS_CONTROL_TSCFUPDT	0x00000002  /* bit [1] Timestamp Fine or Coarse Update */
+#define GMAC_TS_CONTROL_TSENA		0x00000001  /* bit [0] Timestamp Enable */
+
+#define GMAC_TS_CONTROL_DEFAULT		(GMAC_TS_CONTROL_ATSEN0 | GMAC_TS_CONTROL_BIT16 | GMAC_TS_CONTROL_TSIPV4ENA | GMAC_TS_CONTROL_TSCFUPDT | \
+									GMAC_TS_CONTROL_TSIPENA | GMAC_TS_CONTROL_TSCTRLSSR | GMAC_TS_CONTROL_TSENA)
+
+/* Timestamp Timestamp Status Register */
+#define GMAC_TS_STATUS_ATSNS		0xbe000000	/* bit [29:25] Number of Auxiliary Timestamp Snapshots */
+#define GMAC_TS_STATUS_ATSSTM		0x01000000	/* bit [24] Auxiliary Timestamp Snapshot Trigger Missed */
+#define GMAC_TS_STATUS_ATSSTN		0x000f0000	/* bit [19:16] Auxiliary Timestamp Snapshot Trigger Identifier */
+#define GMAC_TS_STATUS_TSTRGTERR3	0x00000200	/* bit [9] Timestamp Target Time Error */
+#define GMAC_TS_STATUS_TSTARGT3		0x00000100	/* bit [8] Timestamp Target Time Reached for Target Time PPS3 */
+#define GMAC_TS_STATUS_TSTRGTERR2	0x00000080	/* bit [7] Timestamp Target Time Error */
+#define GMAC_TS_STATUS_TSTARGT2		0x00000040	/* bit [6] Timestamp Target Time Reached for Target Time PPS2 */
+#define GMAC_TS_STATUS_TSTRGTERR1	0x00000020	/* bit [5] Timestamp Target Time Error */
+#define GMAC_TS_STATUS_TSTARGT1		0x00000010	/* bit [4] Timestamp Target Time Reached for Target Time PPS1 */
+#define GMAC_TS_STATUS_TSTRGTERR	0x00000008	/* bit [3] Timestamp Target Time Error */
+#define GMAC_TS_STATUS_AUXTSTRIG	0x00000004	/* bit [2] Auxiliary Timestamp Trigger Snapshot */
+#define GMAC_TS_STATUS_TSTARGT		0x00000002	/* bit [1] Timestamp Target Time Reached */
+#define GMAC_TS_STATUS_TSSOVF		0x00000001	/* bit [0] Timestamp Seconds Overflow */
+
+#define GMAC_PTP_CLOCK				50			/* 50MHz */
+
+/* GMAC Descriptor Defines */
+#define MAX_DESC_BUF_SZ			(0x2000 - 8)
+
+//rxdesc0
+#define RXDESC_EXT_STATUS		0x00000001	/* bit [0] Extended Status Available */
+#define RXDESC_CRC_ERR			0x00000002	/* bit [1] CE: CRC Error */
+#define RXDESC_RX_ERR			0x00000008	/* bit [3] RE: Receive Error */
+#define RXDESC_RX_WDOG			0x00000010	/* bit [4] RWT: Receive Watchdog Timeout */
+#define RXDESC_FRAME_TYPE		0x00000020	/* bit [5] FT: Frame Type */
+#define RXDESC_CHECKSUM_ERR		0x00000080	/* bit [7] IPC Checksum Error */
+#define RXDESC_LAST_SEG			0x00000100	/* bit [8] LS: Last Descriptor */
+#define RXDESC_FIRST_SEG		0x00000200	/* bit [9] FS: First Descriptor */
+#define RXDESC_VLAN_FRAME		0x00000400	/* bit [10] VLAN: VLAN Tag */
+#define RXDESC_OVERFLOW_ERR		0x00000800	/* bit [11] OE: Overflow Error */
+#define RXDESC_LENGTH_ERR		0x00001000	/* bit [12] LE: Length Error */
+#define RXDESC_SA_FILTER_FAIL	0x00002000	/* bit [13] SAF: Source Address Filter Fail */
+#define RXDESC_DESCRIPTOR_ERR	0x00004000	/* bit [14] DE: Descriptor Error */
+#define RXDESC_ERROR_SUMMARY	0x00008000	/* bit [15] ES: Error Summary */
+#define RXDESC_FRAME_LEN_OFFSET	16
+#define RXDESC_FRAME_LEN_MASK	0x3fff0000	/* bit [29:16] FL: Frame Length */
+#define RXDESC_DA_FILTER_FAIL	0x40000000	/* bit [30] AFM: Destination Address Filter Fail */
+
+//rxdesc1
+#define RXDESC1_END_RING		0x00008000	/* bit [15] RER: Receive End of Ring */
+
+//rxdesc4
+#define RXDESC_IP_PAYLOAD_MASK	0x00000003	/* bit [1:0] IP Payload Type */
+#define RXDESC_IP_PAYLOAD_UDP	0x00000001	/* bit [0] UDP */
+#define RXDESC_IP_PAYLOAD_TCP	0x00000002	/* bit [1] TCP */
+#define RXDESC_IP_PAYLOAD_ICMP	0x00000003	/* bit [1:0] ICMP */
+#define RXDESC_IP_HEADER_ERR	0x00000008	/* bit [3] IP Header Error */
+#define RXDESC_IP_PAYLOAD_ERR	0x00000010	/* bit [4] IP Payload Error */
+#define RXDESC_IPV4_PACKET		0x00000040	/* bit [6] IPv4 Packet Received */
+#define RXDESC_IPV6_PACKET		0x00000080	/* bit [7] IPv6 Packet Received */
+
+//txdesc0
+#define TXDESC_UNDERFLOW_ERR	0x00000002	/* bit [1] UF: Underflow Error */
+#define TXDESC_VLAN_FRAME		0x00000080	/* bit [7] VF: VLAN Frame */
+#define TXDESC_PAYLOAD_CSUM_ERR	0x00001000	/* bit [12] IPE: IP Payload Error */
+#define TXDESC_FRAME_FLUSHED	0x00002000	/* bit [13] FF: Frame Flushed */
+#define TXDESC_JABBER_TIMEOUT	0x00004000	/* bit [14] JT: Jabber Timeout */
+#define TXDESC_ERROR_SUMMARY	0x00008000	/* bit [15] IPE: IP Payload Error */
+#define TXDESC_IP_HEADER_ERR	0x00010000	/* bit [16] IHE: IP Header Error */
+#define TXDESC_TX_TS_STATUS		0x00020000	/* bit [17] TTSS: Transmit Timestamp Status */
+#define TXDESC_VLAN_REMOVE		0x00040000	/* bit [18] Remove VLAN tag */
+#define TXDESC_VLAN_INSERT		0x00080000	/* bit [19] Insert a VLAN tag */
+#define TXDESC_VLAN_REPLACE		0x000c0000	/* bit [19:18] Replace the VLAN tag */
+#define TXDESC_2ND_ADDR_CHAINED	0x00100000	/* bit [20] TCH: Second Address Chained */
+#define TXDESC_END_RING			0x00200000	/* bit [21] TER: Transmit End of Ring */
+#define TXDESC_CSUM_IP			0x00400000	/* bit [22] Only IP header checksum calculation and insertion are enabled */
+#define TXDESC_CSUM_IP_PAYLD	0x00800000	/* bit [23] IP header checksum and payload checksum calculation and insertion are enabled,
+											   but pseudo-header checksum is not calculated in hardware */
+#define TXDESC_CSUM_ALL			0x00C00000	/* bit [23:22] CIC: Checksum Insertion Control */
+#define TXDESC_CRC_EN_REPLACE	0x01000000	/* bit [24] CRCR: CRC Replacement Control */
+#define TXDESC_TX_TS_EN			0x02000000	/* bit [25] TTSE: Transmit Timestamp Enable */
+#define TXDESC_DISABLE_PAD		0x04000000	/* bit [26] DP: Disable Pad */
+#define TXDESC_FIRST_SEG		0x10000000	/* bit [28] FS: First Segment */
+#define TXDESC_LAST_SEG			0x20000000	/* bit [29] LS: Last Segment */
+#define TXDESC_INTERRUPT		0x40000000	/* bit [30] IC: Interrupt on Completion */
+
+//rxdesc0 and txdesc0
+#define DESC_OWN				0x80000000	/* bit [31] OWN: Own Bit */
+
+//rxdesc1 and txdesc1
+#define DESC_BUFFER1_SZ_MASK	0x00001fff	/* bit [12:0] TBS1: Transmit Buffer 1 Size */
+#define DESC_BUFFER2_SZ_MASK	0x1fff0000	/* bit [28:16] TBS2: Transmit Buffer 2 Size */
+#define DESC_BUFFER2_SZ_OFFSET	16
+
+#endif
Index: linux-3.18.29/drivers/net/wireless/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/net/wireless/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/net/wireless/Makefile	2017-11-21 20:13:12.442710527 +0800
@@ -11,7 +11,7 @@
 obj-$(CONFIG_AIRO_CS)		+= airo_cs.o airo.o
 
 obj-$(CONFIG_ATMEL)             += atmel.o
-obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
+obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o
 obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
 
 obj-$(CONFIG_AT76C50X_USB)      += at76c50x-usb.o
@@ -60,3 +60,4 @@
 
 obj-$(CONFIG_CW1200)	+= cw1200/
 obj-$(CONFIG_RSI_91X)	+= rsi/
+obj-$(CONFIG_SIFLOWER_WIFI) += siflower/
Index: linux-3.18.29/drivers/pwm/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/pwm/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/pwm/Kconfig	2017-11-21 20:13:12.442710527 +0800
@@ -233,6 +233,15 @@
 	  Generic PWM framework driver for the PWM controller found on
 	  Rockchip SoCs.
 
+config PWM_SFAX8
+	tristate "Siflower SFAX8 PWM support"
+	depends on SIFLOWER
+	help
+	  Generic PWM framework driver for siflower sfax8.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-sfax8.
+
 config PWM_SAMSUNG
 	tristate "Samsung PWM support"
 	depends on PLAT_SAMSUNG
Index: linux-3.18.29/drivers/pwm/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/pwm/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/pwm/Makefile	2017-11-21 20:13:12.442710527 +0800
@@ -22,6 +22,7 @@
 obj-$(CONFIG_PWM_RENESAS_TPU)	+= pwm-renesas-tpu.o
 obj-$(CONFIG_PWM_ROCKCHIP)	+= pwm-rockchip.o
 obj-$(CONFIG_PWM_SAMSUNG)	+= pwm-samsung.o
+obj-$(CONFIG_PWM_SFAX8)	+= pwm-sfax8.o
 obj-$(CONFIG_PWM_SPEAR)		+= pwm-spear.o
 obj-$(CONFIG_PWM_STI)		+= pwm-sti.o
 obj-$(CONFIG_PWM_TEGRA)		+= pwm-tegra.o
Index: linux-3.18.29/drivers/pwm/pwm-sfax8.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/pwm/pwm-sfax8.c	2017-11-21 20:11:40.422707000 +0800
@@ -0,0 +1,638 @@
+/*
+ * Copyright (C) 2016 Shanghai Siflower Communication Technology Co., Ltd.
+ *
+ * PWM driver for Siflower SoCs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/export.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/time.h>
+
+/* For struct sfax8_timer_variant and sfax8_pwm_lock. */
+#include <clocksource/sfax8_pwm.h>
+
+#define REG_TCFG0			0x00
+#define REG_TCFG1			0x04
+#define REG_TCON			0x08
+
+#define REG_TCNTB(chan)			(0x0c + ((chan) * 0xc))
+#define REG_TCMPB(chan)			(0x10 + ((chan) * 0xc))
+
+#define TCFG0_PRESCALER_MASK		0xff
+#define TCFG0_PRESCALER1_SHIFT		8
+
+#define TCFG0_PRES_MASK			0xf
+#define TCFG1_MUX_MASK			0xf
+#define TCFG0_SHIFT(chan)		(8 * (chan))
+#define TCFG1_SHIFT(chan)		(4 * (chan))
+
+/*
+ * Each channel occupies 4 bits in TCON register, but there is a gap of 4
+ * bits (one channel) after channel 0, so channels have different numbering
+ * when accessing TCON register. See to_tcon_channel() function.
+ *
+ * In addition, the location of autoreload bit for channel 4 (TCON channel 5)
+ * in its set of bits is 2 as opposed to 3 for other channels.
+ */
+#define TCON_START(chan)		BIT(4 * (chan) + 0)
+#define TCON_MANUALUPDATE(chan)		BIT(4 * (chan) + 1)
+#define TCON_INVERT(chan)		BIT(4 * (chan) + 2)
+#define _TCON_AUTORELOAD(chan)		BIT(4 * (chan) + 3)
+#define _TCON_AUTORELOAD4(chan)		BIT(4 * (chan) + 2)
+#define TCON_AUTORELOAD(chan)		\
+	((chan < 5) ? _TCON_AUTORELOAD(chan) : _TCON_AUTORELOAD4(chan))
+
+/**
+ * struct sfax8_pwm_channel - private data of PWM channel
+ * @period_ns:	current period in nanoseconds programmed to the hardware
+ * @duty_ns:	current duty time in nanoseconds programmed to the hardware
+ * @tin_ns:	time of one timer tick in nanoseconds with current timer rate
+ */
+struct sfax8_pwm_channel {
+	u32 period_ns;
+	u32 duty_ns;
+	u32 tin_ns;
+};
+
+/**
+ * struct sfax8_pwm_chip - private data of PWM chip
+ * @chip:		generic PWM chip
+ * @variant:		local copy of hardware variant data
+ * @inverter_mask:	inverter status for all channels - one bit per channel
+ * @base:		base address of mapped PWM registers
+ * @base_clk:		base clock used to drive the timers
+ * @tclk0:		external clock 0 (can be ERR_PTR if not present)
+ * @tclk1:		external clock 1 (can be ERR_PTR if not present)
+ */
+struct sfax8_pwm_chip {
+	struct pwm_chip chip;
+	struct sfax8_pwm_variant variant;
+	u8 inverter_mask;
+
+	void __iomem *base;
+	struct clk *base_clk;
+	struct clk *tclk0;
+	struct clk *tclk1;
+};
+
+#ifndef CONFIG_CLKSRC_SFAX8_PWM
+/*
+ * PWM block is shared between pwm-sfax8 and sfax8_pwm_timer drivers
+ * and some registers need access synchronization. If both drivers are
+ * compiled in, the spinlock is defined in the clocksource driver,
+ * otherwise following definition is used.
+ *
+ * Currently we do not need any more complex synchronization method
+ * because all the supported SoCs contain only one instance of the PWM
+ * IP. Should this change, both drivers will need to be modified to
+ * properly synchronize accesses to particular instances.
+ */
+static DEFINE_SPINLOCK(sfax8_pwm_lock);
+#endif
+
+static inline
+struct sfax8_pwm_chip *to_sfax8_pwm_chip(struct pwm_chip *chip)
+{
+	return container_of(chip, struct sfax8_pwm_chip, chip);
+}
+
+static inline unsigned int to_tcon_channel(unsigned int channel)
+{
+	/* TCON register has a gap of 4 bits (1 channel) after channel 0 */
+	return (channel == 0) ? 0 : (channel + 1);
+}
+
+static void pwm_sfax8_set_divisor(struct sfax8_pwm_chip *pwm,
+				    unsigned int channel, u8 divisor)
+{
+	u8 shift = TCFG1_SHIFT(channel);
+	unsigned long flags;
+	u32 reg;
+	u8 bits;
+
+	bits = 8 + (fls(divisor) - 1) - pwm->variant.div_base;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	reg = readl(pwm->base + REG_TCFG1);
+	reg &= ~(TCFG1_MUX_MASK << shift);
+	reg |= bits << shift;
+	writel(reg, pwm->base + REG_TCFG1);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+
+}
+
+static void pwm_sfax8_set_prescaler(struct sfax8_pwm_chip *pwm, unsigned int channel, u8 prescaler)
+{
+	u8 shift = TCFG0_SHIFT(channel);
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	reg = readl(pwm->base + REG_TCFG0);
+	reg &= ~(TCFG0_PRES_MASK << shift);
+	reg |= prescaler << shift;
+	writel(reg, pwm->base + REG_TCFG0);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+}
+
+static int pwm_sfax8_is_tdiv(struct sfax8_pwm_chip *chip, unsigned int chan)
+{
+	struct sfax8_pwm_variant *variant = &chip->variant;
+	u32 reg;
+
+	reg = readl(chip->base + REG_TCFG1);
+	reg >>= TCFG1_SHIFT(chan);
+	reg &= TCFG1_MUX_MASK;
+
+	return (BIT(reg) & variant->tclk_mask) == 0;
+}
+
+static unsigned long pwm_sfax8_get_tin_rate(struct sfax8_pwm_chip *chip,
+					      unsigned int chan)
+{
+	unsigned long rate;
+	u32 reg;
+
+	rate = clk_get_rate(chip->base_clk);
+
+	reg = readl(chip->base + REG_TCFG0);
+	if (chan >= 2)
+		reg >>= TCFG0_PRESCALER1_SHIFT;
+	reg &= TCFG0_PRESCALER_MASK;
+
+	return rate / (reg + 1);
+}
+
+static unsigned long pwm_sfax8_calc_tin(struct sfax8_pwm_chip *chip,
+					  unsigned int chan, unsigned long freq)
+{
+	unsigned long rate;
+	struct clk *clk;
+	u8 div;
+	u8 pres = 1;
+
+	if (!pwm_sfax8_is_tdiv(chip, chan)) {
+		clk = (chan < 2) ? chip->tclk0 : chip->tclk1;
+		if (!IS_ERR(clk)) {
+			rate = clk_get_rate(clk);
+			if (rate)
+				return rate;
+		}
+
+		dev_warn(chip->chip.dev,
+			"tclk of PWM %d is inoperational, using tdiv\n", chan);
+	}
+
+	rate = pwm_sfax8_get_tin_rate(chip, chan);
+	dev_dbg(chip->chip.dev, "tin parent at %lu\n", rate);
+
+	/*
+	 * Compare minimum PWM frequency that can be achieved with possible
+	 * divider settings and choose the lowest divisor that can generate
+	 * frequencies lower than requested.
+	 */
+	if (rate < freq)
+	{
+		dev_err(chip->chip.dev, "can't set so high a frequency like %lu\n", freq);
+		return -EINVAL;
+	}
+
+	for (div = 1; div < 5; div++)
+	{
+		if ((rate >> div) < freq)
+		{
+			div--;
+			break;
+		}
+	}
+
+
+	if (div == 5)
+		div = 4;
+	if (div == 0)
+		div = 5;
+
+	div--;
+
+	pwm_sfax8_set_divisor(chip, chan, BIT(div));
+
+	div++;
+
+	if(div == 1 || div == 2 || div == 3 || div == 4)
+	    rate = rate >> div;
+
+	while((rate / pres) > (freq << 16) && pres < 256)
+		pres++;
+
+	pres--;
+
+	pwm_sfax8_set_prescaler(chip, chan, pres);
+
+	return rate / (pres + 1);
+}
+
+static int pwm_sfax8_request(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct sfax8_pwm_chip *our_chip = to_sfax8_pwm_chip(chip);
+	struct sfax8_pwm_channel *our_chan;
+
+	if (!(our_chip->variant.output_mask & BIT(pwm->hwpwm))) {
+		dev_warn(chip->dev,
+			"tried to request PWM channel %d without output\n",
+			pwm->hwpwm);
+		return -EINVAL;
+	}
+
+	our_chan = devm_kzalloc(chip->dev, sizeof(*our_chan), GFP_KERNEL);
+	if (!our_chan)
+		return -ENOMEM;
+
+	pwm_set_chip_data(pwm, our_chan);
+
+	return 0;
+}
+
+static void pwm_sfax8_free(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	devm_kfree(chip->dev, pwm_get_chip_data(pwm));
+	pwm_set_chip_data(pwm, NULL);
+}
+
+static int pwm_sfax8_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct sfax8_pwm_chip *our_chip = to_sfax8_pwm_chip(chip);
+	unsigned int tcon_chan = to_tcon_channel(pwm->hwpwm);
+	unsigned long flags;
+	u32 tcon;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	tcon = readl(our_chip->base + REG_TCON);
+
+	tcon &= ~TCON_START(tcon_chan);
+	tcon |= TCON_MANUALUPDATE(tcon_chan);
+	writel(tcon, our_chip->base + REG_TCON);
+
+	tcon &= ~TCON_MANUALUPDATE(tcon_chan);
+	tcon |= TCON_START(tcon_chan) | TCON_AUTORELOAD(tcon_chan);
+	writel(tcon, our_chip->base + REG_TCON);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+
+	return 0;
+}
+
+static void pwm_sfax8_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct sfax8_pwm_chip *our_chip = to_sfax8_pwm_chip(chip);
+	unsigned int tcon_chan = to_tcon_channel(pwm->hwpwm);
+	unsigned long flags;
+	u32 tcon;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	tcon = readl(our_chip->base + REG_TCON);
+	tcon &= ~TCON_AUTORELOAD(tcon_chan);
+	writel(tcon, our_chip->base + REG_TCON);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+}
+
+static int pwm_sfax8_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			      int duty_ns, int period_ns)
+{
+	struct sfax8_pwm_chip *our_chip = to_sfax8_pwm_chip(chip);
+	struct sfax8_pwm_channel *chan = pwm_get_chip_data(pwm);
+	u32 tin_ns = chan->tin_ns, tcnt, tcmp;
+
+	/*
+	 * We currently avoid using 64bit arithmetic by using the
+	 * fact that anything faster than 1Hz is easily representable
+	 * by 32bits.
+	 */
+	if (period_ns > NSEC_PER_SEC)
+		return -ERANGE;
+
+	if (period_ns == chan->period_ns && duty_ns == chan->duty_ns)
+		return 0;
+
+	tcnt = readl(our_chip->base + REG_TCNTB(pwm->hwpwm));
+
+	/* We need tick count for calculation, not last tick. */
+	++tcnt;
+
+	/* Check to see if we are changing the clock rate of the PWM. */
+	if (chan->period_ns != period_ns) {
+		unsigned long tin_rate;
+		u32 period;
+
+		period = NSEC_PER_SEC / period_ns;
+
+		dev_dbg(our_chip->chip.dev, "duty_ns=%d, period_ns=%d (%u)\n",
+						duty_ns, period_ns, period);
+
+
+		tin_rate = pwm_sfax8_calc_tin(our_chip, pwm->hwpwm, period);
+
+		dev_dbg(our_chip->chip.dev, "tin_rate=%lu\n", tin_rate);
+
+		tin_ns = NSEC_PER_SEC / tin_rate;
+		tcnt = period_ns / tin_ns;
+	}
+
+	/* Period is too short. */
+	if (tcnt <= 1)
+		return -ERANGE;
+	/* Note that counters count down. */
+	tcmp = duty_ns / tin_ns;
+
+	/* 0% duty is not available */
+	if (!tcmp)
+		++tcmp;
+
+	tcmp = tcnt - tcmp;
+
+	/* Decrement to get tick numbers, instead of tick counts. */
+	--tcnt;
+	/* -1UL will give 100% duty. */
+	--tcmp;
+
+	dev_dbg(our_chip->chip.dev,
+				"tin_ns=%u, tcmp=%u/%u\n", tin_ns, tcmp, tcnt);
+	/* Update PWM registers. */
+	writel(tcnt, our_chip->base + REG_TCNTB(pwm->hwpwm));
+	writel(tcmp, our_chip->base + REG_TCMPB(pwm->hwpwm));
+
+
+	chan->period_ns = period_ns;
+	chan->tin_ns = tin_ns;
+	chan->duty_ns = duty_ns;
+
+	return 0;
+}
+
+static void pwm_sfax8_set_invert(struct sfax8_pwm_chip *chip,
+				   unsigned int channel, bool invert)
+{
+	unsigned int tcon_chan = to_tcon_channel(channel);
+	unsigned long flags;
+	u32 tcon;
+
+	spin_lock_irqsave(&sfax8_pwm_lock, flags);
+
+	tcon = readl(chip->base + REG_TCON);
+
+	if (invert) {
+		chip->inverter_mask |= BIT(channel);
+		tcon |= TCON_INVERT(tcon_chan);
+	} else {
+		chip->inverter_mask &= ~BIT(channel);
+		tcon &= ~TCON_INVERT(tcon_chan);
+	}
+
+	writel(tcon, chip->base + REG_TCON);
+
+	spin_unlock_irqrestore(&sfax8_pwm_lock, flags);
+}
+
+static int pwm_sfax8_set_polarity(struct pwm_chip *chip,
+				    struct pwm_device *pwm,
+				    enum pwm_polarity polarity)
+{
+	struct sfax8_pwm_chip *our_chip = to_sfax8_pwm_chip(chip);
+	bool invert = (polarity == PWM_POLARITY_NORMAL);
+
+	/* Inverted means normal in the hardware. */
+	pwm_sfax8_set_invert(our_chip, pwm->hwpwm, invert);
+
+	return 0;
+}
+
+static const struct pwm_ops pwm_sfax8_ops = {
+	.request	= pwm_sfax8_request,
+	.free		= pwm_sfax8_free,
+	.enable		= pwm_sfax8_enable,
+	.disable	= pwm_sfax8_disable,
+	.config		= pwm_sfax8_config,
+	.set_polarity	= pwm_sfax8_set_polarity,
+	.owner		= THIS_MODULE,
+};
+
+#ifdef CONFIG_OF
+static const struct sfax8_pwm_variant sfa18_variant = {
+	.bits		= 32,
+	.div_base	= 0,
+	.has_tint_cstat	= false,
+	.tclk_mask	= 0,
+};
+
+static const struct of_device_id sfax8_pwm_matches[] = {
+	{ .compatible = "siflower,sfax8-pwm-output", .data = &sfa18_variant },
+	{},
+};
+
+static int pwm_sfax8_parse_dt(struct sfax8_pwm_chip *chip)
+{
+	struct device_node *np = chip->chip.dev->of_node;
+	const struct of_device_id *match;
+	struct property *prop;
+	const __be32 *cur;
+	u32 val;
+
+	match = of_match_node(sfax8_pwm_matches, np);
+	if (!match)
+		return -ENODEV;
+
+	memcpy(&chip->variant, match->data, sizeof(chip->variant));
+
+	of_property_for_each_u32(np, "pwm-outputs", prop, cur, val) {
+		if (val >= SFAX8_PWM_NUM) {
+			dev_err(chip->chip.dev,
+				"%s: invalid channel index in pwm-outputs property\n",
+								__func__);
+			continue;
+		}
+		chip->variant.output_mask |= BIT(val);
+	}
+
+	return 0;
+}
+#else
+static int pwm_sfax8_parse_dt(struct sfax8_pwm_chip *chip)
+{
+	return -ENODEV;
+}
+#endif
+
+static int pwm_sfax8_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sfax8_pwm_chip *chip;
+	struct resource *res;
+	unsigned int chan;
+	int ret;
+
+	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+
+	chip->chip.dev = &pdev->dev;
+	chip->chip.ops = &pwm_sfax8_ops;
+	chip->chip.base = -1;
+	chip->chip.npwm = SFAX8_PWM_NUM;
+	chip->inverter_mask = BIT(SFAX8_PWM_NUM) - 1;
+
+	if (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {
+		ret = pwm_sfax8_parse_dt(chip);
+		if (ret)
+			return ret;
+
+		chip->chip.of_xlate = of_pwm_xlate_with_flags;
+		chip->chip.of_pwm_n_cells = 3;
+	} else {
+		if (!pdev->dev.platform_data) {
+			dev_err(&pdev->dev, "no platform data specified\n");
+			return -EINVAL;
+		}
+
+		memcpy(&chip->variant, pdev->dev.platform_data,
+							sizeof(chip->variant));
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	chip->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(chip->base))
+		return PTR_ERR(chip->base);
+
+	chip->base_clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(chip->base_clk)) {
+		dev_err(dev, "failed to get timer base clk\n");
+		return PTR_ERR(chip->base_clk);
+	}
+
+	ret = clk_prepare_enable(chip->base_clk);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable base clock\n");
+		return ret;
+	}
+
+	for (chan = 0; chan < SFAX8_PWM_NUM; ++chan)
+		if (chip->variant.output_mask & BIT(chan))
+			pwm_sfax8_set_invert(chip, chan, true);
+
+	/* Following clocks are optional. */
+	chip->tclk0 = devm_clk_get(&pdev->dev, "pwm-tclk0");
+	chip->tclk1 = devm_clk_get(&pdev->dev, "pwm-tclk1");
+
+	platform_set_drvdata(pdev, chip);
+
+	ret = pwmchip_add(&chip->chip);
+	if (ret < 0) {
+		dev_err(dev, "failed to register PWM chip\n");
+		clk_disable_unprepare(chip->base_clk);
+		return ret;
+	}
+
+	dev_dbg(dev, "base_clk at %lu, tclk0 at %lu, tclk1 at %lu\n",
+		clk_get_rate(chip->base_clk),
+		!IS_ERR(chip->tclk0) ? clk_get_rate(chip->tclk0) : 0,
+		!IS_ERR(chip->tclk1) ? clk_get_rate(chip->tclk1) : 0);
+
+	return 0;
+}
+
+static int pwm_sfax8_remove(struct platform_device *pdev)
+{
+	struct sfax8_pwm_chip *chip = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = pwmchip_remove(&chip->chip);
+	if (ret < 0)
+		return ret;
+
+	clk_disable_unprepare(chip->base_clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int pwm_sfax8_suspend(struct device *dev)
+{
+	struct sfax8_pwm_chip *chip = dev_get_drvdata(dev);
+	unsigned int i;
+
+	/*
+	 * No one preserves these values during suspend so reset them.
+	 * Otherwise driver leaves PWM unconfigured if same values are
+	 * passed to pwm_config() next time.
+	 */
+	for (i = 0; i < SFAX8_PWM_NUM; ++i) {
+		struct pwm_device *pwm = &chip->chip.pwms[i];
+		struct sfax8_pwm_channel *chan = pwm_get_chip_data(pwm);
+
+		if (!chan)
+			continue;
+
+		chan->period_ns = 0;
+		chan->duty_ns = 0;
+	}
+
+	return 0;
+}
+
+static int pwm_sfax8_resume(struct device *dev)
+{
+	struct sfax8_pwm_chip *chip = dev_get_drvdata(dev);
+	unsigned int chan;
+
+	/*
+	 * Inverter setting must be preserved across suspend/resume
+	 * as nobody really seems to configure it more than once.
+	 */
+	for (chan = 0; chan < SFAX8_PWM_NUM; ++chan) {
+		if (chip->variant.output_mask & BIT(chan))
+			pwm_sfax8_set_invert(chip, chan,
+					chip->inverter_mask & BIT(chan));
+	}
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(pwm_sfax8_pm_ops, pwm_sfax8_suspend,
+			 pwm_sfax8_resume);
+
+static struct platform_driver pwm_sfax8_driver = {
+	.driver		= {
+		.name	= "sfax8-pwm-output",
+		.owner	= THIS_MODULE,
+		.pm	= &pwm_sfax8_pm_ops,
+		.of_match_table = of_match_ptr(sfax8_pwm_matches),
+	},
+	.probe		= pwm_sfax8_probe,
+	.remove		= pwm_sfax8_remove,
+};
+module_platform_driver(pwm_sfax8_driver);
+
+MODULE_DESCRIPTION("SFAx8 PWM driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Qi Zhang <qi.zhang@siflower.com.cn>");
+MODULE_ALIAS("platform:sfax8-pwm");
Index: linux-3.18.29/drivers/regulator/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/regulator/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/regulator/Kconfig	2017-11-21 20:13:12.442710527 +0800
@@ -725,5 +725,33 @@
 	  This driver provides support for the voltage regulators on the
 	  WM8994 CODEC.
 
-endif
+config REGULATOR_SFAX8_IP6103
+	tristate "SIFLOWER SFAX8 PMU Regulators"
+	depends on MFD_SFAX8_IP6103
+	help
+	  This driver provides support for the voltage regulators on the
+	  SFAX8 PMU. This will enable support for all the software
+	  controllable DCDC/LDO regulators.
+
+config SFAX8_PWRMGMT_IP6103
+	tristate "SiFlower SFAX8 power management"
+	default REGULATOR_SFAX8_IP6103
+	help
+	  This driver is for power management, it can configure regulator by
+	  write a file in procfs.
 
+config REGULATOR_SFAX8_RN5T567
+	tristate "SIFLOWER SFAX8 PMU Regulators"
+	depends on MFD_SFAX8_RN5T567
+	help
+	  This driver provides support for the voltage regulators on the
+	  SFAX8 PMU. This will enable support for all the software
+	  controllable DCDC/LDO regulators.
+
+config SFAX8_PWRMGMT_RN5T567
+	tristate "SiFlower SFAX8 power management"
+	default REGULATOR_SFAX8_RN5T567
+	help
+	  This driver is for power management, it can configure regulator by
+	  write a file in procfs.
+endif
Index: linux-3.18.29/drivers/regulator/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/regulator/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/regulator/Makefile	2017-11-21 20:13:12.442710527 +0800
@@ -72,6 +72,10 @@
 obj-$(CONFIG_REGULATOR_S2MPA01) += s2mpa01.o
 obj-$(CONFIG_REGULATOR_S2MPS11) += s2mps11.o
 obj-$(CONFIG_REGULATOR_S5M8767) += s5m8767.o
+obj-$(CONFIG_REGULATOR_SFAX8_IP6103) += sfax8_regulator_ip6103.o
+obj-$(CONFIG_SFAX8_PWRMGMT_IP6103) += sfax8_pwrmgmt_ip6103.o
+obj-$(CONFIG_REGULATOR_SFAX8_RN5T567) += sfax8_regulator_rn5t567.o
+obj-$(CONFIG_SFAX8_PWRMGMT_RN5T567) += sfax8_pwrmgmt_rn5t567.o
 obj-$(CONFIG_REGULATOR_SKY81452) += sky81452-regulator.o
 obj-$(CONFIG_REGULATOR_STW481X_VMMC) += stw481x-vmmc.o
 obj-$(CONFIG_REGULATOR_TI_ABB) += ti-abb-regulator.o
Index: linux-3.18.29/drivers/spi/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/spi/Kconfig	2017-11-21 20:13:12.234710520 +0800
+++ linux-3.18.29/drivers/spi/Kconfig	2017-11-21 20:13:12.442710527 +0800
@@ -490,6 +490,12 @@
 	help
 	  SPI driver for SuperH HSPI blocks.
 
+config SPI_SFAX8
+	tristate "Siflower 16AX8 serial SPI controller"
+	depends on SPI_MASTER
+	help
+	  SPI driver for Siflower 16Ax8 serial SoCs.
+
 config SPI_SIRF
 	tristate "CSR SiRFprimaII SPI controller"
 	depends on SIRF_DMA
Index: linux-3.18.29/drivers/spi/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/spi/Makefile	2017-11-21 20:13:12.234710520 +0800
+++ linux-3.18.29/drivers/spi/Makefile	2017-11-21 20:13:12.442710527 +0800
@@ -70,6 +70,7 @@
 spi-s3c24xx-hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi-s3c24xx-fiq.o
 obj-$(CONFIG_SPI_S3C64XX)		+= spi-s3c64xx.o
 obj-$(CONFIG_SPI_SC18IS602)		+= spi-sc18is602.o
+obj-$(CONFIG_SPI_SFAX8)		+= spi-sfax8.o
 obj-$(CONFIG_SPI_SH)			+= spi-sh.o
 obj-$(CONFIG_SPI_SH_HSPI)		+= spi-sh-hspi.o
 obj-$(CONFIG_SPI_SH_MSIOF)		+= spi-sh-msiof.o
Index: linux-3.18.29/drivers/spi/spi-sfax8.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/spi/spi-sfax8.c	2017-11-15 17:26:54.373090000 +0800
@@ -0,0 +1,1033 @@
+/*
+ * Driver for Siflower Ax8 SPI controller.
+ *
+ * Copyright (C) 2016 Shanghai Siflower Communication Technology Co., Ltd.
+ *
+ * This driver is based on Cirrus Logic EP93xx SPI driver(spi-ep93xx.c).
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/bitops.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/scatterlist.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <sf16a18.h>
+
+#include <linux/dma-mapping.h>
+
+#define SSPCR0			0x0000
+#define SSPCR0_SPO		BIT(6)
+#define SSPCR0_SPH		BIT(7)
+#define SSPCR0_MODE_SHIFT	6
+#define SSPCR0_SCR_SHIFT	8
+
+#define SSPCR1			0x0004
+#define SSPCR1_LBM		BIT(0)
+#define SSPCR1_SSE		BIT(1)
+#define SSPCR1_MS		BIT(2)
+#define SSPCR1_SOD		BIT(3)
+
+#define SSPDR			0x0008
+
+#define SSPSR			0x000c
+#define SSPSR_TFE		BIT(0)
+#define SSPSR_TNF		BIT(1)
+#define SSPSR_RNE		BIT(2)
+#define SSPSR_RFF		BIT(3)
+#define SSPSR_BSY		BIT(4)
+#define SSPCPSR			0x0010
+
+#define SSPIMSCR		0x0014
+#define SSPIMSCR_RORIM	BIT(0)
+#define SSPIMSCR_RXIM	BIT(2)
+#define SSPIMSCR_TXIM	BIT(3)
+
+#define SSPRIS			0x0018
+
+#define SSPMIS			0x001c
+#define SSPMIS_RXMIS	BIT(2)
+#define SSPMIS_TXMIS	BIT(3)
+#define SSPMIS_RORMIS	BIT(0)
+
+#define SSPICR			0x0020
+#define RORIC			BIT(0)
+#define RTIC			BIT(1)
+
+#define SSPDMACR		0x0024
+#define RXDMAE			BIT(0)
+#define TXDMAE			BIT(1)
+
+#define SSPFIFO			0x0028
+
+#define SSP_FSSOUT_NTXDOE_SEL	0x24844
+#define SSP0_CSN_SEL		0x24840
+
+/* The maximum  bytes that a dma BD can transfer.*/
+#define MAX_DMA_BD_BYTES (PAGE_SIZE)
+/* timeout in milliseconds */
+#define SPI_TIMEOUT	40
+/* maximum depth of RX/TX FIFO */
+#define SPI_FIFO_SIZE	64
+
+/**
+ * struct spi_statistics - statistics for spi transfers
+ * @lock:          lock protecting this structure
+ *
+ * @bytes:         number of bytes transferred to/from device
+ */
+struct sfax8_spi_statistics {
+	spinlock_t		lock; /* lock for the whole structure */
+
+	unsigned long long	bytes;
+};
+
+/**
+ * struct sfax8_spi - SFAx8 SPI controller structure
+ * @statistics: statistics for the controller
+ * @dev: pointer to struct device
+ * @master: pointer to spi_master
+ * @clk: clock for the controller
+ * @sys_base: system manager base address
+ * @regs_base: pointer to ioremap()'d registers
+ * @sspdr_phys: physical address of the SSPDR register
+ * @wait: wait until given transfer is completed
+ * @current_xfer: transfer that is currently processed (or %NULL if none)
+ * @tx: current byte in transfer to transmit
+ * @rx: current byte in transfer to receive
+ * @fifo_level: how full is FIFO (%0..%SPI_FIFO_SIZE - %1). Receiving one
+ *              frame decreases this level and sending one frame increases it.
+ * @dma_rx_ch: RX DMA channel
+ * @dma_tx_ch: TX DMA channel
+ */
+struct sfax8_spi {
+	struct sfax8_spi_statistics	statistics;
+	struct device			*dev;
+	struct spi_master		*master;
+	struct clk			*clk;
+	struct regmap			*sys_base;
+	void __iomem			*regs_base;
+	unsigned long			sspdr_phys;
+	struct completion		wait;
+	struct spi_transfer		*current_xfer;
+	size_t				tx;
+	size_t				rx;
+	size_t				fifo_level;
+	struct dma_chan *		dma_rx_ch;
+	struct dma_chan *		dma_tx_ch;
+	int				irq_num;
+	unsigned			use_dma:1;
+	unsigned			dma_callbacked:1;
+};
+
+static ssize_t bytes_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct sfax8_spi *sfspi = dev_get_drvdata(dev);
+	struct sfax8_spi_statistics *stat = &sfspi->statistics;
+	unsigned long flags;
+	ssize_t len;
+
+	spin_lock_irqsave(&stat->lock, flags);
+	len = sprintf(buf, "%llu\n", stat->bytes);
+	spin_unlock_irqrestore(&stat->lock, flags);
+	return len;
+}
+
+static struct device_attribute device_attrs[] = {
+	__ATTR_RO(bytes),
+};
+
+static inline void sfax8_add_transfer_stats(struct sfax8_spi_statistics *stats,
+				       struct spi_transfer *xfer)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&stats->lock, flags);
+	stats->bytes += xfer->len;
+	spin_unlock_irqrestore(&stats->lock, flags);
+}
+
+static int sfax8_init_statistics(struct sfax8_spi *sfspi)
+{
+	struct sfax8_spi_statistics *stat = &sfspi->statistics;
+	struct device *dev = sfspi->dev;
+	int i, error = 0;
+
+	dev_set_drvdata(dev, sfspi);
+	spin_lock_init(&stat->lock);
+
+	for (i = 0; i < ARRAY_SIZE(device_attrs); i++) {
+		error = device_create_file(dev, &device_attrs[i]);
+
+		if (error)
+			break;
+	}
+
+	if (error) {
+		while (--i >= 0)
+			device_remove_file(dev, &device_attrs[i]);
+	}
+
+	return 0;
+}
+
+/* converts bits per word to CR0.DSS value */
+#define bits_per_word_to_dss(bpw)	((bpw) - 1)
+
+static void sfax8_spi_write_u8(const struct sfax8_spi *sfspi,
+				u16 reg, u8 value)
+{
+	writeb(value, sfspi->regs_base + reg);
+}
+
+static u8 sfax8_spi_read_u8(const struct sfax8_spi *spi, u16 reg)
+{
+	return readb(spi->regs_base + reg);
+}
+
+static void sfax8_spi_write_u16(const struct sfax8_spi *sfspi,
+				 u16 reg, u16 value)
+{
+	writew(value, sfspi->regs_base + reg);
+}
+
+static u16 sfax8_spi_read_u16(const struct sfax8_spi *spi, u16 reg)
+{
+	return readw(spi->regs_base + reg);
+}
+
+static void sfax8_spi_dump_regs(const struct sfax8_spi *sfspi)
+{
+	dev_info(sfspi->dev, "CR0=%#x\n", sfax8_spi_read_u16(sfspi, SSPCR0));
+	dev_info(sfspi->dev, "CR1=%#x\n", sfax8_spi_read_u16(sfspi, SSPCR1));
+	dev_info(sfspi->dev, "SR=%#x\n", sfax8_spi_read_u16(sfspi, SSPSR));
+	dev_info(sfspi->dev, "IMSCR=%#x\n", sfax8_spi_read_u16(sfspi, SSPIMSCR));
+	dev_info(sfspi->dev, "RIS=%#x\n", sfax8_spi_read_u16(sfspi, SSPRIS));
+	dev_info(sfspi->dev, "MIS=%#x\n", sfax8_spi_read_u16(sfspi, SSPMIS));
+	dev_info(sfspi->dev, "DMACR=%#x\n", sfax8_spi_read_u16(sfspi, SSPDMACR));
+}
+
+static int sfax8_spi_enable(const struct sfax8_spi *sfspi)
+{
+	u8 regval;
+	/*
+	 * Science the clock can't be disabled, there is
+	 * no need to enable the clock, too.
+	 */
+/* 	int err;
+ *
+ * 	err = clk_enable(sfspi->clk);
+ * 	if (err)
+ * 		return err;
+ */
+
+	regval = sfax8_spi_read_u8(sfspi, SSPCR1);
+	regval |= SSPCR1_SSE;
+	sfax8_spi_write_u8(sfspi, SSPCR1, regval);
+
+	return 0;
+}
+
+static void sfax8_spi_disable(const struct sfax8_spi *sfspi)
+{
+	u8 regval;
+
+	regval = sfax8_spi_read_u8(sfspi, SSPCR1);
+	regval &= ~SSPCR1_SSE;
+	sfax8_spi_write_u8(sfspi, SSPCR1, regval);
+	/*
+	 * Can't disable clock now, or the pbus's clock will be
+	 * disabled!!!(March 7th, 2017)
+	 */
+	/*clk_disable(sfspi->clk);*/
+}
+
+static void sfax8_spi_enable_interrupts(const struct sfax8_spi *sfspi)
+{
+	u8 regval;
+
+	regval = sfax8_spi_read_u8(sfspi, SSPIMSCR);
+	regval |= (SSPIMSCR_RORIM | SSPIMSCR_TXIM | SSPIMSCR_RXIM);
+	sfax8_spi_write_u8(sfspi, SSPIMSCR, regval);
+}
+
+static void sfax8_spi_disable_interrupts(const struct sfax8_spi *sfspi)
+{
+	u8 regval;
+
+	regval = sfax8_spi_read_u8(sfspi, SSPIMSCR);
+	regval &= ~(SSPIMSCR_RORIM | SSPIMSCR_TXIM | SSPIMSCR_RXIM);
+	sfax8_spi_write_u8(sfspi, SSPIMSCR, regval);
+}
+
+/**
+ * sfax8_spi_calc_divisors() - calculates SPI clock divisors
+ * @sfspi: sfax8 SPI controller struct
+ * @rate: desired SPI output clock rate
+ * @div_cpsr: pointer to return the cpsr (pre-scaler) divider
+ * @div_scr: pointer to return the scr divider
+ */
+static int sfax8_spi_calc_divisors(const struct sfax8_spi *sfspi,
+				    u32 rate, u8 *div_cpsr, u8 *div_scr)
+{
+	struct spi_master *master = sfspi->master;
+	unsigned long spi_clk_rate = clk_get_rate(sfspi->clk);
+	int cpsr, scr;
+
+	/*
+	 * Make sure that max value is between values supported by the
+	 * controller.
+	 */
+	rate = clamp(rate, master->min_speed_hz, master->max_speed_hz);
+
+	/*
+	 * Calculate divisors so that we can get speed according the
+	 * following formula:
+	 *	rate = spi_clock_rate / (cpsr * (1 + scr))
+	 *
+	 * cpsr must be even number and starts from 2, scr can be any number
+	 * between 0 and 255.
+	 */
+	for (cpsr = 2; cpsr <= 254; cpsr += 2) {
+		for (scr = 0; scr <= 255; scr++) {
+			if ((spi_clk_rate / (cpsr * (scr + 1))) <= rate) {
+				*div_scr = (u8)scr;
+				*div_cpsr = (u8)cpsr;
+				return 0;
+			}
+		}
+	}
+
+	return -EINVAL;
+}
+
+/**
+ * sfax8_spi_reg_setup() - configures hardware registers
+ * @sfspi: sfax8 SPI controller struct
+ * @spi: spi device struct
+ * @speed_hz: transfer speed
+ * @bits_per_word: transfer bits_per_word
+ */
+static int sfax8_spi_reg_setup(const struct sfax8_spi *sfspi,
+				 const struct spi_device *spi,
+				 u32 speed_hz, u8 bits_per_word)
+{
+	u8 dss = bits_per_word_to_dss(bits_per_word);
+	u8 div_cpsr = 0;
+	u8 div_scr = 0;
+	u32 dmacr = 0;
+	u16 cr0 = 0;
+	u16 cr1 = 0;
+
+	int err;
+
+	err = sfax8_spi_calc_divisors(sfspi, speed_hz, &div_cpsr, &div_scr);
+	if (err)
+		return err;
+
+	cr0 = div_scr << SSPCR0_SCR_SHIFT;
+	cr0 |= dss;
+	if (spi->mode & SPI_CPHA)
+		cr0 |= SSPCR0_SPH;
+	if (spi->mode & SPI_CPOL)
+		cr0 |= SSPCR0_SPO;
+
+	sfax8_spi_write_u8(sfspi, SSPCPSR, div_cpsr);
+	sfax8_spi_write_u16(sfspi, SSPCR0, cr0);
+
+	if (spi->mode & SPI_LOOP) {
+		cr1 |= SSPCR1_LBM;
+		regmap_write(sfspi->sys_base, SSP_FSSOUT_NTXDOE_SEL, 0xf);
+	} else
+		regmap_write(sfspi->sys_base, SSP_FSSOUT_NTXDOE_SEL, 0x0);
+
+	sfax8_spi_write_u8(sfspi, SSPCR1, cr1);
+
+	if (sfspi->use_dma) {
+			dmacr |= TXDMAE;
+			dmacr |= RXDMAE;
+	}
+	sfax8_spi_write_u8(sfspi, SSPDMACR, dmacr);
+
+	return 0;
+}
+
+/**
+ * sfax8_spi_setup() - setup an SPI device
+ * @spi: SPI device to setup
+ *
+ * This function sets up SPI device mode, speed etc. Can be called multiple
+ * times for a single device. Returns %0 in case of success, negative error in
+ * case of failure. When this function returns success, the device is
+ * deselected.
+ */
+static int sfax8_spi_setup(struct spi_device *spi)
+{
+	struct sfax8_spi *sfspi = spi_master_get_devdata(spi->master);
+	int ret;
+	int value = (spi->mode & SPI_CS_HIGH) ? 0 : 1;
+
+	dev_dbg(sfspi->dev, "initial setup for %s\n",
+			spi->modalias);
+
+	ret = gpio_is_valid(spi->cs_gpio);
+	if (!ret) {
+		dev_err(&spi->dev, "cs_gpio(%d) is not valid\n", spi->cs_gpio);
+		return ret;
+	}
+
+	ret = gpio_request(spi->cs_gpio, NULL);
+	if (ret) {
+		dev_err(&spi->dev, "Failed to request gpio %d\n", spi->cs_gpio);
+		return ret;
+	}
+
+	ret = gpio_direction_output(spi->cs_gpio, value);
+	if (ret) {
+		dev_err(&spi->dev, "Failed to set gpio %d's direction\n", spi->cs_gpio);
+		gpio_free(spi->cs_gpio);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void sfax8_spi_cleanup(struct spi_device *spi)
+{
+	if (gpio_is_valid(spi->cs_gpio))
+		gpio_free(spi->cs_gpio);
+}
+
+/*
+ * JFFS2 filesystem may give a buffer address that is in the stack, which is not
+ * DMA safe. This means the transfer may destory the stack data, thus we have to
+ * do a cache sync before we can transfer the message.
+ */
+static int sfax8_spi_prepare_message(struct spi_master *master,
+				  struct spi_message *msg)
+{
+	struct device *dev = &master->dev;
+	struct spi_transfer *xfer;
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		if (master->can_dma && (!master->can_dma(master, msg->spi, xfer)))
+			continue;
+
+		if (xfer->rx_buf != NULL)
+			dma_cache_sync(dev, xfer->rx_buf, xfer->len, DMA_BIDIRECTIONAL);
+	}
+
+	return 0;
+}
+
+static int sfax8_spi_unprepare_message(struct spi_master *master,
+				  struct spi_message *msg)
+{
+	struct sfax8_spi *sfspi = spi_master_get_devdata(master);
+
+	sfax8_spi_disable(sfspi);
+
+	return 0;
+}
+
+static void sfax8_do_write(struct sfax8_spi *sfspi, struct spi_transfer *t)
+{
+	if (t->bits_per_word > 8) {
+		u16 tx_val = 0;
+
+		if (t->tx_buf)
+			tx_val = ((u16 *)t->tx_buf)[sfspi->tx];
+		sfax8_spi_write_u16(sfspi, SSPDR, tx_val);
+		sfspi->tx += sizeof(tx_val);
+	} else {
+		u8 tx_val = 0;
+
+		if (t->tx_buf)
+			tx_val = ((u8 *)t->tx_buf)[sfspi->tx];
+		sfax8_spi_write_u8(sfspi, SSPDR, tx_val);
+		sfspi->tx += sizeof(tx_val);
+
+/*  	dev_dbg(sfspi->dev, "tx=%d,tx_val=%#x,tx_buf=%#x,fifo_level=%d\n",
+ * 			sfspi->tx, tx_val, (int)t->tx_buf,sfspi->fifo_level);
+ */
+
+	}
+}
+
+static void sfax8_do_read(struct sfax8_spi *sfspi, struct spi_transfer *t)
+{
+	if (t->bits_per_word > 8) {
+		u16 rx_val;
+
+		rx_val = sfax8_spi_read_u16(sfspi, SSPDR);
+		if (t->rx_buf)
+			((u16 *)t->rx_buf)[sfspi->rx] = rx_val;
+		sfspi->rx += sizeof(rx_val);
+	} else {
+		u8 rx_val;
+
+		rx_val = sfax8_spi_read_u8(sfspi, SSPDR);
+		if (t->rx_buf)
+			((u8 *)t->rx_buf)[sfspi->rx] = rx_val;
+		sfspi->rx += sizeof(rx_val);
+
+/*  	dev_dbg(sfspi->dev, "rx=%d,rx_val=%#x,rx_buf=%#x,fifo_level=%d\n",
+ * 			sfspi->rx, rx_val, (int)t->rx_buf,sfspi->fifo_level);
+ */
+
+	}
+}
+
+/**
+ * sfax8_spi_read_write() - perform next RX/TX transfer
+ * @sfspi: sfax8 SPI controller struct
+ *
+ * This function transfers next bytes (or half-words) to/from RX/TX FIFOs. If
+ * called several times, the whole transfer will be completed. Returns
+ * %-EINPROGRESS when current transfer was not yet completed otherwise %0.
+ *
+ * When this function is finished, RX FIFO should be empty and TX FIFO should be
+ * full.
+ */
+static int sfax8_spi_read_write(struct sfax8_spi *sfspi)
+{
+	struct spi_transfer *t = sfspi->current_xfer;
+
+	/* read as long as RX FIFO has frames in it */
+	while ((sfax8_spi_read_u8(sfspi, SSPSR) & SSPSR_RNE)) {
+		sfax8_do_read(sfspi, t);
+		sfspi->fifo_level--;
+	}
+
+	/* write as long as TX FIFO has room */
+	while (sfspi->fifo_level < SPI_FIFO_SIZE && sfspi->tx < t->len) {
+		sfax8_do_write(sfspi, t);
+		sfspi->fifo_level++;
+	}
+
+	if (sfspi->rx == t->len)
+		return 0;
+
+	return -EINPROGRESS;
+}
+
+static int sfax8_spi_pio_transfer(struct sfax8_spi *sfspi)
+{
+	/*
+	 * Now everything is set up for the current transfer. We prime the TX
+	 * FIFO, enable interrupts, and wait for the transfer to complete.
+	 */
+	if (sfax8_spi_read_write(sfspi)) {
+		sfax8_spi_enable_interrupts(sfspi);
+	}
+	return sfspi->current_xfer->len;
+}
+
+/**
+ * sfax8_spi_dma_prepare() - prepares a DMA transfer
+ * @sfspi: sfax8 SPI controller struct
+ * @dir: DMA transfer direction
+ *
+ * Function configures the DMA, maps the buffer and prepares the DMA
+ * descriptor. Returns a valid DMA descriptor in case of success and ERR_PTR
+ * in case of failure.
+ */
+static struct dma_async_tx_descriptor *
+sfax8_spi_dma_prepare(struct sfax8_spi *sfspi, struct dma_chan *chan, struct sg_table *sgt, enum dma_transfer_direction dir)
+{
+	struct spi_transfer *t = sfspi->current_xfer;
+	struct dma_async_tx_descriptor *txd;
+	enum dma_slave_buswidth buswidth;
+	struct dma_slave_config conf;
+	int ret;
+
+	if (t->bits_per_word > 8)
+		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	else
+		buswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;
+
+	memset(&conf, 0, sizeof(conf));
+	conf.direction = dir;
+
+	if (dir == DMA_DEV_TO_MEM) {
+		conf.src_addr = sfspi->sspdr_phys;
+		conf.src_addr_width = buswidth;
+	} else {
+		conf.dst_addr = sfspi->sspdr_phys;
+		conf.dst_addr_width = buswidth;
+	}
+
+	ret = dmaengine_slave_config(chan, &conf);
+	if (ret){
+		dev_dbg(sfspi->dev, "dma %s config fail!\n", dma_chan_name(chan));
+		return ERR_PTR(ret);
+	}
+
+	txd = dmaengine_prep_slave_sg(chan, sgt->sgl, sgt->nents, dir, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!txd) {
+		dev_dbg(sfspi->dev, "dma %s prep fail!\n", dma_chan_name(chan));
+		return ERR_PTR(-ENOMEM);
+	}
+	return txd;
+}
+
+static void sfax8_spi_dma_callback(void *callback_param)
+{
+	struct sfax8_spi *sfspi = callback_param;
+
+	sfspi->dma_callbacked = 1;
+	complete(&sfspi->wait);
+}
+
+static int sfax8_spi_dma_transfer(struct sfax8_spi *sfspi)
+{
+	struct spi_transfer *t = sfspi->current_xfer;
+	struct dma_async_tx_descriptor *rxd, *txd;
+	dma_cookie_t cookie;
+	unsigned long long ms = 1;
+	int ret;
+
+	if ((!t->rx_sg.sgl) || (!t->tx_sg.sgl)) {
+		ret = -EAGAIN;
+		goto no_dma;
+	}
+
+	rxd = sfax8_spi_dma_prepare(sfspi, sfspi->dma_rx_ch,
+			&t->rx_sg, DMA_DEV_TO_MEM);
+	if (IS_ERR(rxd)) {
+		dev_err(sfspi->dev, "DMA RX failed: %ld\n", PTR_ERR(rxd));
+		ret = -EAGAIN;
+		goto no_dma_rx;
+	}
+
+	txd = sfax8_spi_dma_prepare(sfspi, sfspi->dma_tx_ch,
+			&t->tx_sg, DMA_MEM_TO_DEV);
+	if (IS_ERR(txd)) {
+		dev_err(sfspi->dev, "DMA TX failed: %ld\n", PTR_ERR(txd));
+		ret = -EAGAIN;
+		goto no_dma_tx;
+	}
+
+	/* We are ready when RX is done */
+	rxd->callback = sfax8_spi_dma_callback;
+	rxd->callback_param = sfspi;
+
+	/* Now submit both descriptors and wait while they finish */
+	cookie = dmaengine_submit(rxd);
+	if (dma_submit_error(cookie)) {
+		ret = cookie;
+		goto no_dma_rx;
+	}
+	cookie = dmaengine_submit(txd);
+	if (dma_submit_error(cookie)) {
+		ret = cookie;
+		goto no_dma_tx;
+	}
+
+	sfspi->dma_callbacked = 0;
+
+	dma_async_issue_pending(sfspi->dma_rx_ch);
+	dma_async_issue_pending(sfspi->dma_tx_ch);
+
+ 	/* Cauculate transfer time */
+  	ms = 8LL * 1000LL * t->len;
+  	do_div(ms, t->speed_hz);
+  	ms += ms + 200; /* some tolerance */
+
+  	if (ms > UINT_MAX)
+  		ms = UINT_MAX;
+
+	ret = wait_for_completion_timeout(&sfspi->wait,
+				msecs_to_jiffies(ms));
+	if (ret > 0 && sfspi->dma_callbacked)
+  		ret = 0;
+  	else if (!ret) {
+  		dev_err(&sfspi->master->dev, "DMA timeout(%#llx=%#lx, len=%d)\n",
+  		    ms, msecs_to_jiffies(ms), t->len);
+		sfax8_spi_dump_regs(sfspi);
+  		ret = -ETIMEDOUT;
+  		if (txd)
+  			dmaengine_terminate_all(sfspi->dma_tx_ch);
+  		if (rxd)
+  			dmaengine_terminate_all(sfspi->dma_rx_ch);
+  	}
+
+	sfax8_spi_disable(sfspi);
+	return 0;
+
+no_dma_tx:
+	if (rxd)
+		dmaengine_terminate_all(sfspi->dma_rx_ch);
+no_dma_rx:
+no_dma:
+	if (ret == -EAGAIN) {
+		pr_warn_once("%s %s: DMA not available, falling back to PIO\n",
+			     dev_driver_string(&sfspi->master->dev),
+			     dev_name(&sfspi->master->dev));
+	}
+	return ret;
+}
+
+/**
+ * sfax8_spi_process_transfer() - processes one SPI transfer
+ * @sfspi: sfax8 SPI controller struct
+ * @t: transfer to process
+ *
+ * This function processes one SPI transfer given in @t. Function waits until
+ * transfer is complete (may sleep) and updates @msg->status based on whether
+ * transfer was successfully processed or not.
+ */
+static int sfax8_spi_process_transfer(struct spi_master *master,
+					struct spi_device *spi,
+					struct spi_transfer *t)
+{
+	struct sfax8_spi *sfspi = spi_master_get_devdata(master);
+	unsigned long timeout;
+	int err;
+
+	sfspi->current_xfer = t;
+
+	sfax8_add_transfer_stats(&sfspi->statistics, t);
+
+	if (master->can_dma && master->can_dma(master, spi, t))
+		sfspi->use_dma = 1;
+	else
+		sfspi->use_dma = 0;
+
+	err = sfax8_spi_reg_setup(sfspi, spi, t->speed_hz, t->bits_per_word);
+	if (err) {
+		dev_err(sfspi->dev,
+			"failed to setup chip for transfer\n");
+		return err;
+	}
+
+	err = sfax8_spi_enable(sfspi);
+	if (err) {
+		dev_err(sfspi->dev, "failed to enable SPI controller\n");
+		return err;
+	}
+
+	/* Interrupt status can only be cleared when spi is enabled */
+	sfax8_spi_write_u8(sfspi, SSPICR, RORIC | RTIC);
+
+	/*
+	 * Just to be sure: flush any data from RX FIFO.
+	 */
+	timeout = jiffies + msecs_to_jiffies(SPI_TIMEOUT);
+	while (sfax8_spi_read_u16(sfspi, SSPSR) & SSPSR_RNE) {
+		if (time_after(jiffies, timeout)) {
+			dev_warn(sfspi->dev,
+					"timeout while flushing RX FIFO\n");
+			return -ETIMEDOUT;
+		}
+		sfax8_spi_read_u16(sfspi, SSPDR);
+	}
+
+	sfspi->rx = 0;
+	sfspi->tx = 0;
+
+	/*
+	 * We explicitly handle FIFO level. This way we don't have to check TX
+	 * FIFO status using %SSPSR_TNF bit which may cause RX FIFO overruns.
+	 */
+	sfspi->fifo_level = 0;
+
+	/*
+	 * If DMA transfer failed, we try to use pio transfer.
+	 */
+	if (sfspi->use_dma) {
+		err = sfax8_spi_dma_transfer(sfspi);
+
+		if (err != -EAGAIN) {
+			return err;
+		}
+	}
+
+	err = sfax8_spi_pio_transfer(sfspi);
+	return err;
+}
+
+static irqreturn_t sfax8_spi_interrupt(int irq, void *dev_id)
+{
+	struct sfax8_spi *sfspi = dev_id;
+	u8 irq_status = sfax8_spi_read_u8(sfspi, SSPMIS);
+
+	/*
+	 * If we got ROR (receive overrun) interrupt we know that something is
+	 * wrong. Just abort the transfer.
+	 */
+	if (unlikely(irq_status & SSPMIS_RORMIS)) {
+		/* clear the overrun interrupt */
+		sfax8_spi_write_u8(sfspi, SSPICR, SSPIMSCR_RORIM);
+		dev_warn(sfspi->dev,
+			 "receive overrun, aborting the transfer\n");
+	} else {
+		/*
+		 * Interrupt is either RX (RIS) or TX (TIS). For both cases we
+		 * simply execute next data transfer.
+		 */
+		if (sfax8_spi_read_write(sfspi)) {
+			/*
+			 * In normal case, there still is some processing left
+			 * for current transfer. Let's wait for the next
+			 * interrupt then.
+			 */
+			return IRQ_HANDLED;
+		}
+	}
+
+	/*
+	 * Current transfer is finished, either with error or with success. In
+	 * any case we disable interrupts and notify the worker to handle
+	 * any post-processing of the message.
+	 */
+	sfax8_spi_disable_interrupts(sfspi);
+	sfax8_spi_disable(sfspi);
+	spi_finalize_current_transfer(sfspi->master);
+	return IRQ_HANDLED;
+}
+
+static bool sfax8_spi_can_dma(struct spi_master *master, struct spi_device *spi,
+			 struct spi_transfer *xfer)
+{
+	/*
+	 * There is no point of setting up DMA for the transfers which will
+	 * fit into the FIFO and can be transferred with a single interrupt.
+	 * So in these cases we will be using PIO and don't bother for DMA.
+	 */
+	return xfer->len > SPI_FIFO_SIZE;
+}
+
+static int sfax8_dma_autoprobe(struct sfax8_spi *sfspi)
+{
+	struct device *dev = &sfspi->master->dev;
+	struct spi_master *master = sfspi->master;
+	int ret;
+
+	/* automatically configure DMA channels from platform, normally using DT */
+	sfspi->dma_rx_ch = dma_request_slave_channel(dev, "rx");
+	if (!sfspi->dma_rx_ch) {
+		ret = -ENODEV;
+		dev_dbg(sfspi->dev, "DMA request rx channel fail\n");
+		goto err_no_rxchan;
+	}
+	dev_dbg(sfspi->dev,"DMA channel RX %s\n",dma_chan_name(sfspi->dma_rx_ch));
+
+	sfspi->dma_tx_ch = dma_request_slave_channel(dev, "tx");
+	if (!sfspi->dma_tx_ch) {
+		ret = -ENODEV;
+		dev_dbg(sfspi->dev, "DMA request tx channel fail\n");
+		goto err_no_txchan;
+	}
+	dev_dbg(sfspi->dev, "DMA channel TX %s\n", dma_chan_name(sfspi->dma_tx_ch));
+
+	if (sfspi->dma_rx_ch && sfspi->dma_tx_ch) {
+		master->can_dma = sfax8_spi_can_dma;
+		master->dma_tx = sfspi->dma_tx_ch;
+		master->dma_rx = sfspi->dma_rx_ch;
+		master->max_dma_len = MAX_DMA_BD_BYTES;
+	}
+
+	dev_info(sfspi->dev, "DMA available");
+	return 0;
+
+err_no_txchan:
+	dma_release_channel(sfspi->dma_rx_ch);
+	sfspi->dma_rx_ch = NULL;
+err_no_rxchan:
+	return ret;
+}
+
+static void sfax8_spi_release_dma(struct sfax8_spi *sfspi)
+{
+	if (sfspi->dma_rx_ch)
+		dma_release_channel(sfspi->dma_rx_ch);
+	if (sfspi->dma_tx_ch)
+		dma_release_channel(sfspi->dma_tx_ch);
+}
+
+static int sfax8_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct sfax8_spi *sfspi;
+	struct device_node *nc, *grf_node;
+	struct resource *res;
+	int value;
+	int irq;
+	int error = 0;
+
+	dev_info(&pdev->dev, "sfax8_spi_probe...\n");
+
+	if(release_reset(SF_SPI_SOFT_RESET))
+		return -EFAULT;
+
+	nc = pdev->dev.of_node;
+	if (!nc)
+		return -ENODEV;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "failed to get irq resources\n");
+		return -EBUSY;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "unable to get iomem resource\n");
+		return -ENODEV;
+	}
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sfspi));
+	if (!master)
+		return -ENOMEM;
+
+	if (of_property_read_u32(nc, "num-cs", &value)) {
+		dev_err(&pdev->dev, "%s has no valid 'num-cs' property\n",
+				nc->full_name);
+		goto fail_release_master;
+	}
+	master->num_chipselect = value;
+	master->dev.of_node = pdev->dev.of_node;
+
+	master->setup = sfax8_spi_setup;
+	master->cleanup = sfax8_spi_cleanup;
+	master->transfer_one = sfax8_spi_process_transfer;
+	master->prepare_message = sfax8_spi_prepare_message;
+	master->unprepare_message = sfax8_spi_unprepare_message;
+	master->bus_num = pdev->id;
+	master->mode_bits = SPI_MODE_3 | SPI_LOOP;
+	master->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;
+	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
+
+	platform_set_drvdata(pdev, master);
+
+	sfspi = spi_master_get_devdata(master);
+	sfspi->master = master;
+
+	sfspi->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(sfspi->clk)) {
+		dev_err(&pdev->dev, "unable to get spi clock\n");
+		error = PTR_ERR(&sfspi->clk);
+		goto fail_release_master;
+	}
+
+	grf_node = of_parse_phandle(nc, "sfgrf", 0);
+	sfspi->sys_base = syscon_node_to_regmap(grf_node);
+	if (IS_ERR(sfspi->sys_base)) {
+		dev_err(&pdev->dev, "Unable to get system control base\n");
+		error = PTR_ERR(sfspi->sys_base);
+		goto fail_release_master;
+	}
+
+	init_completion(&sfspi->wait);
+
+	/*
+	 * Calculate maximum and minimum supported clock rates
+	 * for the controller.
+	 */
+	master->max_speed_hz = clk_get_rate(sfspi->clk) / 2;
+	master->min_speed_hz = clk_get_rate(sfspi->clk) / (254 * 256);
+
+	sfspi->dev = &pdev->dev;
+	sfspi->sspdr_phys = res->start + SSPDR;
+
+	sfspi->regs_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(sfspi->regs_base)) {
+		error = PTR_ERR(sfspi->regs_base);
+		goto fail_release_master;
+	}
+
+	error = devm_request_irq(&pdev->dev, irq, sfax8_spi_interrupt,
+				0, "sfax8-spi", sfspi);
+	if (error) {
+		dev_err(&pdev->dev, "failed to request irq\n");
+		goto fail_release_master;
+	}
+	sfspi->irq_num = irq;
+
+	if (of_find_property(nc, "use-dma", NULL) && sfax8_dma_autoprobe(sfspi))
+		dev_warn(&pdev->dev, "DMA setup failed. Falling back to PIO\n");
+
+	/* make sure that the hardware is disabled */
+	sfax8_spi_write_u8(sfspi, SSPCR1, 0);
+
+	/* add statistics */
+	if (sfax8_init_statistics(sfspi))
+		dev_err(&pdev->dev, "failed to creat sfax8 spi attributes\n");
+
+	error = devm_spi_register_master(&pdev->dev, master);
+	if (error) {
+		dev_err(&pdev->dev, "failed to register SPI master\n");
+		goto fail_free_dma;
+	}
+
+	dev_info(&pdev->dev, "SFAx8 SPI Controller at 0x%08lx irq %d\n",
+		 (unsigned long)res->start, irq);
+
+	return 0;
+
+fail_free_dma:
+	sfax8_spi_release_dma(sfspi);
+fail_release_master:
+	spi_master_put(master);
+
+	return error;
+}
+
+static int sfax8_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct sfax8_spi *sfspi = spi_master_get_devdata(master);
+
+	sfax8_spi_release_dma(sfspi);
+
+	if(hold_reset(SF_SPI_SOFT_RESET))
+		return -EFAULT;
+
+	return 0;
+}
+
+static const struct of_device_id sfspi_of_match[] = {
+	{ .compatible = "siflower,sfax8-spi", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sfspi_of_match);
+
+static struct platform_driver sfax8_spi_driver = {
+	.driver		= {
+		.name	= "sfax8-spi",
+		.of_match_table = sfspi_of_match,
+	},
+	.probe		= sfax8_spi_probe,
+	.remove		= sfax8_spi_remove,
+};
+module_platform_driver(sfax8_spi_driver);
+
+MODULE_DESCRIPTION("SFAx8 SPI Controller driver");
+MODULE_AUTHOR("Qi Zhang <qi.zhang@siflower.com.cn>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sfax8-spi");
Index: linux-3.18.29/drivers/tty/serial/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/tty/serial/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/tty/serial/Kconfig	2017-11-21 20:13:12.442710527 +0800
@@ -73,6 +73,21 @@
 	  your boot loader (lilo or loadlin) about how to pass options to the
 	  kernel at boot time.)
 
+config SERIAL_SFAX8
+	tristate "SIFLOWER serial port support"
+	depends on SIFLOWER
+	select SERIAL_CORE
+	help
+	  SF16A18 uart driver.
+
+config SERIAL_SFAX8_CONSOLE
+	bool "Support for console on SFAX8 serial port"
+	depends on SERIAL_SFAX8=y
+	select SERIAL_CORE_CONSOLE
+	select SERIAL_EARLYCON
+	---help---
+		SFAX8 serial console.
+
 config SERIAL_EARLYCON_ARM_SEMIHOST
 	bool "Early console using ARM semihosting"
 	depends on ARM64 || ARM
@@ -262,7 +277,7 @@
 	help
 	  Select the number of available UART ports for the Samsung S3C
 	  serial driver
-	
+
 config SERIAL_SAMSUNG_DEBUG
 	bool "Samsung SoC serial debug"
 	depends on SERIAL_SAMSUNG && DEBUG_LL
@@ -698,8 +713,8 @@
 	depends on PARISC && !SERIAL_MUX && VT
 	default n
 	help
-	  Saying Y here will enable the software based PDC console to be 
-	  used as the system console.  This is useful for machines in 
+	  Saying Y here will enable the software based PDC console to be
+	  used as the system console.  This is useful for machines in
 	  which the hardware based console has not been written yet.  The
 	  following steps must be competed to use the PDC console:
 
@@ -890,7 +905,7 @@
 	depends on CPM2 || 8xx
 	select SERIAL_CORE
 	help
-	  This driver supports the SCC and SMC serial ports on Motorola 
+	  This driver supports the SCC and SMC serial ports on Motorola
 	  embedded PowerPC that contain a CPM1 (8xx) or CPM2 (8xxx)
 
 config SERIAL_CPM_CONSOLE
Index: linux-3.18.29/drivers/tty/serial/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/tty/serial/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/tty/serial/Makefile	2017-11-21 20:13:12.442710527 +0800
@@ -22,6 +22,7 @@
 
 obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
+obj-$(CONFIG_SERIAL_SFAX8) += sfax8_uart.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
 obj-$(CONFIG_SERIAL_PXA) += pxa.o
 obj-$(CONFIG_SERIAL_PNX8XXX) += pnx8xxx_uart.o
Index: linux-3.18.29/drivers/tty/serial/amba-pl011.c
===================================================================
--- linux-3.18.29.orig/drivers/tty/serial/amba-pl011.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/tty/serial/amba-pl011.c	2017-11-21 20:13:12.442710527 +0800
@@ -58,6 +58,9 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/sizes.h>
 #include <linux/io.h>
+#include <linux/acpi.h>
+
+#include "amba-pl011.h"
 
 #define UART_NR			14
 
@@ -70,14 +73,32 @@
 #define UART_DR_ERROR		(UART011_DR_OE|UART011_DR_BE|UART011_DR_PE|UART011_DR_FE)
 #define UART_DUMMY_DR_RX	(1 << 16)
 
+static u16 pl011_std_offsets[REG_ARRAY_SIZE] = {
+	[REG_DR] = UART01x_DR,
+	[REG_FR] = UART01x_FR,
+	[REG_LCRH_RX] = UART011_LCRH,
+	[REG_LCRH_TX] = UART011_LCRH,
+	[REG_IBRD] = UART011_IBRD,
+	[REG_FBRD] = UART011_FBRD,
+	[REG_CR] = UART011_CR,
+	[REG_IFLS] = UART011_IFLS,
+	[REG_IMSC] = UART011_IMSC,
+	[REG_RIS] = UART011_RIS,
+	[REG_MIS] = UART011_MIS,
+	[REG_ICR] = UART011_ICR,
+	[REG_DMACR] = UART011_DMACR,
+};
+
 /* There is by now at least one vendor with differing details, so handle it */
 struct vendor_data {
+	const u16		*reg_offset;
 	unsigned int		ifls;
-	unsigned int		lcrh_tx;
-	unsigned int		lcrh_rx;
+	bool			access_32b;
 	bool			oversampling;
 	bool			dma_threshold;
 	bool			cts_event_workaround;
+	bool			always_enabled;
+	bool			fixed_options;
 
 	unsigned int (*get_fifosize)(struct amba_device *dev);
 };
@@ -88,30 +109,92 @@
 }
 
 static struct vendor_data vendor_arm = {
+	.reg_offset		= pl011_std_offsets,
 	.ifls			= UART011_IFLS_RX4_8|UART011_IFLS_TX4_8,
-	.lcrh_tx		= UART011_LCRH,
-	.lcrh_rx		= UART011_LCRH,
 	.oversampling		= false,
 	.dma_threshold		= false,
 	.cts_event_workaround	= false,
+	.always_enabled		= false,
+	.fixed_options		= false,
 	.get_fifosize		= get_fifosize_arm,
 };
 
+static struct vendor_data vendor_sbsa = {
+	.reg_offset		= pl011_std_offsets,
+	.access_32b		= true,
+	.oversampling		= false,
+	.dma_threshold		= false,
+	.cts_event_workaround	= false,
+	.always_enabled		= true,
+	.fixed_options		= true,
+};
+
+static u16 pl011_st_offsets[REG_ARRAY_SIZE] = {
+	[REG_DR] = UART01x_DR,
+	[REG_ST_DMAWM] = ST_UART011_DMAWM,
+	[REG_ST_TIMEOUT] = ST_UART011_TIMEOUT,
+	[REG_FR] = UART01x_FR,
+	[REG_LCRH_RX] = ST_UART011_LCRH_RX,
+	[REG_LCRH_TX] = ST_UART011_LCRH_TX,
+	[REG_IBRD] = UART011_IBRD,
+	[REG_FBRD] = UART011_FBRD,
+	[REG_CR] = UART011_CR,
+	[REG_IFLS] = UART011_IFLS,
+	[REG_IMSC] = UART011_IMSC,
+	[REG_RIS] = UART011_RIS,
+	[REG_MIS] = UART011_MIS,
+	[REG_ICR] = UART011_ICR,
+	[REG_DMACR] = UART011_DMACR,
+	[REG_ST_XFCR] = ST_UART011_XFCR,
+	[REG_ST_XON1] = ST_UART011_XON1,
+	[REG_ST_XON2] = ST_UART011_XON2,
+	[REG_ST_XOFF1] = ST_UART011_XOFF1,
+	[REG_ST_XOFF2] = ST_UART011_XOFF2,
+	[REG_ST_ITCR] = ST_UART011_ITCR,
+	[REG_ST_ITIP] = ST_UART011_ITIP,
+	[REG_ST_ABCR] = ST_UART011_ABCR,
+	[REG_ST_ABIMSC] = ST_UART011_ABIMSC,
+};
+
 static unsigned int get_fifosize_st(struct amba_device *dev)
 {
 	return 64;
 }
 
 static struct vendor_data vendor_st = {
+	.reg_offset		= pl011_st_offsets,
 	.ifls			= UART011_IFLS_RX_HALF|UART011_IFLS_TX_HALF,
-	.lcrh_tx		= ST_UART011_LCRH_TX,
-	.lcrh_rx		= ST_UART011_LCRH_RX,
 	.oversampling		= true,
 	.dma_threshold		= true,
 	.cts_event_workaround	= true,
+	.always_enabled		= false,
+	.fixed_options		= false,
 	.get_fifosize		= get_fifosize_st,
 };
 
+static const u16 pl011_zte_offsets[REG_ARRAY_SIZE] = {
+	[REG_DR] = ZX_UART011_DR,
+	[REG_FR] = ZX_UART011_FR,
+	[REG_LCRH_RX] = ZX_UART011_LCRH,
+	[REG_LCRH_TX] = ZX_UART011_LCRH,
+	[REG_IBRD] = ZX_UART011_IBRD,
+	[REG_FBRD] = ZX_UART011_FBRD,
+	[REG_CR] = ZX_UART011_CR,
+	[REG_IFLS] = ZX_UART011_IFLS,
+	[REG_IMSC] = ZX_UART011_IMSC,
+	[REG_RIS] = ZX_UART011_RIS,
+	[REG_MIS] = ZX_UART011_MIS,
+	[REG_ICR] = ZX_UART011_ICR,
+	[REG_DMACR] = ZX_UART011_DMACR,
+};
+
+static struct vendor_data vendor_zte __maybe_unused = {
+	.reg_offset		= pl011_zte_offsets,
+	.access_32b		= true,
+	.ifls			= UART011_IFLS_RX4_8|UART011_IFLS_TX4_8,
+	.get_fifosize		= get_fifosize_arm,
+};
+
 /* Deals with DMA transactions */
 
 struct pl011_sgbuf {
@@ -147,16 +230,16 @@
  */
 struct uart_amba_port {
 	struct uart_port	port;
+	const u16		*reg_offset;
 	struct clk		*clk;
 	const struct vendor_data *vendor;
 	unsigned int		dmacr;		/* dma control reg */
 	unsigned int		im;		/* interrupt mask */
 	unsigned int		old_status;
 	unsigned int		fifosize;	/* vendor-specific */
-	unsigned int		lcrh_tx;	/* vendor-specific */
-	unsigned int		lcrh_rx;	/* vendor-specific */
 	unsigned int		old_cr;		/* state during shutdown */
 	bool			autorts;
+	unsigned int		fixed_baud;	/* vendor-set fixed baud rate */
 	char			type[12];
 #ifdef CONFIG_DMA_ENGINE
 	/* DMA stuff */
@@ -164,9 +247,36 @@
 	bool			using_rx_dma;
 	struct pl011_dmarx_data dmarx;
 	struct pl011_dmatx_data	dmatx;
+	bool			dma_probed;
 #endif
 };
 
+static unsigned int pl011_reg_to_offset(const struct uart_amba_port *uap,
+	unsigned int reg)
+{
+	return uap->reg_offset[reg];
+}
+
+static unsigned int pl011_read(const struct uart_amba_port *uap,
+	unsigned int reg)
+{
+	void __iomem *addr = uap->port.membase + pl011_reg_to_offset(uap, reg);
+
+	return (uap->port.iotype == UPIO_MEM32) ?
+		readl_relaxed(addr) : readw_relaxed(addr);
+}
+
+static void pl011_write(unsigned int val, const struct uart_amba_port *uap,
+	unsigned int reg)
+{
+	void __iomem *addr = uap->port.membase + pl011_reg_to_offset(uap, reg);
+
+	if (uap->port.iotype == UPIO_MEM32)
+		writel_relaxed(val, addr);
+	else
+		writew_relaxed(val, addr);
+}
+
 /*
  * Reads up to 256 characters from the FIFO or until it's empty and
  * inserts them into the TTY layer. Returns the number of characters
@@ -174,18 +284,17 @@
  */
 static int pl011_fifo_to_tty(struct uart_amba_port *uap)
 {
-	u16 status, ch;
-	unsigned int flag, max_count = 256;
+	u16 status;
+	unsigned int ch, flag, max_count = 256;
 	int fifotaken = 0;
 
 	while (max_count--) {
-		status = readw(uap->port.membase + UART01x_FR);
+		status = pl011_read(uap, REG_FR);
 		if (status & UART01x_FR_RXFE)
 			break;
 
 		/* Take chars from the FIFO and update status */
-		ch = readw(uap->port.membase + UART01x_DR) |
-			UART_DUMMY_DR_RX;
+		ch = pl011_read(uap, REG_DR) | UART_DUMMY_DR_RX;
 		flag = TTY_NORMAL;
 		uap->port.icount.rx++;
 		fifotaken++;
@@ -246,6 +355,7 @@
 	sg_set_page(&sg->sg, phys_to_page(dma_addr),
 		PL011_DMA_BUFFER_SIZE, offset_in_page(dma_addr));
 	sg_dma_address(&sg->sg) = dma_addr;
+	sg_dma_len(&sg->sg) = PL011_DMA_BUFFER_SIZE;
 
 	return 0;
 }
@@ -260,12 +370,14 @@
 	}
 }
 
-static void pl011_dma_probe_initcall(struct device *dev, struct uart_amba_port *uap)
+static void pl011_dma_probe(struct uart_amba_port *uap)
 {
 	/* DMA is the sole user of the platform data right now */
 	struct amba_pl011_data *plat = dev_get_platdata(uap->port.dev);
+	struct device *dev = uap->port.dev;
 	struct dma_slave_config tx_conf = {
-		.dst_addr = uap->port.mapbase + UART01x_DR,
+		.dst_addr = uap->port.mapbase +
+				 pl011_reg_to_offset(uap, REG_DR),
 		.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,
 		.direction = DMA_MEM_TO_DEV,
 		.dst_maxburst = uap->fifosize >> 1,
@@ -274,9 +386,14 @@
 	struct dma_chan *chan;
 	dma_cap_mask_t mask;
 
-	chan = dma_request_slave_channel(dev, "tx");
+	uap->dma_probed = true;
+	chan = dma_request_slave_channel_reason(dev, "tx");
+	if (IS_ERR(chan)) {
+		if (PTR_ERR(chan) == -EPROBE_DEFER) {
+			uap->dma_probed = false;
+			return;
+		}
 
-	if (!chan) {
 		/* We need platform data */
 		if (!plat || !plat->dma_filter) {
 			dev_info(uap->port.dev, "no DMA platform data\n");
@@ -304,7 +421,7 @@
 	/* Optionally make use of an RX channel as well */
 	chan = dma_request_slave_channel(dev, "rx");
 
-	if (!chan && plat->dma_rx_param) {
+	if (!chan && plat && plat->dma_rx_param) {
 		chan = dma_request_channel(mask, plat->dma_filter, plat->dma_rx_param);
 
 		if (!chan) {
@@ -315,16 +432,33 @@
 
 	if (chan) {
 		struct dma_slave_config rx_conf = {
-			.src_addr = uap->port.mapbase + UART01x_DR,
+			.src_addr = uap->port.mapbase +
+				pl011_reg_to_offset(uap, REG_DR),
 			.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,
 			.direction = DMA_DEV_TO_MEM,
 			.src_maxburst = uap->fifosize >> 2,
 			.device_fc = false,
 		};
+		struct dma_slave_caps caps;
 
+		/*
+		 * Some DMA controllers provide information on their capabilities.
+		 * If the controller does, check for suitable residue processing
+		 * otherwise assime all is well.
+		 */
+		if (0 == dma_get_slave_caps(chan, &caps)) {
+			if (caps.residue_granularity ==
+					DMA_RESIDUE_GRANULARITY_DESCRIPTOR) {
+				dma_release_channel(chan);
+				dev_info(uap->port.dev,
+					"RX DMA disabled - no residue processing\n");
+				return;
+			}
+		}
 		dmaengine_slave_config(chan, &rx_conf);
 		uap->dmarx.chan = chan;
 
+		uap->dmarx.auto_poll_rate = false;
 		if (plat && plat->dma_rx_poll_enable) {
 			/* Set poll rate if specified. */
 			if (plat->dma_rx_poll_rate) {
@@ -345,71 +479,40 @@
 					plat->dma_rx_poll_timeout;
 			else
 				uap->dmarx.poll_timeout = 3000;
-		} else
-			uap->dmarx.auto_poll_rate = false;
-
+		} else if (!plat && dev->of_node) {
+			uap->dmarx.auto_poll_rate = of_property_read_bool(
+						dev->of_node, "auto-poll");
+			if (uap->dmarx.auto_poll_rate) {
+				u32 x;
+
+				if (0 == of_property_read_u32(dev->of_node,
+						"poll-rate-ms", &x))
+					uap->dmarx.poll_rate = x;
+				else
+					uap->dmarx.poll_rate = 100;
+				if (0 == of_property_read_u32(dev->of_node,
+						"poll-timeout-ms", &x))
+					uap->dmarx.poll_timeout = x;
+				else
+					uap->dmarx.poll_timeout = 3000;
+			}
+		}
 		dev_info(uap->port.dev, "DMA channel RX %s\n",
 			 dma_chan_name(uap->dmarx.chan));
 	}
 }
 
-#ifndef MODULE
-/*
- * Stack up the UARTs and let the above initcall be done at device
- * initcall time, because the serial driver is called as an arch
- * initcall, and at this time the DMA subsystem is not yet registered.
- * At this point the driver will switch over to using DMA where desired.
- */
-struct dma_uap {
-	struct list_head node;
-	struct uart_amba_port *uap;
-	struct device *dev;
-};
-
-static LIST_HEAD(pl011_dma_uarts);
-
-static int __init pl011_dma_initcall(void)
-{
-	struct list_head *node, *tmp;
-
-	list_for_each_safe(node, tmp, &pl011_dma_uarts) {
-		struct dma_uap *dmau = list_entry(node, struct dma_uap, node);
-		pl011_dma_probe_initcall(dmau->dev, dmau->uap);
-		list_del(node);
-		kfree(dmau);
-	}
-	return 0;
-}
-
-device_initcall(pl011_dma_initcall);
-
-static void pl011_dma_probe(struct device *dev, struct uart_amba_port *uap)
-{
-	struct dma_uap *dmau = kzalloc(sizeof(struct dma_uap), GFP_KERNEL);
-	if (dmau) {
-		dmau->uap = uap;
-		dmau->dev = dev;
-		list_add_tail(&dmau->node, &pl011_dma_uarts);
-	}
-}
-#else
-static void pl011_dma_probe(struct device *dev, struct uart_amba_port *uap)
-{
-	pl011_dma_probe_initcall(dev, uap);
-}
-#endif
-
 static void pl011_dma_remove(struct uart_amba_port *uap)
 {
-	/* TODO: remove the initcall if it has not yet executed */
 	if (uap->dmatx.chan)
 		dma_release_channel(uap->dmatx.chan);
 	if (uap->dmarx.chan)
 		dma_release_channel(uap->dmarx.chan);
 }
 
-/* Forward declare this for the refill routine */
+/* Forward declare these for the refill routine */
 static int pl011_dma_tx_refill(struct uart_amba_port *uap);
+static void pl011_start_tx_pio(struct uart_amba_port *uap);
 
 /*
  * The current DMA TX buffer has been sent.
@@ -429,7 +532,7 @@
 
 	dmacr = uap->dmacr;
 	uap->dmacr = dmacr & ~UART011_TXDMAE;
-	writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+	pl011_write(uap->dmacr, uap, REG_DMACR);
 
 	/*
 	 * If TX DMA was disabled, it means that we've stopped the DMA for
@@ -447,14 +550,13 @@
 		return;
 	}
 
-	if (pl011_dma_tx_refill(uap) <= 0) {
+	if (pl011_dma_tx_refill(uap) <= 0)
 		/*
 		 * We didn't queue a DMA buffer for some reason, but we
 		 * have data pending to be sent.  Re-enable the TX IRQ.
 		 */
-		uap->im |= UART011_TXIM;
-		writew(uap->im, uap->port.membase + UART011_IMSC);
-	}
+		pl011_start_tx_pio(uap);
+
 	spin_unlock_irqrestore(&uap->port.lock, flags);
 }
 
@@ -501,7 +603,11 @@
 		memcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], count);
 	else {
 		size_t first = UART_XMIT_SIZE - xmit->tail;
-		size_t second = xmit->head;
+		size_t second;
+
+		if (first > count)
+			first = count;
+		second = count - first;
 
 		memcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], first);
 		if (second)
@@ -540,7 +646,7 @@
 	dma_dev->device_issue_pending(chan);
 
 	uap->dmacr |= UART011_TXDMAE;
-	writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+	pl011_write(uap->dmacr, uap, REG_DMACR);
 	uap->dmatx.queued = true;
 
 	/*
@@ -576,9 +682,9 @@
 	 */
 	if (uap->dmatx.queued) {
 		uap->dmacr |= UART011_TXDMAE;
-		writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+		pl011_write(uap->dmacr, uap, REG_DMACR);
 		uap->im &= ~UART011_TXIM;
-		writew(uap->im, uap->port.membase + UART011_IMSC);
+		pl011_write(uap->im, uap, REG_IMSC);
 		return true;
 	}
 
@@ -588,7 +694,7 @@
 	 */
 	if (pl011_dma_tx_refill(uap) > 0) {
 		uap->im &= ~UART011_TXIM;
-		writew(uap->im, uap->port.membase + UART011_IMSC);
+		pl011_write(uap->im, uap, REG_IMSC);
 		return true;
 	}
 	return false;
@@ -602,7 +708,7 @@
 {
 	if (uap->dmatx.queued) {
 		uap->dmacr &= ~UART011_TXDMAE;
-		writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+		pl011_write(uap->dmacr, uap, REG_DMACR);
 	}
 }
 
@@ -628,16 +734,12 @@
 		if (!uap->dmatx.queued) {
 			if (pl011_dma_tx_refill(uap) > 0) {
 				uap->im &= ~UART011_TXIM;
-				ret = true;
-			} else {
-				uap->im |= UART011_TXIM;
+				pl011_write(uap->im, uap, REG_IMSC);
+			} else
 				ret = false;
-			}
-			writew(uap->im, uap->port.membase + UART011_IMSC);
 		} else if (!(uap->dmacr & UART011_TXDMAE)) {
 			uap->dmacr |= UART011_TXDMAE;
-			writew(uap->dmacr,
-				       uap->port.membase + UART011_DMACR);
+			pl011_write(uap->dmacr, uap, REG_DMACR);
 		}
 		return ret;
 	}
@@ -648,9 +750,9 @@
 	 */
 	dmacr = uap->dmacr;
 	uap->dmacr &= ~UART011_TXDMAE;
-	writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+	pl011_write(uap->dmacr, uap, REG_DMACR);
 
-	if (readw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF) {
+	if (pl011_read(uap, REG_FR) & UART01x_FR_TXFF) {
 		/*
 		 * No space in the FIFO, so enable the transmit interrupt
 		 * so we know when there is space.  Note that once we've
@@ -659,13 +761,13 @@
 		return false;
 	}
 
-	writew(uap->port.x_char, uap->port.membase + UART01x_DR);
+	pl011_write(uap->port.x_char, uap, REG_DR);
 	uap->port.icount.tx++;
 	uap->port.x_char = 0;
 
 	/* Success - restore the DMA state */
 	uap->dmacr = dmacr;
-	writew(dmacr, uap->port.membase + UART011_DMACR);
+	pl011_write(dmacr, uap, REG_DMACR);
 
 	return true;
 }
@@ -693,7 +795,7 @@
 			     DMA_TO_DEVICE);
 		uap->dmatx.queued = false;
 		uap->dmacr &= ~UART011_TXDMAE;
-		writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+		pl011_write(uap->dmacr, uap, REG_DMACR);
 	}
 }
 
@@ -733,11 +835,11 @@
 	dma_async_issue_pending(rxchan);
 
 	uap->dmacr |= UART011_RXDMAE;
-	writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+	pl011_write(uap->dmacr, uap, REG_DMACR);
 	uap->dmarx.running = true;
 
 	uap->im &= ~UART011_RXIM;
-	writew(uap->im, uap->port.membase + UART011_IMSC);
+	pl011_write(uap->im, uap, REG_IMSC);
 
 	return 0;
 }
@@ -795,8 +897,8 @@
 	 */
 	if (dma_count == pending && readfifo) {
 		/* Clear any error flags */
-		writew(UART011_OEIS | UART011_BEIS | UART011_PEIS | UART011_FEIS,
-		       uap->port.membase + UART011_ICR);
+		pl011_write(UART011_OEIS | UART011_BEIS | UART011_PEIS |
+			    UART011_FEIS, uap, REG_ICR);
 
 		/*
 		 * If we read all the DMA'd characters, and we had an
@@ -844,7 +946,7 @@
 
 	/* Disable RX DMA - incoming data will wait in the FIFO */
 	uap->dmacr &= ~UART011_RXDMAE;
-	writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+	pl011_write(uap->dmacr, uap, REG_DMACR);
 	uap->dmarx.running = false;
 
 	pending = sgbuf->sg.length - state.residue;
@@ -864,7 +966,7 @@
 		dev_dbg(uap->port.dev, "could not retrigger RX DMA job "
 			"fall back to interrupt mode\n");
 		uap->im |= UART011_RXIM;
-		writew(uap->im, uap->port.membase + UART011_IMSC);
+		pl011_write(uap->im, uap, REG_IMSC);
 	}
 }
 
@@ -912,7 +1014,7 @@
 		dev_dbg(uap->port.dev, "could not retrigger RX DMA job "
 			"fall back to interrupt mode\n");
 		uap->im |= UART011_RXIM;
-		writew(uap->im, uap->port.membase + UART011_IMSC);
+		pl011_write(uap->im, uap, REG_IMSC);
 	}
 }
 
@@ -925,7 +1027,7 @@
 {
 	/* FIXME.  Just disable the DMA enable */
 	uap->dmacr &= ~UART011_RXDMAE;
-	writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+	pl011_write(uap->dmacr, uap, REG_DMACR);
 }
 
 /*
@@ -969,7 +1071,7 @@
 		spin_lock_irqsave(&uap->port.lock, flags);
 		pl011_dma_rx_stop(uap);
 		uap->im |= UART011_RXIM;
-		writew(uap->im, uap->port.membase + UART011_IMSC);
+		pl011_write(uap->im, uap, REG_IMSC);
 		spin_unlock_irqrestore(&uap->port.lock, flags);
 
 		uap->dmarx.running = false;
@@ -985,10 +1087,13 @@
 {
 	int ret;
 
+	if (!uap->dma_probed)
+		pl011_dma_probe(uap);
+
 	if (!uap->dmatx.chan)
 		return;
 
-	uap->dmatx.buf = kmalloc(PL011_DMA_BUFFER_SIZE, GFP_KERNEL);
+	uap->dmatx.buf = kmalloc(PL011_DMA_BUFFER_SIZE, GFP_KERNEL | __GFP_DMA);
 	if (!uap->dmatx.buf) {
 		dev_err(uap->port.dev, "no memory for DMA TX buffer\n");
 		uap->port.fifosize = uap->fifosize;
@@ -1028,7 +1133,7 @@
 skip_rx:
 	/* Turn on DMA error (RX/TX will be enabled on demand) */
 	uap->dmacr |= UART011_DMAONERR;
-	writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+	pl011_write(uap->dmacr, uap, REG_DMACR);
 
 	/*
 	 * ST Micro variants has some specific dma burst threshold
@@ -1036,8 +1141,8 @@
 	 * be issued above/below 16 bytes.
 	 */
 	if (uap->vendor->dma_threshold)
-		writew(ST_UART011_DMAWM_RX_16 | ST_UART011_DMAWM_TX_16,
-			       uap->port.membase + ST_UART011_DMAWM);
+		pl011_write(ST_UART011_DMAWM_RX_16 | ST_UART011_DMAWM_TX_16,
+			    uap, REG_ST_DMAWM);
 
 	if (uap->using_rx_dma) {
 		if (pl011_dma_rx_trigger_dma(uap))
@@ -1062,12 +1167,12 @@
 		return;
 
 	/* Disable RX and TX DMA */
-	while (readw(uap->port.membase + UART01x_FR) & UART01x_FR_BUSY)
-		barrier();
+	while (pl011_read(uap, REG_FR) & UART01x_FR_BUSY)
+		cpu_relax();
 
 	spin_lock_irq(&uap->port.lock);
 	uap->dmacr &= ~(UART011_DMAONERR | UART011_RXDMAE | UART011_TXDMAE);
-	writew(uap->dmacr, uap->port.membase + UART011_DMACR);
+	pl011_write(uap->dmacr, uap, REG_DMACR);
 	spin_unlock_irq(&uap->port.lock);
 
 	if (uap->using_tx_dma) {
@@ -1106,7 +1211,7 @@
 
 #else
 /* Blank functions if the DMA engine is not available */
-static inline void pl011_dma_probe(struct device *dev, struct uart_amba_port *uap)
+static inline void pl011_dma_probe(struct uart_amba_port *uap)
 {
 }
 
@@ -1168,19 +1273,27 @@
 	    container_of(port, struct uart_amba_port, port);
 
 	uap->im &= ~UART011_TXIM;
-	writew(uap->im, uap->port.membase + UART011_IMSC);
+	pl011_write(uap->im, uap, REG_IMSC);
 	pl011_dma_tx_stop(uap);
 }
 
+static void pl011_tx_chars(struct uart_amba_port *uap, bool from_irq);
+
+/* Start TX with programmed I/O only (no DMA) */
+static void pl011_start_tx_pio(struct uart_amba_port *uap)
+{
+	uap->im |= UART011_TXIM;
+	pl011_write(uap->im, uap, REG_IMSC);
+	pl011_tx_chars(uap, false);
+}
+
 static void pl011_start_tx(struct uart_port *port)
 {
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
 
-	if (!pl011_dma_tx_start(uap)) {
-		uap->im |= UART011_TXIM;
-		writew(uap->im, uap->port.membase + UART011_IMSC);
-	}
+	if (!pl011_dma_tx_start(uap))
+		pl011_start_tx_pio(uap);
 }
 
 static void pl011_stop_rx(struct uart_port *port)
@@ -1190,7 +1303,7 @@
 
 	uap->im &= ~(UART011_RXIM|UART011_RTIM|UART011_FEIM|
 		     UART011_PEIM|UART011_BEIM|UART011_OEIM);
-	writew(uap->im, uap->port.membase + UART011_IMSC);
+	pl011_write(uap->im, uap, REG_IMSC);
 
 	pl011_dma_rx_stop(uap);
 }
@@ -1201,7 +1314,7 @@
 	    container_of(port, struct uart_amba_port, port);
 
 	uap->im |= UART011_RIMIM|UART011_CTSMIM|UART011_DCDMIM|UART011_DSRMIM;
-	writew(uap->im, uap->port.membase + UART011_IMSC);
+	pl011_write(uap->im, uap, REG_IMSC);
 }
 
 static void pl011_rx_chars(struct uart_amba_port *uap)
@@ -1221,7 +1334,7 @@
 			dev_dbg(uap->port.dev, "could not trigger RX DMA job "
 				"fall back to interrupt mode again\n");
 			uap->im |= UART011_RXIM;
-			writew(uap->im, uap->port.membase + UART011_IMSC);
+			pl011_write(uap->im, uap, REG_IMSC);
 		} else {
 #ifdef CONFIG_DMA_ENGINE
 			/* Start Rx DMA poll */
@@ -1238,16 +1351,29 @@
 	spin_lock(&uap->port.lock);
 }
 
-static void pl011_tx_chars(struct uart_amba_port *uap)
+static bool pl011_tx_char(struct uart_amba_port *uap, unsigned char c,
+			  bool from_irq)
+{
+	if (unlikely(!from_irq) &&
+	    pl011_read(uap, REG_FR) & UART01x_FR_TXFF)
+		return false; /* unable to transmit character */
+
+	pl011_write(c, uap, REG_DR);
+	uap->port.icount.tx++;
+
+	return true;
+}
+
+static void pl011_tx_chars(struct uart_amba_port *uap, bool from_irq)
 {
 	struct circ_buf *xmit = &uap->port.state->xmit;
-	int count;
+	int count = uap->fifosize >> 1;
 
 	if (uap->port.x_char) {
-		writew(uap->port.x_char, uap->port.membase + UART01x_DR);
-		uap->port.icount.tx++;
+		if (!pl011_tx_char(uap, uap->port.x_char, from_irq))
+			return;
 		uap->port.x_char = 0;
-		return;
+		--count;
 	}
 	if (uart_circ_empty(xmit) || uart_tx_stopped(&uap->port)) {
 		pl011_stop_tx(&uap->port);
@@ -1258,14 +1384,15 @@
 	if (pl011_dma_tx_irq(uap))
 		return;
 
-	count = uap->fifosize >> 1;
 	do {
-		writew(xmit->buf[xmit->tail], uap->port.membase + UART01x_DR);
-		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		uap->port.icount.tx++;
-		if (uart_circ_empty(xmit))
+		if (likely(from_irq) && count-- == 0)
 			break;
-	} while (--count > 0);
+
+		if (!pl011_tx_char(uap, xmit->buf[xmit->tail], from_irq))
+			break;
+
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+	} while (!uart_circ_empty(xmit));
 
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
 		uart_write_wakeup(&uap->port);
@@ -1278,7 +1405,7 @@
 {
 	unsigned int status, delta;
 
-	status = readw(uap->port.membase + UART01x_FR) & UART01x_FR_MODEM_ANY;
+	status = pl011_read(uap, REG_FR) & UART01x_FR_MODEM_ANY;
 
 	delta = status ^ uap->old_status;
 	uap->old_status = status;
@@ -1298,34 +1425,43 @@
 	wake_up_interruptible(&uap->port.state->port.delta_msr_wait);
 }
 
+static void check_apply_cts_event_workaround(struct uart_amba_port *uap)
+{
+	unsigned int dummy_read;
+
+	if (!uap->vendor->cts_event_workaround)
+		return;
+
+	/* workaround to make sure that all bits are unlocked.. */
+	pl011_write(0x00, uap, REG_ICR);
+
+	/*
+	 * WA: introduce 26ns(1 uart clk) delay before W1C;
+	 * single apb access will incur 2 pclk(133.12Mhz) delay,
+	 * so add 2 dummy reads
+	 */
+	dummy_read = pl011_read(uap, REG_ICR);
+	dummy_read = pl011_read(uap, REG_ICR);
+}
+
 static irqreturn_t pl011_int(int irq, void *dev_id)
 {
 	struct uart_amba_port *uap = dev_id;
 	unsigned long flags;
 	unsigned int status, pass_counter = AMBA_ISR_PASS_LIMIT;
+	u16 imsc;
 	int handled = 0;
-	unsigned int dummy_read;
 
 	spin_lock_irqsave(&uap->port.lock, flags);
-	status = readw(uap->port.membase + UART011_MIS);
+	imsc = pl011_read(uap, REG_IMSC);
+	status = pl011_read(uap, REG_RIS) & imsc;
 	if (status) {
 		do {
-			if (uap->vendor->cts_event_workaround) {
-				/* workaround to make sure that all bits are unlocked.. */
-				writew(0x00, uap->port.membase + UART011_ICR);
+			check_apply_cts_event_workaround(uap);
 
-				/*
-				 * WA: introduce 26ns(1 uart clk) delay before W1C;
-				 * single apb access will incur 2 pclk(133.12Mhz) delay,
-				 * so add 2 dummy reads
-				 */
-				dummy_read = readw(uap->port.membase + UART011_ICR);
-				dummy_read = readw(uap->port.membase + UART011_ICR);
-			}
-
-			writew(status & ~(UART011_TXIS|UART011_RTIS|
-					  UART011_RXIS),
-			       uap->port.membase + UART011_ICR);
+			pl011_write(status & ~(UART011_TXIS|UART011_RTIS|
+					       UART011_RXIS),
+				    uap, REG_ICR);
 
 			if (status & (UART011_RTIS|UART011_RXIS)) {
 				if (pl011_dma_rx_running(uap))
@@ -1337,12 +1473,12 @@
 				      UART011_CTSMIS|UART011_RIMIS))
 				pl011_modem_status(uap);
 			if (status & UART011_TXIS)
-				pl011_tx_chars(uap);
+				pl011_tx_chars(uap, true);
 
 			if (pass_counter-- == 0)
 				break;
 
-			status = readw(uap->port.membase + UART011_MIS);
+			status = pl011_read(uap, REG_RIS) & imsc;
 		} while (status != 0);
 		handled = 1;
 	}
@@ -1356,7 +1492,7 @@
 {
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
-	unsigned int status = readw(uap->port.membase + UART01x_FR);
+	unsigned int status = pl011_read(uap, REG_FR);
 	return status & (UART01x_FR_BUSY|UART01x_FR_TXFF) ? 0 : TIOCSER_TEMT;
 }
 
@@ -1365,7 +1501,7 @@
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
 	unsigned int result = 0;
-	unsigned int status = readw(uap->port.membase + UART01x_FR);
+	unsigned int status = pl011_read(uap, REG_FR);
 
 #define TIOCMBIT(uartbit, tiocmbit)	\
 	if (status & uartbit)		\
@@ -1385,7 +1521,7 @@
 	    container_of(port, struct uart_amba_port, port);
 	unsigned int cr;
 
-	cr = readw(uap->port.membase + UART011_CR);
+	cr = pl011_read(uap, REG_CR);
 
 #define	TIOCMBIT(tiocmbit, uartbit)		\
 	if (mctrl & tiocmbit)		\
@@ -1405,7 +1541,7 @@
 	}
 #undef TIOCMBIT
 
-	writew(cr, uap->port.membase + UART011_CR);
+	pl011_write(cr, uap, REG_CR);
 }
 
 static void pl011_break_ctl(struct uart_port *port, int break_state)
@@ -1416,12 +1552,12 @@
 	unsigned int lcr_h;
 
 	spin_lock_irqsave(&uap->port.lock, flags);
-	lcr_h = readw(uap->port.membase + uap->lcrh_tx);
+	lcr_h = pl011_read(uap, REG_LCRH_TX);
 	if (break_state == -1)
 		lcr_h |= UART01x_LCRH_BRK;
 	else
 		lcr_h &= ~UART01x_LCRH_BRK;
-	writew(lcr_h, uap->port.membase + uap->lcrh_tx);
+	pl011_write(lcr_h, uap, REG_LCRH_TX);
 	spin_unlock_irqrestore(&uap->port.lock, flags);
 }
 
@@ -1431,9 +1567,8 @@
 {
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
-	unsigned char __iomem *regs = uap->port.membase;
 
-	writew(readw(regs + UART011_MIS), regs + UART011_ICR);
+	pl011_write(pl011_read(uap, REG_MIS), uap, REG_ICR);
 	/*
 	 * There is no way to clear TXIM as this is "ready to transmit IRQ", so
 	 * we simply mask it. start_tx() will unmask it.
@@ -1447,7 +1582,8 @@
 	 * (including tx queue), so we're also fine with start_tx()'s caller
 	 * side.
 	 */
-	writew(readw(regs + UART011_IMSC) & ~UART011_TXIM, regs + UART011_IMSC);
+	pl011_write(pl011_read(uap, REG_IMSC) & ~UART011_TXIM, uap,
+		    REG_IMSC);
 }
 
 static int pl011_get_poll_char(struct uart_port *port)
@@ -1462,11 +1598,11 @@
 	 */
 	pl011_quiesce_irqs(port);
 
-	status = readw(uap->port.membase + UART01x_FR);
+	status = pl011_read(uap, REG_FR);
 	if (status & UART01x_FR_RXFE)
 		return NO_POLL_CHAR;
 
-	return readw(uap->port.membase + UART01x_DR);
+	return pl011_read(uap, REG_DR);
 }
 
 static void pl011_put_poll_char(struct uart_port *port,
@@ -1475,10 +1611,10 @@
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
 
-	while (readw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF)
-		barrier();
+	while (pl011_read(uap, REG_FR) & UART01x_FR_TXFF)
+		cpu_relax();
 
-	writew(ch, uap->port.membase + UART01x_DR);
+	pl011_write(ch, uap, REG_DR);
 }
 
 #endif /* CONFIG_CONSOLE_POLL */
@@ -1502,15 +1638,16 @@
 	uap->port.uartclk = clk_get_rate(uap->clk);
 
 	/* Clear pending error and receive interrupts */
-	writew(UART011_OEIS | UART011_BEIS | UART011_PEIS | UART011_FEIS |
-	       UART011_RTIS | UART011_RXIS, uap->port.membase + UART011_ICR);
+	pl011_write(UART011_OEIS | UART011_BEIS | UART011_PEIS |
+		    UART011_FEIS | UART011_RTIS | UART011_RXIS,
+		    uap, REG_ICR);
 
 	/*
 	 * Save interrupts enable mask, and enable RX interrupts in case if
 	 * the interrupt is used for NMI entry.
 	 */
-	uap->im = readw(uap->port.membase + UART011_IMSC);
-	writew(UART011_RTIM | UART011_RXIM, uap->port.membase + UART011_IMSC);
+	uap->im = pl011_read(uap, REG_IMSC);
+	pl011_write(UART011_RTIM | UART011_RXIM, uap, REG_IMSC);
 
 	if (dev_get_platdata(uap->port.dev)) {
 		struct amba_pl011_data *plat;
@@ -1522,96 +1659,87 @@
 	return 0;
 }
 
+static bool pl011_split_lcrh(const struct uart_amba_port *uap)
+{
+	return pl011_reg_to_offset(uap, REG_LCRH_RX) !=
+	       pl011_reg_to_offset(uap, REG_LCRH_TX);
+}
+
 static void pl011_write_lcr_h(struct uart_amba_port *uap, unsigned int lcr_h)
 {
-	writew(lcr_h, uap->port.membase + uap->lcrh_rx);
-	if (uap->lcrh_rx != uap->lcrh_tx) {
+	pl011_write(lcr_h, uap, REG_LCRH_RX);
+	if (pl011_split_lcrh(uap)) {
 		int i;
 		/*
 		 * Wait 10 PCLKs before writing LCRH_TX register,
 		 * to get this delay write read only register 10 times
 		 */
 		for (i = 0; i < 10; ++i)
-			writew(0xff, uap->port.membase + UART011_MIS);
-		writew(lcr_h, uap->port.membase + uap->lcrh_tx);
+			pl011_write(0xff, uap, REG_MIS);
+		pl011_write(lcr_h, uap, REG_LCRH_TX);
 	}
 }
 
+static int pl011_allocate_irq(struct uart_amba_port *uap)
+{
+	pl011_write(uap->im, uap, REG_IMSC);
+
+	return request_irq(uap->port.irq, pl011_int, 0, "uart-pl011", uap);
+}
+
+/*
+ * Enable interrupts, only timeouts when using DMA
+ * if initial RX DMA job failed, start in interrupt mode
+ * as well.
+ */
+static void pl011_enable_interrupts(struct uart_amba_port *uap)
+{
+	spin_lock_irq(&uap->port.lock);
+
+	/* Clear out any spuriously appearing RX interrupts */
+	pl011_write(UART011_RTIS | UART011_RXIS, uap, REG_ICR);
+	uap->im = UART011_RTIM;
+	if (!pl011_dma_rx_running(uap))
+		uap->im |= UART011_RXIM;
+	pl011_write(uap->im, uap, REG_IMSC);
+	spin_unlock_irq(&uap->port.lock);
+}
+
 static int pl011_startup(struct uart_port *port)
 {
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
-	unsigned int cr, lcr_h, fbrd, ibrd;
+	unsigned int cr;
 	int retval;
 
 	retval = pl011_hwinit(port);
 	if (retval)
 		goto clk_dis;
 
-	writew(uap->im, uap->port.membase + UART011_IMSC);
-
-	/*
-	 * Allocate the IRQ
-	 */
-	retval = request_irq(uap->port.irq, pl011_int, 0, "uart-pl011", uap);
+	retval = pl011_allocate_irq(uap);
 	if (retval)
 		goto clk_dis;
 
-	writew(uap->vendor->ifls, uap->port.membase + UART011_IFLS);
+	pl011_write(uap->vendor->ifls, uap, REG_IFLS);
 
-	/*
-	 * Provoke TX FIFO interrupt into asserting. Taking care to preserve
-	 * baud rate and data format specified by FBRD, IBRD and LCRH as the
-	 * UART may already be in use as a console.
-	 */
 	spin_lock_irq(&uap->port.lock);
 
-	fbrd = readw(uap->port.membase + UART011_FBRD);
-	ibrd = readw(uap->port.membase + UART011_IBRD);
-	lcr_h = readw(uap->port.membase + uap->lcrh_rx);
-
-	cr = UART01x_CR_UARTEN | UART011_CR_TXE | UART011_CR_LBE;
-	writew(cr, uap->port.membase + UART011_CR);
-	writew(0, uap->port.membase + UART011_FBRD);
-	writew(1, uap->port.membase + UART011_IBRD);
-	pl011_write_lcr_h(uap, 0);
-	writew(0, uap->port.membase + UART01x_DR);
-	while (readw(uap->port.membase + UART01x_FR) & UART01x_FR_BUSY)
-		barrier();
-
-	writew(fbrd, uap->port.membase + UART011_FBRD);
-	writew(ibrd, uap->port.membase + UART011_IBRD);
-	pl011_write_lcr_h(uap, lcr_h);
-
 	/* restore RTS and DTR */
 	cr = uap->old_cr & (UART011_CR_RTS | UART011_CR_DTR);
 	cr |= UART01x_CR_UARTEN | UART011_CR_RXE | UART011_CR_TXE;
-	writew(cr, uap->port.membase + UART011_CR);
+	pl011_write(cr, uap, REG_CR);
 
 	spin_unlock_irq(&uap->port.lock);
 
 	/*
 	 * initialise the old status of the modem signals
 	 */
-	uap->old_status = readw(uap->port.membase + UART01x_FR) & UART01x_FR_MODEM_ANY;
+	uap->old_status = pl011_read(uap, REG_FR) & UART01x_FR_MODEM_ANY;
 
 	/* Startup DMA */
 	pl011_dma_startup(uap);
 
-	/*
-	 * Finally, enable interrupts, only timeouts when using DMA
-	 * if initial RX DMA job failed, start in interrupt mode
-	 * as well.
-	 */
-	spin_lock_irq(&uap->port.lock);
-	/* Clear out any spuriously appearing RX interrupts */
-	 writew(UART011_RTIS | UART011_RXIS,
-		uap->port.membase + UART011_ICR);
-	uap->im = UART011_RTIM;
-	if (!pl011_dma_rx_running(uap))
-		uap->im |= UART011_RXIM;
-	writew(uap->im, uap->port.membase + UART011_IMSC);
-	spin_unlock_irq(&uap->port.lock);
+	pl011_enable_interrupts(uap);
 
 	return 0;
 
@@ -1620,59 +1748,88 @@
 	return retval;
 }
 
+static int sbsa_uart_startup(struct uart_port *port)
+{
+	struct uart_amba_port *uap =
+		container_of(port, struct uart_amba_port, port);
+	int retval;
+
+	retval = pl011_hwinit(port);
+	if (retval)
+		return retval;
+
+	retval = pl011_allocate_irq(uap);
+	if (retval)
+		return retval;
+
+	/* The SBSA UART does not support any modem status lines. */
+	uap->old_status = 0;
+
+	pl011_enable_interrupts(uap);
+
+	return 0;
+}
+
 static void pl011_shutdown_channel(struct uart_amba_port *uap,
 					unsigned int lcrh)
 {
       unsigned long val;
 
-      val = readw(uap->port.membase + lcrh);
+      val = pl011_read(uap, lcrh);
       val &= ~(UART01x_LCRH_BRK | UART01x_LCRH_FEN);
-      writew(val, uap->port.membase + lcrh);
+      pl011_write(val, uap, lcrh);
 }
 
-static void pl011_shutdown(struct uart_port *port)
+/*
+ * disable the port. It should not disable RTS and DTR.
+ * Also RTS and DTR state should be preserved to restore
+ * it during startup().
+ */
+static void pl011_disable_uart(struct uart_amba_port *uap)
 {
-	struct uart_amba_port *uap =
-	    container_of(port, struct uart_amba_port, port);
 	unsigned int cr;
 
-	/*
-	 * disable all interrupts
-	 */
-	spin_lock_irq(&uap->port.lock);
-	uap->im = 0;
-	writew(uap->im, uap->port.membase + UART011_IMSC);
-	writew(0xffff, uap->port.membase + UART011_ICR);
-	spin_unlock_irq(&uap->port.lock);
-
-	pl011_dma_shutdown(uap);
-
-	/*
-	 * Free the interrupt
-	 */
-	free_irq(uap->port.irq, uap);
-
-	/*
-	 * disable the port
-	 * disable the port. It should not disable RTS and DTR.
-	 * Also RTS and DTR state should be preserved to restore
-	 * it during startup().
-	 */
 	uap->autorts = false;
 	spin_lock_irq(&uap->port.lock);
-	cr = readw(uap->port.membase + UART011_CR);
+	cr = pl011_read(uap, REG_CR);
 	uap->old_cr = cr;
 	cr &= UART011_CR_RTS | UART011_CR_DTR;
 	cr |= UART01x_CR_UARTEN | UART011_CR_TXE;
-	writew(cr, uap->port.membase + UART011_CR);
+	pl011_write(cr, uap, REG_CR);
 	spin_unlock_irq(&uap->port.lock);
 
 	/*
 	 * disable break condition and fifos
 	 */
-	pl011_shutdown_channel(uap, uap->lcrh_rx);
-	if (uap->lcrh_rx != uap->lcrh_tx)
-		pl011_shutdown_channel(uap, uap->lcrh_tx);
+	pl011_shutdown_channel(uap, REG_LCRH_RX);
+	if (pl011_split_lcrh(uap))
+		pl011_shutdown_channel(uap, REG_LCRH_TX);
+}
+
+static void pl011_disable_interrupts(struct uart_amba_port *uap)
+{
+	spin_lock_irq(&uap->port.lock);
+
+	/* mask all interrupts and clear all pending ones */
+	uap->im = 0;
+	pl011_write(uap->im, uap, REG_IMSC);
+	pl011_write(0xffff, uap, REG_ICR);
+
+	spin_unlock_irq(&uap->port.lock);
+}
+
+static void pl011_shutdown(struct uart_port *port)
+{
+	struct uart_amba_port *uap =
+		container_of(port, struct uart_amba_port, port);
+
+	pl011_disable_interrupts(uap);
+
+	pl011_dma_shutdown(uap);
+
+	free_irq(uap->port.irq, uap);
+
+	pl011_disable_uart(uap);
 
 	/*
 	 * Shut down the clock producer
@@ -1689,6 +1846,53 @@
 			plat->exit();
 	}
 
+	if (uap->port.ops->flush_buffer)
+		uap->port.ops->flush_buffer(port);
+}
+
+static void sbsa_uart_shutdown(struct uart_port *port)
+{
+	struct uart_amba_port *uap =
+		container_of(port, struct uart_amba_port, port);
+
+	pl011_disable_interrupts(uap);
+
+	free_irq(uap->port.irq, uap);
+
+	if (uap->port.ops->flush_buffer)
+		uap->port.ops->flush_buffer(port);
+}
+
+static void
+pl011_setup_status_masks(struct uart_port *port, struct ktermios *termios)
+{
+	port->read_status_mask = UART011_DR_OE | 255;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= UART011_DR_FE | UART011_DR_PE;
+	if (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))
+		port->read_status_mask |= UART011_DR_BE;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= UART011_DR_FE | UART011_DR_PE;
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= UART011_DR_BE;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= UART011_DR_OE;
+	}
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		port->ignore_status_mask |= UART_DUMMY_DR_RX;
 }
 
 static void
@@ -1744,6 +1948,8 @@
 		lcr_h |= UART01x_LCRH_PEN;
 		if (!(termios->c_cflag & PARODD))
 			lcr_h |= UART01x_LCRH_EPS;
+		if (termios->c_cflag & CMSPAR)
+			lcr_h |= UART011_LCRH_SPS;
 	}
 	if (uap->fifosize > 1)
 		lcr_h |= UART01x_LCRH_FEN;
@@ -1755,40 +1961,14 @@
 	 */
 	uart_update_timeout(port, termios->c_cflag, baud);
 
-	port->read_status_mask = UART011_DR_OE | 255;
-	if (termios->c_iflag & INPCK)
-		port->read_status_mask |= UART011_DR_FE | UART011_DR_PE;
-	if (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))
-		port->read_status_mask |= UART011_DR_BE;
-
-	/*
-	 * Characters to ignore
-	 */
-	port->ignore_status_mask = 0;
-	if (termios->c_iflag & IGNPAR)
-		port->ignore_status_mask |= UART011_DR_FE | UART011_DR_PE;
-	if (termios->c_iflag & IGNBRK) {
-		port->ignore_status_mask |= UART011_DR_BE;
-		/*
-		 * If we're ignoring parity and break indicators,
-		 * ignore overruns too (for real raw support).
-		 */
-		if (termios->c_iflag & IGNPAR)
-			port->ignore_status_mask |= UART011_DR_OE;
-	}
-
-	/*
-	 * Ignore all characters if CREAD is not set.
-	 */
-	if ((termios->c_cflag & CREAD) == 0)
-		port->ignore_status_mask |= UART_DUMMY_DR_RX;
+	pl011_setup_status_masks(port, termios);
 
 	if (UART_ENABLE_MS(port, termios->c_cflag))
 		pl011_enable_ms(port);
 
 	/* first, disable everything */
-	old_cr = readw(port->membase + UART011_CR);
-	writew(0, port->membase + UART011_CR);
+	old_cr = pl011_read(uap, REG_CR);
+	pl011_write(0, uap, REG_CR);
 
 	if (termios->c_cflag & CRTSCTS) {
 		if (old_cr & UART011_CR_RTS)
@@ -1821,18 +2001,39 @@
 			quot -= 2;
 	}
 	/* Set baud rate */
-	writew(quot & 0x3f, port->membase + UART011_FBRD);
-	writew(quot >> 6, port->membase + UART011_IBRD);
+	pl011_write(quot & 0x3f, uap, REG_FBRD);
+	pl011_write(quot >> 6, uap, REG_IBRD);
 
 	/*
 	 * ----------v----------v----------v----------v-----
-	 * NOTE: lcrh_tx and lcrh_rx MUST BE WRITTEN AFTER
-	 * UART011_FBRD & UART011_IBRD.
+	 * NOTE: REG_LCRH_TX and REG_LCRH_RX MUST BE WRITTEN AFTER
+	 * REG_FBRD & REG_IBRD.
 	 * ----------^----------^----------^----------^-----
 	 */
 	pl011_write_lcr_h(uap, lcr_h);
-	writew(old_cr, port->membase + UART011_CR);
+	pl011_write(old_cr, uap, REG_CR);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
 
+static void
+sbsa_uart_set_termios(struct uart_port *port, struct ktermios *termios,
+		      struct ktermios *old)
+{
+	struct uart_amba_port *uap =
+	    container_of(port, struct uart_amba_port, port);
+	unsigned long flags;
+
+	tty_termios_encode_baud_rate(termios, uap->fixed_baud, uap->fixed_baud);
+
+	/* The SBSA UART only supports 8n1 without hardware flow control. */
+	termios->c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD);
+	termios->c_cflag &= ~(CMSPAR | CRTSCTS);
+	termios->c_cflag |= CS8 | CLOCAL;
+
+	spin_lock_irqsave(&port->lock, flags);
+	uart_update_timeout(port, CS8, uap->fixed_baud);
+	pl011_setup_status_masks(port, termios);
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
@@ -1911,6 +2112,37 @@
 #endif
 };
 
+static void sbsa_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static unsigned int sbsa_uart_get_mctrl(struct uart_port *port)
+{
+	return 0;
+}
+
+static const struct uart_ops sbsa_uart_pops = {
+	.tx_empty	= pl011_tx_empty,
+	.set_mctrl	= sbsa_uart_set_mctrl,
+	.get_mctrl	= sbsa_uart_get_mctrl,
+	.stop_tx	= pl011_stop_tx,
+	.start_tx	= pl011_start_tx,
+	.stop_rx	= pl011_stop_rx,
+	.startup	= sbsa_uart_startup,
+	.shutdown	= sbsa_uart_shutdown,
+	.set_termios	= sbsa_uart_set_termios,
+	.type		= pl011_type,
+	.release_port	= pl011_release_port,
+	.request_port	= pl011_request_port,
+	.config_port	= pl011_config_port,
+	.verify_port	= pl011_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_init     = pl011_hwinit,
+	.poll_get_char = pl011_get_poll_char,
+	.poll_put_char = pl011_put_poll_char,
+#endif
+};
+
 static struct uart_amba_port *amba_ports[UART_NR];
 
 #ifdef CONFIG_SERIAL_AMBA_PL011_CONSOLE
@@ -1920,16 +2152,16 @@
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
 
-	while (readw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF)
-		barrier();
-	writew(ch, uap->port.membase + UART01x_DR);
+	while (pl011_read(uap, REG_FR) & UART01x_FR_TXFF)
+		cpu_relax();
+	pl011_write(ch, uap, REG_DR);
 }
 
 static void
 pl011_console_write(struct console *co, const char *s, unsigned int count)
 {
 	struct uart_amba_port *uap = amba_ports[co->index];
-	unsigned int status, old_cr, new_cr;
+	unsigned int old_cr = 0, new_cr;
 	unsigned long flags;
 	int locked = 1;
 
@@ -1946,10 +2178,12 @@
 	/*
 	 *	First save the CR then disable the interrupts
 	 */
-	old_cr = readw(uap->port.membase + UART011_CR);
-	new_cr = old_cr & ~UART011_CR_CTSEN;
-	new_cr |= UART01x_CR_UARTEN | UART011_CR_TXE;
-	writew(new_cr, uap->port.membase + UART011_CR);
+	if (!uap->vendor->always_enabled) {
+		old_cr = pl011_read(uap, REG_CR);
+		new_cr = old_cr & ~UART011_CR_CTSEN;
+		new_cr |= UART01x_CR_UARTEN | UART011_CR_TXE;
+		pl011_write(new_cr, uap, REG_CR);
+	}
 
 	uart_console_write(&uap->port, s, count, pl011_console_putchar);
 
@@ -1957,10 +2191,10 @@
 	 *	Finally, wait for transmitter to become empty
 	 *	and restore the TCR
 	 */
-	do {
-		status = readw(uap->port.membase + UART01x_FR);
-	} while (status & UART01x_FR_BUSY);
-	writew(old_cr, uap->port.membase + UART011_CR);
+	while (pl011_read(uap, REG_FR) & UART01x_FR_BUSY)
+		cpu_relax();
+	if (!uap->vendor->always_enabled)
+		pl011_write(old_cr, uap, REG_CR);
 
 	if (locked)
 		spin_unlock(&uap->port.lock);
@@ -1973,10 +2207,10 @@
 pl011_console_get_options(struct uart_amba_port *uap, int *baud,
 			     int *parity, int *bits)
 {
-	if (readw(uap->port.membase + UART011_CR) & UART01x_CR_UARTEN) {
+	if (pl011_read(uap, REG_CR) & UART01x_CR_UARTEN) {
 		unsigned int lcr_h, ibrd, fbrd;
 
-		lcr_h = readw(uap->port.membase + uap->lcrh_tx);
+		lcr_h = pl011_read(uap, REG_LCRH_TX);
 
 		*parity = 'n';
 		if (lcr_h & UART01x_LCRH_PEN) {
@@ -1991,13 +2225,13 @@
 		else
 			*bits = 8;
 
-		ibrd = readw(uap->port.membase + UART011_IBRD);
-		fbrd = readw(uap->port.membase + UART011_FBRD);
+		ibrd = pl011_read(uap, REG_IBRD);
+		fbrd = pl011_read(uap, REG_FBRD);
 
 		*baud = uap->port.uartclk * 4 / (64 * ibrd + fbrd);
 
 		if (uap->vendor->oversampling) {
-			if (readw(uap->port.membase + UART011_CR)
+			if (pl011_read(uap, REG_CR)
 				  & ST_UART011_CR_OVSFACT)
 				*baud *= 2;
 		}
@@ -2041,10 +2275,15 @@
 
 	uap->port.uartclk = clk_get_rate(uap->clk);
 
-	if (options)
-		uart_parse_options(options, &baud, &parity, &bits, &flow);
-	else
-		pl011_console_get_options(uap, &baud, &parity, &bits);
+	if (uap->vendor->fixed_options) {
+		baud = uap->fixed_baud;
+	} else {
+		if (options)
+			uart_parse_options(options,
+					   &baud, &parity, &bits, &flow);
+		else
+			pl011_console_get_options(uap, &baud, &parity, &bits);
+	}
 
 	return uart_set_options(&uap->port, co, baud, parity, bits, flow);
 }
@@ -2065,10 +2304,13 @@
 static void pl011_putc(struct uart_port *port, int c)
 {
 	while (readl(port->membase + UART01x_FR) & UART01x_FR_TXFF)
-		;
-	writeb(c, port->membase + UART01x_DR);
+		cpu_relax();
+	if (port->iotype == UPIO_MEM32)
+		writel(c, port->membase + UART01x_DR);
+	else
+		writeb(c, port->membase + UART01x_DR);
 	while (readl(port->membase + UART01x_FR) & UART01x_FR_BUSY)
-		;
+		cpu_relax();
 }
 
 static void pl011_early_write(struct console *con, const char *s, unsigned n)
@@ -2087,7 +2329,6 @@
 	device->con->write = pl011_early_write;
 	return 0;
 }
-EARLYCON_DECLARE(pl011, pl011_early_console_setup);
 OF_EARLYCON_DECLARE(pl011, "arm,pl011", pl011_early_console_setup);
 
 #else
@@ -2119,7 +2360,7 @@
 		return ret;
 
 	ret = of_alias_get_id(np, "serial");
-	if (IS_ERR_VALUE(ret)) {
+	if (ret < 0) {
 		seen_dev_without_alias = true;
 		ret = index;
 	} else {
@@ -2136,97 +2377,125 @@
 	return ret;
 }
 
-static int pl011_probe(struct amba_device *dev, const struct amba_id *id)
+/* unregisters the driver also if no more ports are left */
+static void pl011_unregister_port(struct uart_amba_port *uap)
 {
-	struct uart_amba_port *uap;
-	struct vendor_data *vendor = id->data;
-	void __iomem *base;
-	int i, ret;
+	int i;
+	bool busy = false;
+
+	for (i = 0; i < ARRAY_SIZE(amba_ports); i++) {
+		if (amba_ports[i] == uap)
+			amba_ports[i] = NULL;
+		else if (amba_ports[i])
+			busy = true;
+	}
+	pl011_dma_remove(uap);
+	if (!busy)
+		uart_unregister_driver(&amba_reg);
+}
+
+static int pl011_find_free_port(void)
+{
+	int i;
 
 	for (i = 0; i < ARRAY_SIZE(amba_ports); i++)
 		if (amba_ports[i] == NULL)
-			break;
+			return i;
 
-	if (i == ARRAY_SIZE(amba_ports))
-		return -EBUSY;
-
-	uap = devm_kzalloc(&dev->dev, sizeof(struct uart_amba_port),
-			   GFP_KERNEL);
-	if (uap == NULL)
-		return -ENOMEM;
+	return -EBUSY;
+}
 
-	i = pl011_probe_dt_alias(i, &dev->dev);
+static int pl011_setup_port(struct device *dev, struct uart_amba_port *uap,
+			    struct resource *mmiobase, int index)
+{
+	void __iomem *base;
 
-	base = devm_ioremap(&dev->dev, dev->res.start,
-			    resource_size(&dev->res));
-	if (!base)
-		return -ENOMEM;
+	base = devm_ioremap_resource(dev, mmiobase);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
 
-	uap->clk = devm_clk_get(&dev->dev, NULL);
-	if (IS_ERR(uap->clk))
-		return PTR_ERR(uap->clk);
+	index = pl011_probe_dt_alias(index, dev);
 
-	uap->vendor = vendor;
-	uap->lcrh_rx = vendor->lcrh_rx;
-	uap->lcrh_tx = vendor->lcrh_tx;
 	uap->old_cr = 0;
-	uap->fifosize = vendor->get_fifosize(dev);
-	uap->port.dev = &dev->dev;
-	uap->port.mapbase = dev->res.start;
+	uap->port.dev = dev;
+	uap->port.mapbase = mmiobase->start;
 	uap->port.membase = base;
-	uap->port.iotype = UPIO_MEM;
-	uap->port.irq = dev->irq[0];
 	uap->port.fifosize = uap->fifosize;
-	uap->port.ops = &amba_pl011_pops;
 	uap->port.flags = UPF_BOOT_AUTOCONF;
-	uap->port.line = i;
-	pl011_dma_probe(&dev->dev, uap);
+	uap->port.line = index;
 
-	/* Ensure interrupts from this UART are masked and cleared */
-	writew(0, uap->port.membase + UART011_IMSC);
-	writew(0xffff, uap->port.membase + UART011_ICR);
+	amba_ports[index] = uap;
 
-	snprintf(uap->type, sizeof(uap->type), "PL011 rev%u", amba_rev(dev));
+	return 0;
+}
 
-	amba_ports[i] = uap;
+static int pl011_register_port(struct uart_amba_port *uap)
+{
+	int ret;
 
-	amba_set_drvdata(dev, uap);
+	/* Ensure interrupts from this UART are masked and cleared */
+	pl011_write(0, uap, REG_IMSC);
+	pl011_write(0xffff, uap, REG_ICR);
 
 	if (!amba_reg.state) {
 		ret = uart_register_driver(&amba_reg);
 		if (ret < 0) {
-			pr_err("Failed to register AMBA-PL011 driver\n");
+			dev_err(uap->port.dev,
+				"Failed to register AMBA-PL011 driver\n");
 			return ret;
 		}
 	}
 
 	ret = uart_add_one_port(&amba_reg, &uap->port);
-	if (ret) {
-		amba_ports[i] = NULL;
-		uart_unregister_driver(&amba_reg);
-		pl011_dma_remove(uap);
-	}
+	if (ret)
+		pl011_unregister_port(uap);
 
 	return ret;
 }
 
+static int pl011_probe(struct amba_device *dev, const struct amba_id *id)
+{
+	struct uart_amba_port *uap;
+	struct vendor_data *vendor = id->data;
+	int portnr, ret;
+
+	portnr = pl011_find_free_port();
+	if (portnr < 0)
+		return portnr;
+
+	uap = devm_kzalloc(&dev->dev, sizeof(struct uart_amba_port),
+			   GFP_KERNEL);
+	if (!uap)
+		return -ENOMEM;
+
+	uap->clk = devm_clk_get(&dev->dev, NULL);
+	if (IS_ERR(uap->clk))
+		return PTR_ERR(uap->clk);
+
+	uap->reg_offset = vendor->reg_offset;
+	uap->vendor = vendor;
+	uap->fifosize = vendor->get_fifosize(dev);
+	uap->port.iotype = vendor->access_32b ? UPIO_MEM32 : UPIO_MEM;
+	uap->port.irq = dev->irq[0];
+	uap->port.ops = &amba_pl011_pops;
+
+	snprintf(uap->type, sizeof(uap->type), "PL011 rev%u", amba_rev(dev));
+
+	ret = pl011_setup_port(&dev->dev, uap, &dev->res, portnr);
+	if (ret)
+		return ret;
+
+	amba_set_drvdata(dev, uap);
+
+	return pl011_register_port(uap);
+}
+
 static int pl011_remove(struct amba_device *dev)
 {
 	struct uart_amba_port *uap = amba_get_drvdata(dev);
-	bool busy = false;
-	int i;
 
 	uart_remove_one_port(&amba_reg, &uap->port);
-
-	for (i = 0; i < ARRAY_SIZE(amba_ports); i++)
-		if (amba_ports[i] == uap)
-			amba_ports[i] = NULL;
-		else if (amba_ports[i])
-			busy = true;
-
-	pl011_dma_remove(uap);
-	if (!busy)
-		uart_unregister_driver(&amba_reg);
+	pl011_unregister_port(uap);
 	return 0;
 }
 
@@ -2254,6 +2523,94 @@
 
 static SIMPLE_DEV_PM_OPS(pl011_dev_pm_ops, pl011_suspend, pl011_resume);
 
+static int sbsa_uart_probe(struct platform_device *pdev)
+{
+	struct uart_amba_port *uap;
+	struct resource *r;
+	int portnr, ret;
+	int baudrate;
+
+	/*
+	 * Check the mandatory baud rate parameter in the DT node early
+	 * so that we can easily exit with the error.
+	 */
+	if (pdev->dev.of_node) {
+		struct device_node *np = pdev->dev.of_node;
+
+		ret = of_property_read_u32(np, "current-speed", &baudrate);
+		if (ret)
+			return ret;
+	} else {
+		baudrate = 115200;
+	}
+
+	portnr = pl011_find_free_port();
+	if (portnr < 0)
+		return portnr;
+
+	uap = devm_kzalloc(&pdev->dev, sizeof(struct uart_amba_port),
+			   GFP_KERNEL);
+	if (!uap)
+		return -ENOMEM;
+
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot obtain irq\n");
+		return ret;
+	}
+	uap->port.irq	= ret;
+
+	uap->reg_offset	= vendor_sbsa.reg_offset;
+	uap->vendor	= &vendor_sbsa;
+	uap->fifosize	= 32;
+	uap->port.iotype = vendor_sbsa.access_32b ? UPIO_MEM32 : UPIO_MEM;
+	uap->port.ops	= &sbsa_uart_pops;
+	uap->fixed_baud = baudrate;
+
+	snprintf(uap->type, sizeof(uap->type), "SBSA");
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	ret = pl011_setup_port(&pdev->dev, uap, r, portnr);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, uap);
+
+	return pl011_register_port(uap);
+}
+
+static int sbsa_uart_remove(struct platform_device *pdev)
+{
+	struct uart_amba_port *uap = platform_get_drvdata(pdev);
+
+	uart_remove_one_port(&amba_reg, &uap->port);
+	pl011_unregister_port(uap);
+	return 0;
+}
+
+static const struct of_device_id sbsa_uart_of_match[] = {
+	{ .compatible = "arm,sbsa-uart", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sbsa_uart_of_match);
+
+static const struct acpi_device_id sbsa_uart_acpi_match[] = {
+	{ "ARMH0011", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(acpi, sbsa_uart_acpi_match);
+
+static struct platform_driver arm_sbsa_uart_platform_driver = {
+	.probe		= sbsa_uart_probe,
+	.remove		= sbsa_uart_remove,
+	.driver	= {
+		.name	= "sbsa-uart",
+		.of_match_table = of_match_ptr(sbsa_uart_of_match),
+		.acpi_match_table = ACPI_PTR(sbsa_uart_acpi_match),
+	},
+};
+
 static struct amba_id pl011_ids[] = {
 	{
 		.id	= 0x00041011,
@@ -2284,11 +2641,14 @@
 {
 	printk(KERN_INFO "Serial: AMBA PL011 UART driver\n");
 
+	if (platform_driver_register(&arm_sbsa_uart_platform_driver))
+		pr_warn("could not register SBSA UART platform driver\n");
 	return amba_driver_register(&pl011_driver);
 }
 
 static void __exit pl011_exit(void)
 {
+	platform_driver_unregister(&arm_sbsa_uart_platform_driver);
 	amba_driver_unregister(&pl011_driver);
 }
 
Index: linux-3.18.29/drivers/tty/serial/sfax8_uart.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/tty/serial/sfax8_uart.c	2017-11-21 20:13:12.446710527 +0800
@@ -0,0 +1,2307 @@
+/*
+ *  Driver for SFAX8 serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2010 ST-Ericsson SA
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * This is a generic driver for SFAX8 serial ports.  They
+ * have a lot of 16550-like features, but are not register compatible.
+ * Note that although they do have CTS, DCD and DSR inputs, they do
+ * not have an RI input, nor do they have DTR or RTS outputs.  If
+ * required, these have to be supplied via some other means (eg, GPIO)
+ * and hooked into this driver.
+ */
+
+
+#if defined(CONFIG_SERIAL_SFAX8_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/sizes.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+
+#include <asm/clock.h>
+#include "sfax8_uart.h"
+
+#define UART_NR			14
+#define PORT_SFAX8		32
+
+#define SERIAL_SFAX8_MAJOR	204
+#define SERIAL_SFAX8_MINOR	64
+#define SERIAL_SFAX8_NR		UART_NR
+
+#define SFAX8_ISR_PASS_LIMIT	256
+
+#define UART_DR_ERROR		(UART_DR_OE|UART_DR_BE|UART_DR_PE|UART_DR_FE)
+#define UART_DUMMY_DR_RX	(1 << 16)
+
+#define sfax8_set_drvdata(d,p)	dev_set_drvdata(&d->dev, p)
+#define sfax8_get_drvdata(d)	dev_get_drvdata(&d->dev)
+
+/* Deals with DMA transactions */
+
+struct sfax8_sgbuf {
+	struct scatterlist sg;
+	char *buf;
+};
+
+struct sfax8_dmarx_data {
+	struct dma_chan		*chan;
+	struct completion	complete;
+	bool			use_buf_b;
+	struct sfax8_sgbuf	sgbuf_a;
+	struct sfax8_sgbuf	sgbuf_b;
+	dma_cookie_t		cookie;
+	bool			running;
+	struct timer_list	timer;
+	unsigned int last_residue;
+	unsigned long last_jiffies;
+	bool auto_poll_rate;
+	unsigned int poll_rate;
+	unsigned int poll_timeout;
+};
+
+struct sfax8_dmatx_data {
+	struct dma_chan		*chan;
+	struct scatterlist	sg;
+	char			*buf;
+	bool			queued;
+};
+
+struct uart_sf_port {
+    struct uart_port    port;
+    struct clk      *clk;
+    struct vendor_data *vendor;
+    unsigned int        dmacr;      /* dma control reg */
+    unsigned int        im;     /* interrupt mask */
+    unsigned int        old_status;
+    unsigned int        fifosize;   /* vendor-specific */
+    unsigned int        lcrh_tx;    /* vendor-specific */
+    unsigned int        lcrh_rx;    /* vendor-specific */
+    unsigned int        old_cr;     /* state during shutdown */
+    bool            autorts;
+    char            type[12];
+#ifdef CONFIG_DMA_ENGINE
+    /* DMA stuff */
+    bool            using_tx_dma;
+    bool            using_rx_dma;
+    struct sfax8_dmarx_data dmarx;
+    struct sfax8_dmatx_data dmatx;
+#endif
+};
+struct vendor_data {
+    unsigned int        ifls;
+    unsigned int        lcrh_tx;
+    unsigned int        lcrh_rx;
+    bool            oversampling;
+    bool            dma_threshold;
+    bool            cts_event_workaround;
+
+    unsigned int (*get_fifosize)(struct platform_device *dev);
+};
+
+struct sfax8_data {
+	bool (*dma_filter)(struct dma_chan *chan, void *filter_param);
+	void *dma_rx_param;
+	void *dma_tx_param;
+	bool dma_rx_poll_enable;
+	unsigned int dma_rx_poll_rate;
+	unsigned int dma_rx_poll_timeout;
+        void (*init) (void);
+	void (*exit) (void);
+};
+
+/*
+ * Reads up to 256 characters from the FIFO or until it's empty and
+ * inserts them into the TTY layer. Returns the number of characters
+ * read from the FIFO.
+ */
+static int sfax8_fifo_to_tty(struct uart_sf_port *uap)
+{
+	u16 status, ch;
+	unsigned int flag, max_count = 256;
+	int fifotaken = 0;
+
+	while (max_count--) {
+		status = readw(uap->port.membase + UART_FR);
+		if (status & UART_FR_RXFE)
+			break;
+
+		/* Take chars from the FIFO and update status */
+		ch = readw(uap->port.membase + UART_DR) |
+			UART_DUMMY_DR_RX;
+		flag = TTY_NORMAL;
+		uap->port.icount.rx++;
+		fifotaken++;
+
+		if (unlikely(ch & UART_DR_ERROR)) {
+			if (ch & UART_DR_BE) {
+				ch &= ~(UART_DR_FE | UART_DR_PE);
+				uap->port.icount.brk++;
+				if (uart_handle_break(&uap->port))
+					continue;
+			} else if (ch & UART_DR_PE)
+				uap->port.icount.parity++;
+			else if (ch & UART_DR_FE)
+				uap->port.icount.frame++;
+			if (ch & UART_DR_OE)
+				uap->port.icount.overrun++;
+
+			ch &= uap->port.read_status_mask;
+
+			if (ch & UART_DR_BE)
+				flag = TTY_BREAK;
+			else if (ch & UART_DR_PE)
+				flag = TTY_PARITY;
+			else if (ch & UART_DR_FE)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(&uap->port, ch & 255))
+			continue;
+
+		uart_insert_char(&uap->port, ch, UART_DR_OE, ch, flag);
+	}
+
+	return fifotaken;
+}
+
+
+/*
+ * All the DMA operation mode stuff goes inside this ifdef.
+ * This assumes that you have a generic DMA device interface,
+ * no custom DMA interfaces are supported.
+ */
+#ifdef CONFIG_DMA_ENGINE
+
+#define SFAX8_DMA_BUFFER_SIZE 1 //PAGE_SIZE
+
+#define phys_to_page(phys)	(pfn_to_page((unsigned long)((phys) >> PAGE_SHIFT)))
+static int sfax8_sgbuf_init(struct dma_chan *chan, struct sfax8_sgbuf *sg,
+	enum dma_data_direction dir)
+{
+	dma_addr_t dma_addr;
+
+	sg->buf = dma_alloc_coherent(chan->device->dev,
+		SFAX8_DMA_BUFFER_SIZE, &dma_addr, GFP_KERNEL);
+	if (!sg->buf)
+		return -ENOMEM;
+
+	sg_init_table(&sg->sg, 1);
+	sg_set_page(&sg->sg, phys_to_page(dma_addr),
+		SFAX8_DMA_BUFFER_SIZE, offset_in_page(dma_addr));
+	sg_dma_address(&sg->sg) = dma_addr;
+
+	return 0;
+}
+
+static void sfax8_sgbuf_free(struct dma_chan *chan, struct sfax8_sgbuf *sg,
+	enum dma_data_direction dir)
+{
+	if (sg->buf) {
+		dma_free_coherent(chan->device->dev,
+			SFAX8_DMA_BUFFER_SIZE, sg->buf,
+			sg_dma_address(&sg->sg));
+	}
+}
+
+static void sfax8_dma_probe_initcall(struct device *dev, struct uart_sf_port *uap)
+{
+	/* DMA is the sole user of the platform data right now */
+	struct sfax8_data *plat = dev_get_platdata(uap->port.dev);
+	struct dma_slave_config tx_conf = {
+		.dst_addr = uap->port.mapbase + UART_DR,
+		.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,
+		.direction = DMA_MEM_TO_DEV,
+		.dst_maxburst = uap->fifosize >> 1,
+		.device_fc = false,
+	};
+	struct dma_chan *chan;
+	dma_cap_mask_t mask;
+
+	chan = dma_request_slave_channel(dev, "tx");
+
+	if (!chan) {
+		/* We need platform data */
+		if (!plat || !plat->dma_filter) {
+			dev_info(uap->port.dev, "no DMA platform data\n");
+			return;
+		}
+
+		/* Try to acquire a generic DMA engine slave TX channel */
+		dma_cap_zero(mask);
+		dma_cap_set(DMA_SLAVE, mask);
+
+		chan = dma_request_channel(mask, plat->dma_filter,
+						plat->dma_tx_param);
+		if (!chan) {
+			dev_err(uap->port.dev, "no TX DMA channel!\n");
+			return;
+		}
+	}
+
+	dmaengine_slave_config(chan, &tx_conf);
+	uap->dmatx.chan = chan;
+
+	dev_info(uap->port.dev, "DMA channel TX %s\n",
+		 dma_chan_name(uap->dmatx.chan));
+
+	/* Optionally make use of an RX channel as well */
+	chan = dma_request_slave_channel(dev, "rx");
+
+	if (!chan && plat->dma_rx_param) {
+		chan = dma_request_channel(mask, plat->dma_filter, plat->dma_rx_param);
+
+		if (!chan) {
+			dev_err(uap->port.dev, "no RX DMA channel!\n");
+			return;
+		}
+	}
+
+	if (chan) {
+		struct dma_slave_config rx_conf = {
+			.src_addr = uap->port.mapbase + UART_DR,
+			.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,
+			.direction = DMA_DEV_TO_MEM,
+			.src_maxburst = uap->fifosize >> 2,
+			.device_fc = false,
+		};
+
+		dmaengine_slave_config(chan, &rx_conf);
+		uap->dmarx.chan = chan;
+
+		if (plat && plat->dma_rx_poll_enable) {
+			/* Set poll rate if specified. */
+			if (plat->dma_rx_poll_rate) {
+				uap->dmarx.auto_poll_rate = false;
+				uap->dmarx.poll_rate = plat->dma_rx_poll_rate;
+			} else {
+				/*
+				 * 100 ms defaults to poll rate if not
+				 * specified. This will be adjusted with
+				 * the baud rate at set_termios.
+				 */
+				uap->dmarx.auto_poll_rate = true;
+				uap->dmarx.poll_rate =  100;
+			}
+			/* 3 secs defaults poll_timeout if not specified. */
+			if (plat->dma_rx_poll_timeout)
+				uap->dmarx.poll_timeout =
+					plat->dma_rx_poll_timeout;
+			else
+				uap->dmarx.poll_timeout = 3000;
+		} else
+			uap->dmarx.auto_poll_rate = false;
+
+		dev_info(uap->port.dev, "DMA channel RX %s\n",
+			 dma_chan_name(uap->dmarx.chan));
+	}
+}
+
+#ifndef MODULE
+/*
+ * Stack up the UARTs and let the above initcall be done at device
+ * initcall time, because the serial driver is called as an arch
+ * initcall, and at this time the DMA subsystem is not yet registered.
+ * At this point the driver will switch over to using DMA where desired.
+ */
+struct dma_uap {
+	struct list_head node;
+	struct uart_sf_port *uap;
+	struct device *dev;
+};
+
+static LIST_HEAD(sfax8_dma_uarts);
+
+static int __init sfax8_dma_initcall(void)
+{
+	struct list_head *node, *tmp;
+
+	list_for_each_safe(node, tmp, &sfax8_dma_uarts) {
+		struct dma_uap *dmau = list_entry(node, struct dma_uap, node);
+		sfax8_dma_probe_initcall(dmau->dev, dmau->uap);
+		list_del(node);
+		kfree(dmau);
+	}
+	return 0;
+}
+
+device_initcall(sfax8_dma_initcall);
+
+static void sfax8_dma_probe(struct device *dev, struct uart_sf_port *uap)
+{
+	struct dma_uap *dmau = kzalloc(sizeof(struct dma_uap), GFP_KERNEL);
+	if (dmau) {
+		dmau->uap = uap;
+		dmau->dev = dev;
+		list_add_tail(&dmau->node, &sfax8_dma_uarts);
+	}
+}
+#else
+static void sfax8_dma_probe(struct device *dev, struct uart_sf_port *uap)
+{
+	sfax8_dma_probe_initcall(dev, uap);
+}
+#endif
+
+static void sfax8_dma_remove(struct uart_sf_port *uap)
+{
+	/* TODO: remove the initcall if it has not yet executed */
+	if (uap->dmatx.chan)
+		dma_release_channel(uap->dmatx.chan);
+	if (uap->dmarx.chan)
+		dma_release_channel(uap->dmarx.chan);
+}
+
+/* Forward declare this for the refill routine */
+static int sfax8_dma_tx_refill(struct uart_sf_port *uap);
+
+/*
+ * The current DMA TX buffer has been sent.
+ * Try to queue up another DMA buffer.
+ */
+static void sfax8_dma_tx_callback(void *data)
+{
+	struct uart_sf_port *uap = data;
+	struct sfax8_dmatx_data *dmatx = &uap->dmatx;
+	unsigned long flags;
+	u16 dmacr;
+
+	spin_lock_irqsave(&uap->port.lock, flags);
+	if (uap->dmatx.queued)
+		dma_unmap_sg(dmatx->chan->device->dev, &dmatx->sg, 1,
+			     DMA_TO_DEVICE);
+
+	dmacr = uap->dmacr;
+	uap->dmacr = dmacr & ~UART_TXDMAE;
+	writew(uap->dmacr, uap->port.membase + UART_DMACR);
+
+	/*
+	 * If TX DMA was disabled, it means that we've stopped the DMA for
+	 * some reason (eg, XOFF received, or we want to send an X-char.)
+	 *
+	 * Note: we need to be careful here of a potential race between DMA
+	 * and the rest of the driver - if the driver disables TX DMA while
+	 * a TX buffer completing, we must update the tx queued status to
+	 * get further refills (hence we check dmacr).
+	 */
+	if (!(dmacr & UART_TXDMAE) || uart_tx_stopped(&uap->port) ||
+	    uart_circ_empty(&uap->port.state->xmit)) {
+		uap->dmatx.queued = false;
+		spin_unlock_irqrestore(&uap->port.lock, flags);
+		return;
+	}
+
+	if (sfax8_dma_tx_refill(uap) <= 0) {
+		/*
+		 * We didn't queue a DMA buffer for some reason, but we
+		 * have data pending to be sent.  Re-enable the TX IRQ.
+		 */
+		uap->im |= UART_TXIM;
+		writew(uap->im, uap->port.membase + UART_IMSC);
+	}
+	spin_unlock_irqrestore(&uap->port.lock, flags);
+}
+
+/*
+ * Try to refill the TX DMA buffer.
+ * Locking: called with port lock held and IRQs disabled.
+ * Returns:
+ *   1 if we queued up a TX DMA buffer.
+ *   0 if we didn't want to handle this by DMA
+ *  <0 on error
+ */
+static int sfax8_dma_tx_refill(struct uart_sf_port *uap)
+{
+	struct sfax8_dmatx_data *dmatx = &uap->dmatx;
+	struct dma_chan *chan = dmatx->chan;
+	struct dma_device *dma_dev = chan->device;
+	struct dma_async_tx_descriptor *desc;
+	struct circ_buf *xmit = &uap->port.state->xmit;
+	unsigned int count;
+
+	/*
+	 * Try to avoid the overhead involved in using DMA if the
+	 * transaction fits in the first half of the FIFO, by using
+	 * the standard interrupt handling.  This ensures that we
+	 * issue a uart_write_wakeup() at the appropriate time.
+	 */
+	count = uart_circ_chars_pending(xmit);
+	if (count < (uap->fifosize >> 1)) {
+		uap->dmatx.queued = false;
+		return 0;
+	}
+
+	/*
+	 * Bodge: don't send the last character by DMA, as this
+	 * will prevent XON from notifying us to restart DMA.
+	 */
+	count -= 1;
+
+	/* Else proceed to copy the TX chars to the DMA buffer and fire DMA */
+	if (count > SFAX8_DMA_BUFFER_SIZE)
+		count = SFAX8_DMA_BUFFER_SIZE;
+
+	if (xmit->tail < xmit->head)
+		memcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], count);
+	else {
+		size_t first = UART_XMIT_SIZE - xmit->tail;
+		size_t second = xmit->head;
+
+		memcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], first);
+		if (second)
+			memcpy(&dmatx->buf[first], &xmit->buf[0], second);
+	}
+
+	dmatx->sg.length = count;
+
+	if (dma_map_sg(dma_dev->dev, &dmatx->sg, 1, DMA_TO_DEVICE) != 1) {
+		uap->dmatx.queued = false;
+		dev_dbg(uap->port.dev, "unable to map TX DMA\n");
+		return -EBUSY;
+	}
+
+	desc = dmaengine_prep_slave_sg(chan, &dmatx->sg, 1, DMA_MEM_TO_DEV,
+					     DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!desc) {
+		dma_unmap_sg(dma_dev->dev, &dmatx->sg, 1, DMA_TO_DEVICE);
+		uap->dmatx.queued = false;
+		/*
+		 * If DMA cannot be used right now, we complete this
+		 * transaction via IRQ and let the TTY layer retry.
+		 */
+		dev_dbg(uap->port.dev, "TX DMA busy\n");
+		return -EBUSY;
+	}
+
+	/* Some data to go along to the callback */
+	desc->callback = sfax8_dma_tx_callback;
+	desc->callback_param = uap;
+
+	/* All errors should happen at prepare time */
+	dmaengine_submit(desc);
+
+	/* Fire the DMA transaction */
+	dma_dev->device_issue_pending(chan);
+
+	uap->dmacr |= UART_TXDMAE;
+	writew(uap->dmacr, uap->port.membase + UART_DMACR);
+	uap->dmatx.queued = true;
+
+	/*
+	 * Now we know that DMA will fire, so advance the ring buffer
+	 * with the stuff we just dispatched.
+	 */
+	xmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);
+	uap->port.icount.tx += count;
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&uap->port);
+
+	return 1;
+}
+
+/*
+ * We received a transmit interrupt without a pending X-char but with
+ * pending characters.
+ * Locking: called with port lock held and IRQs disabled.
+ * Returns:
+ *   false if we want to use PIO to transmit
+ *   true if we queued a DMA buffer
+ */
+static bool sfax8_dma_tx_irq(struct uart_sf_port *uap)
+{
+	if (!uap->using_tx_dma)
+		return false;
+
+	/*
+	 * If we already have a TX buffer queued, but received a
+	 * TX interrupt, it will be because we've just sent an X-char.
+	 * Ensure the TX DMA is enabled and the TX IRQ is disabled.
+	 */
+	if (uap->dmatx.queued) {
+		uap->dmacr |= UART_TXDMAE;
+		writew(uap->dmacr, uap->port.membase + UART_DMACR);
+		uap->im &= ~UART_TXIM;
+		writew(uap->im, uap->port.membase + UART_IMSC);
+		return true;
+	}
+
+	/*
+	 * We don't have a TX buffer queued, so try to queue one.
+	 * If we successfully queued a buffer, mask the TX IRQ.
+	 */
+	if (sfax8_dma_tx_refill(uap) > 0) {
+		uap->im &= ~UART_TXIM;
+		writew(uap->im, uap->port.membase + UART_IMSC);
+		return true;
+	}
+	return false;
+}
+
+/*
+ * Stop the DMA transmit (eg, due to received XOFF).
+ * Locking: called with port lock held and IRQs disabled.
+ */
+static inline void sfax8_dma_tx_stop(struct uart_sf_port *uap)
+{
+	if (uap->dmatx.queued) {
+		uap->dmacr &= ~UART_TXDMAE;
+		writew(uap->dmacr, uap->port.membase + UART_DMACR);
+	}
+}
+
+/*
+ * Try to start a DMA transmit, or in the case of an XON/OFF
+ * character queued for send, try to get that character out ASAP.
+ * Locking: called with port lock held and IRQs disabled.
+ * Returns:
+ *   false if we want the TX IRQ to be enabled
+ *   true if we have a buffer queued
+ */
+static inline bool sfax8_dma_tx_start(struct uart_sf_port *uap)
+{
+	u16 dmacr;
+
+
+	if (!uap->using_tx_dma)
+		return false;
+
+	if (!uap->port.x_char) {
+		/* no X-char, try to push chars out in DMA mode */
+		bool ret = true;
+
+		if (!uap->dmatx.queued) {
+			if (sfax8_dma_tx_refill(uap) > 0) {
+				uap->im &= ~UART_TXIM;
+				ret = true;
+			} else {
+				uap->im |= UART_TXIM;
+				ret = false;
+			}
+			writew(uap->im, uap->port.membase + UART_IMSC);
+		} else if (!(uap->dmacr & UART_TXDMAE)) {
+			uap->dmacr |= UART_TXDMAE;
+			writew(uap->dmacr,
+				       uap->port.membase + UART_DMACR);
+		}
+		return ret;
+	}
+
+	/*
+	 * We have an X-char to send.  Disable DMA to prevent it loading
+	 * the TX fifo, and then see if we can stuff it into the FIFO.
+	 */
+	dmacr = uap->dmacr;
+	uap->dmacr &= ~UART_TXDMAE;
+	writew(uap->dmacr, uap->port.membase + UART_DMACR);
+
+	if (readw(uap->port.membase + UART_FR) & UART_FR_TXFF) {
+		/*
+		 * No space in the FIFO, so enable the transmit interrupt
+		 * so we know when there is space.  Note that once we've
+		 * loaded the character, we should just re-enable DMA.
+		 */
+		return false;
+	}
+
+	writew(uap->port.x_char, uap->port.membase + UART_DR);
+	uap->port.icount.tx++;
+	uap->port.x_char = 0;
+
+	/* Success - restore the DMA state */
+	uap->dmacr = dmacr;
+	writew(dmacr, uap->port.membase + UART_DMACR);
+
+	return true;
+}
+
+/*
+ * Flush the transmit buffer.
+ * Locking: called with port lock held and IRQs disabled.
+ */
+static void sfax8_dma_flush_buffer(struct uart_port *port)
+__releases(&uap->port.lock)
+__acquires(&uap->port.lock)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+
+	if (!uap->using_tx_dma)
+		return;
+
+	/* Avoid deadlock with the DMA engine callback */
+	spin_unlock(&uap->port.lock);
+	dmaengine_terminate_all(uap->dmatx.chan);
+	spin_lock(&uap->port.lock);
+	if (uap->dmatx.queued) {
+		dma_unmap_sg(uap->dmatx.chan->device->dev, &uap->dmatx.sg, 1,
+			     DMA_TO_DEVICE);
+		uap->dmatx.queued = false;
+		uap->dmacr &= ~UART_TXDMAE;
+		writew(uap->dmacr, uap->port.membase + UART_DMACR);
+	}
+}
+
+static void sfax8_dma_rx_callback(void *data);
+
+static int sfax8_dma_rx_trigger_dma(struct uart_sf_port *uap)
+{
+	struct dma_chan *rxchan = uap->dmarx.chan;
+	struct sfax8_dmarx_data *dmarx = &uap->dmarx;
+	struct dma_async_tx_descriptor *desc;
+	struct sfax8_sgbuf *sgbuf;
+
+	if (!rxchan)
+		return -EIO;
+
+	/* Start the RX DMA job */
+	sgbuf = uap->dmarx.use_buf_b ?
+		&uap->dmarx.sgbuf_b : &uap->dmarx.sgbuf_a;
+	desc = dmaengine_prep_slave_sg(rxchan, &sgbuf->sg, 1,
+					DMA_DEV_TO_MEM,
+					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	/*
+	 * If the DMA engine is busy and cannot prepare a
+	 * channel, no big deal, the driver will fall back
+	 * to interrupt mode as a result of this error code.
+	 */
+	if (!desc) {
+		uap->dmarx.running = false;
+		dmaengine_terminate_all(rxchan);
+		return -EBUSY;
+	}
+
+	/* Some data to go along to the callback */
+	desc->callback = sfax8_dma_rx_callback;
+	desc->callback_param = uap;
+	dmarx->cookie = dmaengine_submit(desc);
+	dma_async_issue_pending(rxchan);
+
+	uap->dmacr |= UART_RXDMAE;
+	writew(uap->dmacr, uap->port.membase + UART_DMACR);
+	uap->dmarx.running = true;
+
+	uap->im &= ~UART_RXIM; //why mask the RXIM ?
+	//uap->im |= 0x50;
+	writew(uap->im, uap->port.membase + UART_IMSC);
+
+	return 0;
+}
+
+/*
+ * This is called when either the DMA job is complete, or
+ * the FIFO timeout interrupt occurred. This must be called
+ * with the port spinlock uap->port.lock held.
+ */
+static void sfax8_dma_rx_chars(struct uart_sf_port *uap,
+			       u32 pending, bool use_buf_b,
+			       bool readfifo)
+{
+	struct tty_port *port = &uap->port.state->port;
+	struct sfax8_sgbuf *sgbuf = use_buf_b ?
+		&uap->dmarx.sgbuf_b : &uap->dmarx.sgbuf_a;
+	int dma_count = 0;
+	u32 fifotaken = 0; /* only used for vdbg() */
+
+	struct sfax8_dmarx_data *dmarx = &uap->dmarx;
+	int dmataken = 0;
+
+	if (uap->dmarx.poll_rate) {
+		/* The data can be taken by polling */
+		dmataken = sgbuf->sg.length - dmarx->last_residue;
+		/* Recalculate the pending size */
+		if (pending >= dmataken)
+			pending -= dmataken;
+	}
+
+	/* Pick the remain data from the DMA */
+	if (pending) {
+
+		/*
+		 * First take all chars in the DMA pipe, then look in the FIFO.
+		 * Note that tty_insert_flip_buf() tries to take as many chars
+		 * as it can.
+		 */
+		dma_count = tty_insert_flip_string(port, sgbuf->buf + dmataken,
+				pending);
+
+		uap->port.icount.rx += dma_count;
+		if (dma_count < pending)
+			dev_warn(uap->port.dev,
+				 "couldn't insert all characters (TTY is full?)\n");
+	}
+
+	/* Reset the last_residue for Rx DMA poll */
+	if (uap->dmarx.poll_rate)
+		dmarx->last_residue = sgbuf->sg.length;
+
+	/*
+	 * Only continue with trying to read the FIFO if all DMA chars have
+	 * been taken first.
+	 */
+	if (dma_count == pending && readfifo) {
+		/* Clear any error flags */
+		writew(UART_OEIS | UART_BEIS | UART_PEIS | UART_FEIS,
+		       uap->port.membase + UART_ICR);
+
+		/*
+		 * If we read all the DMA'd characters, and we had an
+		 * incomplete buffer, that could be due to an rx error, or
+		 * maybe we just timed out. Read any pending chars and check
+		 * the error status.
+		 *
+		 * Error conditions will only occur in the FIFO, these will
+		 * trigger an immediate interrupt and stop the DMA job, so we
+		 * will always find the error in the FIFO, never in the DMA
+		 * buffer.
+		 */
+		fifotaken = sfax8_fifo_to_tty(uap);
+	}
+
+	spin_unlock(&uap->port.lock);
+	dev_vdbg(uap->port.dev,
+		 "Took %d chars from DMA buffer and %d chars from the FIFO\n",
+		 dma_count, fifotaken);
+	tty_flip_buffer_push(port);
+	spin_lock(&uap->port.lock);
+}
+
+static void sfax8_dma_rx_irq(struct uart_sf_port *uap)
+{
+	struct sfax8_dmarx_data *dmarx = &uap->dmarx;
+	struct dma_chan *rxchan = dmarx->chan;
+	struct sfax8_sgbuf *sgbuf = dmarx->use_buf_b ?
+		&dmarx->sgbuf_b : &dmarx->sgbuf_a;
+	size_t pending;
+	struct dma_tx_state state;
+	enum dma_status dmastat;
+
+	/*
+	 * Pause the transfer so we can trust the current counter,
+	 * do this before we pause the SFAX8 block, else we may
+	 * overflow the FIFO.
+	 */
+	//if (dmaengine_pause(rxchan))
+	//	dev_err(uap->port.dev, "unable to pause DMA transfer\n");
+	dmastat = rxchan->device->device_tx_status(rxchan,
+						   dmarx->cookie, &state);
+	//if (dmastat != DMA_PAUSED)
+	//	dev_err(uap->port.dev, "unable to pause DMA transfer\n");
+
+	/* Disable RX DMA - incoming data will wait in the FIFO */
+	uap->dmacr &= ~UART_RXDMAE;
+	writew(uap->dmacr, uap->port.membase + UART_DMACR);
+	uap->dmarx.running = false;
+
+	pending = sgbuf->sg.length - state.residue;
+	BUG_ON(pending > SFAX8_DMA_BUFFER_SIZE);
+	/* Then we terminate the transfer - we now know our residue */
+	dmaengine_terminate_all(rxchan);
+
+	/*
+	 * This will take the chars we have so far and insert
+	 * into the framework.
+	 */
+	sfax8_dma_rx_chars(uap, pending, dmarx->use_buf_b, true);
+
+	/* Switch buffer & re-trigger DMA job */
+	dmarx->use_buf_b = !dmarx->use_buf_b;
+	if (sfax8_dma_rx_trigger_dma(uap)) {
+		dev_dbg(uap->port.dev, "could not retrigger RX DMA job "
+			"fall back to interrupt mode\n");
+		uap->im |= UART_RXIM;
+		writew(uap->im, uap->port.membase + UART_IMSC);
+	}
+}
+
+static void sfax8_dma_rx_callback(void *data)
+{
+	struct uart_sf_port *uap = data;
+	struct sfax8_dmarx_data *dmarx = &uap->dmarx;
+	struct dma_chan *rxchan = dmarx->chan;
+	bool lastbuf = dmarx->use_buf_b;
+	struct sfax8_sgbuf *sgbuf = dmarx->use_buf_b ?
+		&dmarx->sgbuf_b : &dmarx->sgbuf_a;
+	size_t pending;
+	struct dma_tx_state state;
+	int ret;
+
+	/*
+	 * This completion interrupt occurs typically when the
+	 * RX buffer is totally stuffed but no timeout has yet
+	 * occurred. When that happens, we just want the RX
+	 * routine to flush out the secondary DMA buffer while
+	 * we immediately trigger the next DMA job.
+	 */
+	spin_lock_irq(&uap->port.lock);
+	/*
+	 * Rx data can be taken by the UART interrupts during
+	 * the DMA irq handler. So we check the residue here.
+	 */
+	rxchan->device->device_tx_status(rxchan, dmarx->cookie, &state);
+	pending = sgbuf->sg.length - state.residue;
+	BUG_ON(pending > SFAX8_DMA_BUFFER_SIZE);
+	/* Then we terminate the transfer - we now know our residue */
+	dmaengine_terminate_all(rxchan);
+
+	uap->dmarx.running = false;
+	dmarx->use_buf_b = !lastbuf;
+	ret = sfax8_dma_rx_trigger_dma(uap);
+
+	sfax8_dma_rx_chars(uap, pending, lastbuf, false);
+	spin_unlock_irq(&uap->port.lock);
+	/*
+	 * Do this check after we picked the DMA chars so we don't
+	 * get some IRQ immediately from RX.
+	 */
+	if (ret) {
+		dev_dbg(uap->port.dev, "could not retrigger RX DMA job "
+			"fall back to interrupt mode\n");
+		uap->im |= UART_RXIM;
+		writew(uap->im, uap->port.membase + UART_IMSC);
+	}
+}
+
+/*
+ * Stop accepting received characters, when we're shutting down or
+ * suspending this port.
+ * Locking: called with port lock held and IRQs disabled.
+ */
+static inline void sfax8_dma_rx_stop(struct uart_sf_port *uap)
+{
+	/* FIXME.  Just disable the DMA enable */
+	uap->dmacr &= ~UART_RXDMAE;
+	writew(uap->dmacr, uap->port.membase + UART_DMACR);
+}
+
+/*
+ * Timer handler for Rx DMA polling.
+ * Every polling, It checks the residue in the dma buffer and transfer
+ * data to the tty. Also, last_residue is updated for the next polling.
+ */
+static void sfax8_dma_rx_poll(unsigned long args)
+{
+	struct uart_sf_port *uap = (struct uart_sf_port *)args;
+	struct tty_port *port = &uap->port.state->port;
+	struct sfax8_dmarx_data *dmarx = &uap->dmarx;
+	struct dma_chan *rxchan = uap->dmarx.chan;
+	unsigned long flags = 0;
+	unsigned int dmataken = 0;
+	unsigned int size = 0;
+	struct sfax8_sgbuf *sgbuf;
+	int dma_count;
+	struct dma_tx_state state;
+
+	sgbuf = dmarx->use_buf_b ? &uap->dmarx.sgbuf_b : &uap->dmarx.sgbuf_a;
+	rxchan->device->device_tx_status(rxchan, dmarx->cookie, &state);
+	if (likely(state.residue < dmarx->last_residue)) {
+		dmataken = sgbuf->sg.length - dmarx->last_residue;
+		size = dmarx->last_residue - state.residue;
+		dma_count = tty_insert_flip_string(port, sgbuf->buf + dmataken,
+				size);
+		if (dma_count == size)
+			dmarx->last_residue =  state.residue;
+		dmarx->last_jiffies = jiffies;
+	}
+	tty_flip_buffer_push(port);
+
+	/*
+	 * If no data is received in poll_timeout, the driver will fall back
+	 * to interrupt mode. We will retrigger DMA at the first interrupt.
+	 */
+	if (jiffies_to_msecs(jiffies - dmarx->last_jiffies)
+			> uap->dmarx.poll_timeout) {
+
+		spin_lock_irqsave(&uap->port.lock, flags);
+		sfax8_dma_rx_stop(uap);
+		uap->im |= UART_RXIM;
+		writew(uap->im, uap->port.membase + UART_IMSC);
+		spin_unlock_irqrestore(&uap->port.lock, flags);
+
+		uap->dmarx.running = false;
+		dmaengine_terminate_all(rxchan);
+		del_timer(&uap->dmarx.timer);
+	} else {
+		mod_timer(&uap->dmarx.timer,
+			jiffies + msecs_to_jiffies(uap->dmarx.poll_rate));
+	}
+}
+
+static void sfax8_dma_startup(struct uart_sf_port *uap)
+{
+	int ret;
+
+	if (!uap->dmatx.chan)
+		return;
+
+	uap->dmatx.buf = kmalloc(SFAX8_DMA_BUFFER_SIZE, GFP_KERNEL);
+	if (!uap->dmatx.buf) {
+		dev_err(uap->port.dev, "no memory for DMA TX buffer\n");
+		uap->port.fifosize = uap->fifosize;
+		return;
+	}
+
+	sg_init_one(&uap->dmatx.sg, uap->dmatx.buf, SFAX8_DMA_BUFFER_SIZE);
+
+	/* The DMA buffer is now the FIFO the TTY subsystem can use */
+	uap->port.fifosize = SFAX8_DMA_BUFFER_SIZE;
+	uap->using_tx_dma = true;
+
+	if (!uap->dmarx.chan)
+		goto skip_rx;
+
+	/* Allocate and map DMA RX buffers */
+	ret = sfax8_sgbuf_init(uap->dmarx.chan, &uap->dmarx.sgbuf_a,
+			       DMA_FROM_DEVICE);
+	if (ret) {
+		dev_err(uap->port.dev, "failed to init DMA %s: %d\n",
+			"RX buffer A", ret);
+		goto skip_rx;
+	}
+
+	ret = sfax8_sgbuf_init(uap->dmarx.chan, &uap->dmarx.sgbuf_b,
+			       DMA_FROM_DEVICE);
+	if (ret) {
+		dev_err(uap->port.dev, "failed to init DMA %s: %d\n",
+			"RX buffer B", ret);
+		sfax8_sgbuf_free(uap->dmarx.chan, &uap->dmarx.sgbuf_a,
+				 DMA_FROM_DEVICE);
+		goto skip_rx;
+	}
+
+	uap->using_rx_dma = true;
+
+skip_rx:
+	/* Turn on DMA error (RX/TX will be enabled on demand) */
+	uap->dmacr |= UART_DMAONERR;
+	writew(uap->dmacr, uap->port.membase + UART_DMACR);
+
+	/*
+	 * ST Micro variants has some specific dma burst threshold
+	 * compensation. Set this to 16 bytes, so burst will only
+	 * be issued above/below 16 bytes.
+	 */
+	if (uap->vendor->dma_threshold)
+		writew(UART_DMAWM_RX_16 | UART_DMAWM_TX_16,
+			       uap->port.membase + UART_DMAWM);
+
+	if (uap->using_rx_dma) {
+		if (sfax8_dma_rx_trigger_dma(uap))
+			dev_dbg(uap->port.dev, "could not trigger initial "
+				"RX DMA job, fall back to interrupt mode\n");
+		if (uap->dmarx.poll_rate) {
+			init_timer(&(uap->dmarx.timer));
+			uap->dmarx.timer.function = sfax8_dma_rx_poll;
+			uap->dmarx.timer.data = (unsigned long)uap;
+			mod_timer(&uap->dmarx.timer,
+				jiffies +
+				msecs_to_jiffies(uap->dmarx.poll_rate));
+			uap->dmarx.last_residue = SFAX8_DMA_BUFFER_SIZE;
+			uap->dmarx.last_jiffies = jiffies;
+		}
+	}
+}
+
+static void sfax8_dma_shutdown(struct uart_sf_port *uap)
+{
+	if (!(uap->using_tx_dma || uap->using_rx_dma))
+		return;
+
+	/* Disable RX and TX DMA */
+	while (readw(uap->port.membase + UART_FR) & UART_FR_BUSY)
+		barrier();
+
+	spin_lock_irq(&uap->port.lock);
+	uap->dmacr &= ~(UART_DMAONERR | UART_RXDMAE | UART_TXDMAE);
+	writew(uap->dmacr, uap->port.membase + UART_DMACR);
+	spin_unlock_irq(&uap->port.lock);
+
+	if (uap->using_tx_dma) {
+		/* In theory, this should already be done by sfax8_dma_flush_buffer */
+		dmaengine_terminate_all(uap->dmatx.chan);
+		if (uap->dmatx.queued) {
+			dma_unmap_sg(uap->dmatx.chan->device->dev, &uap->dmatx.sg, 1,
+				     DMA_TO_DEVICE);
+			uap->dmatx.queued = false;
+		}
+
+		kfree(uap->dmatx.buf);
+		uap->using_tx_dma = false;
+	}
+
+	if (uap->using_rx_dma) {
+		dmaengine_terminate_all(uap->dmarx.chan);
+		/* Clean up the RX DMA */
+		sfax8_sgbuf_free(uap->dmarx.chan, &uap->dmarx.sgbuf_a, DMA_FROM_DEVICE);
+		sfax8_sgbuf_free(uap->dmarx.chan, &uap->dmarx.sgbuf_b, DMA_FROM_DEVICE);
+		if (uap->dmarx.poll_rate)
+			del_timer_sync(&uap->dmarx.timer);
+		uap->using_rx_dma = false;
+	}
+}
+
+static inline bool sfax8_dma_rx_available(struct uart_sf_port *uap)
+{
+	return uap->using_rx_dma;
+}
+
+static inline bool sfax8_dma_rx_running(struct uart_sf_port *uap)
+{
+	return uap->using_rx_dma && uap->dmarx.running;
+}
+
+#else
+/* Blank functions if the DMA engine is not available */
+static inline void sfax8_dma_probe(struct device *dev, struct uart_sf_port *uap)
+{
+}
+
+static inline void sfax8_dma_remove(struct uart_sf_port *uap)
+{
+}
+
+static inline void sfax8_dma_startup(struct uart_sf_port *uap)
+{
+}
+
+static inline void sfax8_dma_shutdown(struct uart_sf_port *uap)
+{
+}
+
+static inline bool sfax8_dma_tx_irq(struct uart_sf_port *uap)
+{
+	return false;
+}
+
+static inline void sfax8_dma_tx_stop(struct uart_sf_port *uap)
+{
+}
+
+static inline bool sfax8_dma_tx_start(struct uart_sf_port *uap)
+{
+	return false;
+}
+
+static inline void sfax8_dma_rx_irq(struct uart_sf_port *uap)
+{
+}
+
+static inline void sfax8_dma_rx_stop(struct uart_sf_port *uap)
+{
+}
+
+static inline int sfax8_dma_rx_trigger_dma(struct uart_sf_port *uap)
+{
+	return -EIO;
+}
+
+static inline bool sfax8_dma_rx_available(struct uart_sf_port *uap)
+{
+	return false;
+}
+
+static inline bool sfax8_dma_rx_running(struct uart_sf_port *uap)
+{
+	return false;
+}
+
+#define sfax8_dma_flush_buffer	NULL
+#endif
+
+static void sfax8_stop_tx(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+
+	uap->im &= ~UART_TXIM;
+	writew(uap->im, uap->port.membase + UART_IMSC);
+	sfax8_dma_tx_stop(uap);
+}
+
+static void sfax8_start_tx(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+
+	if (!sfax8_dma_tx_start(uap)) {
+		uap->im |= UART_TXIM;
+		writew(uap->im, uap->port.membase + UART_IMSC);
+	}
+}
+
+static void sfax8_stop_rx(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+
+	uap->im &= ~(UART_RXIM|UART_RTIM|UART_FEIM|
+		     UART_PEIM|UART_BEIM|UART_OEIM);
+	writew(uap->im, uap->port.membase + UART_IMSC);
+
+	sfax8_dma_rx_stop(uap);
+}
+
+static void sfax8_enable_ms(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+
+	uap->im |= UART_RIMIM|UART_CTSMIM|UART_DCDMIM|UART_DSRMIM;
+	writew(uap->im, uap->port.membase + UART_IMSC);
+}
+
+static void sfax8_rx_chars(struct uart_sf_port *uap)
+__releases(&uap->port.lock)
+__acquires(&uap->port.lock)
+{
+	sfax8_fifo_to_tty(uap);
+
+	spin_unlock(&uap->port.lock);
+	tty_flip_buffer_push(&uap->port.state->port);
+	/*
+	 * If we were temporarily out of DMA mode for a while,
+	 * attempt to switch back to DMA mode again.
+	 */
+	if (sfax8_dma_rx_available(uap)) {
+		if (sfax8_dma_rx_trigger_dma(uap)) {
+			dev_dbg(uap->port.dev, "could not trigger RX DMA job "
+				"fall back to interrupt mode again\n");
+			uap->im |= UART_RXIM;
+			writew(uap->im, uap->port.membase + UART_IMSC);
+		} else {
+#ifdef CONFIG_DMA_ENGINE
+			/* Start Rx DMA poll */
+			if (uap->dmarx.poll_rate) {
+				uap->dmarx.last_jiffies = jiffies;
+				uap->dmarx.last_residue	= SFAX8_DMA_BUFFER_SIZE;
+				mod_timer(&uap->dmarx.timer,
+					jiffies +
+					msecs_to_jiffies(uap->dmarx.poll_rate));
+			}
+#endif
+		}
+	}
+	spin_lock(&uap->port.lock);
+}
+
+static void sfax8_tx_chars(struct uart_sf_port *uap)
+{
+	struct circ_buf *xmit = &uap->port.state->xmit;
+	int count;
+
+	if (uap->port.x_char) {
+		writew(uap->port.x_char, uap->port.membase + UART_DR);
+		uap->port.icount.tx++;
+		uap->port.x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&uap->port)) {
+		sfax8_stop_tx(&uap->port);
+		return;
+	}
+
+	/* If we are using DMA mode, try to send some characters. */
+	if (sfax8_dma_tx_irq(uap))
+		return;
+
+	count = uap->fifosize >> 1;
+	do {
+		writew(xmit->buf[xmit->tail], uap->port.membase + UART_DR);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		uap->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&uap->port);
+
+	if (uart_circ_empty(xmit))
+		sfax8_stop_tx(&uap->port);
+}
+
+static void sfax8_modem_status(struct uart_sf_port *uap)
+{
+	unsigned int status, delta;
+
+	status = readw(uap->port.membase + UART_FR) & UART_FR_MODEM_ANY;
+
+	delta = status ^ uap->old_status;
+	uap->old_status = status;
+
+	if (!delta)
+		return;
+
+	if (delta & UART_FR_DCD)
+		uart_handle_dcd_change(&uap->port, status & UART_FR_DCD);
+
+	if (delta & UART_FR_DSR)
+		uap->port.icount.dsr++;
+
+	if (delta & UART_FR_CTS)
+		uart_handle_cts_change(&uap->port, status & UART_FR_CTS);
+
+	wake_up_interruptible(&uap->port.state->port.delta_msr_wait);
+}
+
+static irqreturn_t sfax8_int(int irq, void *dev_id)
+{
+	struct uart_sf_port *uap = dev_id;
+	unsigned long flags;
+	unsigned int status, pass_counter = SFAX8_ISR_PASS_LIMIT;
+	int handled = 0;
+	unsigned int dummy_read;
+
+	spin_lock_irqsave(&uap->port.lock, flags);
+	status = readw(uap->port.membase + UART_MIS);
+	if (status) {
+		do {
+			if (uap->vendor->cts_event_workaround) {
+				/* workaround to make sure that all bits are unlocked.. */
+				writew(0x00, uap->port.membase + UART_ICR);
+
+				/*
+				 * WA: introduce 26ns(1 uart clk) delay before W1C;
+				 * single apb access will incur 2 pclk(133.12Mhz) delay,
+				 * so add 2 dummy reads
+				 */
+				dummy_read = readw(uap->port.membase + UART_ICR);
+				dummy_read = readw(uap->port.membase + UART_ICR);
+			}
+
+			writew(status & ~(UART_TXIS|UART_RTIS|
+					  UART_RXIS),
+			       uap->port.membase + UART_ICR);
+
+			if (status & (UART_RTIS|UART_RXIS)) {
+				if (sfax8_dma_rx_running(uap))
+					sfax8_dma_rx_irq(uap);
+				else
+					sfax8_rx_chars(uap);
+			}
+			if (status & (UART_DSRMIS|UART_DCDMIS|
+				      UART_CTSMIS|UART_RIMIS))
+				sfax8_modem_status(uap);
+			if (status & UART_TXIS)
+				sfax8_tx_chars(uap);
+
+			if (pass_counter-- == 0)
+				break;
+
+			status = readw(uap->port.membase + UART_MIS);
+		} while (status != 0);
+		handled = 1;
+	}
+
+	spin_unlock_irqrestore(&uap->port.lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+
+static unsigned int sfax8_tx_empty(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	unsigned int status = readw(uap->port.membase + UART_FR);
+	return status & (UART_FR_BUSY|UART_FR_TXFF) ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int sfax8_get_mctrl(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	unsigned int result = 0;
+	unsigned int status = readw(uap->port.membase + UART_FR);
+
+#define TIOCMBIT(uartbit, tiocmbit)	\
+	if (status & uartbit)		\
+		result |= tiocmbit
+
+	TIOCMBIT(UART_FR_DCD, TIOCM_CAR);
+	TIOCMBIT(UART_FR_DSR, TIOCM_DSR);
+	TIOCMBIT(UART_FR_CTS, TIOCM_CTS);
+	TIOCMBIT(UART_FR_RI, TIOCM_RNG);
+#undef TIOCMBIT
+	return result;
+}
+
+static void sfax8_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	unsigned int cr;
+
+	cr = readw(uap->port.membase + UART_CR);
+
+#define	TIOCMBIT(tiocmbit, uartbit)		\
+	if (mctrl & tiocmbit)		\
+		cr |= uartbit;		\
+	else				\
+		cr &= ~uartbit
+
+	TIOCMBIT(TIOCM_RTS, UART_CR_RTS);
+	TIOCMBIT(TIOCM_DTR, UART_CR_DTR);
+	TIOCMBIT(TIOCM_OUT1, UART_CR_OUT1);
+	TIOCMBIT(TIOCM_OUT2, UART_CR_OUT2);
+	TIOCMBIT(TIOCM_LOOP, UART_CR_LBE);
+
+	if (uap->autorts) {
+		/* We need to disable auto-RTS if we want to turn RTS off */
+		TIOCMBIT(TIOCM_RTS, UART_CR_RTSEN);
+	}
+#undef TIOCMBIT
+
+	writew(cr, uap->port.membase + UART_CR);
+}
+
+static void sfax8_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	unsigned long flags;
+	unsigned int lcr_h;
+
+	spin_lock_irqsave(&uap->port.lock, flags);
+	lcr_h = readw(uap->port.membase + uap->lcrh_tx);
+	if (break_state == -1)
+		lcr_h |= UART_LCRH_BRK;
+	else
+		lcr_h &= ~UART_LCRH_BRK;
+	writew(lcr_h, uap->port.membase + uap->lcrh_tx);
+	spin_unlock_irqrestore(&uap->port.lock, flags);
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+
+static void sfax8_quiesce_irqs(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	unsigned char __iomem *regs = uap->port.membase;
+
+	writew(readw(regs + UART_MIS), regs + UART_ICR);
+	/*
+	 * There is no way to clear TXIM as this is "ready to transmit IRQ", so
+	 * we simply mask it. start_tx() will unmask it.
+	 *
+	 * Note we can race with start_tx(), and if the race happens, the
+	 * polling user might get another interrupt just after we clear it.
+	 * But it should be OK and can happen even w/o the race, e.g.
+	 * controller immediately got some new data and raised the IRQ.
+	 *
+	 * And whoever uses polling routines assumes that it manages the device
+	 * (including tx queue), so we're also fine with start_tx()'s caller
+	 * side.
+	 */
+	writew(readw(regs + UART_IMSC) & ~UART_TXIM, regs + UART_IMSC);
+}
+
+static int sfax8_get_poll_char(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	unsigned int status;
+
+	/*
+	 * The caller might need IRQs lowered, e.g. if used with KDB NMI
+	 * debugger.
+	 */
+	sfax8_quiesce_irqs(port);
+
+	status = readw(uap->port.membase + UART_FR);
+	if (status & UART_FR_RXFE)
+		return NO_POLL_CHAR;
+
+	return readw(uap->port.membase + UART_DR);
+}
+
+static void sfax8_put_poll_char(struct uart_port *port,
+			 unsigned char ch)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+
+	while (readw(uap->port.membase + UART_FR) & UART_FR_TXFF)
+		barrier();
+
+	writew(ch, uap->port.membase + UART_DR);
+}
+
+#endif /* CONFIG_CONSOLE_POLL */
+
+static int sfax8_hwinit(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	int retval;
+
+	/* Optionaly enable pins to be muxed in and configured */
+	pinctrl_pm_select_default_state(port->dev);
+
+	/*
+	 * Try to enable the clock producer.
+	 */
+	retval = clk_prepare_enable(uap->clk);
+	if (retval)
+		return retval;
+
+	uap->port.uartclk = uap->clk->rate;
+
+	/* Clear pending error and receive interrupts */
+	writew(UART_OEIS | UART_BEIS | UART_PEIS | UART_FEIS |
+	       UART_RTIS | UART_RXIS, uap->port.membase + UART_ICR);
+
+	/*
+	 * Save interrupts enable mask, and enable RX interrupts in case if
+	 * the interrupt is used for NMI entry.
+	 */
+	uap->im = readw(uap->port.membase + UART_IMSC);
+	writew(UART_RTIM | UART_RXIM, uap->port.membase + UART_IMSC);
+
+	if (dev_get_platdata(uap->port.dev)) {
+		struct sfax8_data *plat;
+
+		plat = dev_get_platdata(uap->port.dev);
+		if (plat->init)
+			plat->init();
+	}
+	return 0;
+}
+
+static void sfax8_write_lcr_h(struct uart_sf_port *uap, unsigned int lcr_h)
+{
+	writew(lcr_h, uap->port.membase + uap->lcrh_rx);
+	if (uap->lcrh_rx != uap->lcrh_tx) {
+		int i;
+		/*
+		 * Wait 10 PCLKs before writing LCRH_TX register,
+		 * to get this delay write read only register 10 times
+		 */
+		for (i = 0; i < 10; ++i)
+			writew(0xff, uap->port.membase + UART_MIS);
+		writew(lcr_h, uap->port.membase + uap->lcrh_tx);
+	}
+}
+
+static int sfax8_startup(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	unsigned int cr, lcr_h, fbrd, ibrd;
+	int retval;
+
+	retval = sfax8_hwinit(port);
+	if (retval)
+		goto clk_dis;
+
+	writew(uap->im, uap->port.membase + UART_IMSC);
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(uap->port.irq, sfax8_int, uap->port.irqflags, "sfax8serial", uap);
+	if (retval)
+		goto clk_dis;
+
+	writew(uap->vendor->ifls, uap->port.membase + UART_IFLS);
+
+	/*
+	 * Provoke TX FIFO interrupt into asserting. Taking care to preserve
+	 * baud rate and data format specified by FBRD, IBRD and LCRH as the
+	 * UART may already be in use as a console.
+	 */
+	spin_lock_irq(&uap->port.lock);
+
+	fbrd = readw(uap->port.membase + UART_FBRD);
+	ibrd = readw(uap->port.membase + UART_IBRD);
+	lcr_h = readw(uap->port.membase + uap->lcrh_rx);
+
+	cr = UART_CR_UARTEN | UART_CR_TXE | UART_CR_LBE;
+	writew(cr, uap->port.membase + UART_CR);
+	writew(0, uap->port.membase + UART_FBRD);
+	writew(1, uap->port.membase + UART_IBRD);
+	sfax8_write_lcr_h(uap, 0);
+	writew(0, uap->port.membase + UART_DR);
+	while (readw(uap->port.membase + UART_FR) & UART_FR_BUSY)
+		barrier();
+
+	writew(fbrd, uap->port.membase + UART_FBRD);
+	writew(ibrd, uap->port.membase + UART_IBRD);
+	sfax8_write_lcr_h(uap, lcr_h);
+
+	/* restore RTS and DTR */
+	cr = uap->old_cr & (UART_CR_RTS | UART_CR_DTR);
+	cr |= UART_CR_UARTEN | UART_CR_RXE | UART_CR_TXE;
+	writew(cr, uap->port.membase + UART_CR);
+
+	spin_unlock_irq(&uap->port.lock);
+
+	/*
+	 * initialise the old status of the modem signals
+	 */
+	uap->old_status = readw(uap->port.membase + UART_FR) & UART_FR_MODEM_ANY;
+
+	/* Startup DMA */
+	sfax8_dma_startup(uap);
+
+	/*
+	 * Finally, enable interrupts, only timeouts when using DMA
+	 * if initial RX DMA job failed, start in interrupt mode
+	 * as well.
+	 */
+	spin_lock_irq(&uap->port.lock);
+	/* Clear out any spuriously appearing RX interrupts */
+	 writew(UART_RTIS | UART_RXIS,
+		uap->port.membase + UART_ICR);
+	//uap->im = UART_RTIM;
+	uap->im = 0x50;
+	if (!sfax8_dma_rx_running(uap))
+		uap->im |= UART_RXIM;
+	writew(uap->im, uap->port.membase + UART_IMSC);
+	spin_unlock_irq(&uap->port.lock);
+
+	return 0;
+
+ clk_dis:
+	clk_disable_unprepare(uap->clk);
+	return retval;
+}
+
+static void sfax8_shutdown_channel(struct uart_sf_port *uap,
+					unsigned int lcrh)
+{
+      unsigned long val;
+
+      val = readw(uap->port.membase + lcrh);
+      val &= ~(UART_LCRH_BRK | UART_LCRH_FEN);
+      writew(val, uap->port.membase + lcrh);
+}
+
+static void sfax8_shutdown(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	unsigned int cr;
+
+	/*
+	 * disable all interrupts
+	 */
+	spin_lock_irq(&uap->port.lock);
+	uap->im = 0;
+	writew(uap->im, uap->port.membase + UART_IMSC);
+	writew(0xffff, uap->port.membase + UART_ICR);
+	spin_unlock_irq(&uap->port.lock);
+
+	sfax8_dma_shutdown(uap);
+
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(uap->port.irq, uap);
+
+	/*
+	 * disable the port
+	 * disable the port. It should not disable RTS and DTR.
+	 * Also RTS and DTR state should be preserved to restore
+	 * it during startup().
+	 */
+	uap->autorts = false;
+	spin_lock_irq(&uap->port.lock);
+	cr = readw(uap->port.membase + UART_CR);
+	uap->old_cr = cr;
+	cr &= UART_CR_RTS | UART_CR_DTR;
+	cr |= UART_CR_UARTEN | UART_CR_TXE;
+	writew(cr, uap->port.membase + UART_CR);
+	spin_unlock_irq(&uap->port.lock);
+
+	/*
+	 * disable break condition and fifos
+	 */
+	sfax8_shutdown_channel(uap, uap->lcrh_rx);
+	if (uap->lcrh_rx != uap->lcrh_tx)
+		sfax8_shutdown_channel(uap, uap->lcrh_tx);
+
+	/*
+	 * Shut down the clock producer
+	 */
+	clk_disable_unprepare(uap->clk);
+	/* Optionally let pins go into sleep states */
+	pinctrl_pm_select_sleep_state(port->dev);
+
+	if (dev_get_platdata(uap->port.dev)) {
+		struct sfax8_data *plat;
+
+		plat = dev_get_platdata(uap->port.dev);
+		if (plat->exit)
+			plat->exit();
+	}
+
+}
+
+static void
+sfax8_set_termios(struct uart_port *port, struct ktermios *termios,
+		     struct ktermios *old)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	unsigned int lcr_h, old_cr;
+	unsigned long flags;
+	unsigned int baud, quot, clkdiv;
+
+	if (uap->vendor->oversampling)
+		clkdiv = 8;
+	else
+		clkdiv = 16;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0,
+				  port->uartclk / clkdiv);
+#ifdef CONFIG_DMA_ENGINE
+	/*
+	 * Adjust RX DMA polling rate with baud rate if not specified.
+	 */
+	if (uap->dmarx.auto_poll_rate)
+		uap->dmarx.poll_rate = DIV_ROUND_UP(10000000, baud);
+#endif
+
+	if (baud > port->uartclk/16)
+		quot = DIV_ROUND_CLOSEST(port->uartclk * 8, baud);
+	else
+		quot = DIV_ROUND_CLOSEST(port->uartclk * 4, baud);
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		lcr_h = UART_LCRH_WLEN_5;
+		break;
+	case CS6:
+		lcr_h = UART_LCRH_WLEN_6;
+		break;
+	case CS7:
+		lcr_h = UART_LCRH_WLEN_7;
+		break;
+	default: // CS8
+		lcr_h = UART_LCRH_WLEN_8;
+		break;
+	}
+	if (termios->c_cflag & CSTOPB)
+		lcr_h |= UART_LCRH_STP2;
+	if (termios->c_cflag & PARENB) {
+		lcr_h |= UART_LCRH_PEN;
+		if (!(termios->c_cflag & PARODD))
+			lcr_h |= UART_LCRH_EPS;
+	}
+	if (uap->fifosize > 1)
+		lcr_h |= UART_LCRH_FEN;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	port->read_status_mask = UART_DR_OE | 255;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= UART_DR_FE | UART_DR_PE;
+	if (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))
+		port->read_status_mask |= UART_DR_BE;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= UART_DR_FE | UART_DR_PE;
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= UART_DR_BE;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= UART_DR_OE;
+	}
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		port->ignore_status_mask |= UART_DUMMY_DR_RX;
+
+	if (UART_ENABLE_MS(port, termios->c_cflag))
+		sfax8_enable_ms(port);
+
+	/* first, disable everything */
+	old_cr = readw(port->membase + UART_CR);
+	writew(0, port->membase + UART_CR);
+
+	if (termios->c_cflag & CRTSCTS) {
+		if (old_cr & UART_CR_RTS)
+			old_cr |= UART_CR_RTSEN;
+
+		old_cr |= UART_CR_CTSEN;
+		uap->autorts = true;
+	} else {
+		old_cr &= ~(UART_CR_CTSEN | UART_CR_RTSEN);
+		uap->autorts = false;
+	}
+
+	if (uap->vendor->oversampling) {
+		if (baud > port->uartclk / 16)
+			old_cr |= UART_CR_OVSFACT;
+		else
+			old_cr &= ~UART_CR_OVSFACT;
+	}
+
+	/*
+	 * Workaround for the ST Micro oversampling variants to
+	 * increase the bitrate slightly, by lowering the divisor,
+	 * to avoid delayed sampling of start bit at high speeds,
+	 * else we see data corruption.
+	 */
+	if (uap->vendor->oversampling) {
+		if ((baud >= 3000000) && (baud < 3250000) && (quot > 1))
+			quot -= 1;
+		else if ((baud > 3250000) && (quot > 2))
+			quot -= 2;
+	}
+	/* Set baud rate */
+	writew(quot & 0x3f, port->membase + UART_FBRD);
+	writew(quot >> 6, port->membase + UART_IBRD);
+
+	/*
+	 * ----------v----------v----------v----------v-----
+	 * NOTE: lcrh_tx and lcrh_rx MUST BE WRITTEN AFTER
+	 * UART_FBRD & UART_IBRD.
+	 * ----------^----------^----------^----------^-----
+	 */
+	sfax8_write_lcr_h(uap, lcr_h);
+	writew(old_cr, port->membase + UART_CR);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *sfax8_type(struct uart_port *port)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+	return uap->port.type == PORT_SFAX8 ? uap->type : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'
+ */
+static void sfax8_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, SZ_4K);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'
+ */
+static int sfax8_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->mapbase, SZ_4K, "sfax8serial")
+			!= NULL ? 0 : -EBUSY;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void sfax8_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_SFAX8;
+		sfax8_request_port(port);
+	}
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int sfax8_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_SFAX8)
+		ret = -EINVAL;
+	if (ser->irq < 0 || ser->irq >= nr_irqs)
+		ret = -EINVAL;
+	if (ser->baud_base < 9600)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops sfax8_pops = {
+	.tx_empty	= sfax8_tx_empty,
+	.set_mctrl	= sfax8_set_mctrl,
+	.get_mctrl	= sfax8_get_mctrl,
+	.stop_tx	= sfax8_stop_tx,
+	.start_tx	= sfax8_start_tx,
+	.stop_rx	= sfax8_stop_rx,
+	.enable_ms	= sfax8_enable_ms,
+	.break_ctl	= sfax8_break_ctl,
+	.startup	= sfax8_startup,
+	.shutdown	= sfax8_shutdown,
+	.flush_buffer	= sfax8_dma_flush_buffer,
+	.set_termios	= sfax8_set_termios,
+	.type		= sfax8_type,
+	.release_port	= sfax8_release_port,
+	.request_port	= sfax8_request_port,
+	.config_port	= sfax8_config_port,
+	.verify_port	= sfax8_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_init     = sfax8_hwinit,
+	.poll_get_char = sfax8_get_poll_char,
+	.poll_put_char = sfax8_put_poll_char,
+#endif
+};
+
+static struct uart_sf_port *sfax8_ports[UART_NR];
+
+#ifdef CONFIG_SERIAL_SFAX8_CONSOLE
+
+static void sfax8_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_sf_port *uap =
+	    container_of(port, struct uart_sf_port, port);
+
+	while (readw(uap->port.membase + UART_FR) & UART_FR_TXFF)
+		barrier();
+	writew(ch, uap->port.membase + UART_DR);
+}
+
+static void
+sfax8_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_sf_port *uap = sfax8_ports[co->index];
+	unsigned int status, old_cr, new_cr;
+	unsigned long flags;
+	int locked = 1;
+
+	clk_enable(uap->clk);
+
+	local_irq_save(flags);
+	if (uap->port.sysrq)
+		locked = 0;
+	else if (oops_in_progress)
+		locked = spin_trylock(&uap->port.lock);
+	else
+		spin_lock(&uap->port.lock);
+
+	/*
+	 *	First save the CR then disable the interrupts
+	 */
+	old_cr = readw(uap->port.membase + UART_CR);
+	new_cr = old_cr & ~UART_CR_CTSEN;
+	new_cr |= UART_CR_UARTEN | UART_CR_TXE;
+	writew(new_cr, uap->port.membase + UART_CR);
+
+	uart_console_write(&uap->port, s, count, sfax8_console_putchar);
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the TCR
+	 */
+	do {
+		status = readw(uap->port.membase + UART_FR);
+	} while (status & UART_FR_BUSY);
+	writew(old_cr, uap->port.membase + UART_CR);
+
+	if (locked)
+		spin_unlock(&uap->port.lock);
+	local_irq_restore(flags);
+
+	clk_disable(uap->clk);
+}
+
+static void __init
+sfax8_console_get_options(struct uart_sf_port *uap, int *baud,
+			     int *parity, int *bits)
+{
+	if (readw(uap->port.membase + UART_CR) & UART_CR_UARTEN) {
+		unsigned int lcr_h, ibrd, fbrd;
+
+		lcr_h = readw(uap->port.membase + uap->lcrh_tx);
+
+		*parity = 'n';
+		if (lcr_h & UART_LCRH_PEN) {
+			if (lcr_h & UART_LCRH_EPS)
+				*parity = 'e';
+			else
+				*parity = 'o';
+		}
+
+		if ((lcr_h & 0x60) == UART_LCRH_WLEN_7)
+			*bits = 7;
+		else
+			*bits = 8;
+
+		ibrd = readw(uap->port.membase + UART_IBRD);
+		fbrd = readw(uap->port.membase + UART_FBRD);
+
+		*baud = uap->port.uartclk * 4 / (64 * ibrd + fbrd);
+
+		if (uap->vendor->oversampling) {
+			if (readw(uap->port.membase + UART_CR)
+				  & UART_CR_OVSFACT)
+				*baud *= 2;
+		}
+	}
+}
+
+static int __init sfax8_console_setup(struct console *co, char *options)
+{
+	struct uart_sf_port *uap;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+	int ret;
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= UART_NR)
+		co->index = 0;
+	uap = sfax8_ports[co->index];
+	if (!uap)
+		return -ENODEV;
+
+	/* Allow pins to be muxed in and configured */
+	pinctrl_pm_select_default_state(uap->port.dev);
+
+	ret = clk_prepare(uap->clk);
+	if (ret)
+		return ret;
+
+	if (dev_get_platdata(uap->port.dev)) {
+		struct sfax8_data *plat;
+
+		plat = dev_get_platdata(uap->port.dev);
+		if (plat->init)
+			plat->init();
+	}
+
+	uap->port.uartclk = uap->clk->rate;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		sfax8_console_get_options(uap, &baud, &parity, &bits);
+
+	return uart_set_options(&uap->port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver sfax8_reg;
+static struct console sfax8_console = {
+	.name		= "ttyS",
+	.write		= sfax8_console_write,
+	.device		= uart_console_device,
+	.setup		= sfax8_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &sfax8_reg,
+};
+
+#define SFAX8_CONSOLE	(&sfax8_console)
+
+static void sfax8_putc(struct uart_port *port, int c)
+{
+	while (readl(port->membase + UART_FR) & UART_FR_TXFF)
+		;
+	writeb(c, port->membase + UART_DR);
+	while (readl(port->membase + UART_FR) & UART_FR_BUSY)
+		;
+}
+
+static void sfax8_early_write(struct console *con, const char *s, unsigned n)
+{
+	struct earlycon_device *dev = con->data;
+
+	uart_console_write(&dev->port, s, n, sfax8_putc);
+}
+
+static int __init sfax8_early_console_setup(struct earlycon_device *device,
+					    const char *opt)
+{
+	if (!device->port.membase)
+		return -ENODEV;
+
+	device->con->write = sfax8_early_write;
+	return 0;
+}
+EARLYCON_DECLARE(sfax8, sfax8_early_console_setup);
+OF_EARLYCON_DECLARE(sfax8, "mips,sfax8", sfax8_early_console_setup);
+
+#else
+#define SFAX8_CONSOLE	NULL
+#endif
+
+static struct uart_driver sfax8_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "serial",
+	.dev_name		= "ttyS",
+	.major			= SERIAL_SFAX8_MAJOR,
+	.minor			= SERIAL_SFAX8_MINOR,
+	.nr			= UART_NR,
+	.cons			= SFAX8_CONSOLE,
+};
+
+static int sfax8_probe_dt_alias(int index, struct device *dev)
+{
+	struct device_node *np;
+	static bool seen_dev_with_alias = false;
+	static bool seen_dev_without_alias = false;
+	int ret = index;
+
+	if (!IS_ENABLED(CONFIG_OF))
+		return ret;
+
+	np = dev->of_node;
+	if (!np)
+		return ret;
+
+	ret = of_alias_get_id(np, "serial");
+	if (IS_ERR_VALUE(ret)) {
+		seen_dev_without_alias = true;
+		ret = index;
+	} else {
+		seen_dev_with_alias = true;
+		if (ret >= ARRAY_SIZE(sfax8_ports) || sfax8_ports[ret] != NULL) {
+			dev_warn(dev, "requested serial port %d  not available.\n", ret);
+			ret = index;
+		}
+	}
+
+	if (seen_dev_with_alias && seen_dev_without_alias)
+		dev_warn(dev, "aliased and non-aliased serial devices found in device tree. Serial port enumeration may be unpredictable.\n");
+
+	return ret;
+}
+
+
+#define SFAX8_UART_FIFOSIZE (32)
+
+static unsigned int get_fifosize_sfax8(struct platform_device *dev)
+{
+	return SFAX8_UART_FIFOSIZE;
+}
+struct vendor_data vendor_sfax8 = {
+	.ifls       = UART_IFLS_RX4_8 | UART_IFLS_TX4_8,
+	.lcrh_tx        = UART_LCRH,
+	.lcrh_rx        = UART_LCRH,
+	.oversampling       = false,
+	.dma_threshold      = false,
+	.cts_event_workaround   = false,
+	.get_fifosize       = get_fifosize_sfax8,
+};
+
+static int sfax8_probe(struct platform_device *dev)
+{
+	struct uart_sf_port *uap;
+	struct vendor_data *vendor = &vendor_sfax8;
+	void __iomem *base;
+	int i, ret;
+	struct resource *res;
+
+	for (i = 0; i < ARRAY_SIZE(sfax8_ports); i++)
+		if (sfax8_ports[i] == NULL)
+			break;
+
+	if (i == ARRAY_SIZE(sfax8_ports))
+		return -EBUSY;
+
+	uap = devm_kzalloc(&dev->dev, sizeof(struct uart_sf_port),
+			   GFP_KERNEL);
+	if (uap == NULL)
+		return -ENOMEM;
+
+	i = sfax8_probe_dt_alias(i, &dev->dev);
+
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+
+	if(!res)
+		return -ENODEV;
+
+	if (!request_mem_region(res->start, resource_size(res), dev->name))
+		return -EBUSY;
+
+	base = ioremap(res->start, resource_size(res));
+
+	if (!base)
+		return -ENOMEM;
+
+	uap->clk = devm_clk_get(&dev->dev, NULL);
+	if (IS_ERR(uap->clk))
+		return PTR_ERR(uap->clk);
+
+	uap->vendor = vendor;
+	uap->lcrh_rx = vendor->lcrh_rx;
+	uap->lcrh_tx = vendor->lcrh_tx;
+	uap->old_cr = 0;
+	uap->fifosize = vendor->get_fifosize(dev);
+	uap->port.dev = &dev->dev;
+	uap->port.mapbase = res->start;
+	uap->port.membase = base;
+	uap->port.iotype = UPIO_MEM32;
+	uap->port.irq = platform_get_irq(dev, 0);
+	uap->port.irqflags = IRQF_TRIGGER_HIGH;
+	uap->port.fifosize = uap->fifosize;
+	uap->port.ops = &sfax8_pops;
+	uap->port.flags = UPF_BOOT_AUTOCONF;
+	uap->port.line = i;
+	uap->port.uartclk = uap->clk->rate;
+	sfax8_dma_probe(&dev->dev, uap);
+
+	/* Ensure interrupts from this UART are masked and cleared */
+	writew(0, uap->port.membase + UART_IMSC);
+	writew(0xffff, uap->port.membase + UART_ICR);
+
+	snprintf(uap->type, sizeof(uap->type), "SFAX8 rev%u", 32);
+
+	sfax8_ports[i] = uap;
+
+	sfax8_set_drvdata(dev, uap);
+
+	if (!sfax8_reg.state) {
+		ret = uart_register_driver(&sfax8_reg);
+		if (ret < 0) {
+			pr_err("Failed to register SFAX8 driver\n");
+			return ret;
+		}
+	}
+
+	ret = uart_add_one_port(&sfax8_reg, &uap->port);
+	if (ret) {
+		sfax8_ports[i] = NULL;
+		uart_unregister_driver(&sfax8_reg);
+		sfax8_dma_remove(uap);
+	}
+
+	return ret;
+}
+
+static int sfax8_remove(struct platform_device *dev)
+{
+	struct uart_sf_port *uap = sfax8_get_drvdata(dev);
+	bool busy = false;
+	int i;
+
+	uart_remove_one_port(&sfax8_reg, &uap->port);
+
+	for (i = 0; i < ARRAY_SIZE(sfax8_ports); i++)
+		if (sfax8_ports[i] == uap)
+			sfax8_ports[i] = NULL;
+		else if (sfax8_ports[i])
+			busy = true;
+
+	sfax8_dma_remove(uap);
+	if (!busy)
+		uart_unregister_driver(&sfax8_reg);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int sfax8_suspend(struct device *dev)
+{
+	struct uart_sf_port *uap = dev_get_drvdata(dev);
+
+	if (!uap)
+		return -EINVAL;
+
+	return uart_suspend_port(&sfax8_reg, &uap->port);
+}
+
+static int sfax8_resume(struct device *dev)
+{
+	struct uart_sf_port *uap = dev_get_drvdata(dev);
+
+	if (!uap)
+		return -EINVAL;
+
+	return uart_resume_port(&sfax8_reg, &uap->port);
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(sfax8_dev_pm_ops, sfax8_suspend, sfax8_resume);
+
+static const struct of_device_id uart_of_match[] = {
+	{ .compatible = "siflower,sfax8-uart", },
+	{},
+};
+
+static struct platform_driver sfax8_driver = {
+	.driver = {
+		.name	= "sfax8serial",
+		.of_match_table = uart_of_match,
+		.pm	= &sfax8_dev_pm_ops,
+	},
+	.probe		= sfax8_probe,
+	.remove		= sfax8_remove,
+};
+
+static int __init sfax8_init(void)
+{
+	printk(KERN_INFO "Serial: SFAX8 UART driver\n");
+
+	return platform_driver_register(&sfax8_driver);
+}
+
+static void __exit sfax8_exit(void)
+{
+	platform_driver_unregister(&sfax8_driver);
+}
+
+/*
+ * While this can be a module, if builtin it's most likely the console
+ * So let's leave module_exit but move module_init to an earlier place
+ */
+arch_initcall(sfax8_init);
+module_exit(sfax8_exit);
+
+MODULE_AUTHOR("ARM Ltd/Deep Blue Solutions Ltd");
+MODULE_DESCRIPTION("Siflower serial port driver");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/tty/serial/sfax8_uart.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/tty/serial/sfax8_uart.h	2017-11-21 20:13:12.446710527 +0800
@@ -0,0 +1,180 @@
+/*
+ *
+ *  Internal header file for SFAX8 serial ports
+ *
+ *  Copyright (C) ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef HARDWARE_SERIAL_SFAX8_H
+#define HARDWARE_SERIAL_SFAX8_H
+
+#include <linux/types.h>
+
+/* -------------------------------------------------------------------------------
+ *  From SFAX8 UART ( Block Specification
+ * -------------------------------------------------------------------------------
+ *  UART Register Offsets.
+ */
+#define UART_DR			0x00	/* Data read or written from the interface. */
+#define UART_RSR		0x04	/* Receive status register (Read). */
+#define UART_ECR		0x04	/* Error clear register (Write). */
+#define UART_DMAWM		0x08    /* DMA watermark configure register. */
+#define UART_TIMEOUT	0x0C    /* Timeout period register. */
+#define UART_FR			0x18	/* Flag register (Read only). */
+#define UART_LCRH_RX	0x1C    /* Rx line control register. */
+#define UART_ILPR		0x20	/* IrDA low power counter register. */
+#define UART_IBRD		0x24	/* Integer baud rate divisor register. */
+#define UART_FBRD		0x28	/* Fractional baud rate divisor register. */
+#define UART_LCRH		0x2c	/* Line control register. */
+#define UART_LCRH_TX	0x2c    /* Tx Line control register. */
+#define UART_CR			0x30	/* Control register. */
+#define UART_IFLS		0x34	/* Interrupt fifo level select. */
+#define UART_IMSC		0x38	/* Interrupt mask. */
+#define UART_RIS		0x3c	/* Raw interrupt status. */
+#define UART_MIS		0x40	/* Masked interrupt status. */
+#define UART_ICR		0x44	/* Interrupt clear register. */
+#define UART_DMACR		0x48	/* DMA control register. */
+#define UART_XFCR		0x50	/* XON/XOFF control register. */
+#define UART_XON1		0x54	/* XON1 register. */
+#define UART_XON2		0x58	/* XON2 register. */
+#define UART_XOFF1		0x5C	/* XON1 register. */
+#define UART_XOFF2		0x60	/* XON2 register. */
+#define UART_ITCR		0x80	/* Integration test control register. */
+#define UART_ITIP		0x84	/* Integration test input register. */
+#define UART_ABCR		0x100	/* Autobaud control register. */
+#define UART_ABIMSC		0x15C	/* Autobaud interrupt mask/clear register. */
+
+#define UART_DR_OE		(1 << 11)
+#define UART_DR_BE		(1 << 10)
+#define UART_DR_PE		(1 << 9)
+#define UART_DR_FE		(1 << 8)
+
+#define UART_RSR_OE 		0x08
+#define UART_RSR_BE 		0x04
+#define UART_RSR_PE 		0x02
+#define UART_RSR_FE 		0x01
+
+#define UART_FR_RI			0x100
+#define UART_FR_TXFE		0x080
+#define UART_FR_RXFF		0x040
+#define UART_FR_TXFF		0x020
+#define UART_FR_RXFE		0x010
+#define UART_FR_BUSY		0x008
+#define UART_FR_DCD 		0x004
+#define UART_FR_DSR 		0x002
+#define UART_FR_CTS 		0x001
+#define UART_FR_TMSK		(UART_FR_TXFF + UART_FR_BUSY)
+
+#define UART_CR_CTSEN		0x8000	/* CTS hardware flow control */
+#define UART_CR_RTSEN		0x4000	/* RTS hardware flow control */
+#define UART_CR_OUT2		0x2000	/* OUT2 */
+#define UART_CR_OUT1		0x1000	/* OUT1 */
+#define UART_CR_RTS			0x0800	/* RTS */
+#define UART_CR_DTR			0x0400	/* DTR */
+#define UART_CR_RXE			0x0200	/* receive enable */
+#define UART_CR_TXE			0x0100	/* transmit enable */
+#define UART_CR_LBE			0x0080	/* loopback enable */
+#define UART_CR_OVSFACT		0x0008	/* Oversampling factor */
+#define UART_CR_IIRLP		0x0004	/* SIR low power mode */
+#define UART_CR_SIREN		0x0002	/* SIR enable */
+#define UART_CR_UARTEN		0x0001	/* UART enable */
+
+#define UART_LCRH_SPS		0x80
+#define UART_LCRH_WLEN_8	0x60
+#define UART_LCRH_WLEN_7	0x40
+#define UART_LCRH_WLEN_6	0x20
+#define UART_LCRH_WLEN_5	0x00
+#define UART_LCRH_FEN		0x10
+#define UART_LCRH_STP2		0x08
+#define UART_LCRH_EPS		0x04
+#define UART_LCRH_PEN		0x02
+#define UART_LCRH_BRK		0x01
+
+#define UART_DMAWM_RX_1		(0 << 3)
+#define UART_DMAWM_RX_2		(1 << 3)
+#define UART_DMAWM_RX_4		(2 << 3)
+#define UART_DMAWM_RX_8		(3 << 3)
+#define UART_DMAWM_RX_16	(4 << 3)
+#define UART_DMAWM_RX_32	(5 << 3)
+#define UART_DMAWM_RX_48	(6 << 3)
+#define UART_DMAWM_TX_1		0
+#define UART_DMAWM_TX_2		1
+#define UART_DMAWM_TX_4		2
+#define UART_DMAWM_TX_8		3
+#define UART_DMAWM_TX_16	4
+#define UART_DMAWM_TX_32	5
+#define UART_DMAWM_TX_48	6
+
+#define UART_IFLS_RX1_8		(0 << 3)
+#define UART_IFLS_RX2_8		(1 << 3)
+#define UART_IFLS_RX4_8		(2 << 3)
+#define UART_IFLS_RX6_8		(3 << 3)
+#define UART_IFLS_RX7_8		(4 << 3)
+#define UART_IFLS_TX1_8		(0 << 0)
+#define UART_IFLS_TX2_8		(1 << 0)
+#define UART_IFLS_TX4_8		(2 << 0)
+#define UART_IFLS_TX6_8		(3 << 0)
+#define UART_IFLS_TX7_8		(4 << 0)
+/* special values for ST vendor with deeper fifo */
+#define UART_IFLS_RX_HALF	(5 << 3)
+#define UART_IFLS_TX_HALF	(5 << 0)
+
+#define UART_OEIM			(1 << 10)	/* overrun error interrupt mask */
+#define UART_BEIM			(1 << 9)	/* break error interrupt mask */
+#define UART_PEIM			(1 << 8)	/* parity error interrupt mask */
+#define UART_FEIM			(1 << 7)	/* framing error interrupt mask */
+#define UART_RTIM			(1 << 6)	/* receive timeout interrupt mask */
+#define UART_TXIM			(1 << 5)	/* transmit interrupt mask */
+#define UART_RXIM			(1 << 4)	/* receive interrupt mask */
+#define UART_DSRMIM			(1 << 3)	/* DSR interrupt mask */
+#define UART_DCDMIM			(1 << 2)	/* DCD interrupt mask */
+#define UART_CTSMIM			(1 << 1)	/* CTS interrupt mask */
+#define UART_RIMIM			(1 << 0)	/* RI interrupt mask */
+
+#define UART_OEIS			(1 << 10)	/* overrun error interrupt status */
+#define UART_BEIS			(1 << 9)	/* break error interrupt status */
+#define UART_PEIS			(1 << 8)	/* parity error interrupt status */
+#define UART_FEIS			(1 << 7)	/* framing error interrupt status */
+#define UART_RTIS			(1 << 6)	/* receive timeout interrupt status */
+#define UART_TXIS			(1 << 5)	/* transmit interrupt status */
+#define UART_RXIS			(1 << 4)	/* receive interrupt status */
+#define UART_DSRMIS			(1 << 3)	/* DSR interrupt status */
+#define UART_DCDMIS			(1 << 2)	/* DCD interrupt status */
+#define UART_CTSMIS			(1 << 1)	/* CTS interrupt status */
+#define UART_RIMIS			(1 << 0)	/* RI interrupt status */
+
+#define UART_OEIC			(1 << 10)	/* overrun error interrupt clear */
+#define UART_BEIC			(1 << 9)	/* break error interrupt clear */
+#define UART_PEIC			(1 << 8)	/* parity error interrupt clear */
+#define UART_FEIC			(1 << 7)	/* framing error interrupt clear */
+#define UART_RTIC			(1 << 6)	/* receive timeout interrupt clear */
+#define UART_TXIC			(1 << 5)	/* transmit interrupt clear */
+#define UART_RXIC			(1 << 4)	/* receive interrupt clear */
+#define UART_DSRMIC			(1 << 3)	/* DSR interrupt clear */
+#define UART_DCDMIC			(1 << 2)	/* DCD interrupt clear */
+#define UART_CTSMIC			(1 << 1)	/* CTS interrupt clear */
+#define UART_RIMIC			(1 << 0)	/* RI interrupt clear */
+
+#define UART_DMAONERR		(1 << 2)	/* disable dma on error */
+#define UART_TXDMAE			(1 << 1)	/* enable transmit dma */
+#define UART_RXDMAE			(1 << 0)	/* enable receive dma */
+
+#define UART_RSR_ANY		(UART_RSR_OE|UART_RSR_BE|UART_RSR_PE|UART_RSR_FE)
+#define UART_FR_MODEM_ANY	(UART_FR_DCD|UART_FR_DSR|UART_FR_CTS)
+
+
+#endif
Index: linux-3.18.29/drivers/usb/common/common.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/common/common.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/common/common.c	2017-11-21 20:13:12.446710527 +0800
@@ -17,6 +17,7 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/of.h>
 #include <linux/usb/otg.h>
+#include <linux/of_platform.h>
 
 const char *usb_otg_state_string(enum usb_otg_state state)
 {
@@ -89,6 +90,40 @@
 	[USB_DR_MODE_OTG]		= "otg",
 };
 
+static enum usb_dr_mode usb_get_dr_mode_from_string(const char *str)
+{
+	int index, ret;
+	const char *item;
+
+	ret = -EINVAL;
+
+	for (index = 0; index < ARRAY_SIZE(usb_dr_modes); index++) {
+		item = usb_dr_modes[index];
+		if (!item) {
+			break;
+		}
+		if (!strcmp(item, str)) {
+			ret = index;
+			break;
+		}
+	}
+
+	return (ret < 0) ? USB_DR_MODE_UNKNOWN : ret;
+}
+
+enum usb_dr_mode usb_get_dr_mode(struct device *dev)
+{
+	const char *dr_mode;
+	int err;
+
+	err = device_property_read_string(dev, "dr_mode", &dr_mode);
+	if (err < 0)
+		return USB_DR_MODE_UNKNOWN;
+
+	return usb_get_dr_mode_from_string(dr_mode);
+}
+EXPORT_SYMBOL_GPL(usb_get_dr_mode);
+
 /**
  * of_usb_get_dr_mode - Get dual role mode for given device_node
  * @np:	Pointer to the given device_node
Index: linux-3.18.29/drivers/usb/dwc2/core.h
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/core.h	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/core.h	2017-11-21 20:13:12.446710527 +0800
@@ -44,22 +44,65 @@
 #include <linux/usb/phy.h>
 #include "hw.h"
 
-#ifdef DWC2_LOG_WRITES
-static inline void do_write(u32 value, void *addr)
+#ifdef CONFIG_MIPS
+/*
+ * There are some MIPS machines that can run in either big-endian
+ * or little-endian mode and that use the dwc2 register without
+ * a byteswap in both ways.
+ * Unlike other architectures, MIPS apparently does not require a
+ * barrier before the __raw_writel() to synchronize with DMA but does
+ * require the barrier after the __raw_writel() to serialize a set of
+ * writes. This set of operations was added specifically for MIPS and
+ * should only be used there.
+ */
+static inline u32 dwc2_readl(const void __iomem *addr)
 {
-	writel(value, addr);
+	u32 value = __raw_readl(addr);
+
+	/* In order to preserve endianness __raw_* operation is used. Therefore
+	 * a barrier is needed to ensure IO access is not re-ordered across
+	 * reads or writes
+	 */
+	mb();
+	return value;
+}
+
+static inline void dwc2_writel(u32 value, void __iomem *addr)
+{
+	__raw_writel(value, addr);
+
+	/*
+	 * In order to preserve endianness __raw_* operation is used. Therefore
+	 * a barrier is needed to ensure IO access is not re-ordered across
+	 * reads or writes
+	 */
+	mb();
+#ifdef DWC2_LOG_WRITES
 	pr_info("INFO:: wrote %08x to %p\n", value, addr);
+#endif
+}
+#else
+/* Normal architectures just use readl/write */
+static inline u32 dwc2_readl(const void __iomem *addr)
+{
+	return readl(addr);
 }
 
-#undef writel
-#define writel(v, a)	do_write(v, a)
+static inline void dwc2_writel(u32 value, void __iomem *addr)
+{
+	writel(value, addr);
+
+#ifdef DWC2_LOG_WRITES
+	pr_info("info:: wrote %08x to %p\n", value, addr);
+#endif
+}
 #endif
 
 /* Maximum number of Endpoints/HostChannels */
 #define MAX_EPS_CHANNELS	16
 
-/* s3c-hsotg declarations */
-static const char * const s3c_hsotg_supply_names[] = {
+/* dwc2-hsotg declarations */
+static const char * const dwc2_hsotg_supply_names[] = {
 	"vusb_d",               /* digital USB supply, 1.2V */
 	"vusb_a",               /* analog USB supply, 1.1V */
 };
@@ -84,11 +127,11 @@
  */
 #define EP0_MPS_LIMIT   64
 
-struct s3c_hsotg;
-struct s3c_hsotg_req;
+struct dwc2_hsotg;
+struct dwc2_hsotg_req;
 
 /**
- * struct s3c_hsotg_ep - driver endpoint definition.
+ * struct dwc2_hsotg_ep - driver endpoint definition.
  * @ep: The gadget layer representation of the endpoint.
  * @name: The driver generated name for the endpoint.
  * @queue: Queue of requests for this endpoint.
@@ -108,7 +151,7 @@
  * @halted: Set if the endpoint has been halted.
  * @periodic: Set if this is a periodic ep, such as Interrupt
  * @isochronous: Set if this is a isochronous ep
- * @sent_zlp: Set if we've sent a zero-length packet.
+ * @send_zlp: Set if we need to send a zero-length packet.
  * @total_data: The total number of data bytes done.
  * @fifo_size: The size of the FIFO (for periodic IN endpoints)
  * @fifo_load: The amount of data loaded into the FIFO (periodic IN)
@@ -127,11 +170,11 @@
  * as in shared-fifo mode periodic in acts like a single-frame packet
  * buffer than a fifo)
  */
-struct s3c_hsotg_ep {
+struct dwc2_hsotg_ep {
 	struct usb_ep           ep;
 	struct list_head        queue;
-	struct s3c_hsotg        *parent;
-	struct s3c_hsotg_req    *req;
+	struct dwc2_hsotg       *parent;
+	struct dwc2_hsotg_req    *req;
 	struct dentry           *debugfs;
 
 	unsigned long           total_data;
@@ -149,86 +192,25 @@
 	unsigned int            halted:1;
 	unsigned int            periodic:1;
 	unsigned int            isochronous:1;
-	unsigned int            sent_zlp:1;
+	unsigned int            send_zlp:1;
+	unsigned int            has_correct_parity:1;
 
 	char                    name[10];
 };
 
 /**
- * struct s3c_hsotg - driver state.
- * @dev: The parent device supplied to the probe function
- * @driver: USB gadget driver
- * @phy: The otg phy transceiver structure for phy control.
- * @uphy: The otg phy transceiver structure for old USB phy control.
- * @plat: The platform specific configuration data. This can be removed once
- * all SoCs support usb transceiver.
- * @regs: The memory area mapped for accessing registers.
- * @irq: The IRQ number we are using
- * @supplies: Definition of USB power supplies
- * @phyif: PHY interface width
- * @dedicated_fifos: Set if the hardware has dedicated IN-EP fifos.
- * @num_of_eps: Number of available EPs (excluding EP0)
- * @debug_root: root directrory for debugfs.
- * @debug_file: main status file for debugfs.
- * @debug_fifo: FIFO status file for debugfs.
- * @ep0_reply: Request used for ep0 reply.
- * @ep0_buff: Buffer for EP0 reply data, if needed.
- * @ctrl_buff: Buffer for EP0 control requests.
- * @ctrl_req: Request for EP0 control packets.
- * @setup: NAK management for EP0 SETUP
- * @last_rst: Time of last reset
- * @eps: The endpoints being supplied to the gadget framework
- */
-struct s3c_hsotg {
-	struct device            *dev;
-	struct usb_gadget_driver *driver;
-	struct phy               *phy;
-	struct usb_phy           *uphy;
-	struct s3c_hsotg_plat    *plat;
-
-	spinlock_t              lock;
-
-	void __iomem            *regs;
-	int                     irq;
-	struct clk              *clk;
-
-	struct regulator_bulk_data supplies[ARRAY_SIZE(s3c_hsotg_supply_names)];
-
-	u32                     phyif;
-	int			fifo_mem;
-	unsigned int            dedicated_fifos:1;
-	unsigned char           num_of_eps;
-	u32			fifo_map;
-
-	struct dentry           *debug_root;
-	struct dentry           *debug_file;
-	struct dentry           *debug_fifo;
-
-	struct usb_request      *ep0_reply;
-	struct usb_request      *ctrl_req;
-	u8                      ep0_buff[8];
-	u8                      ctrl_buff[8];
-
-	struct usb_gadget       gadget;
-	unsigned int            setup;
-	unsigned long           last_rst;
-	struct s3c_hsotg_ep     *eps;
-};
-
-/**
- * struct s3c_hsotg_req - data transfer request
+ * struct dwc2_hsotg_req - data transfer request
  * @req: The USB gadget request
  * @queue: The list of requests for the endpoint this is queued for.
- * @in_progress: Has already had size/packets written to core
- * @mapped: DMA buffer for this request has been mapped via dma_map_single().
+ * @saved_req_buf: variable to save req.buf when bounce buffers are used.
  */
-struct s3c_hsotg_req {
+struct dwc2_hsotg_req {
 	struct usb_request      req;
 	struct list_head        queue;
-	unsigned char           in_progress;
-	unsigned char           mapped;
+	void *saved_req_buf;
 };
 
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
 #define call_gadget(_hs, _entry) \
 do { \
 	if ((_hs)->gadget.speed != USB_SPEED_UNKNOWN && \
@@ -238,6 +220,9 @@
 		spin_lock(&_hs->lock); \
 	} \
 } while (0)
+#else
+#define call_gadget(_hs, _entry)	do {} while (0)
+#endif
 
 struct dwc2_hsotg;
 struct dwc2_host_chan;
@@ -250,6 +235,22 @@
 	DWC2_L3,	/* Off state */
 };
 
+/*
+ * Gadget periodic tx fifo sizes as used by legacy driver
+ * EP0 is not included
+ */
+#define DWC2_G_P_LEGACY_TX_FIFO_SIZE {256, 256, 256, 256, 768, 768, 768, \
+					   768, 0, 0, 0, 0, 0, 0, 0}
+
+/* Gadget ep0 states */
+enum dwc2_ep0_state {
+	DWC2_EP0_SETUP,
+	DWC2_EP0_DATA_IN,
+	DWC2_EP0_DATA_OUT,
+	DWC2_EP0_STATUS_IN,
+	DWC2_EP0_STATUS_OUT,
+};
+
 /**
  * struct dwc2_core_params - Parameters for configuring the core
  *
@@ -374,6 +375,17 @@
  *                      by the driver and are ignored in this
  *                      configuration value.
  * @uframe_sched:       True to enable the microframe scheduler
+ * @external_id_pin_ctl: Specifies whether ID pin is handled externally.
+ *                      Disable CONIDSTSCHNG controller interrupt in such
+ *                      case.
+ *                      0 - No (default)
+ *                      1 - Yes
+ * @hibernation:	Specifies whether the controller support hibernation.
+ *			If hibernation is enabled, the controller will enter
+ *			hibernation in both peripheral and host mode when
+ *			needed.
+ *			0 - No (default)
+ *			1 - Yes
  *
  * The following parameters may be specified when starting the module. These
  * parameters define how the DWC_otg controller should be configured. A
@@ -411,6 +423,8 @@
 	int reload_ctl;
 	int ahbcfg;
 	int uframe_sched;
+	int external_id_pin_ctl;
+	int hibernation;
 };
 
 /**
@@ -438,7 +452,7 @@
  * @power_optimized     Are power optimizations enabled?
  * @num_dev_ep          Number of device endpoints available
  * @num_dev_perio_in_ep Number of device periodic IN endpoints
- *                      avaialable
+ *                      available
  * @dev_token_q_depth   Device Mode IN Token Sequence Learning Queue
  *                      Depth
  *                       0 to 30
@@ -491,15 +505,99 @@
 	u32 snpsid;
 };
 
+/* Size of control and EP0 buffers */
+#define DWC2_CTRL_BUFF_SIZE 8
+
+/**
+ * struct dwc2_gregs_backup - Holds global registers state before entering partial
+ * power down
+ * @gotgctl:		Backup of GOTGCTL register
+ * @gintmsk:		Backup of GINTMSK register
+ * @gahbcfg:		Backup of GAHBCFG register
+ * @gusbcfg:		Backup of GUSBCFG register
+ * @grxfsiz:		Backup of GRXFSIZ register
+ * @gnptxfsiz:		Backup of GNPTXFSIZ register
+ * @gi2cctl:		Backup of GI2CCTL register
+ * @hptxfsiz:		Backup of HPTXFSIZ register
+ * @gdfifocfg:		Backup of GDFIFOCFG register
+ * @dtxfsiz:		Backup of DTXFSIZ registers for each endpoint
+ * @gpwrdn:		Backup of GPWRDN register
+ */
+struct dwc2_gregs_backup {
+	u32 gotgctl;
+	u32 gintmsk;
+	u32 gahbcfg;
+	u32 gusbcfg;
+	u32 grxfsiz;
+	u32 gnptxfsiz;
+	u32 gi2cctl;
+	u32 hptxfsiz;
+	u32 pcgcctl;
+	u32 gdfifocfg;
+	u32 dtxfsiz[MAX_EPS_CHANNELS];
+	u32 gpwrdn;
+	bool valid;
+};
+
+/**
+ * struct  dwc2_dregs_backup - Holds device registers state before entering partial
+ * power down
+ * @dcfg:		Backup of DCFG register
+ * @dctl:		Backup of DCTL register
+ * @daintmsk:		Backup of DAINTMSK register
+ * @diepmsk:		Backup of DIEPMSK register
+ * @doepmsk:		Backup of DOEPMSK register
+ * @diepctl:		Backup of DIEPCTL register
+ * @dieptsiz:		Backup of DIEPTSIZ register
+ * @diepdma:		Backup of DIEPDMA register
+ * @doepctl:		Backup of DOEPCTL register
+ * @doeptsiz:		Backup of DOEPTSIZ register
+ * @doepdma:		Backup of DOEPDMA register
+ */
+struct dwc2_dregs_backup {
+	u32 dcfg;
+	u32 dctl;
+	u32 daintmsk;
+	u32 diepmsk;
+	u32 doepmsk;
+	u32 diepctl[MAX_EPS_CHANNELS];
+	u32 dieptsiz[MAX_EPS_CHANNELS];
+	u32 diepdma[MAX_EPS_CHANNELS];
+	u32 doepctl[MAX_EPS_CHANNELS];
+	u32 doeptsiz[MAX_EPS_CHANNELS];
+	u32 doepdma[MAX_EPS_CHANNELS];
+	bool valid;
+};
+
+/**
+ * struct  dwc2_hregs_backup - Holds host registers state before entering partial
+ * power down
+ * @hcfg:		Backup of HCFG register
+ * @haintmsk:		Backup of HAINTMSK register
+ * @hcintmsk:		Backup of HCINTMSK register
+ * @hptr0:		Backup of HPTR0 register
+ * @hfir:		Backup of HFIR register
+ */
+struct dwc2_hregs_backup {
+	u32 hcfg;
+	u32 haintmsk;
+	u32 hcintmsk[MAX_EPS_CHANNELS];
+	u32 hprt0;
+	u32 hfir;
+	bool valid;
+};
+
 /**
  * struct dwc2_hsotg - Holds the state of the driver, including the non-periodic
  * and periodic schedules
  *
+ * These are common for both host and peripheral modes:
+ *
  * @dev:                The struct device pointer
  * @regs:		Pointer to controller regs
- * @core_params:        Parameters that define how the core should be configured
  * @hw_params:          Parameters that were autodetected from the
  *                      hardware registers
+ * @core_params:	Parameters that define how the core should be configured
  * @op_state:           The operational State, during transitions (a_host=>
  *                      a_peripheral and b_device=>b_host) this may not match
  *                      the core, but allows the software to determine
@@ -508,6 +606,17 @@
  *                      - USB_DR_MODE_PERIPHERAL
  *                      - USB_DR_MODE_HOST
  *                      - USB_DR_MODE_OTG
+ * @hcd_enabled		Host mode sub-driver initialization indicator.
+ * @gadget_enabled	Peripheral mode sub-driver initialization indicator.
+ * @ll_hw_enabled	Status of low-level hardware resources.
+ * @phy:                The otg phy transceiver structure for phy control.
+ * @uphy:               The otg phy transceiver structure for old USB phy control.
+ * @plat:               The platform specific configuration data. This can be removed once
+ *                      all SoCs support usb transceiver.
+ * @supplies:           Definition of USB power supplies
+ * @phyif:              PHY interface width
+ * @lock:		Spinlock that protects all the driver data structures
+ * @priv:		Stores a pointer to the struct usb_hcd
  * @queuing_high_bandwidth: True if multiple packets of a high-bandwidth
  *                      transfer are in process of being queued
  * @srp_success:        Stores status of SRP request in the case of a FS PHY
@@ -517,6 +626,12 @@
  *                      interrupt
  * @wkp_timer:          Timer object for handling Wakeup Detected interrupt
  * @lx_state:           Lx state of connected device
+ * @gregs_backup: Backup of global registers during suspend
+ * @dregs_backup: Backup of device registers during suspend
+ * @hregs_backup: Backup of host registers during suspend
+ *
+ * These are for host mode:
+ *
  * @flags:              Flags for handling root port state changes
  * @non_periodic_sched_inactive: Inactive QHs in the non-periodic schedule.
  *                      Transfers associated with these QHs are not currently
@@ -585,11 +700,30 @@
  * @status_buf_dma:     DMA address for status_buf
  * @start_work:         Delayed work for handling host A-cable connection
  * @reset_work:         Delayed work for handling a port reset
- * @lock:               Spinlock that protects all the driver data structures
- * @priv:               Stores a pointer to the struct usb_hcd
  * @otg_port:           OTG port number
  * @frame_list:         Frame list
  * @frame_list_dma:     Frame list DMA address
+ *
+ * These are for peripheral mode:
+ *
+ * @driver:             USB gadget driver
+ * @dedicated_fifos:    Set if the hardware has dedicated IN-EP fifos.
+ * @num_of_eps:         Number of available EPs (excluding EP0)
+ * @debug_root:         Root directrory for debugfs.
+ * @debug_file:         Main status file for debugfs.
+ * @debug_testmode:     Testmode status file for debugfs.
+ * @debug_fifo:         FIFO status file for debugfs.
+ * @ep0_reply:          Request used for ep0 reply.
+ * @ep0_buff:           Buffer for EP0 reply data, if needed.
+ * @ctrl_buff:          Buffer for EP0 control requests.
+ * @ctrl_req:           Request for EP0 control packets.
+ * @ep0_state:          EP0 control transfers state
+ * @test_mode:          USB test mode requested by the host
+ * @eps:                The endpoints being supplied to the gadget framework
+ * @g_using_dma:          Indicate if dma usage is enabled
+ * @g_rx_fifo_sz:         Contains rx fifo size value
+ * @g_np_g_tx_fifo_sz:      Contains Non-Periodic tx fifo size value
+ * @g_tx_fifo_sz:         Contains tx fifo size value per endpoints
  */
 struct dwc2_hsotg {
 	struct device *dev;
@@ -600,6 +734,20 @@
 	struct dwc2_core_params *core_params;
 	enum usb_otg_state op_state;
 	enum usb_dr_mode dr_mode;
+	unsigned int hcd_enabled:1;
+	unsigned int gadget_enabled:1;
+	unsigned int ll_hw_enabled:1;
+
+	struct phy *phy;
+	struct usb_phy *uphy;
+	struct dwc2_hsotg_plat *plat;
+	struct regulator_bulk_data supplies[ARRAY_SIZE(dwc2_hsotg_supply_names)];
+	u32 phyif;
+
+	spinlock_t lock;
+	void *priv;
+	int     irq;
+	struct clk *clk;
 
 	unsigned int queuing_high_bandwidth:1;
 	unsigned int srp_success:1;
@@ -608,7 +756,21 @@
 	struct work_struct wf_otg;
 	struct timer_list wkp_timer;
 	enum dwc2_lx_state lx_state;
+	struct dwc2_gregs_backup gr_backup;
+	struct dwc2_dregs_backup dr_backup;
+	struct dwc2_hregs_backup hr_backup;
+
+	struct dentry *debug_root;
+	struct debugfs_regset32 *regset;
+
+	/* DWC OTG HW Release versions */
+#define DWC2_CORE_REV_2_71a	0x4f54271a
+#define DWC2_CORE_REV_2_90a	0x4f54290a
+#define DWC2_CORE_REV_2_92a	0x4f54292a
+#define DWC2_CORE_REV_2_94a	0x4f54294a
+#define DWC2_CORE_REV_3_00a	0x4f54300a
 
+#if IS_ENABLED(CONFIG_USB_DWC2_HOST) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
 	union dwc2_hcd_internal_flags {
 		u32 d32;
 		struct {
@@ -634,6 +796,7 @@
 	u16 frame_usecs[8];
 	u16 frame_number;
 	u16 periodic_qh_count;
+	bool bus_suspended;
 
 #ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS
 #define FRAME_NUM_ARRAY_SIZE 1000
@@ -655,19 +818,10 @@
 
 	struct delayed_work start_work;
 	struct delayed_work reset_work;
-	spinlock_t lock;
-	void *priv;
 	u8 otg_port;
 	u32 *frame_list;
 	dma_addr_t frame_list_dma;
 
-	/* DWC OTG HW Release versions */
-#define DWC2_CORE_REV_2_71a	0x4f54271a
-#define DWC2_CORE_REV_2_90a	0x4f54290a
-#define DWC2_CORE_REV_2_92a	0x4f54292a
-#define DWC2_CORE_REV_2_94a	0x4f54294a
-#define DWC2_CORE_REV_3_00a	0x4f54300a
-
 #ifdef DEBUG
 	u32 frrem_samples;
 	u64 frrem_accum;
@@ -686,6 +840,33 @@
 	u32 hfnum_other_samples_b;
 	u64 hfnum_other_frrem_accum_b;
 #endif
+#endif /* CONFIG_USB_DWC2_HOST || CONFIG_USB_DWC2_DUAL_ROLE */
+
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+	/* Gadget structures */
+	struct usb_gadget_driver *driver;
+	int fifo_mem;
+	unsigned int dedicated_fifos:1;
+	unsigned char num_of_eps;
+	u32 fifo_map;
+
+	struct usb_request *ep0_reply;
+	struct usb_request *ctrl_req;
+	void *ep0_buff;
+	void *ctrl_buff;
+	enum dwc2_ep0_state ep0_state;
+	u8 test_mode;
+
+	struct usb_gadget gadget;
+	unsigned int enabled:1;
+	unsigned int connected:1;
+	struct dwc2_hsotg_ep *eps_in[MAX_EPS_CHANNELS];
+	struct dwc2_hsotg_ep *eps_out[MAX_EPS_CHANNELS];
+	u32 g_using_dma;
+	u32 g_rx_fifo_sz;
+	u32 g_np_g_tx_fifo_sz;
+	u32 g_tx_fifo_sz[MAX_EPS_CHANNELS];
+#endif /* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
 };
 
 /* Reasons for halting a host channel */
@@ -711,6 +892,8 @@
  * and the DWC_otg controller
  */
 extern void dwc2_core_host_init(struct dwc2_hsotg *hsotg);
+extern int dwc2_enter_hibernation(struct dwc2_hsotg *hsotg);
+extern int dwc2_exit_hibernation(struct dwc2_hsotg *hsotg, bool restore);
 
 /*
  * Host core Functions.
@@ -943,6 +1126,16 @@
 
 extern void dwc2_set_param_otg_ver(struct dwc2_hsotg *hsotg, int val);
 
+extern void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
+				const struct dwc2_core_params *params);
+
+extern void dwc2_set_all_params(struct dwc2_core_params *params, int value);
+
+extern int dwc2_get_hwparams(struct dwc2_hsotg *hsotg);
+
+extern int dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg);
+extern int dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg);
+
 /*
  * Dump core registers and SPRAM
  */
@@ -955,4 +1148,49 @@
  */
 extern u16 dwc2_get_otg_version(struct dwc2_hsotg *hsotg);
 
+/* Gadget defines */
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+extern int dwc2_hsotg_remove(struct dwc2_hsotg *hsotg);
+extern int dwc2_hsotg_suspend(struct dwc2_hsotg *dwc2);
+extern int dwc2_hsotg_resume(struct dwc2_hsotg *dwc2);
+extern int dwc2_gadget_init(struct dwc2_hsotg *hsotg, int irq);
+extern void dwc2_hsotg_core_init_disconnected(struct dwc2_hsotg *dwc2,
+		bool reset);
+extern void dwc2_hsotg_core_connect(struct dwc2_hsotg *hsotg);
+extern void dwc2_hsotg_disconnect(struct dwc2_hsotg *dwc2);
+extern int dwc2_hsotg_set_test_mode(struct dwc2_hsotg *hsotg, int testmode);
+#define dwc2_is_device_connected(hsotg) (hsotg->connected)
+#else
+static inline int dwc2_hsotg_remove(struct dwc2_hsotg *dwc2)
+{ return 0; }
+static inline int dwc2_hsotg_suspend(struct dwc2_hsotg *dwc2)
+{ return 0; }
+static inline int dwc2_hsotg_resume(struct dwc2_hsotg *dwc2)
+{ return 0; }
+static inline int dwc2_gadget_init(struct dwc2_hsotg *hsotg, int irq)
+{ return 0; }
+static inline void dwc2_hsotg_core_init_disconnected(struct dwc2_hsotg *dwc2,
+		bool reset) {}
+static inline void dwc2_hsotg_core_connect(struct dwc2_hsotg *hsotg) {}
+static inline void dwc2_hsotg_disconnect(struct dwc2_hsotg *dwc2) {}
+static inline int dwc2_hsotg_set_test_mode(struct dwc2_hsotg *hsotg,
+							int testmode)
+{ return 0; }
+#define dwc2_is_device_connected(hsotg) (0)
+#endif
+
+#if IS_ENABLED(CONFIG_USB_DWC2_HOST) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+extern int dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg);
+extern void dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg);
+extern void dwc2_hcd_start(struct dwc2_hsotg *hsotg);
+#else
+static inline int dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg)
+{ return 0; }
+static inline void dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg) {}
+static inline void dwc2_hcd_start(struct dwc2_hsotg *hsotg) {}
+static inline void dwc2_hcd_remove(struct dwc2_hsotg *hsotg) {}
+static inline int dwc2_hcd_init(struct dwc2_hsotg *hsotg, int irq)
+{ return 0; }
+#endif
+
 #endif /* __DWC2_CORE_H__ */
Index: linux-3.18.29/drivers/usb/dwc2/debug.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/usb/dwc2/debug.h	2017-11-21 20:13:12.446710527 +0800
@@ -0,0 +1,38 @@
+/**
+ * debug.h - Designware USB2 DRD controller debug header
+ *
+ * Copyright (C) 2015 Intel Corporation
+ * Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2  of
+ * the License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "core.h"
+
+struct dwc2_data_statistic {
+        spinlock_t lock;
+        u64 total_data;
+};
+
+#ifdef CONFIG_DEBUG_FS
+extern int dwc2_debugfs_init(struct dwc2_hsotg *);
+extern void dwc2_debugfs_exit(struct dwc2_hsotg *);
+extern void dwc2_statistic_add(u32);
+extern void dwc2_statistic_decrease(u32);
+extern void dwc2_statistic_clear(void);
+#else
+static inline int dwc2_debugfs_init(struct dwc2_hsotg *hsotg)
+{  return 0;  }
+static inline void dwc2_debugfs_exit(struct dwc2_hsotg *hsotg)
+{  }
+static void dwc2_statistic_add(u32) {}
+static void dwc2_statistic_decrease(u32) {}
+static void dwc2_statistic_clear(void) {}
+#endif
Index: linux-3.18.29/drivers/usb/dwc2/debugfs.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/usb/dwc2/debugfs.c	2017-11-21 20:13:12.446710527 +0800
@@ -0,0 +1,836 @@
+/**
+ * debugfs.c - Designware USB2 DRD controller debugfs
+ *
+ * Copyright (C) 2015 Intel Corporation
+ * Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2  of
+ * the License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+
+#include "core.h"
+#include "debug.h"
+
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
+	IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+/**
+ * testmode_write - debugfs: change usb test mode
+ * @seq: The seq file to write to.
+ * @v: Unused parameter.
+ *
+ * This debugfs entry modify the current usb test mode.
+ */
+static ssize_t testmode_write(struct file *file, const char __user *ubuf, size_t
+		count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct dwc2_hsotg	*hsotg = s->private;
+	unsigned long		flags;
+	u32			testmode = 0;
+	char			buf[32];
+
+	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
+		return -EFAULT;
+
+	if (!strncmp(buf, "test_j", 6))
+		testmode = TEST_J;
+	else if (!strncmp(buf, "test_k", 6))
+		testmode = TEST_K;
+	else if (!strncmp(buf, "test_se0_nak", 12))
+		testmode = TEST_SE0_NAK;
+	else if (!strncmp(buf, "test_packet", 11))
+		testmode = TEST_PACKET;
+	else if (!strncmp(buf, "test_force_enable", 17))
+		testmode = TEST_FORCE_EN;
+	else
+		testmode = 0;
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	dwc2_hsotg_set_test_mode(hsotg, testmode);
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+	return count;
+}
+
+/**
+ * testmode_show - debugfs: show usb test mode state
+ * @seq: The seq file to write to.
+ * @v: Unused parameter.
+ *
+ * This debugfs entry shows which usb test mode is currently enabled.
+ */
+static int testmode_show(struct seq_file *s, void *unused)
+{
+	struct dwc2_hsotg *hsotg = s->private;
+	unsigned long flags;
+	int dctl;
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	dctl = dwc2_readl(hsotg->regs + DCTL);
+	dctl &= DCTL_TSTCTL_MASK;
+	dctl >>= DCTL_TSTCTL_SHIFT;
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	switch (dctl) {
+	case 0:
+		seq_puts(s, "no test\n");
+		break;
+	case TEST_J:
+		seq_puts(s, "test_j\n");
+		break;
+	case TEST_K:
+		seq_puts(s, "test_k\n");
+		break;
+	case TEST_SE0_NAK:
+		seq_puts(s, "test_se0_nak\n");
+		break;
+	case TEST_PACKET:
+		seq_puts(s, "test_packet\n");
+		break;
+	case TEST_FORCE_EN:
+		seq_puts(s, "test_force_enable\n");
+		break;
+	default:
+		seq_printf(s, "UNKNOWN %d\n", dctl);
+	}
+
+	return 0;
+}
+
+static int testmode_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, testmode_show, inode->i_private);
+}
+
+static const struct file_operations testmode_fops = {
+	.owner		= THIS_MODULE,
+	.open		= testmode_open,
+	.write		= testmode_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/**
+ * state_show - debugfs: show overall driver and device state.
+ * @seq: The seq file to write to.
+ * @v: Unused parameter.
+ *
+ * This debugfs entry shows the overall state of the hardware and
+ * some general information about each of the endpoints available
+ * to the system.
+ */
+static int state_show(struct seq_file *seq, void *v)
+{
+	struct dwc2_hsotg *hsotg = seq->private;
+	void __iomem *regs = hsotg->regs;
+	int idx;
+
+	seq_printf(seq, "DCFG=0x%08x, DCTL=0x%08x, DSTS=0x%08x\n",
+		 dwc2_readl(regs + DCFG),
+		 dwc2_readl(regs + DCTL),
+		 dwc2_readl(regs + DSTS));
+
+	seq_printf(seq, "DIEPMSK=0x%08x, DOEPMASK=0x%08x\n",
+		   dwc2_readl(regs + DIEPMSK), dwc2_readl(regs + DOEPMSK));
+
+	seq_printf(seq, "GINTMSK=0x%08x, GINTSTS=0x%08x\n",
+		   dwc2_readl(regs + GINTMSK),
+		   dwc2_readl(regs + GINTSTS));
+
+	seq_printf(seq, "DAINTMSK=0x%08x, DAINT=0x%08x\n",
+		   dwc2_readl(regs + DAINTMSK),
+		   dwc2_readl(regs + DAINT));
+
+	seq_printf(seq, "GNPTXSTS=0x%08x, GRXSTSR=%08x\n",
+		   dwc2_readl(regs + GNPTXSTS),
+		   dwc2_readl(regs + GRXSTSR));
+
+	seq_puts(seq, "\nEndpoint status:\n");
+
+	for (idx = 0; idx < hsotg->num_of_eps; idx++) {
+		u32 in, out;
+
+		in = dwc2_readl(regs + DIEPCTL(idx));
+		out = dwc2_readl(regs + DOEPCTL(idx));
+
+		seq_printf(seq, "ep%d: DIEPCTL=0x%08x, DOEPCTL=0x%08x",
+			   idx, in, out);
+
+		in = dwc2_readl(regs + DIEPTSIZ(idx));
+		out = dwc2_readl(regs + DOEPTSIZ(idx));
+
+		seq_printf(seq, ", DIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x",
+			   in, out);
+
+		seq_puts(seq, "\n");
+	}
+
+	return 0;
+}
+
+static int state_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, state_show, inode->i_private);
+}
+
+static const struct file_operations state_fops = {
+	.owner		= THIS_MODULE,
+	.open		= state_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/**
+ * fifo_show - debugfs: show the fifo information
+ * @seq: The seq_file to write data to.
+ * @v: Unused parameter.
+ *
+ * Show the FIFO information for the overall fifo and all the
+ * periodic transmission FIFOs.
+ */
+static int fifo_show(struct seq_file *seq, void *v)
+{
+	struct dwc2_hsotg *hsotg = seq->private;
+	void __iomem *regs = hsotg->regs;
+	u32 val;
+	int idx;
+
+	seq_puts(seq, "Non-periodic FIFOs:\n");
+	seq_printf(seq, "RXFIFO: Size %d\n", dwc2_readl(regs + GRXFSIZ));
+
+	val = dwc2_readl(regs + GNPTXFSIZ);
+	seq_printf(seq, "NPTXFIFO: Size %d, Start 0x%08x\n",
+		   val >> FIFOSIZE_DEPTH_SHIFT,
+		   val & FIFOSIZE_DEPTH_MASK);
+
+	seq_puts(seq, "\nPeriodic TXFIFOs:\n");
+
+	for (idx = 1; idx < hsotg->num_of_eps; idx++) {
+		val = dwc2_readl(regs + DPTXFSIZN(idx));
+
+		seq_printf(seq, "\tDPTXFIFO%2d: Size %d, Start 0x%08x\n", idx,
+			   val >> FIFOSIZE_DEPTH_SHIFT,
+			   val & FIFOSIZE_STARTADDR_MASK);
+	}
+
+	return 0;
+}
+
+static int fifo_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, fifo_show, inode->i_private);
+}
+
+static const struct file_operations fifo_fops = {
+	.owner		= THIS_MODULE,
+	.open		= fifo_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static const char *decode_direction(int is_in)
+{
+	return is_in ? "in" : "out";
+}
+
+/**
+ * ep_show - debugfs: show the state of an endpoint.
+ * @seq: The seq_file to write data to.
+ * @v: Unused parameter.
+ *
+ * This debugfs entry shows the state of the given endpoint (one is
+ * registered for each available).
+ */
+static int ep_show(struct seq_file *seq, void *v)
+{
+	struct dwc2_hsotg_ep *ep = seq->private;
+	struct dwc2_hsotg *hsotg = ep->parent;
+	struct dwc2_hsotg_req *req;
+	void __iomem *regs = hsotg->regs;
+	int index = ep->index;
+	int show_limit = 15;
+	unsigned long flags;
+
+	seq_printf(seq, "Endpoint index %d, named %s,  dir %s:\n",
+		   ep->index, ep->ep.name, decode_direction(ep->dir_in));
+
+	/* first show the register state */
+
+	seq_printf(seq, "\tDIEPCTL=0x%08x, DOEPCTL=0x%08x\n",
+		   dwc2_readl(regs + DIEPCTL(index)),
+		   dwc2_readl(regs + DOEPCTL(index)));
+
+	seq_printf(seq, "\tDIEPDMA=0x%08x, DOEPDMA=0x%08x\n",
+		   dwc2_readl(regs + DIEPDMA(index)),
+		   dwc2_readl(regs + DOEPDMA(index)));
+
+	seq_printf(seq, "\tDIEPINT=0x%08x, DOEPINT=0x%08x\n",
+		   dwc2_readl(regs + DIEPINT(index)),
+		   dwc2_readl(regs + DOEPINT(index)));
+
+	seq_printf(seq, "\tDIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x\n",
+		   dwc2_readl(regs + DIEPTSIZ(index)),
+		   dwc2_readl(regs + DOEPTSIZ(index)));
+
+	seq_puts(seq, "\n");
+	seq_printf(seq, "mps %d\n", ep->ep.maxpacket);
+	seq_printf(seq, "total_data=%ld\n", ep->total_data);
+
+	seq_printf(seq, "request list (%p,%p):\n",
+		   ep->queue.next, ep->queue.prev);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (--show_limit < 0) {
+			seq_puts(seq, "not showing more requests...\n");
+			break;
+		}
+
+		seq_printf(seq, "%c req %p: %d bytes @%p, ",
+			   req == ep->req ? '*' : ' ',
+			   req, req->req.length, req->req.buf);
+		seq_printf(seq, "%d done, res %d\n",
+			   req->req.actual, req->req.status);
+	}
+
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	return 0;
+}
+
+static int ep_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ep_show, inode->i_private);
+}
+
+static const struct file_operations ep_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ep_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/**
+ * dwc2_hsotg_create_debug - create debugfs directory and files
+ * @hsotg: The driver state
+ *
+ * Create the debugfs files to allow the user to get information
+ * about the state of the system. The directory name is created
+ * with the same name as the device itself, in case we end up
+ * with multiple blocks in future systems.
+ */
+static void dwc2_hsotg_create_debug(struct dwc2_hsotg *hsotg)
+{
+	struct dentry *root;
+	struct dentry *file;
+	unsigned epidx;
+
+	root = hsotg->debug_root;
+
+	/* create general state file */
+
+	file = debugfs_create_file("state", S_IRUGO, root, hsotg, &state_fops);
+	if (IS_ERR(file))
+		dev_err(hsotg->dev, "%s: failed to create state\n", __func__);
+
+	file = debugfs_create_file("testmode", S_IRUGO | S_IWUSR, root, hsotg,
+							&testmode_fops);
+	if (IS_ERR(file))
+		dev_err(hsotg->dev, "%s: failed to create testmode\n",
+				__func__);
+
+	file = debugfs_create_file("fifo", S_IRUGO, root, hsotg, &fifo_fops);
+	if (IS_ERR(file))
+		dev_err(hsotg->dev, "%s: failed to create fifo\n", __func__);
+
+	/* Create one file for each out endpoint */
+	for (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {
+		struct dwc2_hsotg_ep *ep;
+
+		ep = hsotg->eps_out[epidx];
+		if (ep) {
+			file = debugfs_create_file(ep->name, S_IRUGO,
+							  root, ep, &ep_fops);
+			if (IS_ERR(file))
+				dev_err(hsotg->dev, "failed to create %s debug file\n",
+					ep->name);
+		}
+	}
+	/* Create one file for each in endpoint. EP0 is handled with out eps */
+	for (epidx = 1; epidx < hsotg->num_of_eps; epidx++) {
+		struct dwc2_hsotg_ep *ep;
+
+		ep = hsotg->eps_in[epidx];
+		if (ep) {
+			file = debugfs_create_file(ep->name, S_IRUGO,
+							  root, ep, &ep_fops);
+			if (IS_ERR(file))
+				dev_err(hsotg->dev, "failed to create %s debug file\n",
+					ep->name);
+		}
+	}
+}
+#else
+static inline void dwc2_hsotg_create_debug(struct dwc2_hsotg *hsotg) {}
+#endif
+
+static int statistic_show(struct seq_file *seq, void *v)
+{
+	struct dwc2_data_statistic *statistic = seq->private;
+	unsigned long flags;
+
+	spin_lock_irqsave(&statistic->lock, flags);
+	seq_printf(seq, "%lld\n", statistic->total_data);
+	spin_unlock_irqrestore(&statistic->lock, flags);
+
+	return 0;
+}
+
+static int statistic_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, statistic_show, inode->i_private);
+}
+
+static const struct file_operations statistic_fops = {
+    .owner = THIS_MODULE,
+    .open = statistic_open,
+    .read = seq_read,
+    .llseek = seq_lseek,
+    .release = single_release,
+};
+
+static void dwc2_hsotg_create_statistic(struct dwc2_hsotg *hsotg, struct dwc2_data_statistic *statistic)
+{
+	struct dentry *root;
+	struct dentry *file;
+
+	spin_lock_init(&statistic->lock);
+	dwc2_statistic_clear();
+
+	root = hsotg->debug_root;
+	file = debugfs_create_file("statistic", S_IRUGO, root, statistic, &statistic_fops);
+	if (IS_ERR(file))
+		dev_err(hsotg->dev, "%s: failed to create statistic\n", __func__);
+}
+
+/* dwc2_hsotg_delete_debug is removed as cleanup in done in dwc2_debugfs_exit */
+
+#define dump_register(nm)	\
+{				\
+	.name	= #nm,		\
+	.offset	= nm,		\
+}
+
+static const struct debugfs_reg32 dwc2_regs[] = {
+	/*
+	 * Accessing registers like this can trigger mode mismatch interrupt.
+	 * However, according to dwc2 databook, the register access, in this
+	 * case, is completed on the processor bus but is ignored by the core
+	 * and does not affect its operation.
+	 */
+	dump_register(GOTGCTL),
+	dump_register(GOTGINT),
+	dump_register(GAHBCFG),
+	dump_register(GUSBCFG),
+	dump_register(GRSTCTL),
+	dump_register(GINTSTS),
+	dump_register(GINTMSK),
+	dump_register(GRXSTSR),
+	dump_register(GRXSTSP),
+	dump_register(GRXFSIZ),
+	dump_register(GNPTXFSIZ),
+	dump_register(GNPTXSTS),
+	dump_register(GI2CCTL),
+	dump_register(GPVNDCTL),
+	dump_register(GGPIO),
+	dump_register(GUID),
+	dump_register(GSNPSID),
+	dump_register(GHWCFG1),
+	dump_register(GHWCFG2),
+	dump_register(GHWCFG3),
+	dump_register(GHWCFG4),
+	dump_register(GLPMCFG),
+	dump_register(GPWRDN),
+	dump_register(GDFIFOCFG),
+	dump_register(ADPCTL),
+	dump_register(HPTXFSIZ),
+	dump_register(DPTXFSIZN(1)),
+	dump_register(DPTXFSIZN(2)),
+	dump_register(DPTXFSIZN(3)),
+	dump_register(DPTXFSIZN(4)),
+	dump_register(DPTXFSIZN(5)),
+	dump_register(DPTXFSIZN(6)),
+	dump_register(DPTXFSIZN(7)),
+	dump_register(DPTXFSIZN(8)),
+	dump_register(DPTXFSIZN(9)),
+	dump_register(DPTXFSIZN(10)),
+	dump_register(DPTXFSIZN(11)),
+	dump_register(DPTXFSIZN(12)),
+	dump_register(DPTXFSIZN(13)),
+	dump_register(DPTXFSIZN(14)),
+	dump_register(DPTXFSIZN(15)),
+	dump_register(DCFG),
+	dump_register(DCTL),
+	dump_register(DSTS),
+	dump_register(DIEPMSK),
+	dump_register(DOEPMSK),
+	dump_register(DAINT),
+	dump_register(DAINTMSK),
+	dump_register(DTKNQR1),
+	dump_register(DTKNQR2),
+	dump_register(DTKNQR3),
+	dump_register(DTKNQR4),
+	dump_register(DVBUSDIS),
+	dump_register(DVBUSPULSE),
+	dump_register(DIEPCTL(0)),
+	dump_register(DIEPCTL(1)),
+	dump_register(DIEPCTL(2)),
+	dump_register(DIEPCTL(3)),
+	dump_register(DIEPCTL(4)),
+	dump_register(DIEPCTL(5)),
+	dump_register(DIEPCTL(6)),
+	dump_register(DIEPCTL(7)),
+	dump_register(DIEPCTL(8)),
+	dump_register(DIEPCTL(9)),
+	dump_register(DIEPCTL(10)),
+	dump_register(DIEPCTL(11)),
+	dump_register(DIEPCTL(12)),
+	dump_register(DIEPCTL(13)),
+	dump_register(DIEPCTL(14)),
+	dump_register(DIEPCTL(15)),
+	dump_register(DOEPCTL(0)),
+	dump_register(DOEPCTL(1)),
+	dump_register(DOEPCTL(2)),
+	dump_register(DOEPCTL(3)),
+	dump_register(DOEPCTL(4)),
+	dump_register(DOEPCTL(5)),
+	dump_register(DOEPCTL(6)),
+	dump_register(DOEPCTL(7)),
+	dump_register(DOEPCTL(8)),
+	dump_register(DOEPCTL(9)),
+	dump_register(DOEPCTL(10)),
+	dump_register(DOEPCTL(11)),
+	dump_register(DOEPCTL(12)),
+	dump_register(DOEPCTL(13)),
+	dump_register(DOEPCTL(14)),
+	dump_register(DOEPCTL(15)),
+	dump_register(DIEPINT(0)),
+	dump_register(DIEPINT(1)),
+	dump_register(DIEPINT(2)),
+	dump_register(DIEPINT(3)),
+	dump_register(DIEPINT(4)),
+	dump_register(DIEPINT(5)),
+	dump_register(DIEPINT(6)),
+	dump_register(DIEPINT(7)),
+	dump_register(DIEPINT(8)),
+	dump_register(DIEPINT(9)),
+	dump_register(DIEPINT(10)),
+	dump_register(DIEPINT(11)),
+	dump_register(DIEPINT(12)),
+	dump_register(DIEPINT(13)),
+	dump_register(DIEPINT(14)),
+	dump_register(DIEPINT(15)),
+	dump_register(DOEPINT(0)),
+	dump_register(DOEPINT(1)),
+	dump_register(DOEPINT(2)),
+	dump_register(DOEPINT(3)),
+	dump_register(DOEPINT(4)),
+	dump_register(DOEPINT(5)),
+	dump_register(DOEPINT(6)),
+	dump_register(DOEPINT(7)),
+	dump_register(DOEPINT(8)),
+	dump_register(DOEPINT(9)),
+	dump_register(DOEPINT(10)),
+	dump_register(DOEPINT(11)),
+	dump_register(DOEPINT(12)),
+	dump_register(DOEPINT(13)),
+	dump_register(DOEPINT(14)),
+	dump_register(DOEPINT(15)),
+	dump_register(DIEPTSIZ(0)),
+	dump_register(DIEPTSIZ(1)),
+	dump_register(DIEPTSIZ(2)),
+	dump_register(DIEPTSIZ(3)),
+	dump_register(DIEPTSIZ(4)),
+	dump_register(DIEPTSIZ(5)),
+	dump_register(DIEPTSIZ(6)),
+	dump_register(DIEPTSIZ(7)),
+	dump_register(DIEPTSIZ(8)),
+	dump_register(DIEPTSIZ(9)),
+	dump_register(DIEPTSIZ(10)),
+	dump_register(DIEPTSIZ(11)),
+	dump_register(DIEPTSIZ(12)),
+	dump_register(DIEPTSIZ(13)),
+	dump_register(DIEPTSIZ(14)),
+	dump_register(DIEPTSIZ(15)),
+	dump_register(DOEPTSIZ(0)),
+	dump_register(DOEPTSIZ(1)),
+	dump_register(DOEPTSIZ(2)),
+	dump_register(DOEPTSIZ(3)),
+	dump_register(DOEPTSIZ(4)),
+	dump_register(DOEPTSIZ(5)),
+	dump_register(DOEPTSIZ(6)),
+	dump_register(DOEPTSIZ(7)),
+	dump_register(DOEPTSIZ(8)),
+	dump_register(DOEPTSIZ(9)),
+	dump_register(DOEPTSIZ(10)),
+	dump_register(DOEPTSIZ(11)),
+	dump_register(DOEPTSIZ(12)),
+	dump_register(DOEPTSIZ(13)),
+	dump_register(DOEPTSIZ(14)),
+	dump_register(DOEPTSIZ(15)),
+	dump_register(DIEPDMA(0)),
+	dump_register(DIEPDMA(1)),
+	dump_register(DIEPDMA(2)),
+	dump_register(DIEPDMA(3)),
+	dump_register(DIEPDMA(4)),
+	dump_register(DIEPDMA(5)),
+	dump_register(DIEPDMA(6)),
+	dump_register(DIEPDMA(7)),
+	dump_register(DIEPDMA(8)),
+	dump_register(DIEPDMA(9)),
+	dump_register(DIEPDMA(10)),
+	dump_register(DIEPDMA(11)),
+	dump_register(DIEPDMA(12)),
+	dump_register(DIEPDMA(13)),
+	dump_register(DIEPDMA(14)),
+	dump_register(DIEPDMA(15)),
+	dump_register(DOEPDMA(0)),
+	dump_register(DOEPDMA(1)),
+	dump_register(DOEPDMA(2)),
+	dump_register(DOEPDMA(3)),
+	dump_register(DOEPDMA(4)),
+	dump_register(DOEPDMA(5)),
+	dump_register(DOEPDMA(6)),
+	dump_register(DOEPDMA(7)),
+	dump_register(DOEPDMA(8)),
+	dump_register(DOEPDMA(9)),
+	dump_register(DOEPDMA(10)),
+	dump_register(DOEPDMA(11)),
+	dump_register(DOEPDMA(12)),
+	dump_register(DOEPDMA(13)),
+	dump_register(DOEPDMA(14)),
+	dump_register(DOEPDMA(15)),
+	dump_register(DTXFSTS(0)),
+	dump_register(DTXFSTS(1)),
+	dump_register(DTXFSTS(2)),
+	dump_register(DTXFSTS(3)),
+	dump_register(DTXFSTS(4)),
+	dump_register(DTXFSTS(5)),
+	dump_register(DTXFSTS(6)),
+	dump_register(DTXFSTS(7)),
+	dump_register(DTXFSTS(8)),
+	dump_register(DTXFSTS(9)),
+	dump_register(DTXFSTS(10)),
+	dump_register(DTXFSTS(11)),
+	dump_register(DTXFSTS(12)),
+	dump_register(DTXFSTS(13)),
+	dump_register(DTXFSTS(14)),
+	dump_register(DTXFSTS(15)),
+	dump_register(PCGCTL),
+	dump_register(HCFG),
+	dump_register(HFIR),
+	dump_register(HFNUM),
+	dump_register(HPTXSTS),
+	dump_register(HAINT),
+	dump_register(HAINTMSK),
+	dump_register(HFLBADDR),
+	dump_register(HPRT0),
+	dump_register(HCCHAR(0)),
+	dump_register(HCCHAR(1)),
+	dump_register(HCCHAR(2)),
+	dump_register(HCCHAR(3)),
+	dump_register(HCCHAR(4)),
+	dump_register(HCCHAR(5)),
+	dump_register(HCCHAR(6)),
+	dump_register(HCCHAR(7)),
+	dump_register(HCCHAR(8)),
+	dump_register(HCCHAR(9)),
+	dump_register(HCCHAR(10)),
+	dump_register(HCCHAR(11)),
+	dump_register(HCCHAR(12)),
+	dump_register(HCCHAR(13)),
+	dump_register(HCCHAR(14)),
+	dump_register(HCCHAR(15)),
+	dump_register(HCSPLT(0)),
+	dump_register(HCSPLT(1)),
+	dump_register(HCSPLT(2)),
+	dump_register(HCSPLT(3)),
+	dump_register(HCSPLT(4)),
+	dump_register(HCSPLT(5)),
+	dump_register(HCSPLT(6)),
+	dump_register(HCSPLT(7)),
+	dump_register(HCSPLT(8)),
+	dump_register(HCSPLT(9)),
+	dump_register(HCSPLT(10)),
+	dump_register(HCSPLT(11)),
+	dump_register(HCSPLT(12)),
+	dump_register(HCSPLT(13)),
+	dump_register(HCSPLT(14)),
+	dump_register(HCSPLT(15)),
+	dump_register(HCINT(0)),
+	dump_register(HCINT(1)),
+	dump_register(HCINT(2)),
+	dump_register(HCINT(3)),
+	dump_register(HCINT(4)),
+	dump_register(HCINT(5)),
+	dump_register(HCINT(6)),
+	dump_register(HCINT(7)),
+	dump_register(HCINT(8)),
+	dump_register(HCINT(9)),
+	dump_register(HCINT(10)),
+	dump_register(HCINT(11)),
+	dump_register(HCINT(12)),
+	dump_register(HCINT(13)),
+	dump_register(HCINT(14)),
+	dump_register(HCINT(15)),
+	dump_register(HCINTMSK(0)),
+	dump_register(HCINTMSK(1)),
+	dump_register(HCINTMSK(2)),
+	dump_register(HCINTMSK(3)),
+	dump_register(HCINTMSK(4)),
+	dump_register(HCINTMSK(5)),
+	dump_register(HCINTMSK(6)),
+	dump_register(HCINTMSK(7)),
+	dump_register(HCINTMSK(8)),
+	dump_register(HCINTMSK(9)),
+	dump_register(HCINTMSK(10)),
+	dump_register(HCINTMSK(11)),
+	dump_register(HCINTMSK(12)),
+	dump_register(HCINTMSK(13)),
+	dump_register(HCINTMSK(14)),
+	dump_register(HCINTMSK(15)),
+	dump_register(HCTSIZ(0)),
+	dump_register(HCTSIZ(1)),
+	dump_register(HCTSIZ(2)),
+	dump_register(HCTSIZ(3)),
+	dump_register(HCTSIZ(4)),
+	dump_register(HCTSIZ(5)),
+	dump_register(HCTSIZ(6)),
+	dump_register(HCTSIZ(7)),
+	dump_register(HCTSIZ(8)),
+	dump_register(HCTSIZ(9)),
+	dump_register(HCTSIZ(10)),
+	dump_register(HCTSIZ(11)),
+	dump_register(HCTSIZ(12)),
+	dump_register(HCTSIZ(13)),
+	dump_register(HCTSIZ(14)),
+	dump_register(HCTSIZ(15)),
+	dump_register(HCDMA(0)),
+	dump_register(HCDMA(1)),
+	dump_register(HCDMA(2)),
+	dump_register(HCDMA(3)),
+	dump_register(HCDMA(4)),
+	dump_register(HCDMA(5)),
+	dump_register(HCDMA(6)),
+	dump_register(HCDMA(7)),
+	dump_register(HCDMA(8)),
+	dump_register(HCDMA(9)),
+	dump_register(HCDMA(10)),
+	dump_register(HCDMA(11)),
+	dump_register(HCDMA(12)),
+	dump_register(HCDMA(13)),
+	dump_register(HCDMA(14)),
+	dump_register(HCDMA(15)),
+	dump_register(HCDMAB(0)),
+	dump_register(HCDMAB(1)),
+	dump_register(HCDMAB(2)),
+	dump_register(HCDMAB(3)),
+	dump_register(HCDMAB(4)),
+	dump_register(HCDMAB(5)),
+	dump_register(HCDMAB(6)),
+	dump_register(HCDMAB(7)),
+	dump_register(HCDMAB(8)),
+	dump_register(HCDMAB(9)),
+	dump_register(HCDMAB(10)),
+	dump_register(HCDMAB(11)),
+	dump_register(HCDMAB(12)),
+	dump_register(HCDMAB(13)),
+	dump_register(HCDMAB(14)),
+	dump_register(HCDMAB(15)),
+};
+
+static struct dwc2_data_statistic transfer_statistic;
+
+void dwc2_statistic_add(u32 length)
+{
+	spin_lock(&transfer_statistic.lock);
+	transfer_statistic.total_data += (u64)length;
+	spin_unlock(&transfer_statistic.lock);
+}
+
+void dwc2_statistic_decrease(u32 length)
+{
+	spin_lock(&transfer_statistic.lock);
+	transfer_statistic.total_data -= (u64)length;
+	spin_unlock(&transfer_statistic.lock);
+}
+
+void dwc2_statistic_clear()
+{
+	spin_lock(&transfer_statistic.lock);
+	transfer_statistic.total_data = 0;
+	spin_unlock(&transfer_statistic.lock);
+}
+
+int dwc2_debugfs_init(struct dwc2_hsotg *hsotg)
+{
+	int			ret;
+	struct dentry		*file;
+
+	hsotg->debug_root = debugfs_create_dir(dev_name(hsotg->dev), NULL);
+	if (!hsotg->debug_root) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	/* Add gadget debugfs nodes */
+	dwc2_hsotg_create_debug(hsotg);
+
+	/* Add transfer length node */
+	dwc2_hsotg_create_statistic(hsotg, &transfer_statistic);
+
+	hsotg->regset = devm_kzalloc(hsotg->dev, sizeof(*hsotg->regset),
+								GFP_KERNEL);
+	if (!hsotg->regset) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	hsotg->regset->regs = dwc2_regs;
+	hsotg->regset->nregs = ARRAY_SIZE(dwc2_regs);
+	hsotg->regset->base = hsotg->regs;
+
+	file = debugfs_create_regset32("regdump", S_IRUGO, hsotg->debug_root,
+								hsotg->regset);
+	if (!file) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	return 0;
+err1:
+	debugfs_remove_recursive(hsotg->debug_root);
+err0:
+	return ret;
+}
+
+void dwc2_debugfs_exit(struct dwc2_hsotg *hsotg)
+{
+	debugfs_remove_recursive(hsotg->debug_root);
+	hsotg->debug_root = NULL;
+}
Index: linux-3.18.29/drivers/usb/dwc2/gadget.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/gadget.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/gadget.c	2017-11-21 20:13:12.446710527 +0800
@@ -20,51 +20,57 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
-#include <linux/debugfs.h>
+#include <linux/mutex.h>
 #include <linux/seq_file.h>
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/regulator/consumer.h>
 #include <linux/of_platform.h>
-#include <linux/phy/phy.h>
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/phy.h>
-#include <linux/platform_data/s3c-hsotg.h>
 
 #include "core.h"
+#include "hw.h"
 
 /* conversion functions */
-static inline struct s3c_hsotg_req *our_req(struct usb_request *req)
+static inline struct dwc2_hsotg_req *our_req(struct usb_request *req)
 {
-	return container_of(req, struct s3c_hsotg_req, req);
+	return container_of(req, struct dwc2_hsotg_req, req);
 }
 
-static inline struct s3c_hsotg_ep *our_ep(struct usb_ep *ep)
+static inline struct dwc2_hsotg_ep *our_ep(struct usb_ep *ep)
 {
-	return container_of(ep, struct s3c_hsotg_ep, ep);
+	return container_of(ep, struct dwc2_hsotg_ep, ep);
 }
 
-static inline struct s3c_hsotg *to_hsotg(struct usb_gadget *gadget)
+static inline struct dwc2_hsotg *to_hsotg(struct usb_gadget *gadget)
 {
-	return container_of(gadget, struct s3c_hsotg, gadget);
+	return container_of(gadget, struct dwc2_hsotg, gadget);
 }
 
 static inline void __orr32(void __iomem *ptr, u32 val)
 {
-	writel(readl(ptr) | val, ptr);
+	dwc2_writel(dwc2_readl(ptr) | val, ptr);
 }
 
 static inline void __bic32(void __iomem *ptr, u32 val)
 {
-	writel(readl(ptr) & ~val, ptr);
+	dwc2_writel(dwc2_readl(ptr) & ~val, ptr);
 }
 
-/* forward decleration of functions */
-static void s3c_hsotg_dump(struct s3c_hsotg *hsotg);
+static inline struct dwc2_hsotg_ep *index_to_ep(struct dwc2_hsotg *hsotg,
+						u32 ep_index, u32 dir_in)
+{
+	if (dir_in)
+		return hsotg->eps_in[ep_index];
+	else
+		return hsotg->eps_out[ep_index];
+}
+
+/* forward declaration of functions */
+static void dwc2_hsotg_dump(struct dwc2_hsotg *hsotg);
 
 /**
  * using_dma - return the DMA status of the driver.
@@ -83,49 +89,49 @@
  * a core reset. This means we either need to fix the gadgets to take
  * account of DMA alignment, or add bounce buffers (yuerk).
  *
- * Until this issue is sorted out, we always return 'false'.
+ * g_using_dma is set depending on dts flag.
  */
-static inline bool using_dma(struct s3c_hsotg *hsotg)
+static inline bool using_dma(struct dwc2_hsotg *hsotg)
 {
-	return false;	/* support is not complete */
+	return hsotg->g_using_dma;
 }
 
 /**
- * s3c_hsotg_en_gsint - enable one or more of the general interrupt
+ * dwc2_hsotg_en_gsint - enable one or more of the general interrupt
  * @hsotg: The device state
  * @ints: A bitmask of the interrupts to enable
  */
-static void s3c_hsotg_en_gsint(struct s3c_hsotg *hsotg, u32 ints)
+static void dwc2_hsotg_en_gsint(struct dwc2_hsotg *hsotg, u32 ints)
 {
-	u32 gsintmsk = readl(hsotg->regs + GINTMSK);
+	u32 gsintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 	u32 new_gsintmsk;
 
 	new_gsintmsk = gsintmsk | ints;
 
 	if (new_gsintmsk != gsintmsk) {
 		dev_dbg(hsotg->dev, "gsintmsk now 0x%08x\n", new_gsintmsk);
-		writel(new_gsintmsk, hsotg->regs + GINTMSK);
+		dwc2_writel(new_gsintmsk, hsotg->regs + GINTMSK);
 	}
 }
 
 /**
- * s3c_hsotg_disable_gsint - disable one or more of the general interrupt
+ * dwc2_hsotg_disable_gsint - disable one or more of the general interrupt
  * @hsotg: The device state
  * @ints: A bitmask of the interrupts to enable
  */
-static void s3c_hsotg_disable_gsint(struct s3c_hsotg *hsotg, u32 ints)
+static void dwc2_hsotg_disable_gsint(struct dwc2_hsotg *hsotg, u32 ints)
 {
-	u32 gsintmsk = readl(hsotg->regs + GINTMSK);
+	u32 gsintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 	u32 new_gsintmsk;
 
 	new_gsintmsk = gsintmsk & ~ints;
 
 	if (new_gsintmsk != gsintmsk)
-		writel(new_gsintmsk, hsotg->regs + GINTMSK);
+		dwc2_writel(new_gsintmsk, hsotg->regs + GINTMSK);
 }
 
 /**
- * s3c_hsotg_ctrl_epint - enable/disable an endpoint irq
+ * dwc2_hsotg_ctrl_epint - enable/disable an endpoint irq
  * @hsotg: The device state
  * @ep: The endpoint index
  * @dir_in: True if direction is in.
@@ -134,7 +140,7 @@
  * Set or clear the mask for an individual endpoint's interrupt
  * request.
  */
-static void s3c_hsotg_ctrl_epint(struct s3c_hsotg *hsotg,
+static void dwc2_hsotg_ctrl_epint(struct dwc2_hsotg *hsotg,
 				 unsigned int ep, unsigned int dir_in,
 				 unsigned int en)
 {
@@ -146,32 +152,35 @@
 		bit <<= 16;
 
 	local_irq_save(flags);
-	daint = readl(hsotg->regs + DAINTMSK);
+	daint = dwc2_readl(hsotg->regs + DAINTMSK);
 	if (en)
 		daint |= bit;
 	else
 		daint &= ~bit;
-	writel(daint, hsotg->regs + DAINTMSK);
+	dwc2_writel(daint, hsotg->regs + DAINTMSK);
 	local_irq_restore(flags);
 }
 
 /**
- * s3c_hsotg_init_fifo - initialise non-periodic FIFOs
+ * dwc2_hsotg_init_fifo - initialise non-periodic FIFOs
  * @hsotg: The device instance.
  */
-static void s3c_hsotg_init_fifo(struct s3c_hsotg *hsotg)
+static void dwc2_hsotg_init_fifo(struct dwc2_hsotg *hsotg)
 {
 	unsigned int ep;
 	unsigned int addr;
-	unsigned int size;
 	int timeout;
 	u32 val;
 
-	/* set FIFO sizes to 2048/1024 */
-
-	writel(2048, hsotg->regs + GRXFSIZ);
-	writel((2048 << FIFOSIZE_STARTADDR_SHIFT) |
-		(1024 << FIFOSIZE_DEPTH_SHIFT), hsotg->regs + GNPTXFSIZ);
+	/* Reset fifo map if not correctly cleared during previous session */
+	WARN_ON(hsotg->fifo_map);
+	hsotg->fifo_map = 0;
+
+	/* set RX/NPTX FIFO sizes */
+	dwc2_writel(hsotg->g_rx_fifo_sz, hsotg->regs + GRXFSIZ);
+	dwc2_writel((hsotg->g_rx_fifo_sz << FIFOSIZE_STARTADDR_SHIFT) |
+		(hsotg->g_np_g_tx_fifo_sz << FIFOSIZE_DEPTH_SHIFT),
+		hsotg->regs + GNPTXFSIZ);
 
 	/*
 	 * arange all the rest of the TX FIFOs, as some versions of this
@@ -181,37 +190,23 @@
 	 */
 
 	/* start at the end of the GNPTXFSIZ, rounded up */
-	addr = 2048 + 1024;
+	addr = hsotg->g_rx_fifo_sz + hsotg->g_np_g_tx_fifo_sz;
 
 	/*
-	 * Because we have not enough memory to have each TX FIFO of size at
-	 * least 3072 bytes (the maximum single packet size), we create four
-	 * FIFOs of lenght 1024, and four of length 3072 bytes, and assing
+	 * Configure fifos sizes from provided configuration and assign
 	 * them to endpoints dynamically according to maxpacket size value of
 	 * given endpoint.
 	 */
-
-	/* 256*4=1024 bytes FIFO length */
-	size = 256;
-	for (ep = 1; ep <= 4; ep++) {
-		val = addr;
-		val |= size << FIFOSIZE_DEPTH_SHIFT;
-		WARN_ONCE(addr + size > hsotg->fifo_mem,
-			  "insufficient fifo memory");
-		addr += size;
-
-		writel(val, hsotg->regs + DPTXFSIZN(ep));
-	}
-	/* 768*4=3072 bytes FIFO length */
-	size = 768;
-	for (ep = 5; ep <= 8; ep++) {
+	for (ep = 1; ep < MAX_EPS_CHANNELS; ep++) {
+		if (!hsotg->g_tx_fifo_sz[ep])
+			continue;
 		val = addr;
-		val |= size << FIFOSIZE_DEPTH_SHIFT;
-		WARN_ONCE(addr + size > hsotg->fifo_mem,
+		val |= hsotg->g_tx_fifo_sz[ep] << FIFOSIZE_DEPTH_SHIFT;
+		WARN_ONCE(addr + hsotg->g_tx_fifo_sz[ep] > hsotg->fifo_mem,
 			  "insufficient fifo memory");
-		addr += size;
+		addr += hsotg->g_tx_fifo_sz[ep];
 
-		writel(val, hsotg->regs + DPTXFSIZN(ep));
+		dwc2_writel(val, hsotg->regs + DPTXFSIZN(ep));
 	}
 
 	/*
@@ -219,13 +214,13 @@
 	 * all fifos are flushed before continuing
 	 */
 
-	writel(GRSTCTL_TXFNUM(0x10) | GRSTCTL_TXFFLSH |
+	dwc2_writel(GRSTCTL_TXFNUM(0x10) | GRSTCTL_TXFFLSH |
 	       GRSTCTL_RXFFLSH, hsotg->regs + GRSTCTL);
 
 	/* wait until the fifos are both flushed */
 	timeout = 100;
 	while (1) {
-		val = readl(hsotg->regs + GRSTCTL);
+		val = dwc2_readl(hsotg->regs + GRSTCTL);
 
 		if ((val & (GRSTCTL_TXFFLSH | GRSTCTL_RXFFLSH)) == 0)
 			break;
@@ -234,6 +229,7 @@
 			dev_err(hsotg->dev,
 				"%s: timeout flushing fifos (GRSTCTL=%08x)\n",
 				__func__, val);
+			break;
 		}
 
 		udelay(1);
@@ -248,12 +244,12 @@
  *
  * Allocate a new USB request structure appropriate for the specified endpoint
  */
-static struct usb_request *s3c_hsotg_ep_alloc_request(struct usb_ep *ep,
+static struct usb_request *dwc2_hsotg_ep_alloc_request(struct usb_ep *ep,
 						      gfp_t flags)
 {
-	struct s3c_hsotg_req *req;
+	struct dwc2_hsotg_req *req;
 
-	req = kzalloc(sizeof(struct s3c_hsotg_req), flags);
+	req = kzalloc(sizeof(struct dwc2_hsotg_req), flags);
 	if (!req)
 		return NULL;
 
@@ -269,23 +265,23 @@
  * Returns true if the endpoint is in periodic mode, meaning it is being
  * used for an Interrupt or ISO transfer.
  */
-static inline int is_ep_periodic(struct s3c_hsotg_ep *hs_ep)
+static inline int is_ep_periodic(struct dwc2_hsotg_ep *hs_ep)
 {
 	return hs_ep->periodic;
 }
 
 /**
- * s3c_hsotg_unmap_dma - unmap the DMA memory being used for the request
+ * dwc2_hsotg_unmap_dma - unmap the DMA memory being used for the request
  * @hsotg: The device state.
  * @hs_ep: The endpoint for the request
  * @hs_req: The request being processed.
  *
- * This is the reverse of s3c_hsotg_map_dma(), called for the completion
+ * This is the reverse of dwc2_hsotg_map_dma(), called for the completion
  * of a request to ensure the buffer is ready for access by the caller.
  */
-static void s3c_hsotg_unmap_dma(struct s3c_hsotg *hsotg,
-				struct s3c_hsotg_ep *hs_ep,
-				struct s3c_hsotg_req *hs_req)
+static void dwc2_hsotg_unmap_dma(struct dwc2_hsotg *hsotg,
+				struct dwc2_hsotg_ep *hs_ep,
+				struct dwc2_hsotg_req *hs_req)
 {
 	struct usb_request *req = &hs_req->req;
 
@@ -297,7 +293,7 @@
 }
 
 /**
- * s3c_hsotg_write_fifo - write packet Data to the TxFIFO
+ * dwc2_hsotg_write_fifo - write packet Data to the TxFIFO
  * @hsotg: The controller state.
  * @hs_ep: The endpoint we're going to write for.
  * @hs_req: The request to write data for.
@@ -312,12 +308,12 @@
  *
  * This routine is only needed for PIO
  */
-static int s3c_hsotg_write_fifo(struct s3c_hsotg *hsotg,
-				struct s3c_hsotg_ep *hs_ep,
-				struct s3c_hsotg_req *hs_req)
+static int dwc2_hsotg_write_fifo(struct dwc2_hsotg *hsotg,
+				struct dwc2_hsotg_ep *hs_ep,
+				struct dwc2_hsotg_req *hs_req)
 {
 	bool periodic = is_ep_periodic(hs_ep);
-	u32 gnptxsts = readl(hsotg->regs + GNPTXSTS);
+	u32 gnptxsts = dwc2_readl(hsotg->regs + GNPTXSTS);
 	int buf_pos = hs_req->req.actual;
 	int to_write = hs_ep->size_loaded;
 	void *data;
@@ -332,7 +328,7 @@
 		return 0;
 
 	if (periodic && !hsotg->dedicated_fifos) {
-		u32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
+		u32 epsize = dwc2_readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
 		int size_left;
 		int size_done;
 
@@ -348,7 +344,7 @@
 		 * previous data has been completely sent.
 		 */
 		if (hs_ep->fifo_load != 0) {
-			s3c_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);
+			dwc2_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);
 			return -ENOSPC;
 		}
 
@@ -369,11 +365,11 @@
 			__func__, can_write);
 
 		if (can_write <= 0) {
-			s3c_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);
+			dwc2_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);
 			return -ENOSPC;
 		}
 	} else if (hsotg->dedicated_fifos && hs_ep->index != 0) {
-		can_write = readl(hsotg->regs + DTXFSTS(hs_ep->index));
+		can_write = dwc2_readl(hsotg->regs + DTXFSTS(hs_ep->index));
 
 		can_write &= 0xffff;
 		can_write *= 4;
@@ -383,7 +379,7 @@
 				"%s: no queue slots available (0x%08x)\n",
 				__func__, gnptxsts);
 
-			s3c_hsotg_en_gsint(hsotg, GINTSTS_NPTXFEMP);
+			dwc2_hsotg_en_gsint(hsotg, GINTSTS_NPTXFEMP);
 			return -ENOSPC;
 		}
 
@@ -414,7 +410,7 @@
 
 		/* it's needed only when we do not use dedicated fifos */
 		if (!hsotg->dedicated_fifos)
-			s3c_hsotg_en_gsint(hsotg,
+			dwc2_hsotg_en_gsint(hsotg,
 					   periodic ? GINTSTS_PTXFEMP :
 					   GINTSTS_NPTXFEMP);
 	}
@@ -443,7 +439,7 @@
 
 		/* it's needed only when we do not use dedicated fifos */
 		if (!hsotg->dedicated_fifos)
-			s3c_hsotg_en_gsint(hsotg,
+			dwc2_hsotg_en_gsint(hsotg,
 					   periodic ? GINTSTS_PTXFEMP :
 					   GINTSTS_NPTXFEMP);
 	}
@@ -475,7 +471,7 @@
  * Return the maximum data that can be queued in one go on a given endpoint
  * so that transfers that are too long can be split.
  */
-static unsigned get_ep_limit(struct s3c_hsotg_ep *hs_ep)
+static unsigned get_ep_limit(struct dwc2_hsotg_ep *hs_ep)
 {
 	int index = hs_ep->index;
 	unsigned maxsize;
@@ -508,7 +504,7 @@
 }
 
 /**
- * s3c_hsotg_start_req - start a USB request from an endpoint's queue
+ * dwc2_hsotg_start_req - start a USB request from an endpoint's queue
  * @hsotg: The controller state.
  * @hs_ep: The endpoint to process a request for
  * @hs_req: The request to start.
@@ -517,9 +513,9 @@
  * Start the given request running by setting the endpoint registers
  * appropriately, and writing any data to the FIFOs.
  */
-static void s3c_hsotg_start_req(struct s3c_hsotg *hsotg,
-				struct s3c_hsotg_ep *hs_ep,
-				struct s3c_hsotg_req *hs_req,
+static void dwc2_hsotg_start_req(struct dwc2_hsotg *hsotg,
+				struct dwc2_hsotg_ep *hs_ep,
+				struct dwc2_hsotg_req *hs_req,
 				bool continuing)
 {
 	struct usb_request *ureq = &hs_req->req;
@@ -550,13 +546,13 @@
 	epsize_reg = dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);
 
 	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x, ep %d, dir %s\n",
-		__func__, readl(hsotg->regs + epctrl_reg), index,
+		__func__, dwc2_readl(hsotg->regs + epctrl_reg), index,
 		hs_ep->dir_in ? "in" : "out");
 
 	/* If endpoint is stalled, we will restart request later */
-	ctrl = readl(hsotg->regs + epctrl_reg);
+	ctrl = dwc2_readl(hsotg->regs + epctrl_reg);
 
-	if (ctrl & DXEPCTL_STALL) {
+	if (index && ctrl & DXEPCTL_STALL) {
 		dev_warn(hsotg->dev, "%s: ep%d is stalled\n", __func__, index);
 		return;
 	}
@@ -564,11 +560,6 @@
 	length = ureq->length - ureq->actual;
 	dev_dbg(hsotg->dev, "ureq->length:%d ureq->actual:%d\n",
 		ureq->length, ureq->actual);
-	if (0)
-		dev_dbg(hsotg->dev,
-			"REQ buf %p len %d dma %pad noi=%d zp=%d snok=%d\n",
-			ureq->buf, length, &ureq->dma,
-			ureq->no_interrupt, ureq->zero, ureq->short_not_ok);
 
 	maxreq = get_ep_limit(hs_ep);
 	if (length > maxreq) {
@@ -602,14 +593,15 @@
 	else
 		epsize = 0;
 
-	if (index != 0 && ureq->zero) {
-		/*
-		 * test for the packets being exactly right for the
-		 * transfer
-		 */
-
-		if (length == (packets * hs_ep->ep.maxpacket))
-			packets++;
+	/*
+	 * zero length packet should be programmed on its own and should not
+	 * be counted in DIEPTSIZ.PktCnt with other packets.
+	 */
+	if (dir_in && ureq->zero && !continuing) {
+		/* Test if zlp is actually required. */
+		if ((ureq->length >= hs_ep->ep.maxpacket) &&
+					!(ureq->length % hs_ep->ep.maxpacket))
+			hs_ep->send_zlp = 1;
 	}
 
 	epsize |= DXEPTSIZ_PKTCNT(packets);
@@ -622,18 +614,18 @@
 	hs_ep->req = hs_req;
 
 	/* write size / packets */
-	writel(epsize, hsotg->regs + epsize_reg);
+	dwc2_writel(epsize, hsotg->regs + epsize_reg);
 
 	if (using_dma(hsotg) && !continuing) {
 		unsigned int dma_reg;
 
 		/*
 		 * write DMA address to control register, buffer already
-		 * synced by s3c_hsotg_ep_queue().
+		 * synced by dwc2_hsotg_ep_queue().
 		 */
 
 		dma_reg = dir_in ? DIEPDMA(index) : DOEPDMA(index);
-		writel(ureq->dma, hsotg->regs + dma_reg);
+		dwc2_writel(ureq->dma, hsotg->regs + dma_reg);
 
 		dev_dbg(hsotg->dev, "%s: %pad => 0x%08x\n",
 			__func__, &ureq->dma, dma_reg);
@@ -642,17 +634,14 @@
 	ctrl |= DXEPCTL_EPENA;	/* ensure ep enabled */
 	ctrl |= DXEPCTL_USBACTEP;
 
-	dev_dbg(hsotg->dev, "setup req:%d\n", hsotg->setup);
+	dev_dbg(hsotg->dev, "ep0 state:%d\n", hsotg->ep0_state);
 
 	/* For Setup request do not clear NAK */
-	if (hsotg->setup && index == 0)
-		hsotg->setup = 0;
-	else
+	if (!(index == 0 && hsotg->ep0_state == DWC2_EP0_SETUP))
 		ctrl |= DXEPCTL_CNAK;	/* clear NAK set by core */
 
-
 	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);
-	writel(ctrl, hsotg->regs + epctrl_reg);
+	dwc2_writel(ctrl, hsotg->regs + epctrl_reg);
 
 	/*
 	 * set these, it seems that DMA support increments past the end
@@ -666,7 +655,7 @@
 		/* set these anyway, we may need them for non-periodic in */
 		hs_ep->fifo_load = 0;
 
-		s3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);
+		dwc2_hsotg_write_fifo(hsotg, hs_ep, hs_req);
 	}
 
 	/*
@@ -674,7 +663,7 @@
 	 * to debugging to see what is going on.
 	 */
 	if (dir_in)
-		writel(DIEPMSK_INTKNTXFEMPMSK,
+		dwc2_writel(DIEPMSK_INTKNTXFEMPMSK,
 		       hsotg->regs + DIEPINT(index));
 
 	/*
@@ -683,20 +672,20 @@
 	 */
 
 	/* check ep is enabled */
-	if (!(readl(hsotg->regs + epctrl_reg) & DXEPCTL_EPENA))
-		dev_warn(hsotg->dev,
+	if (!(dwc2_readl(hsotg->regs + epctrl_reg) & DXEPCTL_EPENA))
+		dev_dbg(hsotg->dev,
 			 "ep%d: failed to become enabled (DXEPCTL=0x%08x)?\n",
-			 index, readl(hsotg->regs + epctrl_reg));
+			 index, dwc2_readl(hsotg->regs + epctrl_reg));
 
 	dev_dbg(hsotg->dev, "%s: DXEPCTL=0x%08x\n",
-		__func__, readl(hsotg->regs + epctrl_reg));
+		__func__, dwc2_readl(hsotg->regs + epctrl_reg));
 
 	/* enable ep interrupts */
-	s3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 1);
+	dwc2_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 1);
 }
 
 /**
- * s3c_hsotg_map_dma - map the DMA memory being used for the request
+ * dwc2_hsotg_map_dma - map the DMA memory being used for the request
  * @hsotg: The device state.
  * @hs_ep: The endpoint the request is on.
  * @req: The request being processed.
@@ -707,11 +696,11 @@
  * DMA memory, then we map the memory and mark our request to allow us to
  * cleanup on completion.
  */
-static int s3c_hsotg_map_dma(struct s3c_hsotg *hsotg,
-			     struct s3c_hsotg_ep *hs_ep,
+static int dwc2_hsotg_map_dma(struct dwc2_hsotg *hsotg,
+			     struct dwc2_hsotg_ep *hs_ep,
 			     struct usb_request *req)
 {
-	struct s3c_hsotg_req *hs_req = our_req(req);
+	struct dwc2_hsotg_req *hs_req = our_req(req);
 	int ret;
 
 	/* if the length is zero, ignore the DMA data */
@@ -731,26 +720,91 @@
 	return -EIO;
 }
 
-static int s3c_hsotg_ep_queue(struct usb_ep *ep, struct usb_request *req,
+static int dwc2_hsotg_handle_unaligned_buf_start(struct dwc2_hsotg *hsotg,
+	struct dwc2_hsotg_ep *hs_ep, struct dwc2_hsotg_req *hs_req)
+{
+	void *req_buf = hs_req->req.buf;
+
+	/* If dma is not being used or buffer is aligned */
+	if (!using_dma(hsotg) || !((long)req_buf & 3))
+		return 0;
+
+	WARN_ON(hs_req->saved_req_buf);
+
+	dev_dbg(hsotg->dev, "%s: %s: buf=%p length=%d\n", __func__,
+			hs_ep->ep.name, req_buf, hs_req->req.length);
+
+	hs_req->req.buf = kmalloc(hs_req->req.length, GFP_ATOMIC);
+	if (!hs_req->req.buf) {
+		hs_req->req.buf = req_buf;
+		dev_err(hsotg->dev,
+			"%s: unable to allocate memory for bounce buffer\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	/* Save actual buffer */
+	hs_req->saved_req_buf = req_buf;
+
+	if (hs_ep->dir_in)
+		memcpy(hs_req->req.buf, req_buf, hs_req->req.length);
+	return 0;
+}
+
+static void dwc2_hsotg_handle_unaligned_buf_complete(struct dwc2_hsotg *hsotg,
+	struct dwc2_hsotg_ep *hs_ep, struct dwc2_hsotg_req *hs_req)
+{
+	/* If dma is not being used or buffer was aligned */
+	if (!using_dma(hsotg) || !hs_req->saved_req_buf)
+		return;
+
+	dev_dbg(hsotg->dev, "%s: %s: status=%d actual-length=%d\n", __func__,
+		hs_ep->ep.name, hs_req->req.status, hs_req->req.actual);
+
+	/* Copy data from bounce buffer on successful out transfer */
+	if (!hs_ep->dir_in && !hs_req->req.status)
+		memcpy(hs_req->saved_req_buf, hs_req->req.buf,
+							hs_req->req.actual);
+
+	/* Free bounce buffer */
+	kfree(hs_req->req.buf);
+
+	hs_req->req.buf = hs_req->saved_req_buf;
+	hs_req->saved_req_buf = NULL;
+}
+
+static int dwc2_hsotg_ep_queue(struct usb_ep *ep, struct usb_request *req,
 			      gfp_t gfp_flags)
 {
-	struct s3c_hsotg_req *hs_req = our_req(req);
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hs = hs_ep->parent;
+	struct dwc2_hsotg_req *hs_req = our_req(req);
+	struct dwc2_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *hs = hs_ep->parent;
 	bool first;
+	int ret;
 
 	dev_dbg(hs->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",
 		ep->name, req, req->length, req->buf, req->no_interrupt,
 		req->zero, req->short_not_ok);
 
+	/* Prevent new request submission when controller is suspended */
+	if (hs->lx_state == DWC2_L2) {
+		dev_dbg(hs->dev, "%s: don't submit request while suspended\n",
+				__func__);
+		return -EAGAIN;
+	}
+
 	/* initialise status of the request */
 	INIT_LIST_HEAD(&hs_req->queue);
 	req->actual = 0;
 	req->status = -EINPROGRESS;
 
+	ret = dwc2_hsotg_handle_unaligned_buf_start(hs, hs_ep, hs_req);
+	if (ret)
+		return ret;
+
 	/* if we're using DMA, sync the buffers as necessary */
 	if (using_dma(hs)) {
-		int ret = s3c_hsotg_map_dma(hs, hs_ep, req);
+		ret = dwc2_hsotg_map_dma(hs, hs_ep, req);
 		if (ret)
 			return ret;
 	}
@@ -759,51 +813,51 @@
 	list_add_tail(&hs_req->queue, &hs_ep->queue);
 
 	if (first)
-		s3c_hsotg_start_req(hs, hs_ep, hs_req, false);
+		dwc2_hsotg_start_req(hs, hs_ep, hs_req, false);
 
 	return 0;
 }
 
-static int s3c_hsotg_ep_queue_lock(struct usb_ep *ep, struct usb_request *req,
+static int dwc2_hsotg_ep_queue_lock(struct usb_ep *ep, struct usb_request *req,
 			      gfp_t gfp_flags)
 {
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hs = hs_ep->parent;
+	struct dwc2_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *hs = hs_ep->parent;
 	unsigned long flags = 0;
 	int ret = 0;
 
 	spin_lock_irqsave(&hs->lock, flags);
-	ret = s3c_hsotg_ep_queue(ep, req, gfp_flags);
+	ret = dwc2_hsotg_ep_queue(ep, req, gfp_flags);
 	spin_unlock_irqrestore(&hs->lock, flags);
 
 	return ret;
 }
 
-static void s3c_hsotg_ep_free_request(struct usb_ep *ep,
+static void dwc2_hsotg_ep_free_request(struct usb_ep *ep,
 				      struct usb_request *req)
 {
-	struct s3c_hsotg_req *hs_req = our_req(req);
+	struct dwc2_hsotg_req *hs_req = our_req(req);
 
 	kfree(hs_req);
 }
 
 /**
- * s3c_hsotg_complete_oursetup - setup completion callback
+ * dwc2_hsotg_complete_oursetup - setup completion callback
  * @ep: The endpoint the request was on.
  * @req: The request completed.
  *
  * Called on completion of any requests the driver itself
  * submitted that need cleaning up.
  */
-static void s3c_hsotg_complete_oursetup(struct usb_ep *ep,
+static void dwc2_hsotg_complete_oursetup(struct usb_ep *ep,
 					struct usb_request *req)
 {
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hsotg = hs_ep->parent;
+	struct dwc2_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *hsotg = hs_ep->parent;
 
 	dev_dbg(hsotg->dev, "%s: ep %p, req %p\n", __func__, ep, req);
 
-	s3c_hsotg_ep_free_request(ep, req);
+	dwc2_hsotg_ep_free_request(ep, req);
 }
 
 /**
@@ -814,10 +868,10 @@
  * Convert the given wIndex into a pointer to an driver endpoint
  * structure, or return NULL if it is not a valid endpoint.
  */
-static struct s3c_hsotg_ep *ep_from_windex(struct s3c_hsotg *hsotg,
+static struct dwc2_hsotg_ep *ep_from_windex(struct dwc2_hsotg *hsotg,
 					   u32 windex)
 {
-	struct s3c_hsotg_ep *ep = &hsotg->eps[windex & 0x7F];
+	struct dwc2_hsotg_ep *ep;
 	int dir = (windex & USB_DIR_IN) ? 1 : 0;
 	int idx = windex & 0x7F;
 
@@ -827,6 +881,8 @@
 	if (idx > hsotg->num_of_eps)
 		return NULL;
 
+	ep = index_to_ep(hsotg, idx, dir);
+
 	if (idx && ep->dir_in != dir)
 		return NULL;
 
@@ -834,7 +890,33 @@
 }
 
 /**
- * s3c_hsotg_send_reply - send reply to control request
+ * dwc2_hsotg_set_test_mode - Enable usb Test Modes
+ * @hsotg: The driver state.
+ * @testmode: requested usb test mode
+ * Enable usb Test Mode requested by the Host.
+ */
+int dwc2_hsotg_set_test_mode(struct dwc2_hsotg *hsotg, int testmode)
+{
+	int dctl = dwc2_readl(hsotg->regs + DCTL);
+
+	dctl &= ~DCTL_TSTCTL_MASK;
+	switch (testmode) {
+	case TEST_J:
+	case TEST_K:
+	case TEST_SE0_NAK:
+	case TEST_PACKET:
+	case TEST_FORCE_EN:
+		dctl |= testmode << DCTL_TSTCTL_SHIFT;
+		break;
+	default:
+		return -EINVAL;
+	}
+	dwc2_writel(dctl, hsotg->regs + DCTL);
+	return 0;
+}
+
+/**
+ * dwc2_hsotg_send_reply - send reply to control request
  * @hsotg: The device state
  * @ep: Endpoint 0
  * @buff: Buffer for request
@@ -843,8 +925,8 @@
  * Create a request and queue it on the given endpoint. This is useful as
  * an internal method of sending replies to certain control requests, etc.
  */
-static int s3c_hsotg_send_reply(struct s3c_hsotg *hsotg,
-				struct s3c_hsotg_ep *ep,
+static int dwc2_hsotg_send_reply(struct dwc2_hsotg *hsotg,
+				struct dwc2_hsotg_ep *ep,
 				void *buff,
 				int length)
 {
@@ -853,7 +935,7 @@
 
 	dev_dbg(hsotg->dev, "%s: buff %p, len %d\n", __func__, buff, length);
 
-	req = s3c_hsotg_ep_alloc_request(&ep->ep, GFP_ATOMIC);
+	req = dwc2_hsotg_ep_alloc_request(&ep->ep, GFP_ATOMIC);
 	hsotg->ep0_reply = req;
 	if (!req) {
 		dev_warn(hsotg->dev, "%s: cannot alloc req\n", __func__);
@@ -862,15 +944,17 @@
 
 	req->buf = hsotg->ep0_buff;
 	req->length = length;
-	req->zero = 1; /* always do zero-length final transfer */
-	req->complete = s3c_hsotg_complete_oursetup;
+	/*
+	 * zero flag is for sending zlp in DATA IN stage. It has no impact on
+	 * STATUS stage.
+	 */
+	req->zero = 0;
+	req->complete = dwc2_hsotg_complete_oursetup;
 
 	if (length)
 		memcpy(req->buf, buff, length);
-	else
-		ep->sent_zlp = 1;
 
-	ret = s3c_hsotg_ep_queue(&ep->ep, req, GFP_ATOMIC);
+	ret = dwc2_hsotg_ep_queue(&ep->ep, req, GFP_ATOMIC);
 	if (ret) {
 		dev_warn(hsotg->dev, "%s: cannot queue req\n", __func__);
 		return ret;
@@ -880,15 +964,15 @@
 }
 
 /**
- * s3c_hsotg_process_req_status - process request GET_STATUS
+ * dwc2_hsotg_process_req_status - process request GET_STATUS
  * @hsotg: The device state
  * @ctrl: USB control request
  */
-static int s3c_hsotg_process_req_status(struct s3c_hsotg *hsotg,
+static int dwc2_hsotg_process_req_status(struct dwc2_hsotg *hsotg,
 					struct usb_ctrlrequest *ctrl)
 {
-	struct s3c_hsotg_ep *ep0 = &hsotg->eps[0];
-	struct s3c_hsotg_ep *ep;
+	struct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];
+	struct dwc2_hsotg_ep *ep;
 	__le16 reply;
 	int ret;
 
@@ -925,7 +1009,7 @@
 	if (le16_to_cpu(ctrl->wLength) != 2)
 		return -EINVAL;
 
-	ret = s3c_hsotg_send_reply(hsotg, ep0, &reply, 2);
+	ret = dwc2_hsotg_send_reply(hsotg, ep0, &reply, 2);
 	if (ret) {
 		dev_err(hsotg->dev, "%s: failed to send reply\n", __func__);
 		return ret;
@@ -934,7 +1018,7 @@
 	return 1;
 }
 
-static int s3c_hsotg_ep_sethalt(struct usb_ep *ep, int value);
+static int dwc2_hsotg_ep_sethalt(struct usb_ep *ep, int value);
 
 /**
  * get_ep_head - return the first request on the endpoint
@@ -942,48 +1026,77 @@
  *
  * Get the first request on the endpoint.
  */
-static struct s3c_hsotg_req *get_ep_head(struct s3c_hsotg_ep *hs_ep)
+static struct dwc2_hsotg_req *get_ep_head(struct dwc2_hsotg_ep *hs_ep)
 {
 	if (list_empty(&hs_ep->queue))
 		return NULL;
 
-	return list_first_entry(&hs_ep->queue, struct s3c_hsotg_req, queue);
+	return list_first_entry(&hs_ep->queue, struct dwc2_hsotg_req, queue);
 }
 
 /**
- * s3c_hsotg_process_req_featire - process request {SET,CLEAR}_FEATURE
+ * dwc2_hsotg_process_req_feature - process request {SET,CLEAR}_FEATURE
  * @hsotg: The device state
  * @ctrl: USB control request
  */
-static int s3c_hsotg_process_req_feature(struct s3c_hsotg *hsotg,
+static int dwc2_hsotg_process_req_feature(struct dwc2_hsotg *hsotg,
 					 struct usb_ctrlrequest *ctrl)
 {
-	struct s3c_hsotg_ep *ep0 = &hsotg->eps[0];
-	struct s3c_hsotg_req *hs_req;
+	struct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];
+	struct dwc2_hsotg_req *hs_req;
 	bool restart;
 	bool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);
-	struct s3c_hsotg_ep *ep;
+	struct dwc2_hsotg_ep *ep;
 	int ret;
 	bool halted;
+	u32 recip;
+	u32 wValue;
+	u32 wIndex;
 
 	dev_dbg(hsotg->dev, "%s: %s_FEATURE\n",
 		__func__, set ? "SET" : "CLEAR");
 
-	if (ctrl->bRequestType == USB_RECIP_ENDPOINT) {
-		ep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));
+	wValue = le16_to_cpu(ctrl->wValue);
+	wIndex = le16_to_cpu(ctrl->wIndex);
+	recip = ctrl->bRequestType & USB_RECIP_MASK;
+
+	switch (recip) {
+	case USB_RECIP_DEVICE:
+		switch (wValue) {
+		case USB_DEVICE_TEST_MODE:
+			if ((wIndex & 0xff) != 0)
+				return -EINVAL;
+			if (!set)
+				return -EINVAL;
+
+			hsotg->test_mode = wIndex >> 8;
+			ret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);
+			if (ret) {
+				dev_err(hsotg->dev,
+					"%s: failed to send reply\n", __func__);
+				return ret;
+			}
+			break;
+		default:
+			return -ENOENT;
+		}
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		ep = ep_from_windex(hsotg, wIndex);
 		if (!ep) {
 			dev_dbg(hsotg->dev, "%s: no endpoint for 0x%04x\n",
-				__func__, le16_to_cpu(ctrl->wIndex));
+				__func__, wIndex);
 			return -ENOENT;
 		}
 
-		switch (le16_to_cpu(ctrl->wValue)) {
+		switch (wValue) {
 		case USB_ENDPOINT_HALT:
 			halted = ep->halted;
 
-			s3c_hsotg_ep_sethalt(&ep->ep, set);
+			dwc2_hsotg_ep_sethalt(&ep->ep, set);
 
-			ret = s3c_hsotg_send_reply(hsotg, ep0, NULL, 0);
+			ret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);
 			if (ret) {
 				dev_err(hsotg->dev,
 					"%s: failed to send reply\n", __func__);
@@ -1004,16 +1117,22 @@
 					hs_req = ep->req;
 					ep->req = NULL;
 					list_del_init(&hs_req->queue);
-					usb_gadget_giveback_request(&ep->ep,
-								    &hs_req->req);
+					if (hs_req->req.complete) {
+						spin_unlock(&hsotg->lock);
+						usb_gadget_giveback_request(
+							&ep->ep, &hs_req->req);
+						spin_lock(&hsotg->lock);
+					}
 				}
 
 				/* If we have pending request, then start it */
-				restart = !list_empty(&ep->queue);
-				if (restart) {
-					hs_req = get_ep_head(ep);
-					s3c_hsotg_start_req(hsotg, ep,
-							    hs_req, false);
+				if (!ep->req) {
+					restart = !list_empty(&ep->queue);
+					if (restart) {
+						hs_req = get_ep_head(ep);
+						dwc2_hsotg_start_req(hsotg, ep,
+								hs_req, false);
+					}
 				}
 			}
 
@@ -1022,24 +1141,24 @@
 		default:
 			return -ENOENT;
 		}
-	} else
-		return -ENOENT;  /* currently only deal with endpoint */
-
+		break;
+	default:
+		return -ENOENT;
+	}
 	return 1;
 }
 
-static void s3c_hsotg_enqueue_setup(struct s3c_hsotg *hsotg);
-static void s3c_hsotg_disconnect(struct s3c_hsotg *hsotg);
+static void dwc2_hsotg_enqueue_setup(struct dwc2_hsotg *hsotg);
 
 /**
- * s3c_hsotg_stall_ep0 - stall ep0
+ * dwc2_hsotg_stall_ep0 - stall ep0
  * @hsotg: The device state
  *
  * Set stall for ep0 as response for setup request.
  */
-static void s3c_hsotg_stall_ep0(struct s3c_hsotg *hsotg)
+static void dwc2_hsotg_stall_ep0(struct dwc2_hsotg *hsotg)
 {
-	struct s3c_hsotg_ep *ep0 = &hsotg->eps[0];
+	struct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];
 	u32 reg;
 	u32 ctrl;
 
@@ -1051,24 +1170,24 @@
 	 * taken effect, so no need to clear later.
 	 */
 
-	ctrl = readl(hsotg->regs + reg);
+	ctrl = dwc2_readl(hsotg->regs + reg);
 	ctrl |= DXEPCTL_STALL;
 	ctrl |= DXEPCTL_CNAK;
-	writel(ctrl, hsotg->regs + reg);
+	dwc2_writel(ctrl, hsotg->regs + reg);
 
 	dev_dbg(hsotg->dev,
 		"written DXEPCTL=0x%08x to %08x (DXEPCTL=0x%08x)\n",
-		ctrl, reg, readl(hsotg->regs + reg));
+		ctrl, reg, dwc2_readl(hsotg->regs + reg));
 
 	 /*
 	  * complete won't be called, so we enqueue
 	  * setup request here
 	  */
-	 s3c_hsotg_enqueue_setup(hsotg);
+	 dwc2_hsotg_enqueue_setup(hsotg);
 }
 
 /**
- * s3c_hsotg_process_control - process a control request
+ * dwc2_hsotg_process_control - process a control request
  * @hsotg: The device state
  * @ctrl: The control request received
  *
@@ -1076,56 +1195,51 @@
  * needs to work out what to do next (and whether to pass it on to the
  * gadget driver).
  */
-static void s3c_hsotg_process_control(struct s3c_hsotg *hsotg,
+static void dwc2_hsotg_process_control(struct dwc2_hsotg *hsotg,
 				      struct usb_ctrlrequest *ctrl)
 {
-	struct s3c_hsotg_ep *ep0 = &hsotg->eps[0];
+	struct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];
 	int ret = 0;
 	u32 dcfg;
 
-	ep0->sent_zlp = 0;
-
-	dev_dbg(hsotg->dev, "ctrl Req=%02x, Type=%02x, V=%04x, L=%04x\n",
-		 ctrl->bRequest, ctrl->bRequestType,
-		 ctrl->wValue, ctrl->wLength);
-
-	/*
-	 * record the direction of the request, for later use when enquing
-	 * packets onto EP0.
-	 */
-
-	ep0->dir_in = (ctrl->bRequestType & USB_DIR_IN) ? 1 : 0;
-	dev_dbg(hsotg->dev, "ctrl: dir_in=%d\n", ep0->dir_in);
+	dev_dbg(hsotg->dev,
+		"ctrl Type=%02x, Req=%02x, V=%04x, I=%04x, L=%04x\n",
+		ctrl->bRequestType, ctrl->bRequest, ctrl->wValue,
+		ctrl->wIndex, ctrl->wLength);
 
-	/*
-	 * if we've no data with this request, then the last part of the
-	 * transaction is going to implicitly be IN.
-	 */
-	if (ctrl->wLength == 0)
+	if (ctrl->wLength == 0) {
+		ep0->dir_in = 1;
+		hsotg->ep0_state = DWC2_EP0_STATUS_IN;
+	} else if (ctrl->bRequestType & USB_DIR_IN) {
 		ep0->dir_in = 1;
+		hsotg->ep0_state = DWC2_EP0_DATA_IN;
+	} else {
+		ep0->dir_in = 0;
+		hsotg->ep0_state = DWC2_EP0_DATA_OUT;
+	}
 
 	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
 		switch (ctrl->bRequest) {
 		case USB_REQ_SET_ADDRESS:
-			s3c_hsotg_disconnect(hsotg);
-			dcfg = readl(hsotg->regs + DCFG);
+			hsotg->connected = 1;
+			dcfg = dwc2_readl(hsotg->regs + DCFG);
 			dcfg &= ~DCFG_DEVADDR_MASK;
 			dcfg |= (le16_to_cpu(ctrl->wValue) <<
 				 DCFG_DEVADDR_SHIFT) & DCFG_DEVADDR_MASK;
-			writel(dcfg, hsotg->regs + DCFG);
+			dwc2_writel(dcfg, hsotg->regs + DCFG);
 
 			dev_info(hsotg->dev, "new address %d\n", ctrl->wValue);
 
-			ret = s3c_hsotg_send_reply(hsotg, ep0, NULL, 0);
+			ret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);
 			return;
 
 		case USB_REQ_GET_STATUS:
-			ret = s3c_hsotg_process_req_status(hsotg, ctrl);
+			ret = dwc2_hsotg_process_req_status(hsotg, ctrl);
 			break;
 
 		case USB_REQ_CLEAR_FEATURE:
 		case USB_REQ_SET_FEATURE:
-			ret = s3c_hsotg_process_req_feature(hsotg, ctrl);
+			ret = dwc2_hsotg_process_req_feature(hsotg, ctrl);
 			break;
 		}
 	}
@@ -1146,22 +1260,22 @@
 	 */
 
 	if (ret < 0)
-		s3c_hsotg_stall_ep0(hsotg);
+		dwc2_hsotg_stall_ep0(hsotg);
 }
 
 /**
- * s3c_hsotg_complete_setup - completion of a setup transfer
+ * dwc2_hsotg_complete_setup - completion of a setup transfer
  * @ep: The endpoint the request was on.
  * @req: The request completed.
  *
  * Called on completion of any requests the driver itself submitted for
  * EP0 setup packets
  */
-static void s3c_hsotg_complete_setup(struct usb_ep *ep,
+static void dwc2_hsotg_complete_setup(struct usb_ep *ep,
 				     struct usb_request *req)
 {
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hsotg = hs_ep->parent;
+	struct dwc2_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *hsotg = hs_ep->parent;
 
 	if (req->status < 0) {
 		dev_dbg(hsotg->dev, "%s: failed %d\n", __func__, req->status);
@@ -1170,23 +1284,23 @@
 
 	spin_lock(&hsotg->lock);
 	if (req->actual == 0)
-		s3c_hsotg_enqueue_setup(hsotg);
+		dwc2_hsotg_enqueue_setup(hsotg);
 	else
-		s3c_hsotg_process_control(hsotg, req->buf);
+		dwc2_hsotg_process_control(hsotg, req->buf);
 	spin_unlock(&hsotg->lock);
 }
 
 /**
- * s3c_hsotg_enqueue_setup - start a request for EP0 packets
+ * dwc2_hsotg_enqueue_setup - start a request for EP0 packets
  * @hsotg: The device state.
  *
  * Enqueue a request on EP0 if necessary to received any SETUP packets
  * received from the host.
  */
-static void s3c_hsotg_enqueue_setup(struct s3c_hsotg *hsotg)
+static void dwc2_hsotg_enqueue_setup(struct dwc2_hsotg *hsotg)
 {
 	struct usb_request *req = hsotg->ctrl_req;
-	struct s3c_hsotg_req *hs_req = our_req(req);
+	struct dwc2_hsotg_req *hs_req = our_req(req);
 	int ret;
 
 	dev_dbg(hsotg->dev, "%s: queueing setup request\n", __func__);
@@ -1194,16 +1308,18 @@
 	req->zero = 0;
 	req->length = 8;
 	req->buf = hsotg->ctrl_buff;
-	req->complete = s3c_hsotg_complete_setup;
+	req->complete = dwc2_hsotg_complete_setup;
 
 	if (!list_empty(&hs_req->queue)) {
 		dev_dbg(hsotg->dev, "%s already queued???\n", __func__);
 		return;
 	}
 
-	hsotg->eps[0].dir_in = 0;
+	hsotg->eps_out[0]->dir_in = 0;
+	hsotg->eps_out[0]->send_zlp = 0;
+	hsotg->ep0_state = DWC2_EP0_SETUP;
 
-	ret = s3c_hsotg_ep_queue(&hsotg->eps[0].ep, req, GFP_ATOMIC);
+	ret = dwc2_hsotg_ep_queue(&hsotg->eps_out[0]->ep, req, GFP_ATOMIC);
 	if (ret < 0) {
 		dev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);
 		/*
@@ -1213,8 +1329,34 @@
 	}
 }
 
+static void dwc2_hsotg_program_zlp(struct dwc2_hsotg *hsotg,
+					struct dwc2_hsotg_ep *hs_ep)
+{
+	u32 ctrl;
+	u8 index = hs_ep->index;
+	u32 epctl_reg = hs_ep->dir_in ? DIEPCTL(index) : DOEPCTL(index);
+	u32 epsiz_reg = hs_ep->dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);
+
+	if (hs_ep->dir_in)
+		dev_dbg(hsotg->dev, "Sending zero-length packet on ep%d\n",
+									index);
+	else
+		dev_dbg(hsotg->dev, "Receiving zero-length packet on ep%d\n",
+									index);
+
+	dwc2_writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
+		    DXEPTSIZ_XFERSIZE(0), hsotg->regs +
+		    epsiz_reg);
+
+	ctrl = dwc2_readl(hsotg->regs + epctl_reg);
+	ctrl |= DXEPCTL_CNAK;  /* clear NAK set by core */
+	ctrl |= DXEPCTL_EPENA; /* ensure ep enabled */
+	ctrl |= DXEPCTL_USBACTEP;
+	dwc2_writel(ctrl, hsotg->regs + epctl_reg);
+}
+
 /**
- * s3c_hsotg_complete_request - complete a request given to us
+ * dwc2_hsotg_complete_request - complete a request given to us
  * @hsotg: The device state.
  * @hs_ep: The endpoint the request was on.
  * @hs_req: The request to complete.
@@ -1226,9 +1368,9 @@
  *
  * Note, expects the ep to already be locked as appropriate.
  */
-static void s3c_hsotg_complete_request(struct s3c_hsotg *hsotg,
-				       struct s3c_hsotg_ep *hs_ep,
-				       struct s3c_hsotg_req *hs_req,
+static void dwc2_hsotg_complete_request(struct dwc2_hsotg *hsotg,
+				       struct dwc2_hsotg_ep *hs_ep,
+				       struct dwc2_hsotg_req *hs_req,
 				       int result)
 {
 	bool restart;
@@ -1249,12 +1391,14 @@
 	if (hs_req->req.status == -EINPROGRESS)
 		hs_req->req.status = result;
 
+	if (using_dma(hsotg))
+		dwc2_hsotg_unmap_dma(hsotg, hs_ep, hs_req);
+
+	dwc2_hsotg_handle_unaligned_buf_complete(hsotg, hs_ep, hs_req);
+
 	hs_ep->req = NULL;
 	list_del_init(&hs_req->queue);
 
-	if (using_dma(hsotg))
-		s3c_hsotg_unmap_dma(hsotg, hs_ep, hs_req);
-
 	/*
 	 * call the complete request with the locks off, just in case the
 	 * request tries to queue more work for this endpoint.
@@ -1276,13 +1420,13 @@
 		restart = !list_empty(&hs_ep->queue);
 		if (restart) {
 			hs_req = get_ep_head(hs_ep);
-			s3c_hsotg_start_req(hsotg, hs_ep, hs_req, false);
+			dwc2_hsotg_start_req(hsotg, hs_ep, hs_req, false);
 		}
 	}
 }
 
 /**
- * s3c_hsotg_rx_data - receive data from the FIFO for an endpoint
+ * dwc2_hsotg_rx_data - receive data from the FIFO for an endpoint
  * @hsotg: The device state.
  * @ep_idx: The endpoint index for the data
  * @size: The size of data in the fifo, in bytes
@@ -1291,10 +1435,10 @@
  * endpoint, so sort out whether we need to read the data into a request
  * that has been made for that endpoint.
  */
-static void s3c_hsotg_rx_data(struct s3c_hsotg *hsotg, int ep_idx, int size)
+static void dwc2_hsotg_rx_data(struct dwc2_hsotg *hsotg, int ep_idx, int size)
 {
-	struct s3c_hsotg_ep *hs_ep = &hsotg->eps[ep_idx];
-	struct s3c_hsotg_req *hs_req = hs_ep->req;
+	struct dwc2_hsotg_ep *hs_ep = hsotg->eps_out[ep_idx];
+	struct dwc2_hsotg_req *hs_req = hs_ep->req;
 	void __iomem *fifo = hsotg->regs + EPFIFO(ep_idx);
 	int to_read;
 	int max_req;
@@ -1302,16 +1446,16 @@
 
 
 	if (!hs_req) {
-		u32 epctl = readl(hsotg->regs + DOEPCTL(ep_idx));
+		u32 epctl = dwc2_readl(hsotg->regs + DOEPCTL(ep_idx));
 		int ptr;
 
-		dev_warn(hsotg->dev,
+		dev_dbg(hsotg->dev,
 			 "%s: FIFO %d bytes on ep%d but no req (DXEPCTl=0x%08x)\n",
 			 __func__, size, ep_idx, epctl);
 
 		/* dump the data from the FIFO, we've nothing we can do */
 		for (ptr = 0; ptr < size; ptr += 4)
-			(void)readl(fifo);
+			(void)dwc2_readl(fifo);
 
 		return;
 	}
@@ -1345,9 +1489,9 @@
 }
 
 /**
- * s3c_hsotg_send_zlp - send zero-length packet on control endpoint
+ * dwc2_hsotg_ep0_zlp - send/receive zero-length packet on control endpoint
  * @hsotg: The device instance
- * @req: The request currently on this endpoint
+ * @dir_in: If IN zlp
  *
  * Generate a zero-length IN packet request for terminating a SETUP
  * transaction.
@@ -1356,54 +1500,42 @@
  * currently believed that we do not need to wait for any space in
  * the TxFIFO.
  */
-static void s3c_hsotg_send_zlp(struct s3c_hsotg *hsotg,
-			       struct s3c_hsotg_req *req)
+static void dwc2_hsotg_ep0_zlp(struct dwc2_hsotg *hsotg, bool dir_in)
 {
-	u32 ctrl;
-
-	if (!req) {
-		dev_warn(hsotg->dev, "%s: no request?\n", __func__);
-		return;
-	}
+	/* eps_out[0] is used in both directions */
+	hsotg->eps_out[0]->dir_in = dir_in;
+	hsotg->ep0_state = dir_in ? DWC2_EP0_STATUS_IN : DWC2_EP0_STATUS_OUT;
 
-	if (req->req.length == 0) {
-		hsotg->eps[0].sent_zlp = 1;
-		s3c_hsotg_enqueue_setup(hsotg);
-		return;
-	}
-
-	hsotg->eps[0].dir_in = 1;
-	hsotg->eps[0].sent_zlp = 1;
-
-	dev_dbg(hsotg->dev, "sending zero-length packet\n");
+	dwc2_hsotg_program_zlp(hsotg, hsotg->eps_out[0]);
+}
 
-	/* issue a zero-sized packet to terminate this */
-	writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
-	       DXEPTSIZ_XFERSIZE(0), hsotg->regs + DIEPTSIZ(0));
+static void dwc2_hsotg_change_ep_iso_parity(struct dwc2_hsotg *hsotg,
+			u32 epctl_reg)
+{
+	u32 ctrl;
 
-	ctrl = readl(hsotg->regs + DIEPCTL0);
-	ctrl |= DXEPCTL_CNAK;  /* clear NAK set by core */
-	ctrl |= DXEPCTL_EPENA; /* ensure ep enabled */
-	ctrl |= DXEPCTL_USBACTEP;
-	writel(ctrl, hsotg->regs + DIEPCTL0);
+	ctrl = dwc2_readl(hsotg->regs + epctl_reg);
+	if (ctrl & DXEPCTL_EOFRNUM)
+		ctrl |= DXEPCTL_SETEVENFR;
+	else
+		ctrl |= DXEPCTL_SETODDFR;
+	dwc2_writel(ctrl, hsotg->regs + epctl_reg);
 }
 
 /**
- * s3c_hsotg_handle_outdone - handle receiving OutDone/SetupDone from RXFIFO
+ * dwc2_hsotg_handle_outdone - handle receiving OutDone/SetupDone from RXFIFO
  * @hsotg: The device instance
  * @epnum: The endpoint received from
- * @was_setup: Set if processing a SetupDone event.
  *
  * The RXFIFO has delivered an OutDone event, which means that the data
  * transfer for an OUT endpoint has been completed, either by a short
  * packet or by the finish of a transfer.
  */
-static void s3c_hsotg_handle_outdone(struct s3c_hsotg *hsotg,
-				     int epnum, bool was_setup)
+static void dwc2_hsotg_handle_outdone(struct dwc2_hsotg *hsotg, int epnum)
 {
-	u32 epsize = readl(hsotg->regs + DOEPTSIZ(epnum));
-	struct s3c_hsotg_ep *hs_ep = &hsotg->eps[epnum];
-	struct s3c_hsotg_req *hs_req = hs_ep->req;
+	u32 epsize = dwc2_readl(hsotg->regs + DOEPTSIZ(epnum));
+	struct dwc2_hsotg_ep *hs_ep = hsotg->eps_out[epnum];
+	struct dwc2_hsotg_req *hs_req = hs_ep->req;
 	struct usb_request *req = &hs_req->req;
 	unsigned size_left = DXEPTSIZ_XFERSIZE_GET(epsize);
 	int result = 0;
@@ -1413,6 +1545,13 @@
 		return;
 	}
 
+	if (epnum == 0 && hsotg->ep0_state == DWC2_EP0_STATUS_OUT) {
+		dev_dbg(hsotg->dev, "zlp packet received\n");
+		dwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
+		dwc2_hsotg_enqueue_setup(hsotg);
+		return;
+	}
+
 	if (using_dma(hsotg)) {
 		unsigned size_done;
 
@@ -1433,14 +1572,8 @@
 
 	/* if there is more request to do, schedule new transfer */
 	if (req->actual < req->length && size_left == 0) {
-		s3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);
+		dwc2_hsotg_start_req(hsotg, hs_ep, hs_req, true);
 		return;
-	} else if (epnum == 0) {
-		/*
-		 * After was_setup = 1 =>
-		 * set CNAK for non Setup requests
-		 */
-		hsotg->setup = was_setup ? 0 : 1;
 	}
 
 	if (req->actual < req->length && req->short_not_ok) {
@@ -1453,29 +1586,36 @@
 		 */
 	}
 
-	if (epnum == 0) {
-		/*
-		 * Condition req->complete != s3c_hsotg_complete_setup says:
-		 * send ZLP when we have an asynchronous request from gadget
-		 */
-		if (!was_setup && req->complete != s3c_hsotg_complete_setup)
-			s3c_hsotg_send_zlp(hsotg, hs_req);
+	if (epnum == 0 && hsotg->ep0_state == DWC2_EP0_DATA_OUT) {
+		/* Move to STATUS IN */
+		dwc2_hsotg_ep0_zlp(hsotg, true);
+		return;
+	}
+
+	/*
+	 * Slave mode OUT transfers do not go through XferComplete so
+	 * adjust the ISOC parity here.
+	 */
+	if (!using_dma(hsotg)) {
+		hs_ep->has_correct_parity = 1;
+		if (hs_ep->isochronous && hs_ep->interval == 1)
+			dwc2_hsotg_change_ep_iso_parity(hsotg, DOEPCTL(epnum));
 	}
 
-	s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, result);
+	dwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, result);
 }
 
 /**
- * s3c_hsotg_read_frameno - read current frame number
+ * dwc2_hsotg_read_frameno - read current frame number
  * @hsotg: The device instance
  *
  * Return the current frame number
  */
-static u32 s3c_hsotg_read_frameno(struct s3c_hsotg *hsotg)
+static u32 dwc2_hsotg_read_frameno(struct dwc2_hsotg *hsotg)
 {
 	u32 dsts;
 
-	dsts = readl(hsotg->regs + DSTS);
+	dsts = dwc2_readl(hsotg->regs + DSTS);
 	dsts &= DSTS_SOFFN_MASK;
 	dsts >>= DSTS_SOFFN_SHIFT;
 
@@ -1483,7 +1623,7 @@
 }
 
 /**
- * s3c_hsotg_handle_rx - RX FIFO has data
+ * dwc2_hsotg_handle_rx - RX FIFO has data
  * @hsotg: The device instance
  *
  * The IRQ handler has detected that the RX FIFO has some data in it
@@ -1498,9 +1638,9 @@
  * as the actual data should be sent to the memory directly and we turn
  * on the completion interrupts to get notifications of transfer completion.
  */
-static void s3c_hsotg_handle_rx(struct s3c_hsotg *hsotg)
+static void dwc2_hsotg_handle_rx(struct dwc2_hsotg *hsotg)
 {
-	u32 grxstsr = readl(hsotg->regs + GRXSTSP);
+	u32 grxstsr = dwc2_readl(hsotg->regs + GRXSTSP);
 	u32 epnum, status, size;
 
 	WARN_ON(using_dma(hsotg));
@@ -1511,8 +1651,7 @@
 	size = grxstsr & GRXSTS_BYTECNT_MASK;
 	size >>= GRXSTS_BYTECNT_SHIFT;
 
-	if (1)
-		dev_dbg(hsotg->dev, "%s: GRXSTSP=0x%08x (%d@%d)\n",
+	dev_dbg(hsotg->dev, "%s: GRXSTSP=0x%08x (%d@%d)\n",
 			__func__, grxstsr, size, epnum);
 
 	switch ((status & GRXSTS_PKTSTS_MASK) >> GRXSTS_PKTSTS_SHIFT) {
@@ -1522,48 +1661,55 @@
 
 	case GRXSTS_PKTSTS_OUTDONE:
 		dev_dbg(hsotg->dev, "OutDone (Frame=0x%08x)\n",
-			s3c_hsotg_read_frameno(hsotg));
+			dwc2_hsotg_read_frameno(hsotg));
 
 		if (!using_dma(hsotg))
-			s3c_hsotg_handle_outdone(hsotg, epnum, false);
+			dwc2_hsotg_handle_outdone(hsotg, epnum);
 		break;
 
 	case GRXSTS_PKTSTS_SETUPDONE:
 		dev_dbg(hsotg->dev,
 			"SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
-			s3c_hsotg_read_frameno(hsotg),
-			readl(hsotg->regs + DOEPCTL(0)));
-
-		s3c_hsotg_handle_outdone(hsotg, epnum, true);
+			dwc2_hsotg_read_frameno(hsotg),
+			dwc2_readl(hsotg->regs + DOEPCTL(0)));
+		/*
+		 * Call dwc2_hsotg_handle_outdone here if it was not called from
+		 * GRXSTS_PKTSTS_OUTDONE. That is, if the core didn't
+		 * generate GRXSTS_PKTSTS_OUTDONE for setup packet.
+		 */
+		if (hsotg->ep0_state == DWC2_EP0_SETUP)
+			dwc2_hsotg_handle_outdone(hsotg, epnum);
 		break;
 
 	case GRXSTS_PKTSTS_OUTRX:
-		s3c_hsotg_rx_data(hsotg, epnum, size);
+		dwc2_hsotg_rx_data(hsotg, epnum, size);
 		break;
 
 	case GRXSTS_PKTSTS_SETUPRX:
 		dev_dbg(hsotg->dev,
 			"SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
-			s3c_hsotg_read_frameno(hsotg),
-			readl(hsotg->regs + DOEPCTL(0)));
+			dwc2_hsotg_read_frameno(hsotg),
+			dwc2_readl(hsotg->regs + DOEPCTL(0)));
 
-		s3c_hsotg_rx_data(hsotg, epnum, size);
+		WARN_ON(hsotg->ep0_state != DWC2_EP0_SETUP);
+
+		dwc2_hsotg_rx_data(hsotg, epnum, size);
 		break;
 
 	default:
 		dev_warn(hsotg->dev, "%s: unknown status %08x\n",
 			 __func__, grxstsr);
 
-		s3c_hsotg_dump(hsotg);
+		dwc2_hsotg_dump(hsotg);
 		break;
 	}
 }
 
 /**
- * s3c_hsotg_ep0_mps - turn max packet size into register setting
+ * dwc2_hsotg_ep0_mps - turn max packet size into register setting
  * @mps: The maximum packet size in bytes.
  */
-static u32 s3c_hsotg_ep0_mps(unsigned int mps)
+static u32 dwc2_hsotg_ep0_mps(unsigned int mps)
 {
 	switch (mps) {
 	case 64:
@@ -1582,7 +1728,7 @@
 }
 
 /**
- * s3c_hsotg_set_ep_maxpacket - set endpoint's max-packet field
+ * dwc2_hsotg_set_ep_maxpacket - set endpoint's max-packet field
  * @hsotg: The driver state.
  * @ep: The index number of the endpoint
  * @mps: The maximum packet size in bytes
@@ -1590,18 +1736,22 @@
  * Configure the maximum packet size for the given endpoint, updating
  * the hardware control registers to reflect this.
  */
-static void s3c_hsotg_set_ep_maxpacket(struct s3c_hsotg *hsotg,
-				       unsigned int ep, unsigned int mps)
+static void dwc2_hsotg_set_ep_maxpacket(struct dwc2_hsotg *hsotg,
+			unsigned int ep, unsigned int mps, unsigned int dir_in)
 {
-	struct s3c_hsotg_ep *hs_ep = &hsotg->eps[ep];
+	struct dwc2_hsotg_ep *hs_ep;
 	void __iomem *regs = hsotg->regs;
 	u32 mpsval;
 	u32 mcval;
 	u32 reg;
 
+	hs_ep = index_to_ep(hsotg, ep, dir_in);
+	if (!hs_ep)
+		return;
+
 	if (ep == 0) {
 		/* EP0 is a special case */
-		mpsval = s3c_hsotg_ep0_mps(mps);
+		mpsval = dwc2_hsotg_ep0_mps(mps);
 		if (mpsval > 3)
 			goto bad_mps;
 		hs_ep->ep.maxpacket = mps;
@@ -1617,21 +1767,16 @@
 		hs_ep->ep.maxpacket = mpsval;
 	}
 
-	/*
-	 * update both the in and out endpoint controldir_ registers, even
-	 * if one of the directions may not be in use.
-	 */
-
-	reg = readl(regs + DIEPCTL(ep));
-	reg &= ~DXEPCTL_MPS_MASK;
-	reg |= mpsval;
-	writel(reg, regs + DIEPCTL(ep));
-
-	if (ep) {
-		reg = readl(regs + DOEPCTL(ep));
+	if (dir_in) {
+		reg = dwc2_readl(regs + DIEPCTL(ep));
+		reg &= ~DXEPCTL_MPS_MASK;
+		reg |= mpsval;
+		dwc2_writel(reg, regs + DIEPCTL(ep));
+	} else {
+		reg = dwc2_readl(regs + DOEPCTL(ep));
 		reg &= ~DXEPCTL_MPS_MASK;
 		reg |= mpsval;
-		writel(reg, regs + DOEPCTL(ep));
+		dwc2_writel(reg, regs + DOEPCTL(ep));
 	}
 
 	return;
@@ -1641,23 +1786,23 @@
 }
 
 /**
- * s3c_hsotg_txfifo_flush - flush Tx FIFO
+ * dwc2_hsotg_txfifo_flush - flush Tx FIFO
  * @hsotg: The driver state
  * @idx: The index for the endpoint (0..15)
  */
-static void s3c_hsotg_txfifo_flush(struct s3c_hsotg *hsotg, unsigned int idx)
+static void dwc2_hsotg_txfifo_flush(struct dwc2_hsotg *hsotg, unsigned int idx)
 {
 	int timeout;
 	int val;
 
-	writel(GRSTCTL_TXFNUM(idx) | GRSTCTL_TXFFLSH,
-		hsotg->regs + GRSTCTL);
+	dwc2_writel(GRSTCTL_TXFNUM(idx) | GRSTCTL_TXFFLSH,
+		    hsotg->regs + GRSTCTL);
 
 	/* wait until the fifo is flushed */
 	timeout = 100;
 
 	while (1) {
-		val = readl(hsotg->regs + GRSTCTL);
+		val = dwc2_readl(hsotg->regs + GRSTCTL);
 
 		if ((val & (GRSTCTL_TXFFLSH)) == 0)
 			break;
@@ -1674,17 +1819,17 @@
 }
 
 /**
- * s3c_hsotg_trytx - check to see if anything needs transmitting
+ * dwc2_hsotg_trytx - check to see if anything needs transmitting
  * @hsotg: The driver state
  * @hs_ep: The driver endpoint to check.
  *
  * Check to see if there is a request that has data to send, and if so
  * make an attempt to write data into the FIFO.
  */
-static int s3c_hsotg_trytx(struct s3c_hsotg *hsotg,
-			   struct s3c_hsotg_ep *hs_ep)
+static int dwc2_hsotg_trytx(struct dwc2_hsotg *hsotg,
+			   struct dwc2_hsotg_ep *hs_ep)
 {
-	struct s3c_hsotg_req *hs_req = hs_ep->req;
+	struct dwc2_hsotg_req *hs_req = hs_ep->req;
 
 	if (!hs_ep->dir_in || !hs_req) {
 		/**
@@ -1692,7 +1837,7 @@
 		 * for endpoints, excepting ep0
 		 */
 		if (hs_ep->index != 0)
-			s3c_hsotg_ctrl_epint(hsotg, hs_ep->index,
+			dwc2_hsotg_ctrl_epint(hsotg, hs_ep->index,
 					     hs_ep->dir_in, 0);
 		return 0;
 	}
@@ -1700,25 +1845,25 @@
 	if (hs_req->req.actual < hs_req->req.length) {
 		dev_dbg(hsotg->dev, "trying to write more for ep%d\n",
 			hs_ep->index);
-		return s3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);
+		return dwc2_hsotg_write_fifo(hsotg, hs_ep, hs_req);
 	}
 
 	return 0;
 }
 
 /**
- * s3c_hsotg_complete_in - complete IN transfer
+ * dwc2_hsotg_complete_in - complete IN transfer
  * @hsotg: The device state.
  * @hs_ep: The endpoint that has just completed.
  *
  * An IN transfer has been completed, update the transfer's state and then
  * call the relevant completion routines.
  */
-static void s3c_hsotg_complete_in(struct s3c_hsotg *hsotg,
-				  struct s3c_hsotg_ep *hs_ep)
+static void dwc2_hsotg_complete_in(struct dwc2_hsotg *hsotg,
+				  struct dwc2_hsotg_ep *hs_ep)
 {
-	struct s3c_hsotg_req *hs_req = hs_ep->req;
-	u32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
+	struct dwc2_hsotg_req *hs_req = hs_ep->req;
+	u32 epsize = dwc2_readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
 	int size_left, size_done;
 
 	if (!hs_req) {
@@ -1727,9 +1872,21 @@
 	}
 
 	/* Finish ZLP handling for IN EP0 transactions */
-	if (hsotg->eps[0].sent_zlp) {
-		dev_dbg(hsotg->dev, "zlp packet received\n");
-		s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
+	if (hs_ep->index == 0 && hsotg->ep0_state == DWC2_EP0_STATUS_IN) {
+		dev_dbg(hsotg->dev, "zlp packet sent\n");
+		dwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
+		if (hsotg->test_mode) {
+			int ret;
+
+			ret = dwc2_hsotg_set_test_mode(hsotg, hsotg->test_mode);
+			if (ret < 0) {
+				dev_dbg(hsotg->dev, "Invalid Test #%d\n",
+						hsotg->test_mode);
+				dwc2_hsotg_stall_ep0(hsotg);
+				return;
+			}
+		}
+		dwc2_hsotg_enqueue_setup(hsotg);
 		return;
 	}
 
@@ -1756,90 +1913,92 @@
 	dev_dbg(hsotg->dev, "req->length:%d req->actual:%d req->zero:%d\n",
 		hs_req->req.length, hs_req->req.actual, hs_req->req.zero);
 
-	/*
-	 * Check if dealing with Maximum Packet Size(MPS) IN transfer at EP0
-	 * When sent data is a multiple MPS size (e.g. 64B ,128B ,192B
-	 * ,256B ... ), after last MPS sized packet send IN ZLP packet to
-	 * inform the host that no more data is available.
-	 * The state of req.zero member is checked to be sure that the value to
-	 * send is smaller than wValue expected from host.
-	 * Check req.length to NOT send another ZLP when the current one is
-	 * under completion (the one for which this completion has been called).
-	 */
-	if (hs_req->req.length && hs_ep->index == 0 && hs_req->req.zero &&
-	    hs_req->req.length == hs_req->req.actual &&
-	    !(hs_req->req.length % hs_ep->ep.maxpacket)) {
+	if (!size_left && hs_req->req.actual < hs_req->req.length) {
+		dev_dbg(hsotg->dev, "%s trying more for req...\n", __func__);
+		dwc2_hsotg_start_req(hsotg, hs_ep, hs_req, true);
+		return;
+	}
 
-		dev_dbg(hsotg->dev, "ep0 zlp IN packet sent\n");
-		s3c_hsotg_send_zlp(hsotg, hs_req);
+	/* Zlp for all endpoints, for ep0 only in DATA IN stage */
+	if (hs_ep->send_zlp) {
+		dwc2_hsotg_program_zlp(hsotg, hs_ep);
+		hs_ep->send_zlp = 0;
+		/* transfer will be completed on next complete interrupt */
+		return;
+	}
 
+	if (hs_ep->index == 0 && hsotg->ep0_state == DWC2_EP0_DATA_IN) {
+		/* Move to STATUS OUT */
+		dwc2_hsotg_ep0_zlp(hsotg, false);
 		return;
 	}
 
-	if (!size_left && hs_req->req.actual < hs_req->req.length) {
-		dev_dbg(hsotg->dev, "%s trying more for req...\n", __func__);
-		s3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);
-	} else
-		s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
+	dwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
 }
 
 /**
- * s3c_hsotg_epint - handle an in/out endpoint interrupt
+ * dwc2_hsotg_epint - handle an in/out endpoint interrupt
  * @hsotg: The driver state
  * @idx: The index for the endpoint (0..15)
  * @dir_in: Set if this is an IN endpoint
  *
  * Process and clear any interrupt pending for an individual endpoint
  */
-static void s3c_hsotg_epint(struct s3c_hsotg *hsotg, unsigned int idx,
+static void dwc2_hsotg_epint(struct dwc2_hsotg *hsotg, unsigned int idx,
 			    int dir_in)
 {
-	struct s3c_hsotg_ep *hs_ep = &hsotg->eps[idx];
+	struct dwc2_hsotg_ep *hs_ep = index_to_ep(hsotg, idx, dir_in);
 	u32 epint_reg = dir_in ? DIEPINT(idx) : DOEPINT(idx);
 	u32 epctl_reg = dir_in ? DIEPCTL(idx) : DOEPCTL(idx);
 	u32 epsiz_reg = dir_in ? DIEPTSIZ(idx) : DOEPTSIZ(idx);
 	u32 ints;
 	u32 ctrl;
 
-	ints = readl(hsotg->regs + epint_reg);
-	ctrl = readl(hsotg->regs + epctl_reg);
+	ints = dwc2_readl(hsotg->regs + epint_reg);
+	ctrl = dwc2_readl(hsotg->regs + epctl_reg);
 
 	/* Clear endpoint interrupts */
-	writel(ints, hsotg->regs + epint_reg);
+	dwc2_writel(ints, hsotg->regs + epint_reg);
+
+	if (!hs_ep) {
+		dev_err(hsotg->dev, "%s:Interrupt for unconfigured ep%d(%s)\n",
+					__func__, idx, dir_in ? "in" : "out");
+		return;
+	}
 
 	dev_dbg(hsotg->dev, "%s: ep%d(%s) DxEPINT=0x%08x\n",
 		__func__, idx, dir_in ? "in" : "out", ints);
 
+	/* Don't process XferCompl interrupt if it is a setup packet */
+	if (idx == 0 && (ints & (DXEPINT_SETUP | DXEPINT_SETUP_RCVD)))
+		ints &= ~DXEPINT_XFERCOMPL;
+
 	if (ints & DXEPINT_XFERCOMPL) {
-		if (hs_ep->isochronous && hs_ep->interval == 1) {
-			if (ctrl & DXEPCTL_EOFRNUM)
-				ctrl |= DXEPCTL_SETEVENFR;
-			else
-				ctrl |= DXEPCTL_SETODDFR;
-			writel(ctrl, hsotg->regs + epctl_reg);
-		}
+		hs_ep->has_correct_parity = 1;
+		if (hs_ep->isochronous && hs_ep->interval == 1)
+			dwc2_hsotg_change_ep_iso_parity(hsotg, epctl_reg);
 
 		dev_dbg(hsotg->dev,
 			"%s: XferCompl: DxEPCTL=0x%08x, DXEPTSIZ=%08x\n",
-			__func__, readl(hsotg->regs + epctl_reg),
-			readl(hsotg->regs + epsiz_reg));
+			__func__, dwc2_readl(hsotg->regs + epctl_reg),
+			dwc2_readl(hsotg->regs + epsiz_reg));
 
 		/*
 		 * we get OutDone from the FIFO, so we only need to look
 		 * at completing IN requests here
 		 */
 		if (dir_in) {
-			s3c_hsotg_complete_in(hsotg, hs_ep);
+			dwc2_hsotg_complete_in(hsotg, hs_ep);
 
 			if (idx == 0 && !hs_ep->req)
-				s3c_hsotg_enqueue_setup(hsotg);
+				dwc2_hsotg_enqueue_setup(hsotg);
 		} else if (using_dma(hsotg)) {
 			/*
 			 * We're using DMA, we need to fire an OutDone here
 			 * as we ignore the RXFIFO.
 			 */
 
-			s3c_hsotg_handle_outdone(hsotg, idx, false);
+			dwc2_hsotg_handle_outdone(hsotg, idx);
 		}
 	}
 
@@ -1847,16 +2006,16 @@
 		dev_dbg(hsotg->dev, "%s: EPDisbld\n", __func__);
 
 		if (dir_in) {
-			int epctl = readl(hsotg->regs + epctl_reg);
+			int epctl = dwc2_readl(hsotg->regs + epctl_reg);
 
-			s3c_hsotg_txfifo_flush(hsotg, hs_ep->fifo_index);
+			dwc2_hsotg_txfifo_flush(hsotg, hs_ep->fifo_index);
 
 			if ((epctl & DXEPCTL_STALL) &&
 				(epctl & DXEPCTL_EPTYPE_BULK)) {
-				int dctl = readl(hsotg->regs + DCTL);
+				int dctl = dwc2_readl(hsotg->regs + DCTL);
 
 				dctl |= DCTL_CGNPINNAK;
-				writel(dctl, hsotg->regs + DCTL);
+				dwc2_writel(dctl, hsotg->regs + DCTL);
 			}
 		}
 	}
@@ -1878,7 +2037,7 @@
 			if (dir_in)
 				WARN_ON_ONCE(1);
 			else
-				s3c_hsotg_handle_outdone(hsotg, 0, true);
+				dwc2_hsotg_handle_outdone(hsotg, 0);
 		}
 	}
 
@@ -1904,21 +2063,21 @@
 			dev_dbg(hsotg->dev, "%s: ep%d: TxFIFOEmpty\n",
 				__func__, idx);
 			if (!using_dma(hsotg))
-				s3c_hsotg_trytx(hsotg, hs_ep);
+				dwc2_hsotg_trytx(hsotg, hs_ep);
 		}
 	}
 }
 
 /**
- * s3c_hsotg_irq_enumdone - Handle EnumDone interrupt (enumeration done)
+ * dwc2_hsotg_irq_enumdone - Handle EnumDone interrupt (enumeration done)
  * @hsotg: The device state.
  *
  * Handle updating the device settings after the enumeration phase has
  * been completed.
  */
-static void s3c_hsotg_irq_enumdone(struct s3c_hsotg *hsotg)
+static void dwc2_hsotg_irq_enumdone(struct dwc2_hsotg *hsotg)
 {
-	u32 dsts = readl(hsotg->regs + DSTS);
+	u32 dsts = dwc2_readl(hsotg->regs + DSTS);
 	int ep0_mps = 0, ep_mps = 8;
 
 	/*
@@ -1969,18 +2128,24 @@
 
 	if (ep0_mps) {
 		int i;
-		s3c_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps);
-		for (i = 1; i < hsotg->num_of_eps; i++)
-			s3c_hsotg_set_ep_maxpacket(hsotg, i, ep_mps);
+		/* Initialize ep0 for both in and out directions */
+		dwc2_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps, 1);
+		dwc2_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps, 0);
+		for (i = 1; i < hsotg->num_of_eps; i++) {
+			if (hsotg->eps_in[i])
+				dwc2_hsotg_set_ep_maxpacket(hsotg, i, ep_mps, 1);
+			if (hsotg->eps_out[i])
+				dwc2_hsotg_set_ep_maxpacket(hsotg, i, ep_mps, 0);
+		}
 	}
 
 	/* ensure after enumeration our EP0 is active */
 
-	s3c_hsotg_enqueue_setup(hsotg);
+	dwc2_hsotg_enqueue_setup(hsotg);
 
 	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
-		readl(hsotg->regs + DIEPCTL0),
-		readl(hsotg->regs + DOEPCTL0));
+		dwc2_readl(hsotg->regs + DIEPCTL0),
+		dwc2_readl(hsotg->regs + DOEPCTL0));
 }
 
 /**
@@ -1988,69 +2153,77 @@
  * @hsotg: The device state.
  * @ep: The endpoint the requests may be on.
  * @result: The result code to use.
- * @force: Force removal of any current requests
  *
  * Go through the requests on the given endpoint and mark them
  * completed with the given result code.
  */
-static void kill_all_requests(struct s3c_hsotg *hsotg,
-			      struct s3c_hsotg_ep *ep,
-			      int result, bool force)
+static void kill_all_requests(struct dwc2_hsotg *hsotg,
+			      struct dwc2_hsotg_ep *ep,
+			      int result)
 {
-	struct s3c_hsotg_req *req, *treq;
+	struct dwc2_hsotg_req *req, *treq;
 	unsigned size;
 
-	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
-		/*
-		 * currently, we can't do much about an already
-		 * running request on an in endpoint
-		 */
-
-		if (ep->req == req && ep->dir_in && !force)
-			continue;
+	ep->req = NULL;
 
-		s3c_hsotg_complete_request(hsotg, ep, req,
+	list_for_each_entry_safe(req, treq, &ep->queue, queue)
+		dwc2_hsotg_complete_request(hsotg, ep, req,
 					   result);
-	}
+
 	if (!hsotg->dedicated_fifos)
 		return;
-	size = (readl(hsotg->regs + DTXFSTS(ep->index)) & 0xffff) * 4;
+	size = (dwc2_readl(hsotg->regs + DTXFSTS(ep->index)) & 0xffff) * 4;
 	if (size < ep->fifo_size)
-		s3c_hsotg_txfifo_flush(hsotg, ep->fifo_index);
+		dwc2_hsotg_txfifo_flush(hsotg, ep->fifo_index);
 }
 
 /**
- * s3c_hsotg_disconnect - disconnect service
+ * dwc2_hsotg_disconnect - disconnect service
  * @hsotg: The device state.
  *
  * The device has been disconnected. Remove all current
  * transactions and signal the gadget driver that this
  * has happened.
  */
-static void s3c_hsotg_disconnect(struct s3c_hsotg *hsotg)
+void dwc2_hsotg_disconnect(struct dwc2_hsotg *hsotg)
 {
 	unsigned ep;
 
-	for (ep = 0; ep < hsotg->num_of_eps; ep++)
-		kill_all_requests(hsotg, &hsotg->eps[ep], -ESHUTDOWN, true);
+	if (!hsotg->connected)
+		return;
+
+	hsotg->connected = 0;
+	hsotg->test_mode = 0;
+
+	for (ep = 0; ep < hsotg->num_of_eps; ep++) {
+		if (hsotg->eps_in[ep])
+			kill_all_requests(hsotg, hsotg->eps_in[ep],
+								-ESHUTDOWN);
+		if (hsotg->eps_out[ep])
+			kill_all_requests(hsotg, hsotg->eps_out[ep],
+								-ESHUTDOWN);
+	}
 
 	call_gadget(hsotg, disconnect);
+	hsotg->lx_state = DWC2_L3;
 }
 
 /**
- * s3c_hsotg_irq_fifoempty - TX FIFO empty interrupt handler
+ * dwc2_hsotg_irq_fifoempty - TX FIFO empty interrupt handler
  * @hsotg: The device state:
  * @periodic: True if this is a periodic FIFO interrupt
  */
-static void s3c_hsotg_irq_fifoempty(struct s3c_hsotg *hsotg, bool periodic)
+static void dwc2_hsotg_irq_fifoempty(struct dwc2_hsotg *hsotg, bool periodic)
 {
-	struct s3c_hsotg_ep *ep;
+	struct dwc2_hsotg_ep *ep;
 	int epno, ret;
 
 	/* look through for any more data to transmit */
-
 	for (epno = 0; epno < hsotg->num_of_eps; epno++) {
-		ep = &hsotg->eps[epno];
+		ep = index_to_ep(hsotg, epno, 1);
+
+		if (!ep)
+			continue;
 
 		if (!ep->dir_in)
 			continue;
@@ -2059,7 +2232,7 @@
 		    (!periodic && ep->periodic))
 			continue;
 
-		ret = s3c_hsotg_trytx(hsotg, ep);
+		ret = dwc2_hsotg_trytx(hsotg, ep);
 		if (ret < 0)
 			break;
 	}
@@ -2071,12 +2244,12 @@
 			GINTSTS_RXFLVL)
 
 /**
- * s3c_hsotg_corereset - issue softreset to the core
+ * dwc2_hsotg_corereset - issue softreset to the core
  * @hsotg: The device state
  *
  * Issue a soft reset to the core, and await the core finishing it.
  */
-static int s3c_hsotg_corereset(struct s3c_hsotg *hsotg)
+static int dwc2_hsotg_corereset(struct dwc2_hsotg *hsotg)
 {
 	int timeout;
 	u32 grstctl;
@@ -2084,11 +2257,11 @@
 	dev_dbg(hsotg->dev, "resetting core\n");
 
 	/* issue soft reset */
-	writel(GRSTCTL_CSFTRST, hsotg->regs + GRSTCTL);
+	dwc2_writel(GRSTCTL_CSFTRST, hsotg->regs + GRSTCTL);
 
 	timeout = 10000;
 	do {
-		grstctl = readl(hsotg->regs + GRSTCTL);
+		grstctl = dwc2_readl(hsotg->regs + GRSTCTL);
 	} while ((grstctl & GRSTCTL_CSFTRST) && timeout-- > 0);
 
 	if (grstctl & GRSTCTL_CSFTRST) {
@@ -2099,7 +2272,7 @@
 	timeout = 10000;
 
 	while (1) {
-		u32 grstctl = readl(hsotg->regs + GRSTCTL);
+		u32 grstctl = dwc2_readl(hsotg->regs + GRSTCTL);
 
 		if (timeout-- < 0) {
 			dev_info(hsotg->dev,
@@ -2119,14 +2292,23 @@
 }
 
 /**
- * s3c_hsotg_core_init - issue softreset to the core
+ * dwc2_hsotg_core_init - issue softreset to the core
  * @hsotg: The device state
  *
  * Issue a soft reset to the core, and await the core finishing it.
  */
-static void s3c_hsotg_core_init(struct s3c_hsotg *hsotg)
+void dwc2_hsotg_core_init_disconnected(struct dwc2_hsotg *hsotg,
+						bool is_usb_reset)
 {
-	s3c_hsotg_corereset(hsotg);
+	u32 intmsk;
+	u32 val;
+
+	/* Kill any ep0 requests as controller will be reinitialized */
+	kill_all_requests(hsotg, hsotg->eps_out[0], -ECONNRESET);
+
+	if (!is_usb_reset)
+		if (dwc2_hsotg_corereset(hsotg))
+			return;
 
 	/*
 	 * we must now enable ep0 ready for host detection and then
@@ -2134,37 +2316,43 @@
 	 */
 
 	/* set the PLL on, remove the HNP/SRP and set the PHY */
-	writel(hsotg->phyif | GUSBCFG_TOUTCAL(7) |
-	       (0x5 << 10), hsotg->regs + GUSBCFG);
+	val = (hsotg->phyif == GUSBCFG_PHYIF8) ? 9 : 5;
+	dwc2_writel(hsotg->phyif | GUSBCFG_TOUTCAL(7) |
+	       (val << GUSBCFG_USBTRDTIM_SHIFT), hsotg->regs + GUSBCFG);
 
-	s3c_hsotg_init_fifo(hsotg);
+	dwc2_hsotg_init_fifo(hsotg);
 
-	__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);
+	if (!is_usb_reset)
+		__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);
 
-	writel(1 << 18 | DCFG_DEVSPD_HS,  hsotg->regs + DCFG);
+	dwc2_writel(DCFG_EPMISCNT(1) | DCFG_DEVSPD_HS,  hsotg->regs + DCFG);
 
 	/* Clear any pending OTG interrupts */
-	writel(0xffffffff, hsotg->regs + GOTGINT);
+	dwc2_writel(0xffffffff, hsotg->regs + GOTGINT);
 
 	/* Clear any pending interrupts */
-	writel(0xffffffff, hsotg->regs + GINTSTS);
-
-	writel(GINTSTS_ERLYSUSP | GINTSTS_SESSREQINT |
+	dwc2_writel(0xffffffff, hsotg->regs + GINTSTS);
+	intmsk = GINTSTS_ERLYSUSP | GINTSTS_SESSREQINT |
 		GINTSTS_GOUTNAKEFF | GINTSTS_GINNAKEFF |
-		GINTSTS_CONIDSTSCHNG | GINTSTS_USBRST |
+		GINTSTS_USBRST | GINTSTS_RESETDET |
 		GINTSTS_ENUMDONE | GINTSTS_OTGINT |
-		GINTSTS_USBSUSP | GINTSTS_WKUPINT,
-		hsotg->regs + GINTMSK);
+		GINTSTS_USBSUSP | GINTSTS_WKUPINT |
+		GINTSTS_INCOMPL_SOIN | GINTSTS_INCOMPL_SOOUT;
+
+	if (hsotg->core_params->external_id_pin_ctl <= 0)
+		intmsk |= GINTSTS_CONIDSTSCHNG;
+
+	dwc2_writel(intmsk, hsotg->regs + GINTMSK);
 
 	if (using_dma(hsotg))
-		writel(GAHBCFG_GLBL_INTR_EN | GAHBCFG_DMA_EN |
-		       GAHBCFG_HBSTLEN_INCR4,
-		       hsotg->regs + GAHBCFG);
+		dwc2_writel(GAHBCFG_GLBL_INTR_EN | GAHBCFG_DMA_EN |
+			    (GAHBCFG_HBSTLEN_INCR4 << GAHBCFG_HBSTLEN_SHIFT),
+			    hsotg->regs + GAHBCFG);
 	else
-		writel(((hsotg->dedicated_fifos) ? (GAHBCFG_NP_TXF_EMP_LVL |
-						    GAHBCFG_P_TXF_EMP_LVL) : 0) |
-		       GAHBCFG_GLBL_INTR_EN,
-		       hsotg->regs + GAHBCFG);
+		dwc2_writel(((hsotg->dedicated_fifos) ?
+						(GAHBCFG_NP_TXF_EMP_LVL |
+						 GAHBCFG_P_TXF_EMP_LVL) : 0) |
+			    GAHBCFG_GLBL_INTR_EN, hsotg->regs + GAHBCFG);
 
 	/*
 	 * If INTknTXFEmpMsk is enabled, it's important to disable ep interrupts
@@ -2172,8 +2360,8 @@
 	 * interrupts.
 	 */
 
-	writel(((hsotg->dedicated_fifos) ? DIEPMSK_TXFIFOEMPTY |
-		DIEPMSK_INTKNTXFEMPMSK : 0) |
+	dwc2_writel(((hsotg->dedicated_fifos && !using_dma(hsotg)) ?
+		DIEPMSK_TXFIFOEMPTY | DIEPMSK_INTKNTXFEMPMSK : 0) |
 		DIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK |
 		DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |
 		DIEPMSK_INTKNEPMISMSK,
@@ -2183,20 +2371,20 @@
 	 * don't need XferCompl, we get that from RXFIFO in slave mode. In
 	 * DMA mode we may need this.
 	 */
-	writel((using_dma(hsotg) ? (DIEPMSK_XFERCOMPLMSK |
+	dwc2_writel((using_dma(hsotg) ? (DIEPMSK_XFERCOMPLMSK |
 				    DIEPMSK_TIMEOUTMSK) : 0) |
 		DOEPMSK_EPDISBLDMSK | DOEPMSK_AHBERRMSK |
 		DOEPMSK_SETUPMSK,
 		hsotg->regs + DOEPMSK);
 
-	writel(0, hsotg->regs + DAINTMSK);
+	dwc2_writel(0, hsotg->regs + DAINTMSK);
 
 	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
-		readl(hsotg->regs + DIEPCTL0),
-		readl(hsotg->regs + DOEPCTL0));
+		dwc2_readl(hsotg->regs + DIEPCTL0),
+		dwc2_readl(hsotg->regs + DOEPCTL0));
 
 	/* enable in and out endpoint interrupts */
-	s3c_hsotg_en_gsint(hsotg, GINTSTS_OEPINT | GINTSTS_IEPINT);
+	dwc2_hsotg_en_gsint(hsotg, GINTSTS_OEPINT | GINTSTS_IEPINT);
 
 	/*
 	 * Enable the RXFIFO when in slave mode, as this is how we collect
@@ -2204,17 +2392,19 @@
 	 * things we cannot process, so do not use it.
 	 */
 	if (!using_dma(hsotg))
-		s3c_hsotg_en_gsint(hsotg, GINTSTS_RXFLVL);
+		dwc2_hsotg_en_gsint(hsotg, GINTSTS_RXFLVL);
 
 	/* Enable interrupts for EP0 in and out */
-	s3c_hsotg_ctrl_epint(hsotg, 0, 0, 1);
-	s3c_hsotg_ctrl_epint(hsotg, 0, 1, 1);
+	dwc2_hsotg_ctrl_epint(hsotg, 0, 0, 1);
+	dwc2_hsotg_ctrl_epint(hsotg, 0, 1, 1);
 
-	__orr32(hsotg->regs + DCTL, DCTL_PWRONPRGDONE);
-	udelay(10);  /* see openiboot */
-	__bic32(hsotg->regs + DCTL, DCTL_PWRONPRGDONE);
+	if (!is_usb_reset) {
+		__orr32(hsotg->regs + DCTL, DCTL_PWRONPRGDONE);
+		udelay(10);  /* see openiboot */
+		__bic32(hsotg->regs + DCTL, DCTL_PWRONPRGDONE);
+	}
 
-	dev_dbg(hsotg->dev, "DCTL=0x%08x\n", readl(hsotg->regs + DCTL));
+	dev_dbg(hsotg->dev, "DCTL=0x%08x\n", dwc2_readl(hsotg->regs + DCTL));
 
 	/*
 	 * DxEPCTL_USBActEp says RO in manual, but seems to be set by
@@ -2222,87 +2412,109 @@
 	 */
 
 	/* set to read 1 8byte packet */
-	writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
+	dwc2_writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
 	       DXEPTSIZ_XFERSIZE(8), hsotg->regs + DOEPTSIZ0);
 
-	writel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
+	dwc2_writel(dwc2_hsotg_ep0_mps(hsotg->eps_out[0]->ep.maxpacket) |
 	       DXEPCTL_CNAK | DXEPCTL_EPENA |
 	       DXEPCTL_USBACTEP,
 	       hsotg->regs + DOEPCTL0);
 
 	/* enable, but don't activate EP0in */
-	writel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
+	dwc2_writel(dwc2_hsotg_ep0_mps(hsotg->eps_out[0]->ep.maxpacket) |
 	       DXEPCTL_USBACTEP, hsotg->regs + DIEPCTL0);
 
-	s3c_hsotg_enqueue_setup(hsotg);
+	dwc2_hsotg_enqueue_setup(hsotg);
 
 	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
-		readl(hsotg->regs + DIEPCTL0),
-		readl(hsotg->regs + DOEPCTL0));
+		dwc2_readl(hsotg->regs + DIEPCTL0),
+		dwc2_readl(hsotg->regs + DOEPCTL0));
 
 	/* clear global NAKs */
-	writel(DCTL_CGOUTNAK | DCTL_CGNPINNAK,
-	       hsotg->regs + DCTL);
+	val = DCTL_CGOUTNAK | DCTL_CGNPINNAK;
+	if (!is_usb_reset)
+		val |= DCTL_SFTDISCON;
+	__orr32(hsotg->regs + DCTL, val);
 
 	/* must be at-least 3ms to allow bus to see disconnect */
 	mdelay(3);
 
+	hsotg->lx_state = DWC2_L0;
+}
+
+static void dwc2_hsotg_core_disconnect(struct dwc2_hsotg *hsotg)
+{
+	/* set the soft-disconnect bit */
+	__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);
+}
+
+void dwc2_hsotg_core_connect(struct dwc2_hsotg *hsotg)
+{
 	/* remove the soft-disconnect and let's go */
 	__bic32(hsotg->regs + DCTL, DCTL_SFTDISCON);
 }
 
 /**
- * s3c_hsotg_irq - handle device interrupt
+ * dwc2_hsotg_irq - handle device interrupt
  * @irq: The IRQ number triggered
  * @pw: The pw value when registered the handler.
  */
-static irqreturn_t s3c_hsotg_irq(int irq, void *pw)
+static irqreturn_t dwc2_hsotg_irq(int irq, void *pw)
 {
-	struct s3c_hsotg *hsotg = pw;
+	struct dwc2_hsotg *hsotg = pw;
 	int retry_count = 8;
 	u32 gintsts;
 	u32 gintmsk;
 
 	spin_lock(&hsotg->lock);
 irq_retry:
-	gintsts = readl(hsotg->regs + GINTSTS);
-	gintmsk = readl(hsotg->regs + GINTMSK);
+	gintsts = dwc2_readl(hsotg->regs + GINTSTS);
+	gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 
 	dev_dbg(hsotg->dev, "%s: %08x %08x (%08x) retry %d\n",
 		__func__, gintsts, gintsts & gintmsk, gintmsk, retry_count);
 
 	gintsts &= gintmsk;
 
-	if (gintsts & GINTSTS_OTGINT) {
-		u32 otgint = readl(hsotg->regs + GOTGINT);
+	if (gintsts & GINTSTS_RESETDET) {
+		dev_dbg(hsotg->dev, "%s: USBRstDet\n", __func__);
 
-		dev_info(hsotg->dev, "OTGInt: %08x\n", otgint);
+		dwc2_writel(GINTSTS_RESETDET, hsotg->regs + GINTSTS);
 
-		writel(otgint, hsotg->regs + GOTGINT);
+		/* This event must be used only if controller is suspended */
+		if (hsotg->lx_state == DWC2_L2) {
+			dwc2_exit_hibernation(hsotg, true);
+			hsotg->lx_state = DWC2_L0;
+		}
 	}
 
-	if (gintsts & GINTSTS_SESSREQINT) {
-		dev_dbg(hsotg->dev, "%s: SessReqInt\n", __func__);
-		writel(GINTSTS_SESSREQINT, hsotg->regs + GINTSTS);
-	}
+	if (gintsts & (GINTSTS_USBRST | GINTSTS_RESETDET)) {
 
-	if (gintsts & GINTSTS_ENUMDONE) {
-		writel(GINTSTS_ENUMDONE, hsotg->regs + GINTSTS);
+		u32 usb_status = dwc2_readl(hsotg->regs + GOTGCTL);
+		u32 connected = hsotg->connected;
+
+		dev_dbg(hsotg->dev, "%s: USBRst\n", __func__);
+		dev_dbg(hsotg->dev, "GNPTXSTS=%08x\n",
+			dwc2_readl(hsotg->regs + GNPTXSTS));
+
+		dwc2_writel(GINTSTS_USBRST, hsotg->regs + GINTSTS);
+
+		/* Report disconnection if it is not already done. */
+		dwc2_hsotg_disconnect(hsotg);
 
-		s3c_hsotg_irq_enumdone(hsotg);
+		if (usb_status & GOTGCTL_BSESVLD && connected)
+			dwc2_hsotg_core_init_disconnected(hsotg, true);
 	}
 
-	if (gintsts & GINTSTS_CONIDSTSCHNG) {
-		dev_dbg(hsotg->dev, "ConIDStsChg (DSTS=0x%08x, GOTCTL=%08x)\n",
-			readl(hsotg->regs + DSTS),
-			readl(hsotg->regs + GOTGCTL));
+	if (gintsts & GINTSTS_ENUMDONE) {
+		dwc2_writel(GINTSTS_ENUMDONE, hsotg->regs + GINTSTS);
 
-		writel(GINTSTS_CONIDSTSCHNG, hsotg->regs + GINTSTS);
+		dwc2_hsotg_irq_enumdone(hsotg);
 	}
 
 	if (gintsts & (GINTSTS_OEPINT | GINTSTS_IEPINT)) {
-		u32 daint = readl(hsotg->regs + DAINT);
-		u32 daintmsk = readl(hsotg->regs + DAINTMSK);
+		u32 daint = dwc2_readl(hsotg->regs + DAINT);
+		u32 daintmsk = dwc2_readl(hsotg->regs + DAINTMSK);
 		u32 daint_out, daint_in;
 		int ep;
 
@@ -2312,37 +2524,16 @@
 
 		dev_dbg(hsotg->dev, "%s: daint=%08x\n", __func__, daint);
 
-		for (ep = 0; ep < 15 && daint_out; ep++, daint_out >>= 1) {
+		for (ep = 0; ep < hsotg->num_of_eps && daint_out;
+						ep++, daint_out >>= 1) {
 			if (daint_out & 1)
-				s3c_hsotg_epint(hsotg, ep, 0);
+				dwc2_hsotg_epint(hsotg, ep, 0);
 		}
 
-		for (ep = 0; ep < 15 && daint_in; ep++, daint_in >>= 1) {
+		for (ep = 0; ep < hsotg->num_of_eps  && daint_in;
+						ep++, daint_in >>= 1) {
 			if (daint_in & 1)
-				s3c_hsotg_epint(hsotg, ep, 1);
-		}
-	}
-
-	if (gintsts & GINTSTS_USBRST) {
-
-		u32 usb_status = readl(hsotg->regs + GOTGCTL);
-
-		dev_dbg(hsotg->dev, "%s: USBRst\n", __func__);
-		dev_dbg(hsotg->dev, "GNPTXSTS=%08x\n",
-			readl(hsotg->regs + GNPTXSTS));
-
-		writel(GINTSTS_USBRST, hsotg->regs + GINTSTS);
-
-		if (usb_status & GOTGCTL_BSESVLD) {
-			if (time_after(jiffies, hsotg->last_rst +
-				       msecs_to_jiffies(200))) {
-
-				kill_all_requests(hsotg, &hsotg->eps[0],
-							  -ECONNRESET, true);
-
-				s3c_hsotg_core_init(hsotg);
-				hsotg->last_rst = jiffies;
-			}
+				dwc2_hsotg_epint(hsotg, ep, 1);
 		}
 	}
 
@@ -2357,8 +2548,8 @@
 		 * it needs re-enabling
 		 */
 
-		s3c_hsotg_disable_gsint(hsotg, GINTSTS_NPTXFEMP);
-		s3c_hsotg_irq_fifoempty(hsotg, false);
+		dwc2_hsotg_disable_gsint(hsotg, GINTSTS_NPTXFEMP);
+		dwc2_hsotg_irq_fifoempty(hsotg, false);
 	}
 
 	if (gintsts & GINTSTS_PTXFEMP) {
@@ -2366,42 +2557,23 @@
 
 		/* See note in GINTSTS_NPTxFEmp */
 
-		s3c_hsotg_disable_gsint(hsotg, GINTSTS_PTXFEMP);
-		s3c_hsotg_irq_fifoempty(hsotg, true);
+		dwc2_hsotg_disable_gsint(hsotg, GINTSTS_PTXFEMP);
+		dwc2_hsotg_irq_fifoempty(hsotg, true);
 	}
 
 	if (gintsts & GINTSTS_RXFLVL) {
 		/*
 		 * note, since GINTSTS_RxFLvl doubles as FIFO-not-empty,
-		 * we need to retry s3c_hsotg_handle_rx if this is still
+		 * we need to retry dwc2_hsotg_handle_rx if this is still
 		 * set.
 		 */
 
-		s3c_hsotg_handle_rx(hsotg);
-	}
-
-	if (gintsts & GINTSTS_MODEMIS) {
-		dev_warn(hsotg->dev, "warning, mode mismatch triggered\n");
-		writel(GINTSTS_MODEMIS, hsotg->regs + GINTSTS);
-	}
-
-	if (gintsts & GINTSTS_USBSUSP) {
-		dev_info(hsotg->dev, "GINTSTS_USBSusp\n");
-		writel(GINTSTS_USBSUSP, hsotg->regs + GINTSTS);
-
-		call_gadget(hsotg, suspend);
-	}
-
-	if (gintsts & GINTSTS_WKUPINT) {
-		dev_info(hsotg->dev, "GINTSTS_WkUpIn\n");
-		writel(GINTSTS_WKUPINT, hsotg->regs + GINTSTS);
-
-		call_gadget(hsotg, resume);
+		dwc2_hsotg_handle_rx(hsotg);
 	}
 
 	if (gintsts & GINTSTS_ERLYSUSP) {
 		dev_dbg(hsotg->dev, "GINTSTS_ErlySusp\n");
-		writel(GINTSTS_ERLYSUSP, hsotg->regs + GINTSTS);
+		dwc2_writel(GINTSTS_ERLYSUSP, hsotg->regs + GINTSTS);
 	}
 
 	/*
@@ -2413,17 +2585,51 @@
 	if (gintsts & GINTSTS_GOUTNAKEFF) {
 		dev_info(hsotg->dev, "GOUTNakEff triggered\n");
 
-		writel(DCTL_CGOUTNAK, hsotg->regs + DCTL);
+		dwc2_writel(DCTL_CGOUTNAK, hsotg->regs + DCTL);
 
-		s3c_hsotg_dump(hsotg);
+		dwc2_hsotg_dump(hsotg);
 	}
 
 	if (gintsts & GINTSTS_GINNAKEFF) {
 		dev_info(hsotg->dev, "GINNakEff triggered\n");
 
-		writel(DCTL_CGNPINNAK, hsotg->regs + DCTL);
+		dwc2_writel(DCTL_CGNPINNAK, hsotg->regs + DCTL);
+
+		dwc2_hsotg_dump(hsotg);
+	}
+
+	if (gintsts & GINTSTS_INCOMPL_SOIN) {
+		u32 idx, epctl_reg;
+		struct dwc2_hsotg_ep *hs_ep;
 
-		s3c_hsotg_dump(hsotg);
+		dev_dbg(hsotg->dev, "%s: GINTSTS_INCOMPL_SOIN\n", __func__);
+		for (idx = 1; idx < hsotg->num_of_eps; idx++) {
+			hs_ep = hsotg->eps_in[idx];
+
+			if (!hs_ep->isochronous || hs_ep->has_correct_parity)
+				continue;
+
+			epctl_reg = DIEPCTL(idx);
+			dwc2_hsotg_change_ep_iso_parity(hsotg, epctl_reg);
+		}
+		dwc2_writel(GINTSTS_INCOMPL_SOIN, hsotg->regs + GINTSTS);
+	}
+
+	if (gintsts & GINTSTS_INCOMPL_SOOUT) {
+		u32 idx, epctl_reg;
+		struct dwc2_hsotg_ep *hs_ep;
+
+		dev_dbg(hsotg->dev, "%s: GINTSTS_INCOMPL_SOOUT\n", __func__);
+		for (idx = 1; idx < hsotg->num_of_eps; idx++) {
+			hs_ep = hsotg->eps_out[idx];
+
+			if (!hs_ep->isochronous || hs_ep->has_correct_parity)
+				continue;
+
+			epctl_reg = DOEPCTL(idx);
+			dwc2_hsotg_change_ep_iso_parity(hsotg, epctl_reg);
+		}
+		dwc2_writel(GINTSTS_INCOMPL_SOOUT, hsotg->regs + GINTSTS);
 	}
 
 	/*
@@ -2440,24 +2646,24 @@
 }
 
 /**
- * s3c_hsotg_ep_enable - enable the given endpoint
+ * dwc2_hsotg_ep_enable - enable the given endpoint
  * @ep: The USB endpint to configure
  * @desc: The USB endpoint descriptor to configure with.
  *
  * This is called from the USB gadget code's usb_ep_enable().
  */
-static int s3c_hsotg_ep_enable(struct usb_ep *ep,
+static int dwc2_hsotg_ep_enable(struct usb_ep *ep,
 			       const struct usb_endpoint_descriptor *desc)
 {
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hsotg = hs_ep->parent;
+	struct dwc2_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *hsotg = hs_ep->parent;
 	unsigned long flags;
-	int index = hs_ep->index;
+	unsigned int index = hs_ep->index;
 	u32 epctrl_reg;
 	u32 epctrl;
 	u32 mps;
-	int dir_in;
-	int i, val, size;
+	unsigned int dir_in;
+	unsigned int i, val, size;
 	int ret = 0;
 
 	dev_dbg(hsotg->dev,
@@ -2476,10 +2682,10 @@
 
 	mps = usb_endpoint_maxp(desc);
 
-	/* note, we handle this here instead of s3c_hsotg_set_ep_maxpacket */
+	/* note, we handle this here instead of dwc2_hsotg_set_ep_maxpacket */
 
 	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
-	epctrl = readl(hsotg->regs + epctrl_reg);
+	epctrl = dwc2_readl(hsotg->regs + epctrl_reg);
 
 	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",
 		__func__, epctrl, epctrl_reg);
@@ -2505,13 +2711,14 @@
 	epctrl |= DXEPCTL_SNAK;
 
 	/* update the endpoint state */
-	s3c_hsotg_set_ep_maxpacket(hsotg, hs_ep->index, mps);
+	dwc2_hsotg_set_ep_maxpacket(hsotg, hs_ep->index, mps, dir_in);
 
 	/* default, set to non-periodic */
 	hs_ep->isochronous = 0;
 	hs_ep->periodic = 0;
 	hs_ep->halted = 0;
 	hs_ep->interval = desc->bInterval;
+	hs_ep->has_correct_parity = 0;
 
 	if (hs_ep->interval > 1 && hs_ep->mc > 1)
 		dev_err(hsotg->dev, "MC > 1 when interval is not 1\n");
@@ -2541,30 +2748,48 @@
 		break;
 	}
 
+	/* If fifo is already allocated for this ep */
+	if (hs_ep->fifo_index) {
+		size =  hs_ep->ep.maxpacket * hs_ep->mc;
+		/* If bigger fifo is required deallocate current one */
+		if (size > hs_ep->fifo_size) {
+			hsotg->fifo_map &= ~(1 << hs_ep->fifo_index);
+			hs_ep->fifo_index = 0;
+			hs_ep->fifo_size = 0;
+		}
+	}
+
 	/*
 	 * if the hardware has dedicated fifos, we must give each IN EP
 	 * a unique tx-fifo even if it is non-periodic.
 	 */
-	if (dir_in && hsotg->dedicated_fifos) {
+	if (dir_in && hsotg->dedicated_fifos && !hs_ep->fifo_index) {
+		u32 fifo_index = 0;
+		u32 fifo_size = UINT_MAX;
 		size = hs_ep->ep.maxpacket*hs_ep->mc;
-		for (i = 1; i <= 8; ++i) {
+		for (i = 1; i < hsotg->num_of_eps; ++i) {
 			if (hsotg->fifo_map & (1<<i))
 				continue;
-			val = readl(hsotg->regs + DPTXFSIZN(i));
+			val = dwc2_readl(hsotg->regs + DPTXFSIZN(i));
 			val = (val >> FIFOSIZE_DEPTH_SHIFT)*4;
 			if (val < size)
 				continue;
-			hsotg->fifo_map |= 1<<i;
-
-			epctrl |= DXEPCTL_TXFNUM(i);
-			hs_ep->fifo_index = i;
-			hs_ep->fifo_size = val;
-			break;
+			/* Search for smallest acceptable fifo */
+			if (val < fifo_size) {
+				fifo_size = val;
+				fifo_index = i;
+			}
 		}
-		if (i == 8) {
+		if (!fifo_index) {
+			dev_err(hsotg->dev,
+				"%s: No suitable fifo found\n", __func__);
 			ret = -ENOMEM;
 			goto error;
 		}
+		hsotg->fifo_map |= 1 << fifo_index;
+		epctrl |= DXEPCTL_TXFNUM(fifo_index);
+		hs_ep->fifo_index = fifo_index;
+		hs_ep->fifo_size = fifo_size;
 	}
 
 	/* for non control endpoints, set PID to D0 */
@@ -2574,12 +2799,12 @@
 	dev_dbg(hsotg->dev, "%s: write DxEPCTL=0x%08x\n",
 		__func__, epctrl);
 
-	writel(epctrl, hsotg->regs + epctrl_reg);
+	dwc2_writel(epctrl, hsotg->regs + epctrl_reg);
 	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x\n",
-		__func__, readl(hsotg->regs + epctrl_reg));
+		__func__, dwc2_readl(hsotg->regs + epctrl_reg));
 
 	/* enable the endpoint interrupt */
-	s3c_hsotg_ctrl_epint(hsotg, index, dir_in, 1);
+	dwc2_hsotg_ctrl_epint(hsotg, index, dir_in, 1);
 
 error:
 	spin_unlock_irqrestore(&hsotg->lock, flags);
@@ -2587,13 +2812,13 @@
 }
 
 /**
- * s3c_hsotg_ep_disable - disable given endpoint
+ * dwc2_hsotg_ep_disable - disable given endpoint
  * @ep: The endpoint to disable.
  */
-static int s3c_hsotg_ep_disable(struct usb_ep *ep)
+static int dwc2_hsotg_ep_disable(struct usb_ep *ep)
 {
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hsotg = hs_ep->parent;
+	struct dwc2_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *hsotg = hs_ep->parent;
 	int dir_in = hs_ep->dir_in;
 	int index = hs_ep->index;
 	unsigned long flags;
@@ -2602,7 +2827,7 @@
 
 	dev_dbg(hsotg->dev, "%s(ep %p)\n", __func__, ep);
 
-	if (ep == &hsotg->eps[0].ep) {
+	if (ep == &hsotg->eps_out[0]->ep) {
 		dev_err(hsotg->dev, "%s: called for ep0\n", __func__);
 		return -EINVAL;
 	}
@@ -2610,23 +2835,24 @@
 	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
 
 	spin_lock_irqsave(&hsotg->lock, flags);
-	/* terminate all requests with shutdown */
-	kill_all_requests(hsotg, hs_ep, -ESHUTDOWN, false);
 
 	hsotg->fifo_map &= ~(1<<hs_ep->fifo_index);
 	hs_ep->fifo_index = 0;
 	hs_ep->fifo_size = 0;
 
-	ctrl = readl(hsotg->regs + epctrl_reg);
+	ctrl = dwc2_readl(hsotg->regs + epctrl_reg);
 	ctrl &= ~DXEPCTL_EPENA;
 	ctrl &= ~DXEPCTL_USBACTEP;
 	ctrl |= DXEPCTL_SNAK;
 
 	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);
-	writel(ctrl, hsotg->regs + epctrl_reg);
+	dwc2_writel(ctrl, hsotg->regs + epctrl_reg);
 
 	/* disable endpoint interrupts */
-	s3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);
+	dwc2_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);
+
+	/* terminate all requests with shutdown */
+	kill_all_requests(hsotg, hs_ep, -ESHUTDOWN);
 
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 	return 0;
@@ -2637,9 +2863,9 @@
  * @ep: The endpoint to check.
  * @test: The request to test if it is on the endpoint.
  */
-static bool on_list(struct s3c_hsotg_ep *ep, struct s3c_hsotg_req *test)
+static bool on_list(struct dwc2_hsotg_ep *ep, struct dwc2_hsotg_req *test)
 {
-	struct s3c_hsotg_req *req, *treq;
+	struct dwc2_hsotg_req *req, *treq;
 
 	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
 		if (req == test)
@@ -2649,16 +2875,89 @@
 	return false;
 }
 
+static int dwc2_hsotg_wait_bit_set(struct dwc2_hsotg *hs_otg, u32 reg,
+							u32 bit, u32 timeout)
+{
+	u32 i;
+
+	for (i = 0; i < timeout; i++) {
+		if (dwc2_readl(hs_otg->regs + reg) & bit)
+			return 0;
+		udelay(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static void dwc2_hsotg_ep_stop_xfr(struct dwc2_hsotg *hsotg,
+						struct dwc2_hsotg_ep *hs_ep)
+{
+	u32 epctrl_reg;
+	u32 epint_reg;
+
+	epctrl_reg = hs_ep->dir_in ? DIEPCTL(hs_ep->index) :
+		DOEPCTL(hs_ep->index);
+	epint_reg = hs_ep->dir_in ? DIEPINT(hs_ep->index) :
+		DOEPINT(hs_ep->index);
+
+	dev_dbg(hsotg->dev, "%s: stopping transfer on %s\n", __func__,
+			hs_ep->name);
+	if (hs_ep->dir_in) {
+		__orr32(hsotg->regs + epctrl_reg, DXEPCTL_SNAK);
+		/* Wait for Nak effect */
+		if (dwc2_hsotg_wait_bit_set(hsotg, epint_reg,
+						DXEPINT_INEPNAKEFF, 100))
+			dev_warn(hsotg->dev,
+				"%s: timeout DIEPINT.NAKEFF\n", __func__);
+	} else {
+		/* Clear any pending nak effect interrupt */
+		dwc2_writel(GINTSTS_GINNAKEFF, hsotg->regs + GINTSTS);
+
+		__orr32(hsotg->regs + DCTL, DCTL_SGNPINNAK);
+
+		/* Wait for global nak to take effect */
+		if (dwc2_hsotg_wait_bit_set(hsotg, GINTSTS,
+						GINTSTS_GINNAKEFF, 100))
+			dev_warn(hsotg->dev,
+				"%s: timeout GINTSTS.GINNAKEFF\n", __func__);
+	}
+
+	/* Disable ep */
+	__orr32(hsotg->regs + epctrl_reg, DXEPCTL_EPDIS | DXEPCTL_SNAK);
+
+	/* Wait for ep to be disabled */
+	if (dwc2_hsotg_wait_bit_set(hsotg, epint_reg, DXEPINT_EPDISBLD, 100))
+		dev_warn(hsotg->dev,
+			"%s: timeout DOEPCTL.EPDisable\n", __func__);
+
+	if (hs_ep->dir_in) {
+		if (hsotg->dedicated_fifos) {
+			dwc2_writel(GRSTCTL_TXFNUM(hs_ep->fifo_index) |
+				GRSTCTL_TXFFLSH, hsotg->regs + GRSTCTL);
+			/* Wait for fifo flush */
+			if (dwc2_hsotg_wait_bit_set(hsotg, GRSTCTL,
+							GRSTCTL_TXFFLSH, 100))
+				dev_warn(hsotg->dev,
+					"%s: timeout flushing fifos\n",
+					__func__);
+		}
+		/* TODO: Flush shared tx fifo */
+	} else {
+		/* Remove global NAKs */
+		__bic32(hsotg->regs + DCTL, DCTL_SGNPINNAK);
+	}
+}
+
 /**
- * s3c_hsotg_ep_dequeue - dequeue given endpoint
+ * dwc2_hsotg_ep_dequeue - dequeue given endpoint
  * @ep: The endpoint to dequeue.
  * @req: The request to be removed from a queue.
  */
-static int s3c_hsotg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
+static int dwc2_hsotg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
 {
-	struct s3c_hsotg_req *hs_req = our_req(req);
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hs = hs_ep->parent;
+	struct dwc2_hsotg_req *hs_req = our_req(req);
+	struct dwc2_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *hs = hs_ep->parent;
 	unsigned long flags;
 
 	dev_dbg(hs->dev, "ep_dequeue(%p,%p)\n", ep, req);
@@ -2670,21 +2969,25 @@
 		return -EINVAL;
 	}
 
-	s3c_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);
+	/* Dequeue already started request */
+	if (req == &hs_ep->req->req)
+		dwc2_hsotg_ep_stop_xfr(hs, hs_ep);
+
+	dwc2_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);
 	spin_unlock_irqrestore(&hs->lock, flags);
 
 	return 0;
 }
 
 /**
- * s3c_hsotg_ep_sethalt - set halt on a given endpoint
+ * dwc2_hsotg_ep_sethalt - set halt on a given endpoint
  * @ep: The endpoint to set halt.
  * @value: Set or unset the halt.
  */
-static int s3c_hsotg_ep_sethalt(struct usb_ep *ep, int value)
+static int dwc2_hsotg_ep_sethalt(struct usb_ep *ep, int value)
 {
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hs = hs_ep->parent;
+	struct dwc2_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *hs = hs_ep->parent;
 	int index = hs_ep->index;
 	u32 epreg;
 	u32 epctl;
@@ -2694,181 +2997,134 @@
 
 	if (index == 0) {
 		if (value)
-			s3c_hsotg_stall_ep0(hs);
+			dwc2_hsotg_stall_ep0(hs);
 		else
 			dev_warn(hs->dev,
 				 "%s: can't clear halt on ep0\n", __func__);
 		return 0;
 	}
 
-	/* write both IN and OUT control registers */
-
-	epreg = DIEPCTL(index);
-	epctl = readl(hs->regs + epreg);
-
-	if (value) {
-		epctl |= DXEPCTL_STALL + DXEPCTL_SNAK;
-		if (epctl & DXEPCTL_EPENA)
-			epctl |= DXEPCTL_EPDIS;
+	if (hs_ep->dir_in) {
+		epreg = DIEPCTL(index);
+		epctl = dwc2_readl(hs->regs + epreg);
+
+		if (value) {
+			epctl |= DXEPCTL_STALL | DXEPCTL_SNAK;
+			if (epctl & DXEPCTL_EPENA)
+				epctl |= DXEPCTL_EPDIS;
+		} else {
+			epctl &= ~DXEPCTL_STALL;
+			xfertype = epctl & DXEPCTL_EPTYPE_MASK;
+			if (xfertype == DXEPCTL_EPTYPE_BULK ||
+				xfertype == DXEPCTL_EPTYPE_INTERRUPT)
+					epctl |= DXEPCTL_SETD0PID;
+		}
+		dwc2_writel(epctl, hs->regs + epreg);
 	} else {
-		epctl &= ~DXEPCTL_STALL;
-		xfertype = epctl & DXEPCTL_EPTYPE_MASK;
-		if (xfertype == DXEPCTL_EPTYPE_BULK ||
-			xfertype == DXEPCTL_EPTYPE_INTERRUPT)
-				epctl |= DXEPCTL_SETD0PID;
-	}
-
-	writel(epctl, hs->regs + epreg);
 
-	epreg = DOEPCTL(index);
-	epctl = readl(hs->regs + epreg);
+		epreg = DOEPCTL(index);
+		epctl = dwc2_readl(hs->regs + epreg);
 
-	if (value)
-		epctl |= DXEPCTL_STALL;
-	else {
-		epctl &= ~DXEPCTL_STALL;
-		xfertype = epctl & DXEPCTL_EPTYPE_MASK;
-		if (xfertype == DXEPCTL_EPTYPE_BULK ||
-			xfertype == DXEPCTL_EPTYPE_INTERRUPT)
-				epctl |= DXEPCTL_SETD0PID;
+		if (value)
+			epctl |= DXEPCTL_STALL;
+		else {
+			epctl &= ~DXEPCTL_STALL;
+			xfertype = epctl & DXEPCTL_EPTYPE_MASK;
+			if (xfertype == DXEPCTL_EPTYPE_BULK ||
+				xfertype == DXEPCTL_EPTYPE_INTERRUPT)
+					epctl |= DXEPCTL_SETD0PID;
+		}
+		dwc2_writel(epctl, hs->regs + epreg);
 	}
 
-	writel(epctl, hs->regs + epreg);
-
 	hs_ep->halted = value;
 
 	return 0;
 }
 
 /**
- * s3c_hsotg_ep_sethalt_lock - set halt on a given endpoint with lock held
+ * dwc2_hsotg_ep_sethalt_lock - set halt on a given endpoint with lock held
  * @ep: The endpoint to set halt.
  * @value: Set or unset the halt.
  */
-static int s3c_hsotg_ep_sethalt_lock(struct usb_ep *ep, int value)
+static int dwc2_hsotg_ep_sethalt_lock(struct usb_ep *ep, int value)
 {
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hs = hs_ep->parent;
+	struct dwc2_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *hs = hs_ep->parent;
 	unsigned long flags = 0;
 	int ret = 0;
 
 	spin_lock_irqsave(&hs->lock, flags);
-	ret = s3c_hsotg_ep_sethalt(ep, value);
+	ret = dwc2_hsotg_ep_sethalt(ep, value);
 	spin_unlock_irqrestore(&hs->lock, flags);
 
 	return ret;
 }
 
-static struct usb_ep_ops s3c_hsotg_ep_ops = {
-	.enable		= s3c_hsotg_ep_enable,
-	.disable	= s3c_hsotg_ep_disable,
-	.alloc_request	= s3c_hsotg_ep_alloc_request,
-	.free_request	= s3c_hsotg_ep_free_request,
-	.queue		= s3c_hsotg_ep_queue_lock,
-	.dequeue	= s3c_hsotg_ep_dequeue,
-	.set_halt	= s3c_hsotg_ep_sethalt_lock,
+static struct usb_ep_ops dwc2_hsotg_ep_ops = {
+	.enable		= dwc2_hsotg_ep_enable,
+	.disable	= dwc2_hsotg_ep_disable,
+	.alloc_request	= dwc2_hsotg_ep_alloc_request,
+	.free_request	= dwc2_hsotg_ep_free_request,
+	.queue		= dwc2_hsotg_ep_queue_lock,
+	.dequeue	= dwc2_hsotg_ep_dequeue,
+	.set_halt	= dwc2_hsotg_ep_sethalt_lock,
 	/* note, don't believe we have any call for the fifo routines */
 };
 
 /**
- * s3c_hsotg_phy_enable - enable platform phy dev
+ * dwc2_hsotg_init - initalize the usb core
  * @hsotg: The driver state
- *
- * A wrapper for platform code responsible for controlling
- * low-level USB code
  */
-static void s3c_hsotg_phy_enable(struct s3c_hsotg *hsotg)
-{
-	struct platform_device *pdev = to_platform_device(hsotg->dev);
-
-	dev_dbg(hsotg->dev, "pdev 0x%p\n", pdev);
-
-	if (hsotg->uphy)
-		usb_phy_init(hsotg->uphy);
-	else if (hsotg->plat && hsotg->plat->phy_init)
-		hsotg->plat->phy_init(pdev, hsotg->plat->phy_type);
-	else {
-		phy_init(hsotg->phy);
-		phy_power_on(hsotg->phy);
-	}
-}
-
-/**
- * s3c_hsotg_phy_disable - disable platform phy dev
- * @hsotg: The driver state
- *
- * A wrapper for platform code responsible for controlling
- * low-level USB code
- */
-static void s3c_hsotg_phy_disable(struct s3c_hsotg *hsotg)
-{
-	struct platform_device *pdev = to_platform_device(hsotg->dev);
-
-	if (hsotg->uphy)
-		usb_phy_shutdown(hsotg->uphy);
-	else if (hsotg->plat && hsotg->plat->phy_exit)
-		hsotg->plat->phy_exit(pdev, hsotg->plat->phy_type);
-	else {
-		phy_power_off(hsotg->phy);
-		phy_exit(hsotg->phy);
-	}
-}
-
-/**
- * s3c_hsotg_init - initalize the usb core
- * @hsotg: The driver state
- */
-static void s3c_hsotg_init(struct s3c_hsotg *hsotg)
+static void dwc2_hsotg_init(struct dwc2_hsotg *hsotg)
 {
+	u32 trdtim;
 	/* unmask subset of endpoint interrupts */
 
-	writel(DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |
-		DIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK,
-		hsotg->regs + DIEPMSK);
-
-	writel(DOEPMSK_SETUPMSK | DOEPMSK_AHBERRMSK |
-		DOEPMSK_EPDISBLDMSK | DOEPMSK_XFERCOMPLMSK,
-		hsotg->regs + DOEPMSK);
+	dwc2_writel(DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |
+		    DIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK,
+		    hsotg->regs + DIEPMSK);
+
+	dwc2_writel(DOEPMSK_SETUPMSK | DOEPMSK_AHBERRMSK |
+		    DOEPMSK_EPDISBLDMSK | DOEPMSK_XFERCOMPLMSK,
+		    hsotg->regs + DOEPMSK);
 
-	writel(0, hsotg->regs + DAINTMSK);
+	dwc2_writel(0, hsotg->regs + DAINTMSK);
 
 	/* Be in disconnected state until gadget is registered */
 	__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);
 
-	if (0) {
-		/* post global nak until we're ready */
-		writel(DCTL_SGNPINNAK | DCTL_SGOUTNAK,
-		       hsotg->regs + DCTL);
-	}
-
 	/* setup fifos */
 
 	dev_dbg(hsotg->dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
-		readl(hsotg->regs + GRXFSIZ),
-		readl(hsotg->regs + GNPTXFSIZ));
+		dwc2_readl(hsotg->regs + GRXFSIZ),
+		dwc2_readl(hsotg->regs + GNPTXFSIZ));
 
-	s3c_hsotg_init_fifo(hsotg);
+	dwc2_hsotg_init_fifo(hsotg);
 
 	/* set the PLL on, remove the HNP/SRP and set the PHY */
-	writel(GUSBCFG_PHYIF16 | GUSBCFG_TOUTCAL(7) | (0x5 << 10),
-	       hsotg->regs + GUSBCFG);
+	trdtim = (hsotg->phyif == GUSBCFG_PHYIF8) ? 9 : 5;
+	dwc2_writel(hsotg->phyif | GUSBCFG_TOUTCAL(7) |
+		(trdtim << GUSBCFG_USBTRDTIM_SHIFT),
+		hsotg->regs + GUSBCFG);
 
-	writel(using_dma(hsotg) ? GAHBCFG_DMA_EN : 0x0,
-	       hsotg->regs + GAHBCFG);
+	if (using_dma(hsotg))
+		__orr32(hsotg->regs + GAHBCFG, GAHBCFG_DMA_EN);
 }
 
 /**
- * s3c_hsotg_udc_start - prepare the udc for work
+ * dwc2_hsotg_udc_start - prepare the udc for work
  * @gadget: The usb gadget state
  * @driver: The usb gadget driver
  *
  * Perform initialization to prepare udc device and driver
  * to work.
  */
-static int s3c_hsotg_udc_start(struct usb_gadget *gadget,
+static int dwc2_hsotg_udc_start(struct usb_gadget *gadget,
 			   struct usb_gadget_driver *driver)
 {
-	struct s3c_hsotg *hsotg = to_hsotg(gadget);
+	struct dwc2_hsotg *hsotg = to_hsotg(gadget);
+	unsigned long flags;
 	int ret;
 
 	if (!hsotg) {
@@ -2896,17 +3152,23 @@
 	hsotg->gadget.dev.of_node = hsotg->dev->of_node;
 	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
 
-	clk_enable(hsotg->clk);
-
-	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
-				    hsotg->supplies);
-	if (ret) {
-		dev_err(hsotg->dev, "failed to enable supplies: %d\n", ret);
-		goto err;
+	if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) {
+		ret = dwc2_lowlevel_hw_enable(hsotg);
+		if (ret)
+			goto err;
 	}
 
-	hsotg->last_rst = jiffies;
+	if (!IS_ERR_OR_NULL(hsotg->uphy))
+		otg_set_peripheral(hsotg->uphy->otg, &hsotg->gadget);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	dwc2_hsotg_init(hsotg);
+	dwc2_hsotg_core_init_disconnected(hsotg, false);
+	hsotg->enabled = 0;
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
 	dev_info(hsotg->dev, "bound driver %s\n", driver->driver.name);
+
 	return 0;
 
 err:
@@ -2915,16 +3177,16 @@
 }
 
 /**
- * s3c_hsotg_udc_stop - stop the udc
+ * dwc2_hsotg_udc_stop - stop the udc
  * @gadget: The usb gadget state
  * @driver: The usb gadget driver
  *
  * Stop udc hw block and stay tunned for future transmissions
  */
-static int s3c_hsotg_udc_stop(struct usb_gadget *gadget,
-			  struct usb_gadget_driver *driver)
+static int dwc2_hsotg_udc_stop(struct usb_gadget *gadget,
+			   struct usb_gadget_driver *driver)
 {
-	struct s3c_hsotg *hsotg = to_hsotg(gadget);
+	struct dwc2_hsotg *hsotg = to_hsotg(gadget);
 	unsigned long flags = 0;
 	int ep;
 
@@ -2932,56 +3194,71 @@
 		return -ENODEV;
 
 	/* all endpoints should be shutdown */
-	for (ep = 1; ep < hsotg->num_of_eps; ep++)
-		s3c_hsotg_ep_disable(&hsotg->eps[ep].ep);
+	for (ep = 1; ep < hsotg->num_of_eps; ep++) {
+		if (hsotg->eps_in[ep])
+			dwc2_hsotg_ep_disable(&hsotg->eps_in[ep]->ep);
+		if (hsotg->eps_out[ep])
+			dwc2_hsotg_ep_disable(&hsotg->eps_out[ep]->ep);
+	}
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 
 	hsotg->driver = NULL;
 	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
+	hsotg->enabled = 0;
 
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 
-	regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
+	if (!IS_ERR_OR_NULL(hsotg->uphy))
+		otg_set_peripheral(hsotg->uphy->otg, NULL);
 
-	clk_disable(hsotg->clk);
+	if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)
+		dwc2_lowlevel_hw_disable(hsotg);
 
 	return 0;
 }
 
 /**
- * s3c_hsotg_gadget_getframe - read the frame number
+ * dwc2_hsotg_gadget_getframe - read the frame number
  * @gadget: The usb gadget state
  *
  * Read the {micro} frame number
  */
-static int s3c_hsotg_gadget_getframe(struct usb_gadget *gadget)
+static int dwc2_hsotg_gadget_getframe(struct usb_gadget *gadget)
 {
-	return s3c_hsotg_read_frameno(to_hsotg(gadget));
+	return dwc2_hsotg_read_frameno(to_hsotg(gadget));
 }
 
 /**
- * s3c_hsotg_pullup - connect/disconnect the USB PHY
+ * dwc2_hsotg_pullup - connect/disconnect the USB PHY
  * @gadget: The usb gadget state
  * @is_on: Current state of the USB PHY
  *
  * Connect/Disconnect the USB PHY pullup
  */
-static int s3c_hsotg_pullup(struct usb_gadget *gadget, int is_on)
+static int dwc2_hsotg_pullup(struct usb_gadget *gadget, int is_on)
 {
-	struct s3c_hsotg *hsotg = to_hsotg(gadget);
+	struct dwc2_hsotg *hsotg = to_hsotg(gadget);
 	unsigned long flags = 0;
 
-	dev_dbg(hsotg->dev, "%s: is_on: %d\n", __func__, is_on);
+	dev_dbg(hsotg->dev, "%s: is_on: %d op_state: %d\n", __func__, is_on,
+			hsotg->op_state);
+
+	/* Don't modify pullup state while in host mode */
+	if (hsotg->op_state != OTG_STATE_B_PERIPHERAL) {
+		hsotg->enabled = is_on;
+		return 0;
+	}
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 	if (is_on) {
-		s3c_hsotg_phy_enable(hsotg);
-		clk_enable(hsotg->clk);
-		s3c_hsotg_core_init(hsotg);
+		hsotg->enabled = 1;
+		dwc2_hsotg_core_init_disconnected(hsotg, false);
+		dwc2_hsotg_core_connect(hsotg);
 	} else {
-		clk_disable(hsotg->clk);
-		s3c_hsotg_phy_disable(hsotg);
+		dwc2_hsotg_core_disconnect(hsotg);
+		dwc2_hsotg_disconnect(hsotg);
+		hsotg->enabled = 0;
 	}
 
 	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
@@ -2990,15 +3267,63 @@
 	return 0;
 }
 
-static const struct usb_gadget_ops s3c_hsotg_gadget_ops = {
-	.get_frame	= s3c_hsotg_gadget_getframe,
-	.udc_start		= s3c_hsotg_udc_start,
-	.udc_stop		= s3c_hsotg_udc_stop,
-	.pullup                 = s3c_hsotg_pullup,
+static int dwc2_hsotg_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct dwc2_hsotg *hsotg = to_hsotg(gadget);
+	unsigned long flags;
+
+	dev_dbg(hsotg->dev, "%s: is_active: %d\n", __func__, is_active);
+	spin_lock_irqsave(&hsotg->lock, flags);
+
+	/*
+	 * If controller is hibernated, it must exit from hibernation
+	 * before being initialized / de-initialized
+	 */
+	if (hsotg->lx_state == DWC2_L2)
+		dwc2_exit_hibernation(hsotg, false);
+
+	if (is_active) {
+		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
+
+		dwc2_hsotg_core_init_disconnected(hsotg, false);
+		if (hsotg->enabled)
+			dwc2_hsotg_core_connect(hsotg);
+	} else {
+		dwc2_hsotg_core_disconnect(hsotg);
+		dwc2_hsotg_disconnect(hsotg);
+	}
+
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+	return 0;
+}
+
+/**
+ * dwc2_hsotg_vbus_draw - report bMaxPower field
+ * @gadget: The usb gadget state
+ * @mA: Amount of current
+ *
+ * Report how much power the device may consume to the phy.
+ */
+static int dwc2_hsotg_vbus_draw(struct usb_gadget *gadget, unsigned mA)
+{
+	struct dwc2_hsotg *hsotg = to_hsotg(gadget);
+
+	if (IS_ERR_OR_NULL(hsotg->uphy))
+		return -ENOTSUPP;
+	return usb_phy_set_power(hsotg->uphy, mA);
+}
+
+static const struct usb_gadget_ops dwc2_hsotg_gadget_ops = {
+	.get_frame	= dwc2_hsotg_gadget_getframe,
+	.udc_start		= dwc2_hsotg_udc_start,
+	.udc_stop		= dwc2_hsotg_udc_stop,
+	.pullup                 = dwc2_hsotg_pullup,
+	.vbus_session		= dwc2_hsotg_vbus_session,
+	.vbus_draw		= dwc2_hsotg_vbus_draw,
 };
 
 /**
- * s3c_hsotg_initep - initialise a single endpoint
+ * dwc2_hsotg_initep - initialise a single endpoint
  * @hsotg: The device state.
  * @hs_ep: The endpoint to be initialised.
  * @epnum: The endpoint number
@@ -3007,21 +3332,21 @@
  * creation) to give to the gadget driver. Setup the endpoint name, any
  * direction information and other state that may be required.
  */
-static void s3c_hsotg_initep(struct s3c_hsotg *hsotg,
-				       struct s3c_hsotg_ep *hs_ep,
-				       int epnum)
+static void dwc2_hsotg_initep(struct dwc2_hsotg *hsotg,
+				       struct dwc2_hsotg_ep *hs_ep,
+				       int epnum,
+				       bool dir_in)
 {
 	char *dir;
 
 	if (epnum == 0)
 		dir = "";
-	else if ((epnum % 2) == 0) {
-		dir = "out";
-	} else {
+	else if (dir_in)
 		dir = "in";
-		hs_ep->dir_in = 1;
-	}
+	else
+		dir = "out";
 
+	hs_ep->dir_in = dir_in;
 	hs_ep->index = epnum;
 
 	snprintf(hs_ep->name, sizeof(hs_ep->name), "ep%d%s", epnum, dir);
@@ -3036,7 +3361,20 @@
 	hs_ep->parent = hsotg;
 	hs_ep->ep.name = hs_ep->name;
 	usb_ep_set_maxpacket_limit(&hs_ep->ep, epnum ? 1024 : EP0_MPS_LIMIT);
-	hs_ep->ep.ops = &s3c_hsotg_ep_ops;
+	hs_ep->ep.ops = &dwc2_hsotg_ep_ops;
+
+	if (epnum == 0) {
+		hs_ep->ep.caps.type_control = true;
+	} else {
+		hs_ep->ep.caps.type_iso = true;
+		hs_ep->ep.caps.type_bulk = true;
+		hs_ep->ep.caps.type_int = true;
+	}
+
+	if (dir_in)
+		hs_ep->ep.caps.dir_in = true;
+	else
+		hs_ep->ep.caps.dir_out = true;
 
 	/*
 	 * if we're using dma, we need to set the next-endpoint pointer
@@ -3045,42 +3383,76 @@
 
 	if (using_dma(hsotg)) {
 		u32 next = DXEPCTL_NEXTEP((epnum + 1) % 15);
-		writel(next, hsotg->regs + DIEPCTL(epnum));
-		writel(next, hsotg->regs + DOEPCTL(epnum));
+		if (dir_in)
+			dwc2_writel(next, hsotg->regs + DIEPCTL(epnum));
+		else
+			dwc2_writel(next, hsotg->regs + DOEPCTL(epnum));
 	}
 }
 
 /**
- * s3c_hsotg_hw_cfg - read HW configuration registers
+ * dwc2_hsotg_hw_cfg - read HW configuration registers
  * @param: The device state
  *
  * Read the USB core HW configuration registers
  */
-static void s3c_hsotg_hw_cfg(struct s3c_hsotg *hsotg)
+static int dwc2_hsotg_hw_cfg(struct dwc2_hsotg *hsotg)
 {
-	u32 cfg2, cfg3, cfg4;
+	u32 cfg;
+	u32 ep_type;
+	u32 i;
+
 	/* check hardware configuration */
 
-	cfg2 = readl(hsotg->regs + 0x48);
-	hsotg->num_of_eps = (cfg2 >> 10) & 0xF;
+	cfg = dwc2_readl(hsotg->regs + GHWCFG2);
+	hsotg->num_of_eps = (cfg >> GHWCFG2_NUM_DEV_EP_SHIFT) & 0xF;
+	/* Add ep0 */
+	hsotg->num_of_eps++;
+
+	hsotg->eps_in[0] = devm_kzalloc(hsotg->dev, sizeof(struct dwc2_hsotg_ep),
+								GFP_KERNEL);
+	if (!hsotg->eps_in[0])
+		return -ENOMEM;
+	/* Same dwc2_hsotg_ep is used in both directions for ep0 */
+	hsotg->eps_out[0] = hsotg->eps_in[0];
+
+	cfg = dwc2_readl(hsotg->regs + GHWCFG1);
+	for (i = 1, cfg >>= 2; i < hsotg->num_of_eps; i++, cfg >>= 2) {
+		ep_type = cfg & 3;
+		/* Direction in or both */
+		if (!(ep_type & 2)) {
+			hsotg->eps_in[i] = devm_kzalloc(hsotg->dev,
+				sizeof(struct dwc2_hsotg_ep), GFP_KERNEL);
+			if (!hsotg->eps_in[i])
+				return -ENOMEM;
+		}
+		/* Direction out or both */
+		if (!(ep_type & 1)) {
+			hsotg->eps_out[i] = devm_kzalloc(hsotg->dev,
+				sizeof(struct dwc2_hsotg_ep), GFP_KERNEL);
+			if (!hsotg->eps_out[i])
+				return -ENOMEM;
+		}
+	}
 
-	cfg3 = readl(hsotg->regs + 0x4C);
-	hsotg->fifo_mem = (cfg3 >> 16);
+	cfg = dwc2_readl(hsotg->regs + GHWCFG3);
+	hsotg->fifo_mem = (cfg >> GHWCFG3_DFIFO_DEPTH_SHIFT);
 
-	cfg4 = readl(hsotg->regs + 0x50);
-	hsotg->dedicated_fifos = (cfg4 >> 25) & 1;
+	cfg = dwc2_readl(hsotg->regs + GHWCFG4);
+	hsotg->dedicated_fifos = (cfg >> GHWCFG4_DED_FIFO_SHIFT) & 1;
 
 	dev_info(hsotg->dev, "EPs: %d, %s fifos, %d entries in SPRAM\n",
 		 hsotg->num_of_eps,
 		 hsotg->dedicated_fifos ? "dedicated" : "shared",
 		 hsotg->fifo_mem);
+	return 0;
 }
 
 /**
- * s3c_hsotg_dump - dump state of the udc
+ * dwc2_hsotg_dump - dump state of the udc
  * @param: The device state
  */
-static void s3c_hsotg_dump(struct s3c_hsotg *hsotg)
+static void dwc2_hsotg_dump(struct dwc2_hsotg *hsotg)
 {
 #ifdef DEBUG
 	struct device *dev = hsotg->dev;
@@ -3089,613 +3461,270 @@
 	int idx;
 
 	dev_info(dev, "DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\n",
-		 readl(regs + DCFG), readl(regs + DCTL),
-		 readl(regs + DIEPMSK));
+		 dwc2_readl(regs + DCFG), dwc2_readl(regs + DCTL),
+		 dwc2_readl(regs + DIEPMSK));
 
-	dev_info(dev, "GAHBCFG=0x%08x, 0x44=0x%08x\n",
-		 readl(regs + GAHBCFG), readl(regs + 0x44));
+	dev_info(dev, "GAHBCFG=0x%08x, GHWCFG1=0x%08x\n",
+		 dwc2_readl(regs + GAHBCFG), dwc2_readl(regs + GHWCFG1));
 
 	dev_info(dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
-		 readl(regs + GRXFSIZ), readl(regs + GNPTXFSIZ));
+		 dwc2_readl(regs + GRXFSIZ), dwc2_readl(regs + GNPTXFSIZ));
 
 	/* show periodic fifo settings */
 
-	for (idx = 1; idx <= 15; idx++) {
-		val = readl(regs + DPTXFSIZN(idx));
+	for (idx = 1; idx < hsotg->num_of_eps; idx++) {
+		val = dwc2_readl(regs + DPTXFSIZN(idx));
 		dev_info(dev, "DPTx[%d] FSize=%d, StAddr=0x%08x\n", idx,
 			 val >> FIFOSIZE_DEPTH_SHIFT,
 			 val & FIFOSIZE_STARTADDR_MASK);
 	}
 
-	for (idx = 0; idx < 15; idx++) {
+	for (idx = 0; idx < hsotg->num_of_eps; idx++) {
 		dev_info(dev,
 			 "ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n", idx,
-			 readl(regs + DIEPCTL(idx)),
-			 readl(regs + DIEPTSIZ(idx)),
-			 readl(regs + DIEPDMA(idx)));
+			 dwc2_readl(regs + DIEPCTL(idx)),
+			 dwc2_readl(regs + DIEPTSIZ(idx)),
+			 dwc2_readl(regs + DIEPDMA(idx)));
 
-		val = readl(regs + DOEPCTL(idx));
+		val = dwc2_readl(regs + DOEPCTL(idx));
 		dev_info(dev,
 			 "ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",
-			 idx, readl(regs + DOEPCTL(idx)),
-			 readl(regs + DOEPTSIZ(idx)),
-			 readl(regs + DOEPDMA(idx)));
+			 idx, dwc2_readl(regs + DOEPCTL(idx)),
+			 dwc2_readl(regs + DOEPTSIZ(idx)),
+			 dwc2_readl(regs + DOEPDMA(idx)));
 
 	}
 
 	dev_info(dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n",
-		 readl(regs + DVBUSDIS), readl(regs + DVBUSPULSE));
+		 dwc2_readl(regs + DVBUSDIS), dwc2_readl(regs + DVBUSPULSE));
 #endif
 }
 
-/**
- * state_show - debugfs: show overall driver and device state.
- * @seq: The seq file to write to.
- * @v: Unused parameter.
- *
- * This debugfs entry shows the overall state of the hardware and
- * some general information about each of the endpoints available
- * to the system.
- */
-static int state_show(struct seq_file *seq, void *v)
-{
-	struct s3c_hsotg *hsotg = seq->private;
-	void __iomem *regs = hsotg->regs;
-	int idx;
-
-	seq_printf(seq, "DCFG=0x%08x, DCTL=0x%08x, DSTS=0x%08x\n",
-		 readl(regs + DCFG),
-		 readl(regs + DCTL),
-		 readl(regs + DSTS));
-
-	seq_printf(seq, "DIEPMSK=0x%08x, DOEPMASK=0x%08x\n",
-		   readl(regs + DIEPMSK), readl(regs + DOEPMSK));
-
-	seq_printf(seq, "GINTMSK=0x%08x, GINTSTS=0x%08x\n",
-		   readl(regs + GINTMSK),
-		   readl(regs + GINTSTS));
-
-	seq_printf(seq, "DAINTMSK=0x%08x, DAINT=0x%08x\n",
-		   readl(regs + DAINTMSK),
-		   readl(regs + DAINT));
-
-	seq_printf(seq, "GNPTXSTS=0x%08x, GRXSTSR=%08x\n",
-		   readl(regs + GNPTXSTS),
-		   readl(regs + GRXSTSR));
-
-	seq_puts(seq, "\nEndpoint status:\n");
-
-	for (idx = 0; idx < 15; idx++) {
-		u32 in, out;
-
-		in = readl(regs + DIEPCTL(idx));
-		out = readl(regs + DOEPCTL(idx));
-
-		seq_printf(seq, "ep%d: DIEPCTL=0x%08x, DOEPCTL=0x%08x",
-			   idx, in, out);
-
-		in = readl(regs + DIEPTSIZ(idx));
-		out = readl(regs + DOEPTSIZ(idx));
-
-		seq_printf(seq, ", DIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x",
-			   in, out);
-
-		seq_puts(seq, "\n");
-	}
-
-	return 0;
-}
-
-static int state_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, state_show, inode->i_private);
-}
-
-static const struct file_operations state_fops = {
-	.owner		= THIS_MODULE,
-	.open		= state_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-/**
- * fifo_show - debugfs: show the fifo information
- * @seq: The seq_file to write data to.
- * @v: Unused parameter.
- *
- * Show the FIFO information for the overall fifo and all the
- * periodic transmission FIFOs.
- */
-static int fifo_show(struct seq_file *seq, void *v)
-{
-	struct s3c_hsotg *hsotg = seq->private;
-	void __iomem *regs = hsotg->regs;
-	u32 val;
-	int idx;
-
-	seq_puts(seq, "Non-periodic FIFOs:\n");
-	seq_printf(seq, "RXFIFO: Size %d\n", readl(regs + GRXFSIZ));
-
-	val = readl(regs + GNPTXFSIZ);
-	seq_printf(seq, "NPTXFIFO: Size %d, Start 0x%08x\n",
-		   val >> FIFOSIZE_DEPTH_SHIFT,
-		   val & FIFOSIZE_DEPTH_MASK);
-
-	seq_puts(seq, "\nPeriodic TXFIFOs:\n");
-
-	for (idx = 1; idx <= 15; idx++) {
-		val = readl(regs + DPTXFSIZN(idx));
-
-		seq_printf(seq, "\tDPTXFIFO%2d: Size %d, Start 0x%08x\n", idx,
-			   val >> FIFOSIZE_DEPTH_SHIFT,
-			   val & FIFOSIZE_STARTADDR_MASK);
-	}
-
-	return 0;
-}
-
-static int fifo_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, fifo_show, inode->i_private);
-}
-
-static const struct file_operations fifo_fops = {
-	.owner		= THIS_MODULE,
-	.open		= fifo_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-
-static const char *decode_direction(int is_in)
-{
-	return is_in ? "in" : "out";
-}
-
-/**
- * ep_show - debugfs: show the state of an endpoint.
- * @seq: The seq_file to write data to.
- * @v: Unused parameter.
- *
- * This debugfs entry shows the state of the given endpoint (one is
- * registered for each available).
- */
-static int ep_show(struct seq_file *seq, void *v)
-{
-	struct s3c_hsotg_ep *ep = seq->private;
-	struct s3c_hsotg *hsotg = ep->parent;
-	struct s3c_hsotg_req *req;
-	void __iomem *regs = hsotg->regs;
-	int index = ep->index;
-	int show_limit = 15;
-	unsigned long flags;
-
-	seq_printf(seq, "Endpoint index %d, named %s,  dir %s:\n",
-		   ep->index, ep->ep.name, decode_direction(ep->dir_in));
-
-	/* first show the register state */
-
-	seq_printf(seq, "\tDIEPCTL=0x%08x, DOEPCTL=0x%08x\n",
-		   readl(regs + DIEPCTL(index)),
-		   readl(regs + DOEPCTL(index)));
-
-	seq_printf(seq, "\tDIEPDMA=0x%08x, DOEPDMA=0x%08x\n",
-		   readl(regs + DIEPDMA(index)),
-		   readl(regs + DOEPDMA(index)));
-
-	seq_printf(seq, "\tDIEPINT=0x%08x, DOEPINT=0x%08x\n",
-		   readl(regs + DIEPINT(index)),
-		   readl(regs + DOEPINT(index)));
-
-	seq_printf(seq, "\tDIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x\n",
-		   readl(regs + DIEPTSIZ(index)),
-		   readl(regs + DOEPTSIZ(index)));
-
-	seq_puts(seq, "\n");
-	seq_printf(seq, "mps %d\n", ep->ep.maxpacket);
-	seq_printf(seq, "total_data=%ld\n", ep->total_data);
-
-	seq_printf(seq, "request list (%p,%p):\n",
-		   ep->queue.next, ep->queue.prev);
-
-	spin_lock_irqsave(&hsotg->lock, flags);
-
-	list_for_each_entry(req, &ep->queue, queue) {
-		if (--show_limit < 0) {
-			seq_puts(seq, "not showing more requests...\n");
-			break;
-		}
-
-		seq_printf(seq, "%c req %p: %d bytes @%p, ",
-			   req == ep->req ? '*' : ' ',
-			   req, req->req.length, req->req.buf);
-		seq_printf(seq, "%d done, res %d\n",
-			   req->req.actual, req->req.status);
-	}
-
-	spin_unlock_irqrestore(&hsotg->lock, flags);
-
-	return 0;
-}
-
-static int ep_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, ep_show, inode->i_private);
-}
-
-static const struct file_operations ep_fops = {
-	.owner		= THIS_MODULE,
-	.open		= ep_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-/**
- * s3c_hsotg_create_debug - create debugfs directory and files
- * @hsotg: The driver state
- *
- * Create the debugfs files to allow the user to get information
- * about the state of the system. The directory name is created
- * with the same name as the device itself, in case we end up
- * with multiple blocks in future systems.
- */
-static void s3c_hsotg_create_debug(struct s3c_hsotg *hsotg)
+#ifdef CONFIG_OF
+static void dwc2_hsotg_of_probe(struct dwc2_hsotg *hsotg)
 {
-	struct dentry *root;
-	unsigned epidx;
-
-	root = debugfs_create_dir(dev_name(hsotg->dev), NULL);
-	hsotg->debug_root = root;
-	if (IS_ERR(root)) {
-		dev_err(hsotg->dev, "cannot create debug root\n");
-		return;
-	}
-
-	/* create general state file */
-
-	hsotg->debug_file = debugfs_create_file("state", 0444, root,
-						hsotg, &state_fops);
+	struct device_node *np = hsotg->dev->of_node;
+	u32 len = 0;
+	u32 i = 0;
 
-	if (IS_ERR(hsotg->debug_file))
-		dev_err(hsotg->dev, "%s: failed to create state\n", __func__);
+	/* Enable dma if requested in device tree */
+	hsotg->g_using_dma = of_property_read_bool(np, "g-use-dma");
 
-	hsotg->debug_fifo = debugfs_create_file("fifo", 0444, root,
-						hsotg, &fifo_fops);
-
-	if (IS_ERR(hsotg->debug_fifo))
-		dev_err(hsotg->dev, "%s: failed to create fifo\n", __func__);
+	/*
+	* Register TX periodic fifo size per endpoint.
+	* EP0 is excluded since it has no fifo configuration.
+	*/
+	if (!of_find_property(np, "g-tx-fifo-size", &len))
+		goto rx_fifo;
 
-	/* create one file for each endpoint */
+	len /= sizeof(u32);
 
-	for (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {
-		struct s3c_hsotg_ep *ep = &hsotg->eps[epidx];
+	/* Read tx fifo sizes other than ep0 */
+	if (of_property_read_u32_array(np, "g-tx-fifo-size",
+						&hsotg->g_tx_fifo_sz[1], len))
+		goto rx_fifo;
 
-		ep->debugfs = debugfs_create_file(ep->name, 0444,
-						  root, ep, &ep_fops);
+	/* Add ep0 */
+	len++;
 
-		if (IS_ERR(ep->debugfs))
-			dev_err(hsotg->dev, "failed to create %s debug file\n",
-				ep->name);
+	/* Make remaining TX fifos unavailable */
+	if (len < MAX_EPS_CHANNELS) {
+		for (i = len; i < MAX_EPS_CHANNELS; i++)
+			hsotg->g_tx_fifo_sz[i] = 0;
 	}
-}
-
-/**
- * s3c_hsotg_delete_debug - cleanup debugfs entries
- * @hsotg: The driver state
- *
- * Cleanup (remove) the debugfs files for use on module exit.
- */
-static void s3c_hsotg_delete_debug(struct s3c_hsotg *hsotg)
-{
-	unsigned epidx;
 
-	for (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {
-		struct s3c_hsotg_ep *ep = &hsotg->eps[epidx];
-		debugfs_remove(ep->debugfs);
-	}
+rx_fifo:
+	/* Register RX fifo size */
+	of_property_read_u32(np, "g-rx-fifo-size", &hsotg->g_rx_fifo_sz);
 
-	debugfs_remove(hsotg->debug_file);
-	debugfs_remove(hsotg->debug_fifo);
-	debugfs_remove(hsotg->debug_root);
+	/* Register NPTX fifo size */
+	of_property_read_u32(np, "g-np-tx-fifo-size",
+						&hsotg->g_np_g_tx_fifo_sz);
 }
+#else
+static inline void dwc2_hsotg_of_probe(struct dwc2_hsotg *hsotg) { }
+#endif
 
 /**
- * s3c_hsotg_probe - probe function for hsotg driver
- * @pdev: The platform information for the driver
+ * dwc2_gadget_init - init function for gadget
+ * @dwc2: The data structure for the DWC2 driver.
+ * @irq: The IRQ number for the controller.
  */
-
-static int s3c_hsotg_probe(struct platform_device *pdev)
+int dwc2_gadget_init(struct dwc2_hsotg *hsotg, int irq)
 {
-	struct s3c_hsotg_plat *plat = dev_get_platdata(&pdev->dev);
-	struct phy *phy;
-	struct usb_phy *uphy;
-	struct device *dev = &pdev->dev;
-	struct s3c_hsotg_ep *eps;
-	struct s3c_hsotg *hsotg;
-	struct resource *res;
+	struct device *dev = hsotg->dev;
 	int epnum;
 	int ret;
 	int i;
+	u32 p_tx_fifo[] = DWC2_G_P_LEGACY_TX_FIFO_SIZE;
 
-	hsotg = devm_kzalloc(&pdev->dev, sizeof(struct s3c_hsotg), GFP_KERNEL);
-	if (!hsotg)
-		return -ENOMEM;
+	/* Initialize to legacy fifo configuration values */
+	hsotg->g_rx_fifo_sz = 2048;
+	hsotg->g_np_g_tx_fifo_sz = 1024;
+	memcpy(&hsotg->g_tx_fifo_sz[1], p_tx_fifo, sizeof(p_tx_fifo));
+	/* Device tree specific probe */
+	dwc2_hsotg_of_probe(hsotg);
+	/* Dump fifo information */
+	dev_dbg(dev, "NonPeriodic TXFIFO size: %d\n",
+						hsotg->g_np_g_tx_fifo_sz);
+	dev_dbg(dev, "RXFIFO size: %d\n", hsotg->g_rx_fifo_sz);
+	for (i = 0; i < MAX_EPS_CHANNELS; i++)
+		dev_dbg(dev, "Periodic TXFIFO%2d size: %d\n", i,
+						hsotg->g_tx_fifo_sz[i]);
 
-	/* Set default UTMI width */
-	hsotg->phyif = GUSBCFG_PHYIF16;
+	hsotg->gadget.max_speed = USB_SPEED_HIGH;
+	hsotg->gadget.ops = &dwc2_hsotg_gadget_ops;
+	hsotg->gadget.name = dev_name(dev);
+	if (hsotg->dr_mode == USB_DR_MODE_OTG)
+		hsotg->gadget.is_otg = 1;
+	else if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)
+		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
 
 	/*
-	 * Attempt to find a generic PHY, then look for an old style
-	 * USB PHY, finally fall back to pdata
+	 * Force Device mode before initialization.
+	 * This allows correctly configuring fifo for device mode.
 	 */
-	phy = devm_phy_get(&pdev->dev, "usb2-phy");
-	if (IS_ERR(phy)) {
-		uphy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
-		if (IS_ERR(uphy)) {
-			/* Fallback for pdata */
-			plat = dev_get_platdata(&pdev->dev);
-			if (!plat) {
-				dev_err(&pdev->dev,
-				"no platform data or transceiver defined\n");
-				return -EPROBE_DEFER;
-			}
-			hsotg->plat = plat;
-		} else
-			hsotg->uphy = uphy;
-	} else {
-		hsotg->phy = phy;
-		/*
-		 * If using the generic PHY framework, check if the PHY bus
-		 * width is 8-bit and set the phyif appropriately.
-		 */
-		if (phy_get_bus_width(phy) == 8)
-			hsotg->phyif = GUSBCFG_PHYIF8;
-	}
-
-	hsotg->dev = dev;
-
-	hsotg->clk = devm_clk_get(&pdev->dev, "otg");
-	if (IS_ERR(hsotg->clk)) {
-		dev_err(dev, "cannot get otg clock\n");
-		return PTR_ERR(hsotg->clk);
-	}
+	__bic32(hsotg->regs + GUSBCFG, GUSBCFG_FORCEHOSTMODE);
+	__orr32(hsotg->regs + GUSBCFG, GUSBCFG_FORCEDEVMODE);
 
-	platform_set_drvdata(pdev, hsotg);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
-	hsotg->regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(hsotg->regs)) {
-		ret = PTR_ERR(hsotg->regs);
-		goto err_clk;
-	}
+	/*
+	 * According to Synopsys databook, this sleep is needed for the force
+	 * device mode to take effect.
+	 */
+	msleep(25);
 
-	ret = platform_get_irq(pdev, 0);
-	if (ret < 0) {
-		dev_err(dev, "cannot find IRQ\n");
-		goto err_clk;
+	dwc2_hsotg_corereset(hsotg);
+	ret = dwc2_hsotg_hw_cfg(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "Hardware configuration failed: %d\n", ret);
+		return ret;
 	}
 
-	spin_lock_init(&hsotg->lock);
-
-	hsotg->irq = ret;
-
-	dev_info(dev, "regs %p, irq %d\n", hsotg->regs, hsotg->irq);
-
-	hsotg->gadget.max_speed = USB_SPEED_HIGH;
-	hsotg->gadget.ops = &s3c_hsotg_gadget_ops;
-	hsotg->gadget.name = dev_name(dev);
-
-	/* reset the system */
-
-	clk_prepare_enable(hsotg->clk);
+	dwc2_hsotg_init(hsotg);
 
-	/* regulators */
+	/* Switch back to default configuration */
+	__bic32(hsotg->regs + GUSBCFG, GUSBCFG_FORCEDEVMODE);
 
-	for (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)
-		hsotg->supplies[i].supply = s3c_hsotg_supply_names[i];
-
-	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(hsotg->supplies),
-				 hsotg->supplies);
-	if (ret) {
-		dev_err(dev, "failed to request supplies: %d\n", ret);
-		goto err_clk;
+	hsotg->ctrl_buff = devm_kzalloc(hsotg->dev,
+			DWC2_CTRL_BUFF_SIZE, GFP_KERNEL);
+	if (!hsotg->ctrl_buff) {
+		dev_err(dev, "failed to allocate ctrl request buff\n");
+		return -ENOMEM;
 	}
 
-	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
-				    hsotg->supplies);
-
-	if (ret) {
-		dev_err(hsotg->dev, "failed to enable supplies: %d\n", ret);
-		goto err_supplies;
+	hsotg->ep0_buff = devm_kzalloc(hsotg->dev,
+			DWC2_CTRL_BUFF_SIZE, GFP_KERNEL);
+	if (!hsotg->ep0_buff) {
+		dev_err(dev, "failed to allocate ctrl reply buff\n");
+		return -ENOMEM;
 	}
 
-	/* usb phy enable */
-	s3c_hsotg_phy_enable(hsotg);
-
-	s3c_hsotg_corereset(hsotg);
-	s3c_hsotg_hw_cfg(hsotg);
-	s3c_hsotg_init(hsotg);
-
-	ret = devm_request_irq(&pdev->dev, hsotg->irq, s3c_hsotg_irq, 0,
-				dev_name(dev), hsotg);
+	ret = devm_request_irq(hsotg->dev, irq, dwc2_hsotg_irq, IRQF_SHARED,
+				dev_name(hsotg->dev), hsotg);
 	if (ret < 0) {
-		s3c_hsotg_phy_disable(hsotg);
-		clk_disable_unprepare(hsotg->clk);
-		regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),
-				       hsotg->supplies);
-		dev_err(dev, "cannot claim IRQ\n");
-		goto err_clk;
+		dev_err(dev, "cannot claim IRQ for gadget\n");
+		return ret;
 	}
 
 	/* hsotg->num_of_eps holds number of EPs other than ep0 */
 
 	if (hsotg->num_of_eps == 0) {
 		dev_err(dev, "wrong number of EPs (zero)\n");
-		ret = -EINVAL;
-		goto err_supplies;
-	}
-
-	eps = kcalloc(hsotg->num_of_eps + 1, sizeof(struct s3c_hsotg_ep),
-		      GFP_KERNEL);
-	if (!eps) {
-		ret = -ENOMEM;
-		goto err_supplies;
+		return -EINVAL;
 	}
 
-	hsotg->eps = eps;
-
 	/* setup endpoint information */
 
 	INIT_LIST_HEAD(&hsotg->gadget.ep_list);
-	hsotg->gadget.ep0 = &hsotg->eps[0].ep;
+	hsotg->gadget.ep0 = &hsotg->eps_out[0]->ep;
 
 	/* allocate EP0 request */
 
-	hsotg->ctrl_req = s3c_hsotg_ep_alloc_request(&hsotg->eps[0].ep,
+	hsotg->ctrl_req = dwc2_hsotg_ep_alloc_request(&hsotg->eps_out[0]->ep,
 						     GFP_KERNEL);
 	if (!hsotg->ctrl_req) {
 		dev_err(dev, "failed to allocate ctrl req\n");
-		ret = -ENOMEM;
-		goto err_ep_mem;
+		return -ENOMEM;
 	}
 
 	/* initialise the endpoints now the core has been initialised */
-	for (epnum = 0; epnum < hsotg->num_of_eps; epnum++)
-		s3c_hsotg_initep(hsotg, &hsotg->eps[epnum], epnum);
-
-	/* disable power and clock */
-	s3c_hsotg_phy_disable(hsotg);
-
-	ret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),
-				    hsotg->supplies);
-	if (ret) {
-		dev_err(hsotg->dev, "failed to disable supplies: %d\n", ret);
-		goto err_ep_mem;
+	for (epnum = 0; epnum < hsotg->num_of_eps; epnum++) {
+		if (hsotg->eps_in[epnum])
+			dwc2_hsotg_initep(hsotg, hsotg->eps_in[epnum],
+								epnum, 1);
+		if (hsotg->eps_out[epnum])
+			dwc2_hsotg_initep(hsotg, hsotg->eps_out[epnum],
+								epnum, 0);
 	}
 
-	ret = usb_add_gadget_udc(&pdev->dev, &hsotg->gadget);
+	ret = usb_add_gadget_udc(dev, &hsotg->gadget);
 	if (ret)
-		goto err_ep_mem;
-
-	s3c_hsotg_create_debug(hsotg);
+		return ret;
 
-	s3c_hsotg_dump(hsotg);
+	dwc2_hsotg_dump(hsotg);
 
 	return 0;
-
-err_ep_mem:
-	kfree(eps);
-err_supplies:
-	s3c_hsotg_phy_disable(hsotg);
-err_clk:
-	clk_disable_unprepare(hsotg->clk);
-
-	return ret;
 }
 
 /**
- * s3c_hsotg_remove - remove function for hsotg driver
+ * dwc2_hsotg_remove - remove function for hsotg driver
  * @pdev: The platform information for the driver
  */
-static int s3c_hsotg_remove(struct platform_device *pdev)
+int dwc2_hsotg_remove(struct dwc2_hsotg *hsotg)
 {
-	struct s3c_hsotg *hsotg = platform_get_drvdata(pdev);
-
 	usb_del_gadget_udc(&hsotg->gadget);
 
-	s3c_hsotg_delete_debug(hsotg);
-
-	if (hsotg->driver) {
-		/* should have been done already by driver model core */
-		usb_gadget_unregister_driver(hsotg->driver);
-	}
-
-	clk_disable_unprepare(hsotg->clk);
-
 	return 0;
 }
 
-static int s3c_hsotg_suspend(struct platform_device *pdev, pm_message_t state)
+int dwc2_hsotg_suspend(struct dwc2_hsotg *hsotg)
 {
-	struct s3c_hsotg *hsotg = platform_get_drvdata(pdev);
 	unsigned long flags;
-	int ret = 0;
 
-	if (hsotg->driver)
-		dev_info(hsotg->dev, "suspending usb gadget %s\n",
-			 hsotg->driver->driver.name);
-
-	spin_lock_irqsave(&hsotg->lock, flags);
-	s3c_hsotg_disconnect(hsotg);
-	s3c_hsotg_phy_disable(hsotg);
-	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
-	spin_unlock_irqrestore(&hsotg->lock, flags);
+	if (hsotg->lx_state != DWC2_L0)
+		return 0;
 
 	if (hsotg->driver) {
 		int ep;
-		for (ep = 0; ep < hsotg->num_of_eps; ep++)
-			s3c_hsotg_ep_disable(&hsotg->eps[ep].ep);
 
-		ret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),
-					     hsotg->supplies);
-		clk_disable(hsotg->clk);
+		dev_info(hsotg->dev, "suspending usb gadget %s\n",
+			 hsotg->driver->driver.name);
+
+		spin_lock_irqsave(&hsotg->lock, flags);
+		if (hsotg->enabled)
+			dwc2_hsotg_core_disconnect(hsotg);
+		dwc2_hsotg_disconnect(hsotg);
+		hsotg->gadget.speed = USB_SPEED_UNKNOWN;
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+
+		for (ep = 0; ep < hsotg->num_of_eps; ep++) {
+			if (hsotg->eps_in[ep])
+				dwc2_hsotg_ep_disable(&hsotg->eps_in[ep]->ep);
+			if (hsotg->eps_out[ep])
+				dwc2_hsotg_ep_disable(&hsotg->eps_out[ep]->ep);
+		}
 	}
 
-	return ret;
+	return 0;
 }
 
-static int s3c_hsotg_resume(struct platform_device *pdev)
+int dwc2_hsotg_resume(struct dwc2_hsotg *hsotg)
 {
-	struct s3c_hsotg *hsotg = platform_get_drvdata(pdev);
 	unsigned long flags;
-	int ret = 0;
+
+	if (hsotg->lx_state == DWC2_L2)
+		return 0;
 
 	if (hsotg->driver) {
 		dev_info(hsotg->dev, "resuming usb gadget %s\n",
 			 hsotg->driver->driver.name);
 
-		clk_enable(hsotg->clk);
-		ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
-				      hsotg->supplies);
+		spin_lock_irqsave(&hsotg->lock, flags);
+		dwc2_hsotg_core_init_disconnected(hsotg, false);
+		if (hsotg->enabled)
+			dwc2_hsotg_core_connect(hsotg);
+		spin_unlock_irqrestore(&hsotg->lock, flags);
 	}
 
-	spin_lock_irqsave(&hsotg->lock, flags);
-	hsotg->last_rst = jiffies;
-	s3c_hsotg_phy_enable(hsotg);
-	s3c_hsotg_core_init(hsotg);
-	spin_unlock_irqrestore(&hsotg->lock, flags);
-
-	return ret;
+	return 0;
 }
-
-#ifdef CONFIG_OF
-static const struct of_device_id s3c_hsotg_of_ids[] = {
-	{ .compatible = "samsung,s3c6400-hsotg", },
-	{ .compatible = "snps,dwc2", },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, s3c_hsotg_of_ids);
-#endif
-
-static struct platform_driver s3c_hsotg_driver = {
-	.driver		= {
-		.name	= "s3c-hsotg",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(s3c_hsotg_of_ids),
-	},
-	.probe		= s3c_hsotg_probe,
-	.remove		= s3c_hsotg_remove,
-	.suspend	= s3c_hsotg_suspend,
-	.resume		= s3c_hsotg_resume,
-};
-
-module_platform_driver(s3c_hsotg_driver);
-
-MODULE_DESCRIPTION("Samsung S3C USB High-speed/OtG device");
-MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:s3c-hsotg");
Index: linux-3.18.29/drivers/usb/dwc2/hcd_intr.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/hcd_intr.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/hcd_intr.c	2017-11-21 20:13:12.450710527 +0800
@@ -148,7 +148,7 @@
 		dwc2_hcd_queue_transactions(hsotg, tr_type);
 
 	/* Clear interrupt */
-	writel(GINTSTS_SOF, hsotg->regs + GINTSTS);
+	dwc2_writel(GINTSTS_SOF, hsotg->regs + GINTSTS);
 }
 
 /*
@@ -164,7 +164,7 @@
 	if (dbg_perio())
 		dev_vdbg(hsotg->dev, "--RxFIFO Level Interrupt--\n");
 
-	grxsts = readl(hsotg->regs + GRXSTSP);
+	grxsts = dwc2_readl(hsotg->regs + GRXSTSP);
 	chnum = (grxsts & GRXSTS_HCHNUM_MASK) >> GRXSTS_HCHNUM_SHIFT;
 	chan = hsotg->hc_ptr_array[chnum];
 	if (!chan) {
@@ -247,11 +247,11 @@
 	dev_vdbg(hsotg->dev, "%s(%p)\n", __func__, hsotg);
 
 	/* Every time when port enables calculate HFIR.FrInterval */
-	hfir = readl(hsotg->regs + HFIR);
+	hfir = dwc2_readl(hsotg->regs + HFIR);
 	hfir &= ~HFIR_FRINT_MASK;
 	hfir |= dwc2_calc_frame_interval(hsotg) << HFIR_FRINT_SHIFT &
 		HFIR_FRINT_MASK;
-	writel(hfir, hsotg->regs + HFIR);
+	dwc2_writel(hfir, hsotg->regs + HFIR);
 
 	/* Check if we need to adjust the PHY clock speed for low power */
 	if (!params->host_support_fs_ls_low_power) {
@@ -260,7 +260,7 @@
 		return;
 	}
 
-	usbcfg = readl(hsotg->regs + GUSBCFG);
+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 	prtspd = (hprt0 & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;
 
 	if (prtspd == HPRT0_SPD_LOW_SPEED || prtspd == HPRT0_SPD_FULL_SPEED) {
@@ -268,11 +268,11 @@
 		if (!(usbcfg & GUSBCFG_PHY_LP_CLK_SEL)) {
 			/* Set PHY low power clock select for FS/LS devices */
 			usbcfg |= GUSBCFG_PHY_LP_CLK_SEL;
-			writel(usbcfg, hsotg->regs + GUSBCFG);
+			dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
 			do_reset = 1;
 		}
 
-		hcfg = readl(hsotg->regs + HCFG);
+		hcfg = dwc2_readl(hsotg->regs + HCFG);
 		fslspclksel = (hcfg & HCFG_FSLSPCLKSEL_MASK) >>
 			      HCFG_FSLSPCLKSEL_SHIFT;
 
@@ -286,7 +286,7 @@
 				fslspclksel = HCFG_FSLSPCLKSEL_6_MHZ;
 				hcfg &= ~HCFG_FSLSPCLKSEL_MASK;
 				hcfg |= fslspclksel << HCFG_FSLSPCLKSEL_SHIFT;
-				writel(hcfg, hsotg->regs + HCFG);
+				dwc2_writel(hcfg, hsotg->regs + HCFG);
 				do_reset = 1;
 			}
 		} else {
@@ -297,7 +297,7 @@
 				fslspclksel = HCFG_FSLSPCLKSEL_48_MHZ;
 				hcfg &= ~HCFG_FSLSPCLKSEL_MASK;
 				hcfg |= fslspclksel << HCFG_FSLSPCLKSEL_SHIFT;
-				writel(hcfg, hsotg->regs + HCFG);
+				dwc2_writel(hcfg, hsotg->regs + HCFG);
 				do_reset = 1;
 			}
 		}
@@ -305,7 +305,7 @@
 		/* Not low power */
 		if (usbcfg & GUSBCFG_PHY_LP_CLK_SEL) {
 			usbcfg &= ~GUSBCFG_PHY_LP_CLK_SEL;
-			writel(usbcfg, hsotg->regs + GUSBCFG);
+			dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
 			do_reset = 1;
 		}
 	}
@@ -332,7 +332,7 @@
 
 	dev_vdbg(hsotg->dev, "--Port Interrupt--\n");
 
-	hprt0 = readl(hsotg->regs + HPRT0);
+	hprt0 = dwc2_readl(hsotg->regs + HPRT0);
 	hprt0_modify = hprt0;
 
 	/*
@@ -350,6 +350,9 @@
 		dev_vdbg(hsotg->dev,
 			 "--Port Interrupt HPRT0=0x%08x Port Connect Detected--\n",
 			 hprt0);
+		if (hsotg->lx_state != DWC2_L0)
+			usb_hcd_resume_root_hub(hsotg->priv);
+
 		hsotg->flags.b.port_connect_status_change = 1;
 		hsotg->flags.b.port_connect_status = 1;
 		hprt0_modify |= HPRT0_CONNDET;
@@ -385,7 +388,7 @@
 	}
 
 	/* Clear Port Interrupts */
-	writel(hprt0_modify, hsotg->regs + HPRT0);
+	dwc2_writel(hprt0_modify, hsotg->regs + HPRT0);
 }
 
 /*
@@ -405,7 +408,7 @@
 {
 	u32 hctsiz, count, length;
 
-	hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
 
 	if (halt_status == DWC2_HC_XFER_COMPLETE) {
 		if (chan->ep_is_in) {
@@ -463,10 +466,15 @@
 	}
 
 	/* Non DWORD-aligned buffer case handling */
-	if (chan->align_buf && xfer_length && chan->ep_is_in) {
+	if (chan->align_buf && xfer_length) {
 		dev_vdbg(hsotg->dev, "%s(): non-aligned buffer\n", __func__);
-		memcpy(urb->buf + urb->actual_length, chan->qh->dw_align_buf,
-		       xfer_length);
+		dma_unmap_single(hsotg->dev, chan->qh->dw_align_buf_dma,
+				chan->qh->dw_align_buf_size,
+				chan->ep_is_in ?
+				DMA_FROM_DEVICE : DMA_TO_DEVICE);
+		if (chan->ep_is_in)
+			memcpy(urb->buf + urb->actual_length,
+					chan->qh->dw_align_buf, xfer_length);
 	}
 
 	dev_vdbg(hsotg->dev, "urb->actual_length=%d xfer_length=%d\n",
@@ -483,7 +491,7 @@
 		urb->status = 0;
 	}
 
-	hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
 	dev_vdbg(hsotg->dev, "DWC_otg: %s: %s, channel %d\n",
 		 __func__, (chan->ep_is_in ? "IN" : "OUT"), chnum);
 	dev_vdbg(hsotg->dev, "  chan->xfer_len %d\n", chan->xfer_len);
@@ -506,7 +514,7 @@
 			       struct dwc2_host_chan *chan, int chnum,
 			       struct dwc2_qtd *qtd)
 {
-	u32 hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
+	u32 hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
 	u32 pid = (hctsiz & TSIZ_SC_MC_PID_MASK) >> TSIZ_SC_MC_PID_SHIFT;
 
 	if (chan->ep_type != USB_ENDPOINT_XFER_CONTROL) {
@@ -552,13 +560,18 @@
 					chan, chnum, qtd, halt_status, NULL);
 
 		/* Non DWORD-aligned buffer case handling */
-		if (chan->align_buf && frame_desc->actual_length &&
-		    chan->ep_is_in) {
+		if (chan->align_buf && frame_desc->actual_length) {
 			dev_vdbg(hsotg->dev, "%s(): non-aligned buffer\n",
 				 __func__);
-			memcpy(urb->buf + frame_desc->offset +
-			       qtd->isoc_split_offset, chan->qh->dw_align_buf,
-			       frame_desc->actual_length);
+			dma_unmap_single(hsotg->dev, chan->qh->dw_align_buf_dma,
+					chan->qh->dw_align_buf_size,
+					chan->ep_is_in ?
+					DMA_FROM_DEVICE : DMA_TO_DEVICE);
+			if (chan->ep_is_in)
+				memcpy(urb->buf + frame_desc->offset +
+					qtd->isoc_split_offset,
+					chan->qh->dw_align_buf,
+					frame_desc->actual_length);
 		}
 		break;
 	case DWC2_HC_XFER_FRAME_OVERRUN:
@@ -581,13 +594,18 @@
 					chan, chnum, qtd, halt_status, NULL);
 
 		/* Non DWORD-aligned buffer case handling */
-		if (chan->align_buf && frame_desc->actual_length &&
-		    chan->ep_is_in) {
+		if (chan->align_buf && frame_desc->actual_length) {
 			dev_vdbg(hsotg->dev, "%s(): non-aligned buffer\n",
 				 __func__);
-			memcpy(urb->buf + frame_desc->offset +
-			       qtd->isoc_split_offset, chan->qh->dw_align_buf,
-			       frame_desc->actual_length);
+			dma_unmap_single(hsotg->dev, chan->qh->dw_align_buf_dma,
+					chan->qh->dw_align_buf_size,
+					chan->ep_is_in ?
+					DMA_FROM_DEVICE : DMA_TO_DEVICE);
+			if (chan->ep_is_in)
+				memcpy(urb->buf + frame_desc->offset +
+					qtd->isoc_split_offset,
+					chan->qh->dw_align_buf,
+					frame_desc->actual_length);
 		}
 
 		/* Skip whole frame */
@@ -753,9 +771,9 @@
 		}
 	}
 
-	haintmsk = readl(hsotg->regs + HAINTMSK);
+	haintmsk = dwc2_readl(hsotg->regs + HAINTMSK);
 	haintmsk &= ~(1 << chan->hc_num);
-	writel(haintmsk, hsotg->regs + HAINTMSK);
+	dwc2_writel(haintmsk, hsotg->regs + HAINTMSK);
 
 	/* Try to queue more transfers now that there's a free channel */
 	tr_type = dwc2_hcd_select_transactions(hsotg);
@@ -802,9 +820,9 @@
 			 * is enabled so that the non-periodic schedule will
 			 * be processed
 			 */
-			gintmsk = readl(hsotg->regs + GINTMSK);
+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 			gintmsk |= GINTSTS_NPTXFEMP;
-			writel(gintmsk, hsotg->regs + GINTMSK);
+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 		} else {
 			dev_vdbg(hsotg->dev, "isoc/intr\n");
 			/*
@@ -821,9 +839,9 @@
 			 * enabled so that the periodic schedule will be
 			 * processed
 			 */
-			gintmsk = readl(hsotg->regs + GINTMSK);
+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 			gintmsk |= GINTSTS_PTXFEMP;
-			writel(gintmsk, hsotg->regs + GINTMSK);
+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 		}
 	}
 }
@@ -888,7 +906,7 @@
 					struct dwc2_qtd *qtd,
 					enum dwc2_halt_status halt_status)
 {
-	u32 hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
+	u32 hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
 
 	qtd->error_count = 0;
 
@@ -923,6 +941,8 @@
 
 	if (chan->align_buf) {
 		dev_vdbg(hsotg->dev, "%s(): non-aligned buffer\n", __func__);
+		dma_unmap_single(hsotg->dev, chan->qh->dw_align_buf_dma,
+				chan->qh->dw_align_buf_size, DMA_FROM_DEVICE);
 		memcpy(qtd->urb->buf + frame_desc->offset +
 		       qtd->isoc_split_offset, chan->qh->dw_align_buf, len);
 	}
@@ -1152,13 +1172,19 @@
 	/* Non DWORD-aligned buffer case handling */
 	if (chan->align_buf && xfer_length && chan->ep_is_in) {
 		dev_vdbg(hsotg->dev, "%s(): non-aligned buffer\n", __func__);
-		memcpy(urb->buf + urb->actual_length, chan->qh->dw_align_buf,
-		       xfer_length);
+		dma_unmap_single(hsotg->dev, chan->qh->dw_align_buf_dma,
+				chan->qh->dw_align_buf_size,
+				chan->ep_is_in ?
+				DMA_FROM_DEVICE : DMA_TO_DEVICE);
+		if (chan->ep_is_in)
+			memcpy(urb->buf + urb->actual_length,
+					chan->qh->dw_align_buf,
+					xfer_length);
 	}
 
 	urb->actual_length += xfer_length;
 
-	hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
 	dev_vdbg(hsotg->dev, "DWC_otg: %s: %s, channel %d\n",
 		 __func__, (chan->ep_is_in ? "IN" : "OUT"), chnum);
 	dev_vdbg(hsotg->dev, "  chan->start_pkt_count %d\n",
@@ -1182,6 +1208,16 @@
 			     struct dwc2_host_chan *chan, int chnum,
 			     struct dwc2_qtd *qtd)
 {
+	if (!qtd) {
+		dev_dbg(hsotg->dev, "%s: qtd is NULL\n", __func__);
+		return;
+	}
+
+	if (!qtd->urb) {
+		dev_dbg(hsotg->dev, "%s: qtd->urb is NULL\n", __func__);
+		return;
+	}
+
 	if (dbg_hc(chan))
 		dev_vdbg(hsotg->dev, "--Host Channel %d Interrupt: NAK Received--\n",
 			 chnum);
@@ -1469,10 +1505,10 @@
 
 	dwc2_hc_handle_tt_clear(hsotg, chan, qtd);
 
-	hcchar = readl(hsotg->regs + HCCHAR(chnum));
-	hcsplt = readl(hsotg->regs + HCSPLT(chnum));
-	hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
-	hc_dma = readl(hsotg->regs + HCDMA(chnum));
+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chnum));
+	hcsplt = dwc2_readl(hsotg->regs + HCSPLT(chnum));
+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
+	hc_dma = dwc2_readl(hsotg->regs + HCDMA(chnum));
 
 	dev_err(hsotg->dev, "AHB ERROR, Channel %d\n", chnum);
 	dev_err(hsotg->dev, "  hcchar 0x%08x, hcsplt 0x%08x\n", hcchar, hcsplt);
@@ -1685,10 +1721,10 @@
 		 * This code is here only as a check. This condition should
 		 * never happen. Ignore the halt if it does occur.
 		 */
-		hcchar = readl(hsotg->regs + HCCHAR(chnum));
-		hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
-		hcintmsk = readl(hsotg->regs + HCINTMSK(chnum));
-		hcsplt = readl(hsotg->regs + HCSPLT(chnum));
+		hcchar = dwc2_readl(hsotg->regs + HCCHAR(chnum));
+		hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
+		hcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(chnum));
+		hcsplt = dwc2_readl(hsotg->regs + HCSPLT(chnum));
 		dev_dbg(hsotg->dev,
 			"%s: chan->halt_status DWC2_HC_XFER_NO_HALT_STATUS,\n",
 			 __func__);
@@ -1712,7 +1748,7 @@
 	 * when the halt interrupt occurs. Halt the channel again if it does
 	 * occur.
 	 */
-	hcchar = readl(hsotg->regs + HCCHAR(chnum));
+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chnum));
 	if (hcchar & HCCHAR_CHDIS) {
 		dev_warn(hsotg->dev,
 			 "%s: hcchar.chdis set unexpectedly, hcchar 0x%08x, trying to halt again\n",
@@ -1772,7 +1808,7 @@
 		return;
 	}
 
-	hcintmsk = readl(hsotg->regs + HCINTMSK(chnum));
+	hcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(chnum));
 
 	if (chan->hcint & HCINTMSK_XFERCOMPL) {
 		/*
@@ -1867,7 +1903,7 @@
 				dev_err(hsotg->dev,
 					"hcint 0x%08x, intsts 0x%08x\n",
 					chan->hcint,
-					readl(hsotg->regs + GINTSTS));
+					dwc2_readl(hsotg->regs + GINTSTS));
 				goto error;
 			}
 		}
@@ -1913,6 +1949,24 @@
 	}
 }
 
+/*
+ * Check if the given qtd is still the top of the list (and thus valid).
+ *
+ * If dwc2_hcd_qtd_unlink_and_free() has been called since we grabbed
+ * the qtd from the top of the list, this will return false (otherwise true).
+ */
+static bool dwc2_check_qtd_still_ok(struct dwc2_qtd *qtd, struct dwc2_qh *qh)
+{
+	struct dwc2_qtd *cur_head;
+
+	if (qh == NULL)
+		return false;
+
+	cur_head = list_first_entry(&qh->qtd_list, struct dwc2_qtd,
+				    qtd_list_entry);
+	return (cur_head == qtd);
+}
+
 /* Handles interrupt for a specific Host Channel */
 static void dwc2_hc_n_intr(struct dwc2_hsotg *hsotg, int chnum)
 {
@@ -1922,11 +1976,11 @@
 
 	chan = hsotg->hc_ptr_array[chnum];
 
-	hcint = readl(hsotg->regs + HCINT(chnum));
-	hcintmsk = readl(hsotg->regs + HCINTMSK(chnum));
+	hcint = dwc2_readl(hsotg->regs + HCINT(chnum));
+	hcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(chnum));
 	if (!chan) {
 		dev_err(hsotg->dev, "## hc_ptr_array for channel is NULL ##\n");
-		writel(hcint, hsotg->regs + HCINT(chnum));
+		dwc2_writel(hcint, hsotg->regs + HCINT(chnum));
 		return;
 	}
 
@@ -1938,7 +1992,7 @@
 			 hcint, hcintmsk, hcint & hcintmsk);
 	}
 
-	writel(hcint, hsotg->regs + HCINT(chnum));
+	dwc2_writel(hcint, hsotg->regs + HCINT(chnum));
 	chan->hcint = hcint;
 	hcint &= hcintmsk;
 
@@ -1995,27 +2049,59 @@
 		 */
 		hcint &= ~HCINTMSK_NYET;
 	}
-	if (hcint & HCINTMSK_CHHLTD)
+
+	if (hcint & HCINTMSK_CHHLTD) {
 		dwc2_hc_chhltd_intr(hsotg, chan, chnum, qtd);
-	if (hcint & HCINTMSK_AHBERR)
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
+	if (hcint & HCINTMSK_AHBERR) {
 		dwc2_hc_ahberr_intr(hsotg, chan, chnum, qtd);
-	if (hcint & HCINTMSK_STALL)
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
+	if (hcint & HCINTMSK_STALL) {
 		dwc2_hc_stall_intr(hsotg, chan, chnum, qtd);
-	if (hcint & HCINTMSK_NAK)
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
+	if (hcint & HCINTMSK_NAK) {
 		dwc2_hc_nak_intr(hsotg, chan, chnum, qtd);
-	if (hcint & HCINTMSK_ACK)
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
+	if (hcint & HCINTMSK_ACK) {
 		dwc2_hc_ack_intr(hsotg, chan, chnum, qtd);
-	if (hcint & HCINTMSK_NYET)
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
+	if (hcint & HCINTMSK_NYET) {
 		dwc2_hc_nyet_intr(hsotg, chan, chnum, qtd);
-	if (hcint & HCINTMSK_XACTERR)
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
+	if (hcint & HCINTMSK_XACTERR) {
 		dwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);
-	if (hcint & HCINTMSK_BBLERR)
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
+	if (hcint & HCINTMSK_BBLERR) {
 		dwc2_hc_babble_intr(hsotg, chan, chnum, qtd);
-	if (hcint & HCINTMSK_FRMOVRUN)
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
+	if (hcint & HCINTMSK_FRMOVRUN) {
 		dwc2_hc_frmovrun_intr(hsotg, chan, chnum, qtd);
-	if (hcint & HCINTMSK_DATATGLERR)
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
+	if (hcint & HCINTMSK_DATATGLERR) {
 		dwc2_hc_datatglerr_intr(hsotg, chan, chnum, qtd);
+		if (!dwc2_check_qtd_still_ok(qtd, chan->qh))
+			goto exit;
+	}
 
+exit:
 	chan->hcint = 0;
 }
 
@@ -2030,7 +2116,7 @@
 	u32 haint;
 	int i;
 
-	haint = readl(hsotg->regs + HAINT);
+	haint = dwc2_readl(hsotg->regs + HAINT);
 	if (dbg_perio()) {
 		dev_vdbg(hsotg->dev, "%s()\n", __func__);
 
@@ -2098,8 +2184,8 @@
 				 "DWC OTG HCD Finished Servicing Interrupts\n");
 			dev_vdbg(hsotg->dev,
 				 "DWC OTG HCD gintsts=0x%08x gintmsk=0x%08x\n",
-				 readl(hsotg->regs + GINTSTS),
-				 readl(hsotg->regs + GINTMSK));
+				 dwc2_readl(hsotg->regs + GINTSTS),
+				 dwc2_readl(hsotg->regs + GINTMSK));
 		}
 	}
 
Index: linux-3.18.29/drivers/usb/dwc2/hw.h
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/hw.h	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/hw.h	2017-11-21 20:13:12.450710527 +0800
@@ -56,6 +56,7 @@
 #define GOTGCTL_SESREQSCS		(1 << 0)
 
 #define GOTGINT				HSOTG_REG(0x004)
+#define GOTGINT_MULTVALLPCHNG		(1 << 20)
 #define GOTGINT_DBNCE_DONE		(1 << 19)
 #define GOTGINT_A_DEV_TOUT_CHG		(1 << 18)
 #define GOTGINT_HST_NEG_DET		(1 << 17)
@@ -142,6 +143,7 @@
 #define GINTSTS_RESETDET		(1 << 23)
 #define GINTSTS_FET_SUSP		(1 << 22)
 #define GINTSTS_INCOMPL_IP		(1 << 21)
+#define GINTSTS_INCOMPL_SOOUT		(1 << 21)
 #define GINTSTS_INCOMPL_SOIN		(1 << 20)
 #define GINTSTS_OEPINT			(1 << 19)
 #define GINTSTS_IEPINT			(1 << 18)
@@ -294,6 +296,7 @@
 #define GHWCFG4_NUM_IN_EPS_MASK			(0xf << 26)
 #define GHWCFG4_NUM_IN_EPS_SHIFT		26
 #define GHWCFG4_DED_FIFO_EN			(1 << 25)
+#define GHWCFG4_DED_FIFO_SHIFT		25
 #define GHWCFG4_SESSION_END_FILT_EN		(1 << 24)
 #define GHWCFG4_B_VALID_FILT_EN			(1 << 23)
 #define GHWCFG4_A_VALID_FILT_EN			(1 << 22)
@@ -541,6 +544,7 @@
 
 #define DIEPINT(_a)			HSOTG_REG(0x908 + ((_a) * 0x20))
 #define DOEPINT(_a)			HSOTG_REG(0xB08 + ((_a) * 0x20))
+#define DXEPINT_SETUP_RCVD		(1 << 15)
 #define DXEPINT_INEPNAKEFF		(1 << 6)
 #define DXEPINT_BACK2BACKSETUP		(1 << 6)
 #define DXEPINT_INTKNEPMIS		(1 << 5)
Index: linux-3.18.29/drivers/usb/dwc2/platform.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/platform.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/platform.c	2017-11-21 20:13:12.450710527 +0800
@@ -37,15 +37,20 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/of_device.h>
+#include <linux/mutex.h>
 #include <linux/platform_device.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_data/dwc2-hsotg.h>
 
 #include <linux/usb/of.h>
 
 #include "core.h"
 #include "hcd.h"
+#include "debug.h"
 
 static const char dwc2_driver_name[] = "dwc2";
 
@@ -75,6 +80,8 @@
 	.reload_ctl			= 0,
 	.ahbcfg				= 0x10,
 	.uframe_sched			= 0,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
 };
 
 static const struct dwc2_core_params params_rk3066 = {
@@ -101,10 +108,207 @@
 	.host_ls_low_power_phy_clk	= -1,
 	.ts_dline			= -1,
 	.reload_ctl			= -1,
-	.ahbcfg				= 0x7, /* INCR16 */
+	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
+					  GAHBCFG_HBSTLEN_SHIFT,
 	.uframe_sched			= -1,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
 };
 
+static const struct dwc2_core_params params_sfax8 = {
+	.otg_cap			= 0,	/* HNP/SRP capable */
+	.otg_ver			= 1,	/* 2.0 */
+	.dma_enable			= 1,
+	.dma_desc_enable		= 1,
+	.speed				= 0,	/* High Speed */
+	.enable_dynamic_fifo		= 1,
+	.en_multiple_tx_fifo		= 1,
+	.host_rx_fifo_size		= 7150,	/* 774 DWORDs */
+	.host_nperio_tx_fifo_size	= 7150,	/* 256 DWORDs */
+	.host_perio_tx_fifo_size	= 7150,	/* 512 DWORDs */
+	.max_transfer_size		= 65535,
+	.max_packet_count		= 511,
+	.host_channels			= 16,
+	.phy_type			= 1,	/* UTMI */
+	.phy_utmi_width			= 16,	/* 16 bits */
+	.phy_ulpi_ddr			= 0,	/* Single */
+	.phy_ulpi_ext_vbus		= 0,
+	.i2c_enable			= 0,
+	.ulpi_fs_ls			= 0,
+	.host_support_fs_ls_low_power	= 0,
+	.host_ls_low_power_phy_clk	= 0,	/* 48 MHz */
+	.ts_dline			= 0,
+	.reload_ctl			= 0,
+	.ahbcfg				= -1, /* INCR4 */
+	.uframe_sched			= 0,
+	.external_id_pin_ctl		= 0,
+	.hibernation			= -1,
+};
+
+static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
+{
+	struct platform_device *pdev = to_platform_device(hsotg->dev);
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
+				    hsotg->supplies);
+	if (ret)
+		return ret;
+
+	if (hsotg->clk) {
+		ret = clk_prepare_enable(hsotg->clk);
+		if (ret)
+			return ret;
+	}
+
+	if (hsotg->uphy)
+		ret = usb_phy_init(hsotg->uphy);
+	else if (hsotg->plat && hsotg->plat->phy_init)
+		ret = hsotg->plat->phy_init(pdev, hsotg->plat->phy_type);
+	else {
+		ret = phy_power_on(hsotg->phy);
+		if (ret == 0)
+			ret = phy_init(hsotg->phy);
+	}
+
+	return ret;
+}
+
+/**
+ * dwc2_lowlevel_hw_enable - enable platform lowlevel hw resources
+ * @hsotg: The driver state
+ *
+ * A wrapper for platform code responsible for controlling
+ * low-level USB platform resources (phy, clock, regulators)
+ */
+int dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
+{
+	int ret = __dwc2_lowlevel_hw_enable(hsotg);
+
+	if (ret == 0)
+		hsotg->ll_hw_enabled = true;
+	return ret;
+}
+
+static int __dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)
+{
+	struct platform_device *pdev = to_platform_device(hsotg->dev);
+	int ret = 0;
+
+	if (hsotg->uphy)
+		usb_phy_shutdown(hsotg->uphy);
+	else if (hsotg->plat && hsotg->plat->phy_exit)
+		ret = hsotg->plat->phy_exit(pdev, hsotg->plat->phy_type);
+	else {
+		ret = phy_exit(hsotg->phy);
+		if (ret == 0)
+			ret = phy_power_off(hsotg->phy);
+	}
+	if (ret)
+		return ret;
+
+	if (hsotg->clk)
+		clk_disable_unprepare(hsotg->clk);
+
+	ret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),
+				     hsotg->supplies);
+
+	return ret;
+}
+
+/**
+ * dwc2_lowlevel_hw_disable - disable platform lowlevel hw resources
+ * @hsotg: The driver state
+ *
+ * A wrapper for platform code responsible for controlling
+ * low-level USB platform resources (phy, clock, regulators)
+ */
+int dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)
+{
+	int ret = __dwc2_lowlevel_hw_disable(hsotg);
+
+	if (ret == 0)
+		hsotg->ll_hw_enabled = false;
+	return ret;
+}
+
+static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
+{
+	int i, ret;
+
+	/* Set default UTMI width */
+	hsotg->phyif = GUSBCFG_PHYIF16;
+
+	/*
+	 * Attempt to find a generic PHY, then look for an old style
+	 * USB PHY and then fall back to pdata
+	 */
+	hsotg->phy = devm_phy_get(hsotg->dev, "usb2-phy");
+	if (IS_ERR(hsotg->phy)) {
+		ret = PTR_ERR(hsotg->phy);
+		switch (ret) {
+		case -ENODEV:
+		case -ENOSYS:
+			hsotg->phy = NULL;
+			break;
+		case -EPROBE_DEFER:
+			return ret;
+		default:
+			dev_err(hsotg->dev, "error getting phy %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (!hsotg->phy) {
+		hsotg->uphy = devm_usb_get_phy(hsotg->dev, USB_PHY_TYPE_USB2);
+		if (IS_ERR(hsotg->uphy)) {
+			ret = PTR_ERR(hsotg->uphy);
+			switch (ret) {
+			case -ENODEV:
+			case -ENXIO:
+				hsotg->uphy = NULL;
+				break;
+			case -EPROBE_DEFER:
+				return ret;
+			default:
+				dev_err(hsotg->dev, "error getting usb phy %d\n",
+					ret);
+				return ret;
+			}
+		}
+	}
+
+	hsotg->plat = dev_get_platdata(hsotg->dev);
+
+	if (hsotg->phy) {
+		/*
+		 * If using the generic PHY framework, check if the PHY bus
+		 * width is 8-bit and set the phyif appropriately.
+		 */
+		if (phy_get_bus_width(hsotg->phy) == 8)
+			hsotg->phyif = GUSBCFG_PHYIF8;
+	}
+
+	/* Clock */
+	hsotg->clk = devm_clk_get(hsotg->dev, "otg");
+	if (IS_ERR(hsotg->clk)) {
+		hsotg->clk = NULL;
+		dev_dbg(hsotg->dev, "cannot get otg clock\n");
+	}
+
+	/* Regulators */
+	for (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)
+		hsotg->supplies[i].supply = dwc2_hsotg_supply_names[i];
+
+	ret = devm_regulator_bulk_get(hsotg->dev, ARRAY_SIZE(hsotg->supplies),
+				      hsotg->supplies);
+	if (ret) {
+		dev_err(hsotg->dev, "failed to request supplies: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
 /**
  * dwc2_driver_remove() - Called when the DWC_otg core is unregistered with the
  * DWC_otg driver
@@ -120,7 +324,14 @@
 {
 	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
 
-	dwc2_hcd_remove(hsotg);
+	dwc2_debugfs_exit(hsotg);
+	if (hsotg->hcd_enabled)
+		dwc2_hcd_remove(hsotg);
+	if (hsotg->gadget_enabled)
+		dwc2_hsotg_remove(hsotg);
+
+	if (hsotg->ll_hw_enabled)
+		dwc2_lowlevel_hw_disable(hsotg);
 
 	return 0;
 }
@@ -129,6 +340,8 @@
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
 	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
 	{ .compatible = "snps,dwc2", .data = NULL },
+	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
+	{ .compatible = "siflower,sfax8-usb", .data = &params_sfax8 },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
@@ -155,9 +368,6 @@
 	int retval;
 	int irq;
 
-	if (usb_disabled())
-		return -ENODEV;
-
 	match = of_match_device(dwc2_of_match_table, &dev->dev);
 	if (match && match->data) {
 		params = match->data;
@@ -188,12 +398,6 @@
 	if (retval)
 		return retval;
 
-	irq = platform_get_irq(dev, 0);
-	if (irq < 0) {
-		dev_err(&dev->dev, "missing IRQ resource\n");
-		return irq;
-	}
-
 	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
 	hsotg->regs = devm_ioremap_resource(&dev->dev, res);
 	if (IS_ERR(hsotg->regs))
@@ -202,21 +406,130 @@
 	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
 		(unsigned long)res->start, hsotg->regs);
 
-	hsotg->dr_mode = of_usb_get_dr_mode(dev->dev.of_node);
+	hsotg->dr_mode = usb_get_dr_mode(&dev->dev);
+	if (IS_ENABLED(CONFIG_USB_DWC2_HOST) &&
+			hsotg->dr_mode != USB_DR_MODE_HOST) {
+		hsotg->dr_mode = USB_DR_MODE_HOST;
+		dev_warn(hsotg->dev,
+			"Configuration mismatch. Forcing host mode\n");
+	} else if (IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) &&
+			hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {
+		hsotg->dr_mode = USB_DR_MODE_PERIPHERAL;
+		dev_warn(hsotg->dev,
+			"Configuration mismatch. Forcing peripheral mode\n");
+	}
+
+	retval = dwc2_lowlevel_hw_init(hsotg);
+	if (retval)
+		return retval;
+
+	spin_lock_init(&hsotg->lock);
+
+	hsotg->core_params = devm_kzalloc(&dev->dev,
+				sizeof(*hsotg->core_params), GFP_KERNEL);
+	if (!hsotg->core_params)
+		return -ENOMEM;
+
+	dwc2_set_all_params(hsotg->core_params, -1);
+
+	irq = platform_get_irq(dev, 0);
+	if (irq < 0) {
+		dev_err(&dev->dev, "missing IRQ resource\n");
+		return irq;
+	}
+
+	dev_dbg(hsotg->dev, "registering common handler for irq%d\n",
+		irq);
+	retval = devm_request_irq(hsotg->dev, irq,
+				  dwc2_handle_common_intr, IRQF_SHARED,
+				  dev_name(hsotg->dev), hsotg);
+	if (retval)
+		return retval;
 
-	retval = dwc2_hcd_init(hsotg, irq, params);
+	retval = dwc2_lowlevel_hw_enable(hsotg);
 	if (retval)
 		return retval;
 
+	/* Detect config values from hardware */
+	retval = dwc2_get_hwparams(hsotg);
+	if (retval)
+		goto error;
+
+	/* Validate parameter values */
+	dwc2_set_parameters(hsotg, params);
+
+	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
+		retval = dwc2_gadget_init(hsotg, irq);
+		if (retval)
+			goto error;
+		hsotg->gadget_enabled = 1;
+	}
+
+	if (hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {
+		retval = dwc2_hcd_init(hsotg, irq);
+		if (retval) {
+			if (hsotg->gadget_enabled)
+				dwc2_hsotg_remove(hsotg);
+			goto error;
+		}
+		hsotg->hcd_enabled = 1;
+	}
+
 	platform_set_drvdata(dev, hsotg);
 
+	dwc2_debugfs_init(hsotg);
+
+	/* Gadget code manages lowlevel hw on its own */
+	if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)
+		dwc2_lowlevel_hw_disable(hsotg);
+
+	return 0;
+
+error:
+	dwc2_lowlevel_hw_disable(hsotg);
 	return retval;
 }
 
+static int __maybe_unused dwc2_suspend(struct device *dev)
+{
+	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (dwc2_is_device_mode(dwc2))
+		dwc2_hsotg_suspend(dwc2);
+
+	if (dwc2->ll_hw_enabled)
+		ret = __dwc2_lowlevel_hw_disable(dwc2);
+
+	return ret;
+}
+
+static int __maybe_unused dwc2_resume(struct device *dev)
+{
+	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (dwc2->ll_hw_enabled) {
+		ret = __dwc2_lowlevel_hw_enable(dwc2);
+		if (ret)
+			return ret;
+	}
+
+	if (dwc2_is_device_mode(dwc2))
+		ret = dwc2_hsotg_resume(dwc2);
+
+	return ret;
+}
+
+static const struct dev_pm_ops dwc2_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dwc2_suspend, dwc2_resume)
+};
+
 static struct platform_driver dwc2_platform_driver = {
 	.driver = {
 		.name = dwc2_driver_name,
 		.of_match_table = dwc2_of_match_table,
+		.pm = &dwc2_dev_pm_ops,
 	},
 	.probe = dwc2_driver_probe,
 	.remove = dwc2_driver_remove,
Index: linux-3.18.29/drivers/watchdog/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/watchdog/Kconfig	2017-11-21 20:13:12.394710525 +0800
+++ linux-3.18.29/drivers/watchdog/Kconfig	2017-11-21 20:13:12.450710527 +0800
@@ -1257,6 +1257,15 @@
 	help
 	  Hardware driver for the Ralink SoC Watchdog Timer.
 
+config SFAX8_WDT
+	tristate "Siflower watchdog"
+	select WATCHDOG_CORE
+	depends on HAS_IOMEM
+	help
+	  Say Y here if to include support for the Siflower watchdog timer.
+	  To compile this driver as a module, choose M here: the module will
+	  be called sfax8_wdt.
+
 # PARISC Architecture
 
 # POWERPC Architecture
Index: linux-3.18.29/drivers/watchdog/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/watchdog/Makefile	2017-11-21 20:13:12.394710525 +0800
+++ linux-3.18.29/drivers/watchdog/Makefile	2017-11-21 20:13:12.450710527 +0800
@@ -143,6 +143,7 @@
 octeon-wdt-y := octeon-wdt-main.o octeon-wdt-nmi.o
 obj-$(CONFIG_LANTIQ_WDT) += lantiq_wdt.o
 obj-$(CONFIG_RALINK_WDT) += rt2880_wdt.o
+obj-$(CONFIG_SFAX8_WDT) += sfax8_wdt.o
 
 # PARISC Architecture
 
Index: linux-3.18.29/drivers/watchdog/sfax8_wdt.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/watchdog/sfax8_wdt.c	2017-11-15 17:26:54.373090000 +0800
@@ -0,0 +1,347 @@
+/*
+ * Copyright 2016 Shanghai Siflower Communication Technology Co., Ltd.
+ * http://www.siflower.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Based on dw_wdt.c
+ *
+ * This file implements a driver for the Siflower watchdog device
+ * in the many subsystems. The watchdog has 16 different timeout periods
+ * and these are a function of the input clock frequency.
+ *
+ * The Siflower watchdog can be stopped once it has been started so we
+ * implement a stop function. The watchdog core will continue to send
+ * heartbeat requests after the watchdog device has been closed.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/notifier.h>
+#include <linux/of.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+#include <linux/watchdog.h>
+#include <sf16a18.h>
+
+#define WDOG_CONTROL_REG_OFFSET		    0x00
+#define WDOG_CONTROL_REG_WDT_EN_MASK	    0x01
+#define WDOG_TIMEOUT_RANGE_REG_OFFSET	    0x04
+#define WDOG_TIMEOUT_RANGE_TOPINIT_SHIFT    4
+#define WDOG_CURRENT_COUNT_REG_OFFSET	    0x08
+#define WDOG_COUNTER_RESTART_REG_OFFSET     0x0c
+#define WDOG_COUNTER_RESTART_KICK_VALUE	    0x76
+
+/* The maximum TOP (timeout period) value that can be set in the watchdog. */
+#define SFAX8_WDT_MAX_TOP		15
+
+#define SFAX8_WDT_DEFAULT_SECONDS	30
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
+		 "(default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+struct sfax8_wdt {
+	void __iomem		*regs;
+	struct clk		*clk;
+	struct timer_list	timer;
+	unsigned long		rate;
+	struct notifier_block	restart_handler;
+	struct watchdog_device	wdd;
+};
+
+#define to_sfax8_wdt(wdd)	container_of(wdd, struct sfax8_wdt, wdd)
+
+static inline int sfax8_wdt_is_enabled(struct sfax8_wdt *sfax8_wdt)
+{
+	return readl(sfax8_wdt->regs + WDOG_CONTROL_REG_OFFSET) &
+		WDOG_CONTROL_REG_WDT_EN_MASK;
+}
+
+static inline int sfax8_wdt_top_in_seconds(struct sfax8_wdt *sfax8_wdt, unsigned top)
+{
+	/*
+	 * There are 16 possible timeout values in 0..15 where the number of
+	 * cycles is 2 ^ (16 + i) and the watchdog counts down.
+	 */
+	return (1U << (16 + top)) / sfax8_wdt->rate;
+}
+
+static int sfax8_wdt_ping(struct watchdog_device *wdd)
+{
+	struct sfax8_wdt *sfax8_wdt = to_sfax8_wdt(wdd);
+
+	writel(WDOG_COUNTER_RESTART_KICK_VALUE, sfax8_wdt->regs +
+	       WDOG_COUNTER_RESTART_REG_OFFSET);
+
+	/*
+	 *  Modify timer here or we won't know when to ping after close
+	 *  /dev/watchdog
+	 */
+	mod_timer(&sfax8_wdt->timer, jiffies + wdd->timeout * HZ / 2);
+	return 0;
+}
+
+static void sfax8_wdt_timer_ping(unsigned long arg)
+{
+	struct watchdog_device *wdd = (struct watchdog_device *)arg;
+
+	/*
+	 * If watchdog is not opened via /dev/watchdog, ping it
+	 * every wdog->timeout / 2 seconds to prevent reboot
+	 */
+	if (test_bit(WDOG_ACTIVE, &wdd->status) &&
+			(!test_bit(WDOG_DEV_OPEN, &wdd->status)))
+		sfax8_wdt_ping(wdd);
+}
+
+static int sfax8_wdt_set_timeout(struct watchdog_device *wdd, unsigned int top_s)
+{
+	struct sfax8_wdt *sfax8_wdt = to_sfax8_wdt(wdd);
+	int i, top_val = SFAX8_WDT_MAX_TOP;
+
+	/*
+	 * Iterate over the timeout values until we find the closest match. We
+	 * always look for >=.
+	 */
+	for (i = 0; i <= SFAX8_WDT_MAX_TOP; ++i)
+		if (sfax8_wdt_top_in_seconds(sfax8_wdt, i) >= top_s) {
+			top_val = i;
+			break;
+		}
+
+	/*
+	 * Set the new value in the watchdog.  Some versions of sfax8_wdt
+	 * have have TOPINIT in the TIMEOUT_RANGE register (as per
+	 * CP_WDT_DUAL_TOP in WDT_COMP_PARAMS_1).  On those we
+	 * effectively get a pat of the watchdog right here.
+	 */
+	writel(top_val | top_val << WDOG_TIMEOUT_RANGE_TOPINIT_SHIFT,
+	       sfax8_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);
+
+	sfax8_wdt_ping(wdd);
+
+	wdd->timeout = sfax8_wdt_top_in_seconds(sfax8_wdt, top_val);
+
+	return 0;
+}
+
+static int sfax8_wdt_start(struct watchdog_device *wdd)
+{
+	struct sfax8_wdt *sfax8_wdt = to_sfax8_wdt(wdd);
+
+	sfax8_wdt_set_timeout(wdd, wdd->timeout);
+
+	writel(WDOG_CONTROL_REG_WDT_EN_MASK,
+	       sfax8_wdt->regs + WDOG_CONTROL_REG_OFFSET);
+
+	return 0;
+}
+
+static int sfax8_wdt_stop(struct watchdog_device *wdd)
+{
+	struct sfax8_wdt *sfax8_wdt = to_sfax8_wdt(wdd);
+	u32 val = readl(sfax8_wdt->regs + WDOG_CONTROL_REG_OFFSET);
+
+	writel(val & (~WDOG_CONTROL_REG_WDT_EN_MASK),
+			sfax8_wdt->regs + WDOG_CONTROL_REG_OFFSET);
+
+	return 0;
+}
+
+static int sfax8_wdt_restart_handle(struct notifier_block *this,
+				 unsigned long mode, void *cmd)
+{
+	struct sfax8_wdt *sfax8_wdt;
+	u32 val;
+
+	sfax8_wdt = container_of(this, struct sfax8_wdt, restart_handler);
+
+	writel(0, sfax8_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);
+	val = readl(sfax8_wdt->regs + WDOG_CONTROL_REG_OFFSET);
+	if (val & WDOG_CONTROL_REG_WDT_EN_MASK)
+		writel(WDOG_COUNTER_RESTART_KICK_VALUE,
+		       sfax8_wdt->regs + WDOG_COUNTER_RESTART_REG_OFFSET);
+	else
+		writel(WDOG_CONTROL_REG_WDT_EN_MASK,
+		       sfax8_wdt->regs + WDOG_CONTROL_REG_OFFSET);
+
+	/* wait for reset to assert... */
+	mdelay(500);
+
+	return NOTIFY_DONE;
+}
+
+static unsigned int sfax8_wdt_get_timeleft(struct watchdog_device *wdd)
+{
+	struct sfax8_wdt *sfax8_wdt = to_sfax8_wdt(wdd);
+
+	return readl(sfax8_wdt->regs + WDOG_CURRENT_COUNT_REG_OFFSET) /
+		sfax8_wdt->rate;
+}
+
+static const struct watchdog_info sfax8_wdt_ident = {
+	.options	= WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |
+			  WDIOF_MAGICCLOSE,
+	.identity	= "Siflower Watchdog",
+};
+
+static const struct watchdog_ops sfax8_wdt_ops = {
+	.owner		= THIS_MODULE,
+	.start		= sfax8_wdt_start,
+	.stop		= sfax8_wdt_stop,
+	.ping		= sfax8_wdt_ping,
+	.set_timeout	= sfax8_wdt_set_timeout,
+	.get_timeleft	= sfax8_wdt_get_timeleft,
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int sfax8_wdt_suspend(struct device *dev)
+{
+	struct sfax8_wdt *sfax8_wdt = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(sfax8_wdt->clk);
+
+	return 0;
+}
+
+static int sfax8_wdt_resume(struct device *dev)
+{
+	struct sfax8_wdt *sfax8_wdt = dev_get_drvdata(dev);
+	int err = clk_prepare_enable(sfax8_wdt->clk);
+
+	if (err)
+		return err;
+
+	sfax8_wdt_ping(&sfax8_wdt->wdd);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(sfax8_wdt_pm_ops, sfax8_wdt_suspend, sfax8_wdt_resume);
+
+static int sfax8_wdt_drv_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct watchdog_device *wdd;
+	struct sfax8_wdt *sfax8_wdt;
+	struct resource *mem;
+	int ret;
+
+	if(release_reset(SF_WDT_SOFT_RESET))
+		return -EFAULT;
+
+	sfax8_wdt = devm_kzalloc(dev, sizeof(*sfax8_wdt), GFP_KERNEL);
+	if (!sfax8_wdt)
+		return -ENOMEM;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sfax8_wdt->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(sfax8_wdt->regs))
+		return PTR_ERR(sfax8_wdt->regs);
+
+	sfax8_wdt->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(sfax8_wdt->clk))
+		return PTR_ERR(sfax8_wdt->clk);
+
+	ret = clk_prepare_enable(sfax8_wdt->clk);
+	if (ret)
+		return ret;
+
+	sfax8_wdt->rate = clk_get_rate(sfax8_wdt->clk);
+	if (sfax8_wdt->rate == 0) {
+		ret = -EINVAL;
+		goto out_disable_clk;
+	}
+
+	wdd = &sfax8_wdt->wdd;
+	wdd->info = &sfax8_wdt_ident;
+	wdd->ops = &sfax8_wdt_ops;
+	wdd->min_timeout = 1;
+	wdd->max_timeout =
+		sfax8_wdt_top_in_seconds(sfax8_wdt, SFAX8_WDT_MAX_TOP) * 1000;
+	wdd->parent = dev;
+
+	watchdog_set_drvdata(wdd, sfax8_wdt);
+	watchdog_set_nowayout(wdd, nowayout);
+
+	wdd->timeout = SFAX8_WDT_DEFAULT_SECONDS;
+	watchdog_init_timeout(wdd, 0, dev);
+
+	platform_set_drvdata(pdev, sfax8_wdt);
+
+	setup_timer(&sfax8_wdt->timer, sfax8_wdt_timer_ping, (unsigned long)wdd);
+	/* Always start watchdog */
+	sfax8_wdt_start(wdd);
+	set_bit(WDOG_ACTIVE, &wdd->status);
+
+	ret = watchdog_register_device(wdd);
+	if (ret)
+		goto out_disable_clk;
+
+	sfax8_wdt->restart_handler.notifier_call = sfax8_wdt_restart_handle;
+	sfax8_wdt->restart_handler.priority = 128;
+	ret = register_restart_handler(&sfax8_wdt->restart_handler);
+	if (ret)
+		pr_warn("cannot register restart handler\n");
+
+	return 0;
+
+out_disable_clk:
+	clk_disable_unprepare(sfax8_wdt->clk);
+	return ret;
+}
+
+static int sfax8_wdt_drv_remove(struct platform_device *pdev)
+{
+	struct sfax8_wdt *sfax8_wdt = platform_get_drvdata(pdev);
+
+	unregister_restart_handler(&sfax8_wdt->restart_handler);
+	watchdog_unregister_device(&sfax8_wdt->wdd);
+	sfax8_wdt_stop(&sfax8_wdt->wdd);
+	clk_disable_unprepare(sfax8_wdt->clk);
+	del_timer_sync(&sfax8_wdt->timer);
+
+	if(hold_reset(SF_WDT_SOFT_RESET))
+		return -EFAULT;
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id sfax8_wdt_of_match[] = {
+	{ .compatible = "siflower,sfax8-wdt", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sfax8_wdt_of_match);
+#endif
+
+static struct platform_driver sfax8_wdt_driver = {
+	.probe		= sfax8_wdt_drv_probe,
+	.remove		= sfax8_wdt_drv_remove,
+	.driver		= {
+		.name	= "sfax8_wdt",
+		.of_match_table = of_match_ptr(sfax8_wdt_of_match),
+		.pm	= &sfax8_wdt_pm_ops,
+	},
+};
+
+module_platform_driver(sfax8_wdt_driver);
+
+MODULE_AUTHOR("Qi Zhang");
+MODULE_DESCRIPTION("Siflower Watchdog Driver");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/include/clocksource/sfax8_pwm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/clocksource/sfax8_pwm.h	2017-11-21 20:13:12.450710527 +0800
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2016 Shanghai Siflower Communication Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __CLOCKSOURCE_SFAX8_PWM_H
+#define __CLOCKSOURCE_SFAX8_PWM_H
+
+#include <linux/spinlock.h>
+
+#define SFAX8_PWM_NUM		4
+
+/*
+ * Following declaration must be in an ifdef due to this symbol being static
+ * in pwm-sfax8 driver if the clocksource driver is not compiled in and the
+ * spinlock is not shared between both drivers.
+ */
+#ifdef CONFIG_CLKSRC_SFAX8_PWM
+extern spinlock_t sfax8_pwm_lock;
+#endif
+
+struct sfax8_pwm_variant {
+	u8 bits;
+	u8 div_base;
+	u8 tclk_mask;
+	u8 output_mask;
+	bool has_tint_cstat;
+};
+
+#endif /* __CLOCKSOURCE_SFAX8_PWM_H */
Index: linux-3.18.29/include/linux/platform_data/dwc2-hsotg.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/linux/platform_data/dwc2-hsotg.h	2017-11-21 20:13:12.450710527 +0800
@@ -0,0 +1,42 @@
+/* include/linux/platform_data/s3c-hsotg.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * S3C USB2.0 High-speed / OtG platform information
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __LINUX_USB_S3C_HSOTG_H
+#define __LINUX_USB_S3C_HSOTG_H
+
+struct platform_device;
+
+enum dwc2_hsotg_dmamode {
+	S3C_HSOTG_DMA_NONE,	/* do not use DMA at-all */
+	S3C_HSOTG_DMA_ONLY,	/* always use DMA */
+	S3C_HSOTG_DMA_DRV,	/* DMA is chosen by driver */
+};
+
+/**
+ * struct dwc2_hsotg_plat - platform data for high-speed otg/udc
+ * @dma: Whether to use DMA or not.
+ * @is_osc: The clock source is an oscillator, not a crystal
+ */
+struct dwc2_hsotg_plat {
+	enum dwc2_hsotg_dmamode	dma;
+	unsigned int		is_osc:1;
+	int                     phy_type;
+
+	int (*phy_init)(struct platform_device *pdev, int type);
+	int (*phy_exit)(struct platform_device *pdev, int type);
+};
+
+extern void dwc2_hsotg_set_platdata(struct dwc2_hsotg_plat *pd);
+
+#endif /* __LINUX_USB_S3C_HSOTG_H */
Index: linux-3.18.29/include/linux/usb/gadget.h
===================================================================
--- linux-3.18.29.orig/include/linux/usb/gadget.h	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/include/linux/usb/gadget.h	2017-11-21 20:13:12.450710527 +0800
@@ -141,10 +141,49 @@
 };
 
 /**
+ * struct usb_ep_caps - endpoint capabilities description
+ * @type_control:Endpoint supports control type (reserved for ep0).
+ * @type_iso:Endpoint supports isochronous transfers.
+ * @type_bulk:Endpoint supports bulk transfers.
+ * @type_int:Endpoint supports interrupt transfers.
+ * @dir_in:Endpoint supports IN direction.
+ * @dir_out:Endpoint supports OUT direction.
+ */
+struct usb_ep_caps {
+	unsigned type_control:1;
+	unsigned type_iso:1;
+	unsigned type_bulk:1;
+	unsigned type_int:1;
+	unsigned dir_in:1;
+	unsigned dir_out:1;
+};
+
+#define USB_EP_CAPS_TYPE_CONTROL     0x01
+#define USB_EP_CAPS_TYPE_ISO         0x02
+#define USB_EP_CAPS_TYPE_BULK        0x04
+#define USB_EP_CAPS_TYPE_INT         0x08
+#define USB_EP_CAPS_TYPE_ALL \
+	(USB_EP_CAPS_TYPE_ISO | USB_EP_CAPS_TYPE_BULK | USB_EP_CAPS_TYPE_INT)
+#define USB_EP_CAPS_DIR_IN           0x01
+#define USB_EP_CAPS_DIR_OUT          0x02
+#define USB_EP_CAPS_DIR_ALL  (USB_EP_CAPS_DIR_IN | USB_EP_CAPS_DIR_OUT)
+
+#define USB_EP_CAPS(_type, _dir) \
+	{ \
+		.type_control = !!(_type & USB_EP_CAPS_TYPE_CONTROL), \
+		.type_iso = !!(_type & USB_EP_CAPS_TYPE_ISO), \
+		.type_bulk = !!(_type & USB_EP_CAPS_TYPE_BULK), \
+		.type_int = !!(_type & USB_EP_CAPS_TYPE_INT), \
+		.dir_in = !!(_dir & USB_EP_CAPS_DIR_IN), \
+		.dir_out = !!(_dir & USB_EP_CAPS_DIR_OUT), \
+	}
+
+/**
  * struct usb_ep - device side representation of USB endpoint
  * @name:identifier for the endpoint, such as "ep-a" or "ep9in-bulk"
  * @ops: Function pointers used to access hardware-specific operations.
  * @ep_list:the gadget's ep_list holds all of its endpoints
+ * @caps:The structure describing types and directions supported by endoint.
  * @maxpacket:The maximum packet size used on this endpoint.  The initial
  *	value can sometimes be reduced (hardware allowing), according to
  *      the endpoint descriptor used to configure the endpoint.
@@ -167,12 +206,16 @@
  * gadget->ep_list.  the control endpoint (gadget->ep0) is not in that list,
  * and is accessed only in response to a driver setup() callback.
  */
+
 struct usb_ep {
 	void			*driver_data;
 
 	const char		*name;
 	const struct usb_ep_ops	*ops;
 	struct list_head	ep_list;
+	struct usb_ep_caps	caps;
+	bool			claimed;
+	bool			enabled;
 	unsigned		maxpacket:16;
 	unsigned		maxpacket_limit:16;
 	unsigned		max_streams:16;
Index: linux-3.18.29/include/linux/usb/otg.h
===================================================================
--- linux-3.18.29.orig/include/linux/usb/otg.h	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/include/linux/usb/otg.h	2017-11-21 20:13:12.450710527 +0800
@@ -99,4 +99,13 @@
 	USB_DR_MODE_OTG,
 };
 
+/**
+ * usb_get_dr_mode - Get dual role mode for given device
+ * @dev: Pointer to the given device
+ *
+ * The function gets phy interface string from property 'dr_mode',
+ * and returns the correspondig enum usb_dr_mode
+ */
+extern enum usb_dr_mode usb_get_dr_mode(struct device *dev);
+
 #endif /* __LINUX_USB_OTG_H */
Index: linux-3.18.29/kernel/Kconfig.preempt
===================================================================
--- linux-3.18.29.orig/kernel/Kconfig.preempt	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/kernel/Kconfig.preempt	2017-11-21 20:13:12.450710527 +0800
@@ -1,7 +1,7 @@
 
 choice
 	prompt "Preemption Model"
-	default PREEMPT_NONE
+	default PREEMPT
 
 config PREEMPT_NONE
 	bool "No Forced Preemption (Server)"
Index: linux-3.18.29/kernel/time/udelay_test.c
===================================================================
--- linux-3.18.29.orig/kernel/time/udelay_test.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/kernel/time/udelay_test.c	2017-11-21 20:13:12.450710527 +0800
@@ -68,6 +68,12 @@
 			(usecs * 1000) - allowed_error_ns, min, avg, max);
 	if (fail_count)
 		seq_printf(s, " FAIL=%d", fail_count);
+	if (fail_count > 0){
+		printk("test fail!\n");
+	}
+	else {
+		printk("test success!\n");
+	}
 	seq_puts(s, "\n");
 
 	return 0;
Index: linux-3.18.29/net/core/sysctl_net_core.c
===================================================================
--- linux-3.18.29.orig/net/core/sysctl_net_core.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/net/core/sysctl_net_core.c	2017-11-21 20:13:12.450710527 +0800
@@ -23,7 +23,7 @@
 #include <net/pkt_sched.h>
 
 static int zero = 0;
-static int one = 1;
+// static int one = 1;
 static int ushort_max = USHRT_MAX;
 static int min_sndbuf = SOCK_MIN_SNDBUF;
 static int min_rcvbuf = SOCK_MIN_RCVBUF;
Index: linux-3.18.29/net/sched/Kconfig
===================================================================
--- linux-3.18.29.orig/net/sched/Kconfig	2017-11-21 20:13:11.898710510 +0800
+++ linux-3.18.29/net/sched/Kconfig	2017-11-21 20:13:12.450710527 +0800
@@ -3,6 +3,7 @@
 # 
 
 menuconfig NET_SCHED
+	bool "QoS and/or fair queueing"
 	def_bool y
 	select NET_SCH_FIFO
 	select NET_SCH_FQ_CODEL
Index: linux-3.18.29/sound/soc/Kconfig
===================================================================
--- linux-3.18.29.orig/sound/soc/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/sound/soc/Kconfig	2017-11-21 20:13:12.450710527 +0800
@@ -52,15 +52,16 @@
 source "sound/soc/sh/Kconfig"
 source "sound/soc/sirf/Kconfig"
 source "sound/soc/spear/Kconfig"
+source "sound/soc/siflower/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
 source "sound/soc/ux500/Kconfig"
+source "sound/soc/siflower/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
 
 # generic frame-work
 source "sound/soc/generic/Kconfig"
-
 endif	# SND_SOC
 
Index: linux-3.18.29/sound/soc/Makefile
===================================================================
--- linux-3.18.29.orig/sound/soc/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/sound/soc/Makefile	2017-11-21 20:13:12.450710527 +0800
@@ -27,8 +27,9 @@
 obj-$(CONFIG_SND_SOC)	+= rockchip/
 obj-$(CONFIG_SND_SOC)	+= samsung/
 obj-$(CONFIG_SND_SOC)	+= sh/
+obj-$(CONFIG_SND_SOC)	+= siflower/
 obj-$(CONFIG_SND_SOC)	+= sirf/
 obj-$(CONFIG_SND_SOC)	+= spear/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
-obj-$(CONFIG_SND_SOC)	+= ux500/
+obj-$(CONFIG_SND_SOC)	+= ux500/
\ No newline at end of file
Index: linux-3.18.29/sound/soc/codecs/Kconfig
===================================================================
--- linux-3.18.29.orig/sound/soc/codecs/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/sound/soc/codecs/Kconfig	2017-11-21 20:13:12.450710527 +0800
@@ -417,6 +417,12 @@
 config SND_SOC_ES8328
 	tristate "Everest Semi ES8328 CODEC"
 
+config SND_SOC_ES8316
+	tristate "Everest Semi ES8316 CODEC"
+
+config SND_SOC_ES8388S
+	tristate "Everest Semi ES8388s CODEC"
+
 config SND_SOC_ES8328_I2C
 	tristate
 	select SND_SOC_ES8328
@@ -487,7 +493,7 @@
 	depends on I2C
 
 config SND_SOC_RT5631
-	tristate
+	tristate "123413"
 
 config SND_SOC_RT5640
 	tristate
Index: linux-3.18.29/sound/soc/codecs/Makefile
===================================================================
--- linux-3.18.29.orig/sound/soc/codecs/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/sound/soc/codecs/Makefile	2017-11-21 20:13:12.450710527 +0800
@@ -53,6 +53,8 @@
 snd-soc-es8328-objs := es8328.o
 snd-soc-es8328-i2c-objs := es8328-i2c.o
 snd-soc-es8328-spi-objs := es8328-spi.o
+snd-soc-es8388s-objs := es8388s.o
+snd-soc-es8316-objs := es8316.o
 snd-soc-isabelle-objs := isabelle.o
 snd-soc-jz4740-codec-objs := jz4740.o
 snd-soc-l3-objs := l3.o
@@ -229,6 +231,8 @@
 obj-$(CONFIG_SND_SOC_ES8328)	+= snd-soc-es8328.o
 obj-$(CONFIG_SND_SOC_ES8328_I2C)+= snd-soc-es8328-i2c.o
 obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
+obj-$(CONFIG_SND_SOC_ES8316)	+= snd-soc-es8316.o
+obj-$(CONFIG_SND_SOC_ES8388S)	+= snd-soc-es8388s.o
 obj-$(CONFIG_SND_SOC_ISABELLE)	+= snd-soc-isabelle.o
 obj-$(CONFIG_SND_SOC_JZ4740_CODEC)	+= snd-soc-jz4740-codec.o
 obj-$(CONFIG_SND_SOC_L3)	+= snd-soc-l3.o
Index: linux-3.18.29/sound/soc/codecs/es8316.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/codecs/es8316.c	2017-11-21 20:13:12.450710527 +0800
@@ -0,0 +1,1322 @@
+/*
+ * es8316.c -- es8316 ALSA SoC audio driver
+ * Copyright Everest Semiconductor Co.,Ltd
+ *
+ * Author: David Yang <yangxiaohua@everest-semi.com>
+ *
+ * Based on es8316.c
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of_gpio.h>
+#include <linux/acpi.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <linux/proc_fs.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/regmap.h>
+#include "es8316.h"
+
+#if 1
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...) do { } while (0)
+#endif
+#define alsa_dbg DBG
+
+#define dmic_used  1
+#define amic_used  0
+
+#define INVALID_GPIO -1
+int es8316_spk_con_gpio = INVALID_GPIO;
+int es8316_hp_con_gpio = INVALID_GPIO;
+int es8316_hp_det_gpio = INVALID_GPIO;
+int es8316_init_reg = 0;
+
+#define GPIO_LOW  0
+#define GPIO_HIGH 1
+#ifndef es8316_DEF_VOL
+#define es8316_DEF_VOL			0x1e
+#endif
+
+struct snd_soc_codec *es8316_codec;
+static int es8316_init_regs(struct snd_soc_codec *codec);
+static int es8316_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level);
+
+static const struct reg_default es8316_reg_defaults[] = {
+       {0x00, 0x03}, {0x01 ,0x03}, {0x02, 0x00}, {0x03, 0x20}, 
+       {0x04, 0x11}, {0x05, 0x00}, {0x06, 0x11}, {0x07, 0x00},  
+       {0x08, 0x00}, {0x09, 0x01}, {0x0a, 0x00}, {0x0b, 0x00}, 
+       {0x0c, 0xf8}, {0x0d, 0x3f}, {0x0e, 0x00}, {0x0f, 0x00},  
+       {0x10, 0x01}, {0x11, 0xfc}, {0x12, 0x28}, {0x13, 0x00},
+       {0x14, 0x00}, {0x15, 0x33}, {0x16, 0x00}, {0x17, 0x00},  
+       {0x18, 0x88}, {0x19, 0x06}, {0x1a, 0x22}, {0x1b, 0x03},
+       {0x1c, 0x0f}, {0x1d, 0x00}, {0x1e, 0x80}, {0x1f, 0x80},  
+       {0x20, 0x00}, {0x21, 0x00}, {0x22, 0xc0}, {0x23, 0x00},
+       {0x24, 0x01}, {0x25, 0x08}, {0x26, 0x10}, {0x27, 0xc0},  
+       {0x28, 0x00}, {0x29, 0x1c}, {0x2a, 0x00}, {0x2b, 0xb0}, 
+       {0x2c, 0x32}, {0x2d, 0x03}, {0x2e, 0x00}, {0x2f, 0x11},  
+       {0x30, 0x10}, {0x31, 0x00}, {0x32, 0x00}, {0x33, 0xc0}, 
+       {0x34, 0xc0}, {0x35, 0x1f}, {0x36, 0xf7}, {0x37, 0xfd},  
+       {0x38, 0xff}, {0x39, 0x1f}, {0x3a, 0xf7}, {0x3b, 0xfd}, 
+       {0x3c, 0xff}, {0x3d, 0x1f}, {0x3e, 0xf7}, {0x3f, 0xfd},  
+       {0x40, 0xff}, {0x41, 0x1f}, {0x42, 0xf7}, {0x43, 0xfd}, 
+       {0x44, 0xff}, {0x45, 0x1f}, {0x46, 0xf7}, {0x47, 0xfd},  
+       {0x48, 0xff}, {0x49, 0x1f}, {0x4a, 0xf7}, {0x4b, 0xfd}, 
+       {0x4c, 0xff}, {0x4d, 0x00}, {0x4e, 0x00}, {0x4f, 0xff},  
+       {0x50, 0x00}, {0x51, 0x00}, {0x52, 0x00}, {0x53, 0x00},                           
+	};
+
+static bool es8316_volatile(struct device *dev, unsigned int reg)
+{
+	if (reg <= 90)
+		return true;
+	else
+		return false;
+}
+/* codec private data */
+struct es8316_priv {
+	struct regmap *regmap;
+	unsigned int dmic_amic;
+	unsigned int sysclk;
+	struct snd_pcm_hw_constraint_list *sysclk_constraints;
+};
+
+/*
+* es8316_reset
+* write value 0xff to reg0x00, the chip will be in reset mode
+* then, writer 0x00 to reg0x00, unreset the chip
+*/
+ static int es8316_reset(struct snd_soc_codec *codec)
+ {
+	snd_soc_write(codec, ES8316_RESET_REG00, 0x3F);
+	msleep(5);
+  	return snd_soc_write(codec, ES8316_RESET_REG00, 0x03);
+ }
+
+/*
+ * es8316S Controls
+ */
+//#define DECLARE_TLV_DB_SCALE(name, min, step, mute) 
+//static const DECLARE_TLV_DB_SCALE(hpout_vol_tlv, -4800, 1200, 0);
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -9600, 50, 1);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -9600, 50, 1);
+static const DECLARE_TLV_DB_SCALE(hpmixer_gain_tlv, -1200, 150, 0);
+static const DECLARE_TLV_DB_SCALE(mic_bst_tlv, 0, 1200, 0);
+//static const DECLARE_TLV_DB_SCALE(linin_pga_tlv, 0, 300, 0);
+/* {0, +3, +6, +9, +12, +15, +18, +21, +24,+27,+30,+33} dB */
+static unsigned int linin_pga_tlv[] = {
+	TLV_DB_RANGE_HEAD(12),
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 1, TLV_DB_SCALE_ITEM(300, 0, 0),
+	2, 2, TLV_DB_SCALE_ITEM(600, 0, 0),
+	3, 3, TLV_DB_SCALE_ITEM(900, 0, 0),
+	4, 4, TLV_DB_SCALE_ITEM(1200, 0, 0),
+	5, 5, TLV_DB_SCALE_ITEM(1500, 0, 0),
+	6, 6, TLV_DB_SCALE_ITEM(1800, 0, 0),
+	7, 7, TLV_DB_SCALE_ITEM(2100, 0, 0),
+	8, 8, TLV_DB_SCALE_ITEM(2400, 0, 0),
+};
+static unsigned int hpout_vol_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 3, TLV_DB_SCALE_ITEM(-4800, 1200, 0),
+	
+};
+static const char *alc_func_txt[] = {"Off", "On"};
+static const struct soc_enum alc_func =
+	SOC_ENUM_SINGLE(ES8316_ADC_ALC1_REG29, 6, 2, alc_func_txt);
+
+static const char *ng_type_txt[] = {"Constant PGA Gain",
+				    "Mute ADC Output"};
+static const struct soc_enum ng_type =
+	SOC_ENUM_SINGLE(ES8316_ADC_ALC6_REG2E, 6, 2, ng_type_txt);
+
+static const char *adcpol_txt[] = {"Normal", "Invert"};
+static const struct soc_enum adcpol =
+	SOC_ENUM_SINGLE(ES8316_ADC_MUTE_REG26, 1, 2, adcpol_txt);
+static const char *dacpol_txt[] = {"Normal", "R Invert", "L Invert",
+				   "L + R Invert"};
+static const struct soc_enum dacpol =
+	SOC_ENUM_SINGLE(ES8316_DAC_SET1_REG30, 0, 4, dacpol_txt);
+
+static const struct snd_kcontrol_new es8316_snd_controls[] = {
+	/* HP OUT VOLUME */
+	SOC_DOUBLE_TLV("HP Playback Volume", ES8316_CPHP_ICAL_VOL_REG18,
+		4, 0, 0, 1, hpout_vol_tlv),
+	/* HPMIXER VOLUME Control */
+	SOC_DOUBLE_TLV("HPMixer Gain", ES8316_HPMIX_VOL_REG16, 
+	  0, 4, 7, 0, hpmixer_gain_tlv),
+			    
+	/* DAC Digital controls */
+	SOC_DOUBLE_R_TLV("DAC Playback Volume", ES8316_DAC_VOLL_REG33,
+			ES8316_DAC_VOLR_REG34, 0, 0xC0, 1, dac_vol_tlv),
+			
+  	SOC_SINGLE("Enable DAC Soft Ramp", ES8316_DAC_SET1_REG30, 4, 1, 1),		
+  	SOC_SINGLE("DAC Soft Ramp Rate", ES8316_DAC_SET1_REG30, 2, 4, 0),
+    
+  	SOC_ENUM("Playback Polarity", dacpol),		
+  	SOC_SINGLE("DAC Notch Filter", ES8316_DAC_SET2_REG31, 6, 1, 0),	
+  	SOC_SINGLE("DAC Double Fs Mode", ES8316_DAC_SET2_REG31, 7, 1, 0),	  
+  	SOC_SINGLE("DAC Volume Control-LeR", ES8316_DAC_SET2_REG31, 2, 1, 0),	   
+  	SOC_SINGLE("DAC Stereo Enhancement", ES8316_DAC_SET3_REG32, 0, 7, 0),
+  
+	/* +20dB D2SE PGA Control */
+	SOC_SINGLE_TLV("MIC Boost", ES8316_ADC_D2SEPGA_REG24,
+		0, 1, 0, mic_bst_tlv),
+	/* 0-+24dB Lineinput PGA Control */	
+	SOC_SINGLE_TLV("Input PGA", ES8316_ADC_PGAGAIN_REG23,
+		4, 8, 0, linin_pga_tlv),
+
+	/* ADC Digital  Control */
+	SOC_SINGLE_TLV("ADC Capture Volume", ES8316_ADC_VOLUME_REG27, 
+	  0, 0xC0, 1, adc_vol_tlv),
+	SOC_SINGLE("ADC Soft Ramp", ES8316_ADC_MUTE_REG26, 4, 1, 0),
+  	SOC_ENUM("Capture Polarity", adcpol),	
+	SOC_SINGLE("ADC Double FS Mode", ES8316_ADC_DMIC_REG25, 4, 1, 0),
+		/* ADC ALC  Control */	
+  	SOC_SINGLE("ALC Capture Target Volume", ES8316_ADC_ALC3_REG2B, 4, 10, 0),
+  	SOC_SINGLE("ALC Capture Max PGA", ES8316_ADC_ALC1_REG29, 0, 28, 0), 
+  	SOC_SINGLE("ALC Capture Min PGA", ES8316_ADC_ALC2_REG2A, 0, 28, 0),
+  	SOC_ENUM("ALC Capture Function", alc_func),
+  	SOC_SINGLE("ALC Capture Hold Time", ES8316_ADC_ALC3_REG2B, 0, 10, 0),
+  	SOC_SINGLE("ALC Capture Decay Time", ES8316_ADC_ALC4_REG2C, 4, 10, 0),
+  	SOC_SINGLE("ALC Capture Attack Time", ES8316_ADC_ALC4_REG2C, 0, 10, 0),
+  	SOC_SINGLE("ALC Capture NG Threshold", ES8316_ADC_ALC6_REG2E, 0, 31, 0),
+  	SOC_ENUM("ALC Capture NG Type", ng_type),
+  	SOC_SINGLE("ALC Capture NG Switch", ES8316_ADC_ALC6_REG2E, 5, 1, 0),
+};
+
+/* Analog Input MUX */
+static const char * const es8316_analog_in_txt[] = {
+		"lin1-rin1",
+		"lin2-rin2",
+		"lin1-rin1 with 20db Boost",
+		"lin2-rin2 with 20db Boost"
+		};
+static const unsigned int es8316_analog_in_values[] = {
+		0,/*1,*/
+		1,
+		2,
+		3
+		};		
+static const struct soc_enum es8316_analog_input_enum =
+        SOC_VALUE_ENUM_SINGLE(ES8316_ADC_PDN_LINSEL_REG22, 4, 3,
+                              ARRAY_SIZE(es8316_analog_in_txt),
+                               es8316_analog_in_txt,
+                               es8316_analog_in_values);
+static const struct snd_kcontrol_new es8316_analog_in_mux_controls =
+         SOC_DAPM_ENUM("Route", es8316_analog_input_enum);
+
+/* Dmic MUX */
+static const char * const es8316_dmic_txt[] = {
+		"dmic disable",
+		"dmic data at high level",
+		"dmic data at low level",
+		};
+static const unsigned int es8316_dmic_values[] = {
+		0,/*1,*/
+		1,
+		2
+		};		
+static const struct soc_enum es8316_dmic_src_enum =
+        SOC_VALUE_ENUM_SINGLE(ES8316_ADC_DMIC_REG25, 0, 3,
+                              ARRAY_SIZE(es8316_dmic_txt),
+                               es8316_dmic_txt,
+                               es8316_dmic_values);
+static const struct snd_kcontrol_new es8316_dmic_src_controls =
+         SOC_DAPM_ENUM("Route", es8316_dmic_src_enum);
+         
+/* hp mixer mux */
+static const char *es8316_hpmux_texts[] = {
+	"lin1-rin1",
+	"lin2-rin2",
+	"lin-rin with Boost",
+	"lin-rin with Boost and PGA"
+	};
+
+static const unsigned int es8316_hpmux_values[] = {
+	0, 1, 2, 3};
+
+static const struct soc_enum es8316_left_hpmux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8316_HPMIX_SEL_REG13, 4, 7,
+			      ARRAY_SIZE(es8316_hpmux_texts),
+			      es8316_hpmux_texts,
+			      es8316_hpmux_values);
+static const struct snd_kcontrol_new es8316_left_hpmux_controls =
+	SOC_DAPM_ENUM("Route", es8316_left_hpmux_enum);
+
+static const struct soc_enum es8316_right_hpmux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8316_HPMIX_SEL_REG13, 0, 7,
+			      ARRAY_SIZE(es8316_hpmux_texts),
+			      es8316_hpmux_texts,
+			      es8316_hpmux_values);
+static const struct snd_kcontrol_new es8316_right_hpmux_controls =
+	SOC_DAPM_ENUM("Route", es8316_right_hpmux_enum);
+
+/* headphone Output Mixer */
+static const struct snd_kcontrol_new es8316_out_left_mix[] = {
+	SOC_DAPM_SINGLE("LLIN Switch", ES8316_HPMIX_SWITCH_REG14,
+			6, 1, 0),
+	SOC_DAPM_SINGLE("Left DAC Switch", ES8316_HPMIX_SWITCH_REG14,
+			7, 1, 0),
+};
+static const struct snd_kcontrol_new es8316_out_right_mix[] = {
+	SOC_DAPM_SINGLE("RLIN Switch", ES8316_HPMIX_SWITCH_REG14,
+			2, 1, 0),
+	SOC_DAPM_SINGLE("Right DAC Switch", ES8316_HPMIX_SWITCH_REG14,
+			3, 1, 0),
+};
+
+/* DAC data source mux */
+static const char *es8316_dacsrc_texts[] = {
+	"LDATA TO LDAC, RDATA TO RDAC", 
+	"LDATA TO LDAC, LDATA TO RDAC", 
+	"RDATA TO LDAC, RDATA TO RDAC", 
+	"RDATA TO LDAC, LDATA TO RDAC", 
+  };
+
+static const unsigned int es8316_dacsrc_values[] = {
+	0, 1, 2, 3};
+
+static const struct soc_enum es8316_dacsrc_mux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8316_DAC_SET1_REG30, 6, 4,
+			      ARRAY_SIZE(es8316_dacsrc_texts),
+			      es8316_dacsrc_texts,
+			      es8316_dacsrc_values);
+static const struct snd_kcontrol_new es8316_dacsrc_mux_controls =
+	SOC_DAPM_ENUM("Route", es8316_dacsrc_mux_enum);
+
+
+static const struct snd_soc_dapm_widget es8316_dapm_widgets[] = {
+	/* Input Lines */
+	SND_SOC_DAPM_INPUT("DMIC"),
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_INPUT("MIC2"),	
+//	SND_SOC_DAPM_MICBIAS("micbias", ES8316_SYS_PDN_REG0D,
+//			5, 1),
+			
+	SND_SOC_DAPM_MICBIAS("micbias", SND_SOC_NOPM,
+			0, 0),
+  	/* Input MUX */
+	SND_SOC_DAPM_MUX("Differential Mux", SND_SOC_NOPM, 0, 0,
+		&es8316_analog_in_mux_controls),
+	SND_SOC_DAPM_PGA("Line input PGA", SND_SOC_NOPM,
+		0, 0, NULL, 0),
+
+	/* ADCs */
+	//SND_SOC_DAPM_ADC("Mono ADC", NULL, ES8316_ADC_PDN_LINSEL_REG22, 6, 0),
+	SND_SOC_DAPM_ADC("Mono ADC", NULL, SND_SOC_NOPM, 0, 0),
+
+ 	 /* Dmic MUX */
+	SND_SOC_DAPM_MUX("Digital Mic Mux", SND_SOC_NOPM, 0, 0,
+		&es8316_dmic_src_controls),
+
+	/* Digital Interface */
+	SND_SOC_DAPM_AIF_OUT("I2S OUT", "I2S1 Capture",  1,
+			SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("I2S IN", "I2S1 Playback", 0,
+			SND_SOC_NOPM, 0, 0),
+
+	 /*  DACs DATA SRC MUX */
+	SND_SOC_DAPM_MUX("DAC SRC Mux", SND_SOC_NOPM, 0, 0,
+		&es8316_dacsrc_mux_controls),	
+ 	/*  DACs  */
+        SND_SOC_DAPM_DAC("Right DAC", NULL, SND_SOC_NOPM, 0, 0),
+
+	//SND_SOC_DAPM_DAC("Left DAC", NULL, ES8316_DAC_PDN_REG2F, 4, 0),
+        SND_SOC_DAPM_DAC("Left DAC", NULL, SND_SOC_NOPM, 0, 0),
+
+	/* Headphone Output Side */
+	/* hpmux for hp mixer */	
+	SND_SOC_DAPM_MUX("Left Hp mux", SND_SOC_NOPM, 0, 0, 
+	   &es8316_left_hpmux_controls),
+	SND_SOC_DAPM_MUX("Right Hp mux", SND_SOC_NOPM, 0, 0,
+	   &es8316_right_hpmux_controls),
+	/* Output mixer  */
+//	SND_SOC_DAPM_MIXER("Left Hp mixer", ES8316_HPMIX_PDN_REG15, 
+//	   4, 1, &es8316_out_left_mix[0], ARRAY_SIZE(es8316_out_left_mix)),
+//	SND_SOC_DAPM_MIXER("Right Hp mixer", ES8316_HPMIX_PDN_REG15, 
+//	   0, 1, &es8316_out_right_mix[0], ARRAY_SIZE(es8316_out_right_mix)),
+	SND_SOC_DAPM_MIXER("Left Hp mixer", SND_SOC_NOPM, 
+	   4, 1, &es8316_out_left_mix[0], ARRAY_SIZE(es8316_out_left_mix)),
+	SND_SOC_DAPM_MIXER("Right Hp mixer", SND_SOC_NOPM, 
+	   0, 1, &es8316_out_right_mix[0], ARRAY_SIZE(es8316_out_right_mix)),
+
+
+	/* Ouput charge pump */
+
+        SND_SOC_DAPM_PGA("HPCP L", 0x17,
+                 6, 0, NULL, 0),
+         SND_SOC_DAPM_PGA("HPCP R", 0x17,
+                 2, 0, NULL, 0),
+ 
+         /* Ouput Driver */
+         SND_SOC_DAPM_PGA("HPVOL L", 0x17,
+                 5, 0, NULL, 0),
+         SND_SOC_DAPM_PGA("HPVOL R", 0x17,
+                 1, 0, NULL, 0),
+
+		
+	/* Output Lines */
+	SND_SOC_DAPM_OUTPUT("HPOL"),
+	SND_SOC_DAPM_OUTPUT("HPOR"),
+};
+
+static const struct snd_soc_dapm_route es8316_dapm_routes[] = {
+  	 /*
+  	 * record route map
+  	 */
+	{"MIC1", NULL, "micbias"},
+	{"MIC2", NULL, "micbias"},
+	{"DMIC", NULL, "micbias"},
+
+	{"Differential Mux", "lin1-rin1", "MIC1"},
+	{"Differential Mux", "lin2-rin2", "MIC2"},
+	{"Line input PGA", NULL, "Differential Mux"},
+
+	{"Mono ADC", NULL, "Line input PGA"},
+	
+	{"Digital Mic Mux", "dmic disable", "Mono ADC"},
+	{"Digital Mic Mux", "dmic data at high level", "DMIC"},
+  	{"Digital Mic Mux", "dmic data at low level", "DMIC"},
+  
+ 	{"I2S OUT", NULL, "Digital Mic Mux"},
+	 /*
+  	 * playback route map
+   	*/
+ 	{"DAC SRC Mux", "LDATA TO LDAC, RDATA TO RDAC", "I2S IN"},
+  	{"DAC SRC Mux", "LDATA TO LDAC, LDATA TO RDAC", "I2S IN"},
+ 	{"DAC SRC Mux", "RDATA TO LDAC, RDATA TO RDAC", "I2S IN"},
+ 	{"DAC SRC Mux", "RDATA TO LDAC, LDATA TO RDAC", "I2S IN"},
+
+	{"Left DAC", NULL, "DAC SRC Mux"},
+	{"Right DAC", NULL, "DAC SRC Mux"},
+   
+  
+  	{"Left Hp mux", "lin1-rin1", "MIC1"},
+  	{"Left Hp mux", "lin2-rin2", "MIC2"},
+  	{"Left Hp mux", "lin-rin with Boost", "Differential Mux"},
+  	{"Left Hp mux", "lin-rin with Boost and PGA", "Line input PGA"},
+  
+  	{"Right Hp mux", "lin1-rin1", "MIC1"},
+  	{"Right Hp mux", "lin2-rin2", "MIC2"},
+  	{"Right Hp mux", "lin-rin with Boost", "Differential Mux"},
+  	{"Right Hp mux", "lin-rin with Boost and PGA", "Line input PGA"},
+
+	{"Left Hp mixer", "LLIN Switch", "Left Hp mux"},
+	{"Left Hp mixer", "Left DAC Switch", "Left DAC"},
+	
+	{"Right Hp mixer", "RLIN Switch", "Right Hp mux"},
+	{"Right Hp mixer", "Right DAC Switch", "Right DAC"},
+
+	{"HPCP L", NULL, "Left Hp mixer"},
+	{"HPCP R", NULL, "Right Hp mixer"},
+
+	{"HPVOL L", NULL, "HPCP L"},
+	{"HPVOL R", NULL, "HPCP R"},
+	
+	{"HPOL", NULL, "HPVOL L"},
+	{"HPOR", NULL, "HPVOL R"},
+};
+
+struct _coeff_div {
+	u32 mclk;       //mclk frequency
+	u32 rate;       //sample rate
+	u8 div;         //adcclk and dacclk divider
+	u8 lrck_h;      //adclrck divider and daclrck divider
+	u8 lrck_l;
+	u8 sr;          //sclk divider
+	u8 osr;         //adc osr
+};
+
+
+/* codec hifi mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 8k */
+	{12288000, 8000 , 6 , 0x06, 0x00, 21, 32},
+	{11289600, 8000 , 6 , 0x05, 0x83, 20, 29},
+	{18432000, 8000 , 9 , 0x09, 0x00, 27, 32},
+	{16934400, 8000 , 8 , 0x08, 0x44, 25, 33},
+	{12000000, 8000 , 7 , 0x05, 0xdc, 21, 25},
+	{19200000, 8000 , 12, 0x09, 0x60, 27, 25},
+
+	/* 11.025k */
+	{11289600, 11025, 4 , 0x04, 0x00, 16, 32},
+	{16934400, 11025, 6 , 0x06, 0x00, 21, 32},
+	{12000000, 11025, 4 , 0x04, 0x40, 17, 34},
+
+	/* 16k */
+	{12288000, 16000, 3 , 0x03, 0x00, 12, 32},
+	{18432000, 16000, 5 , 0x04, 0x80, 18, 25},
+	{12000000, 16000, 3 , 0x02, 0xee, 12, 31},
+	{19200000, 16000, 6 , 0x04, 0xb0, 18, 25},
+
+	/* 22.05k */
+	{11289600, 22050, 2 , 0x02, 0x00, 8 , 32},
+	{16934400, 22050, 3 , 0x03, 0x00, 12, 32},
+	{12000000, 22050, 2 , 0x02, 0x20, 8 , 34},
+
+	/* 32k */
+	{12288000, 32000, 1 , 0x01, 0x80, 6 , 48},
+	{18432000, 32000, 2 , 0x02, 0x40, 9 , 32},
+	{12000000, 32000, 1 , 0x01, 0x77, 6 , 31},
+	{19200000, 32000, 3 , 0x02, 0x58, 10, 25},
+
+	/* 44.1k */
+	{11289600, 44100, 1 , 0x01, 0x00, 4 , 32},
+	{16934400, 44100, 1 , 0x01, 0x80, 6 , 32},
+	{12000000, 44100, 1 , 0x01, 0x10, 4 , 34},
+
+	/* 48k */
+	{12288000, 48000, 1 , 0x01, 0x00, 4 , 32},
+	{18432000, 48000, 1 , 0x01, 0x80, 6 , 32},
+	{12000000, 48000, 1 , 0x00, 0xfa, 4 , 31},
+	{19200000, 48000, 2 , 0x01, 0x90, 6, 25},
+
+	/* 88.2k */
+	{11289600, 88200, 1 , 0x00, 0x80, 2 , 32},
+	{16934400, 88200, 1 , 0x00, 0xc0, 3 , 48},
+	{12000000, 88200, 1 , 0x00, 0x88, 2 , 34},
+
+	/* 96k */
+	{12288000, 96000, 1 , 0x00, 0x80, 2 , 32},
+	{18432000, 96000, 1 , 0x00, 0xc0, 3 , 48},
+	{12000000, 96000, 1 , 0x00, 0x7d, 1 , 31},
+	{19200000, 96000, 1 , 0x00, 0xc8, 3 , 25},	
+};
+static inline int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+/* The set of rates we can generate from the above for each SYSCLK */
+
+static unsigned int rates_12288[] = {
+	8000, 12000, 16000, 24000, 24000, 32000, 48000, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_12288 = {
+	.count	= ARRAY_SIZE(rates_12288),
+	.list	= rates_12288,
+};
+
+static unsigned int rates_112896[] = {
+	8000, 11025, 22050, 44100,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_112896 = {
+	.count	= ARRAY_SIZE(rates_112896),
+	.list	= rates_112896,
+};
+
+static unsigned int rates_12[] = {
+	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,
+	48000, 88235, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_12 = {
+	.count	= ARRAY_SIZE(rates_12),
+	.list	= rates_12,
+};
+
+/*
+ * Note that this should be called from init rather than from hw_params.
+ */
+static int es8316_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct es8316_priv *es8316 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("Enter::%s----%d, freq:%u\n",__FUNCTION__,__LINE__, freq);
+		
+	switch (freq) {
+	case 11289600:
+	case 18432000:
+	case 22579200:
+	case 36864000:
+		es8316->sysclk_constraints = &constraints_112896;
+		es8316->sysclk = freq;
+		return 0;
+
+	case 12288000:
+	case 19200000:
+	case 16934400:
+	case 24576000:
+	case 33868800:
+		es8316->sysclk_constraints = &constraints_12288;
+		es8316->sysclk = freq;
+		return 0;
+
+	case 12000000:
+	case 24000000:
+		es8316->sysclk_constraints = &constraints_12;
+		es8316->sysclk = freq;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int es8316_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+  struct snd_soc_codec *codec = codec_dai->codec;
+    u8 iface = 0;
+    u8 adciface = 0;
+    u8 daciface = 0;
+
+    alsa_dbg("%s----%d, fmt[%02x]\n",__FUNCTION__,__LINE__,fmt);
+
+    iface    = snd_soc_read(codec, ES8316_IFACE);
+    adciface = snd_soc_read(codec, ES8316_ADC_IFACE);
+    daciface = snd_soc_read(codec, ES8316_DAC_IFACE);
+
+    /* set master/slave audio interface */
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+        case SND_SOC_DAIFMT_CBM_CFM:    // MASTER MODE
+        	  alsa_dbg("es8316 in master mode");
+            iface |= 0x80;
+            break;
+        case SND_SOC_DAIFMT_CBS_CFS:    // SLAVE MODE
+        	  alsa_dbg("es8316 in slave mode");
+            iface &= 0x7F;
+            break;
+        default:
+            return -EINVAL;
+    }
+
+
+    /* interface format */
+
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+        case SND_SOC_DAIFMT_I2S:
+            adciface &= 0xFC;                   
+            daciface &= 0xFC;
+            break;
+        case SND_SOC_DAIFMT_RIGHT_J:
+            return -EINVAL;
+        case SND_SOC_DAIFMT_LEFT_J:
+            adciface &= 0xFC;                   
+            daciface &= 0xFC;        
+            adciface |= 0x01;                   
+            daciface |= 0x01;             
+            break;
+        case SND_SOC_DAIFMT_DSP_A:
+            adciface &= 0xDC;                   
+            daciface &= 0xDC;        
+            adciface |= 0x03;                   
+            daciface |= 0x03;         
+            break;
+        case SND_SOC_DAIFMT_DSP_B:
+            adciface &= 0xDC;                   
+            daciface &= 0xDC;        
+            adciface |= 0x23;                   
+            daciface |= 0x23;        
+            break;
+        default:
+            return -EINVAL;
+    }
+
+
+    /* clock inversion */
+    switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+        case SND_SOC_DAIFMT_NB_NF:  
+            iface    &= 0xDF;
+            adciface &= 0xDF;                  
+            daciface &= 0xDF;			
+            break;
+        case SND_SOC_DAIFMT_IB_IF:
+            iface    |= 0x20;            
+            adciface |= 0x20;            
+            daciface |= 0x20;
+            break;
+        case SND_SOC_DAIFMT_IB_NF:
+            iface    |= 0x20;           
+            adciface &= 0xDF;           
+            daciface &= 0xDF;
+            break;
+        case SND_SOC_DAIFMT_NB_IF:
+            iface    &= 0xDF;
+            adciface |= 0x20;            
+            daciface |= 0x20;
+            break;
+        default:
+            return -EINVAL;
+    }
+    snd_soc_write(codec, ES8316_IFACE, iface);
+    snd_soc_write(codec, ES8316_ADC_IFACE, adciface);
+    snd_soc_write(codec, ES8316_DAC_IFACE, daciface);
+    return 0;
+}
+static int es8316_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{ 
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct es8316_priv *es8316 = snd_soc_codec_get_drvdata(codec);
+
+	int retv;
+	
+
+	u16 osrate  =  snd_soc_read(codec, ES8316_CLKMGR_ADCOSR_REG03) & 0xc0; 
+	u16 mclkdiv = snd_soc_read(codec, ES8316_CLKMGR_CLKSW_REG01) & 0x7f;
+	u16 srate = snd_soc_read(codec, ES8316_SDP_MS_BCKDIV_REG09) & 0xE0;
+	u16 adciface = snd_soc_read(codec, ES8316_SDP_ADCFMT_REG0A) & 0xE3;
+	u16 daciface = snd_soc_read(codec, ES8316_SDP_DACFMT_REG0B) & 0xE3;
+	u16 adcdiv   = snd_soc_read(codec, ES8316_CLKMGR_ADCDIV1_REG04); 
+	u16 adclrckdiv_l = snd_soc_read(codec, ES8316_CLKMGR_ADCDIV2_REG05) & 0x00; 
+	u16 dacdiv   = snd_soc_read(codec, ES8316_CLKMGR_DACDIV1_REG06);
+ 	u16 daclrckdiv_l = snd_soc_read(codec, ES8316_CLKMGR_DACDIV2_REG07) & 0x00;
+	int coeff;
+	u16 adclrckdiv_h = adcdiv & 0xf0;
+	u16 daclrckdiv_h = dacdiv & 0xf0;	
+ 	adcdiv &= 0x0f;
+ 	dacdiv &= 0x0f;
+
+	DBG("Enter::%s----%d  es8316->sysclk=%d\n",__FUNCTION__,__LINE__,es8316->sysclk);
+	/* The set of sample rates that can be supported depends on the
+	 * MCLK supplied to the CODEC - enforce this.
+	 */
+	if (!es8316->sysclk) {
+		dev_err(codec->dev,
+			"No MCLK configured, call set_sysclk() on init\n");
+		return -EINVAL;
+	}
+
+	snd_pcm_hw_constraint_list(substream->runtime, 0,
+				   SNDRV_PCM_HW_PARAM_RATE,
+				   es8316->sysclk_constraints);
+
+
+	coeff = get_coeff(es8316->sysclk, params_rate(params));
+	if (coeff < 0) {
+		coeff = get_coeff(es8316->sysclk / 2, params_rate(params));
+		mclkdiv |= 0x80;
+	}
+	if (coeff < 0) {
+		dev_err(codec->dev,
+			"Unable to configure sample rate %dHz with %dHz MCLK\n",
+			params_rate(params), es8316->sysclk);
+		return coeff;
+	}
+
+	/* bit size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		adciface |= 0x000C;
+		daciface |= 0x000C;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		adciface |= 0x0004;
+		daciface |= 0x0004;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		adciface |= 0x0010;
+		daciface |= 0x0010;
+		break;
+	}
+
+	/* set iface & srate*/
+	snd_soc_update_bits(codec,ES8316_SDP_DACFMT_REG0B, 0xe3, daciface);
+	snd_soc_update_bits(codec, ES8316_SDP_ADCFMT_REG0A, 0xe3, adciface);
+  //snd_soc_update_bits(codec, ES8316_CLKMGR_CLKSW_REG01, 0x80, mclkdiv);
+	if (coeff >= 0) {
+		osrate = coeff_div[coeff].osr;
+		osrate &= 0x3f;
+		
+		srate |= coeff_div[coeff].sr;
+		srate &= 0x1f;
+	
+		adcdiv |= (coeff_div[coeff].div << 4);
+		adclrckdiv_h |= coeff_div[coeff].lrck_h;
+		adcdiv &= 0xf0;
+		adclrckdiv_h &= 0x0f;
+		adcdiv |= adclrckdiv_h;
+		adclrckdiv_l = coeff_div[coeff].lrck_l;
+
+		dacdiv |= (coeff_div[coeff].div << 4);
+		daclrckdiv_h |= coeff_div[coeff].lrck_h;
+		dacdiv &= 0xf0;
+		daclrckdiv_h &= 0x0f;
+		dacdiv |= daclrckdiv_h;
+		daclrckdiv_l = coeff_div[coeff].lrck_l;
+		snd_soc_update_bits(codec, ES8316_CLKMGR_ADCOSR_REG03, 0x3f, osrate);
+		snd_soc_update_bits(codec, ES8316_SDP_MS_BCKDIV_REG09, 0x1f, srate);
+		snd_soc_update_bits(codec, ES8316_CLKMGR_ADCDIV1_REG04, 0xff, adcdiv);
+		snd_soc_update_bits(codec, ES8316_CLKMGR_ADCDIV2_REG05, 0xff, adclrckdiv_l);
+		snd_soc_update_bits(codec, ES8316_CLKMGR_DACDIV1_REG06, 0xff, dacdiv);
+		snd_soc_update_bits(codec, ES8316_CLKMGR_DACDIV2_REG07, 0xff, daclrckdiv_l);
+    /* 
+      * must do codec power on initialization at here becauses MCLK and I2S CLK always startup at here
+      */
+	retv = snd_soc_read(codec, 0x14) ; 
+	pr_err("%s:%d,   retv=%x \n", __func__, __LINE__, retv);
+		if (retv == 0) { 
+			es8316_init_regs(codec);
+
+			snd_soc_write(codec, 0x22,	0x20);  //CHARGE PUMP DIVIDER
+     		snd_soc_write(codec, 0x2F,	0x00);
+			snd_soc_write(codec, 0X18, 0x00);
+			snd_soc_write(codec, 0X1b, 0x30);
+			snd_soc_write(codec, 0X1a, 0x10);
+			snd_soc_write(codec, 0X19, 0x02);
+			snd_soc_write(codec, 0X14, 0x88);
+			snd_soc_write(codec, 0X15, 0x88);
+			snd_soc_write(codec, 0X16, 0xbb);      
+    		snd_soc_write(codec, 0x00, 0xC0);  //CHARGE PUMP DIVIDER
+     		msleep(50);
+     	    snd_soc_write(codec, 0X17, 0x66);
+			if(es8316->dmic_amic ==  dmic_used){
+				snd_soc_write(codec, ES8316_GPIO_SEL_REG4D, 0x02);  //set gpio2 to DMIC CLK
+			} else {
+				snd_soc_write(codec, ES8316_GPIO_SEL_REG4D, 0x00);  //set gpio2 to GM SHORT
+			}
+			snd_soc_write(codec, ES8316_GPIO_DEBUNCE_INT_REG4E, 0xf3);  //maximum debance time, enable interrupt, low active
+			es8316_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+			es8316_init_reg = 1;
+		}
+	}
+	snd_soc_write(codec, ES8316_DAC_SET1_REG30, 0x00);
+	retv = snd_soc_read(codec, ES8316_GPIO_FLAG);
+	return 0;
+}
+
+static int es8316_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	dev_dbg(codec->dev, "%s %d\n", __func__, mute);
+	if (mute) {		
+		snd_soc_write(codec, ES8316_DAC_SET1_REG30, 0x20);
+	} else {
+		//if (dai->playback_active) {
+			snd_soc_write(codec, ES8316_DAC_SET1_REG30, 0x00);
+		//		}
+			}
+	return 0;
+}
+
+static int es8316_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{        
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		dev_dbg(codec->dev, "%s on\n", __func__);
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		dev_dbg(codec->dev, "%s prepare\n", __func__);
+		if(es8316_init_reg>0)
+			{
+				snd_soc_write(codec, ES8316_CLKMGR_CLKSW_REG01, 0x7F);
+				snd_soc_write(codec, ES8316_SYS_PDN_REG0D, 0x00);
+				snd_soc_write(codec, ES8316_DAC_PDN_REG2F, 0x00);
+				snd_soc_write(codec, ES8316_HPMIX_SWITCH_REG14, 0x88);
+				snd_soc_write(codec, ES8316_HPMIX_PDN_REG15, 0x88);		
+				snd_soc_write(codec, ES8316_HPMIX_VOL_REG16, 0xBB);
+				snd_soc_write(codec, ES8316_CPHP_PDN2_REG1A, 0x10);		
+				snd_soc_write(codec, ES8316_CPHP_LDOCTL_REG1B, 0x30);
+				snd_soc_write(codec, ES8316_CPHP_PDN1_REG19, 0x02);
+				snd_soc_write(codec, ES8316_CPHP_ICAL_VOL_REG18, 0x00);
+				snd_soc_write(codec, ES8316_RESET_REG00, 0xC0);	
+				snd_soc_write(codec, ES8316_CPHP_OUTEN_REG17, 0x66);
+			}
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		dev_dbg(codec->dev, "%s standby\n", __func__);
+		if(es8316_init_reg>0)   // if codec intialized, 
+			{
+				snd_soc_write(codec, ES8316_CLKMGR_CLKSW_REG01, 0x7F);
+				snd_soc_write(codec, ES8316_SYS_PDN_REG0D, 0x00);
+				snd_soc_write(codec, ES8316_DAC_PDN_REG2F, 0x00);
+				snd_soc_write(codec, ES8316_HPMIX_SWITCH_REG14, 0x88);
+				snd_soc_write(codec, ES8316_HPMIX_PDN_REG15, 0x88);		
+				snd_soc_write(codec, ES8316_HPMIX_VOL_REG16, 0xBB);
+				snd_soc_write(codec, ES8316_CPHP_PDN2_REG1A, 0x10);		
+				snd_soc_write(codec, ES8316_CPHP_LDOCTL_REG1B, 0x30);
+				snd_soc_write(codec, ES8316_CPHP_PDN1_REG19, 0x02);
+				snd_soc_write(codec, ES8316_CPHP_ICAL_VOL_REG18, 0x00);
+				snd_soc_write(codec, ES8316_RESET_REG00, 0xC0);	
+				snd_soc_write(codec, ES8316_CPHP_OUTEN_REG17, 0x66);	
+			}
+		break;
+	case SND_SOC_BIAS_OFF:
+		dev_dbg(codec->dev, "%s off\n", __func__);
+		if(es8316_init_reg>0){
+		snd_soc_write(codec, ES8316_CPHP_OUTEN_REG17, 0x00);
+		snd_soc_write(codec, ES8316_CPHP_LDOCTL_REG1B, 0x03);
+		snd_soc_write(codec, ES8316_CPHP_PDN2_REG1A, 0x22);
+		snd_soc_write(codec, ES8316_CPHP_PDN1_REG19, 0x06);
+		snd_soc_write(codec, ES8316_HPMIX_SWITCH_REG14, 0x00);
+		snd_soc_write(codec, ES8316_HPMIX_PDN_REG15, 0x33);
+		snd_soc_write(codec, ES8316_HPMIX_VOL_REG16, 0x00);
+		snd_soc_write(codec, ES8316_ADC_PDN_LINSEL_REG22, 0xC0);
+		snd_soc_write(codec, ES8316_DAC_PDN_REG2F, 0x11);
+		snd_soc_write(codec, ES8316_SYS_PDN_REG0D, 0x3F);
+		snd_soc_write(codec, ES8316_CLKMGR_CLKSW_REG01, 0x03);
+		snd_soc_write(codec, ES8316_RESET_REG00, 0x7F);		
+	}
+		break;
+	}
+	codec->dapm.bias_level = level;
+	
+	return 0;
+}
+
+#define es8316_RATES SNDRV_PCM_RATE_8000_96000
+
+#define es8316_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops es8316_ops = {
+	//.startup = es8316_pcm_startup,
+	.hw_params = es8316_pcm_hw_params,
+	.set_fmt = es8316_set_dai_fmt,
+	.set_sysclk = es8316_set_dai_sysclk,
+	.digital_mute = es8316_mute,
+};
+
+static struct snd_soc_dai_driver es8316_dai = {
+	.name = "ES8316 HiFi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = es8316_RATES,
+		.formats = es8316_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = es8316_RATES,
+		.formats = es8316_FORMATS,
+	 },
+	.ops = &es8316_ops,
+	.symmetric_rates = 1,
+};
+
+
+static int es8316_init_regs(struct snd_soc_codec *codec)
+{
+	dev_dbg(codec->dev, "%s\n", __func__);
+	snd_soc_write(codec,0x01, 0x7f); //setup adc volume
+   	snd_soc_write(codec,0x02, 0x00);   //disable DAC ds and notch mode
+	snd_soc_write(codec, 0x03,0x19);  //CHARGE PUMP DIVIDER
+   	snd_soc_write(codec, 0x04,0x21);
+   	snd_soc_write(codec, 0x05,0x90);
+   	snd_soc_write(codec, 0x06,0x21);
+    snd_soc_write(codec, 0x07,0x90);
+	snd_soc_write(codec, 0x08,0x00);
+   	snd_soc_write(codec, 0x09,0x01);
+	
+	snd_soc_write(codec, 0x0A, 0x0C);//ADC FORMAT , i2s-16bit, 
+	snd_soc_write(codec, 0x0B, 0x0C);//DAC FORMAT, i2s-16bit
+	snd_soc_write(codec, 0x0D,0x00);  //CLK CASE
+	snd_soc_write(codec, 0x22,0x20);  //CHARGE PUMP DIVIDER
+    snd_soc_write(codec, 0x2F,0x00);
+    snd_soc_write(codec, 0x10,0x11);
+    snd_soc_write(codec, 0x12,0x28);
+    snd_soc_write(codec, 0x1C,0x0F);
+    snd_soc_write(codec, 0x1D,0x0C);
+	snd_soc_write(codec, 0x00,0xC0);  //CHARGE PUMP DIVIDER
+	msleep(50);
+	
+	snd_soc_write(codec, 0x23,0x10);  //CLK ON
+	snd_soc_write(codec, 0x24,0x01);  //VMID SEQUENCE
+	snd_soc_write(codec, 0x26,0x00);      //ADC,DAC VREF SET, micbias pup
+	snd_soc_write(codec, 0x27,0x00);  //CSM POWER UP
+	snd_soc_write(codec, 0x30, 0x10); //INPUT SELECT INPUT1:0X20,INPUT2:0X30, ain and adc power down
+	snd_soc_write(codec, 0x33, 0x00); //POWER UP DACPOWER
+	snd_soc_write(codec, 0x34, 0x00); //L,R MIXER SET
+	snd_soc_write(codec, 0x14,0x88);  //MIXER
+	snd_soc_write(codec, 0x15,0x88);  //MIXER
+	snd_soc_write(codec, 0x16,0xAA);  //MIXER
+	snd_soc_write(codec, 0X18,0x00);  //CHARGE PUMP 
+	snd_soc_write(codec, 0X31, 0x00); //CHARGE PUMP 	
+	snd_soc_write(codec, 0X29, 0xd2); //CHARGE PUMP 
+	snd_soc_write(codec, 0X2A, 0x08); //vmidlow = 10'b
+	snd_soc_write(codec, 0X2B,0xA0);  //HPOUT SET
+	
+	snd_soc_write(codec, 0X2C, 0x05);
+	snd_soc_write(codec, 0X2D, 0x06);
+	snd_soc_write(codec, 0X2E, 0x61);
+	/*alc set*/
+	snd_soc_write(codec, 0X4D, 0x00); 
+	snd_soc_write(codec, 0X4E, 0xF3); 
+	snd_soc_write(codec, 0X50, 0xA0); //adc ds mode, HPF enable
+	snd_soc_write(codec, 0X51, 0x00); //ALC ON,
+	snd_soc_write(codec, 0X52, 0x00);
+          
+	snd_soc_write(codec, 0X18, 0x00);
+	snd_soc_write(codec, 0X1b, 0x30);
+	snd_soc_write(codec, 0X1a, 0x10);
+	snd_soc_write(codec, 0X19, 0x02);
+	snd_soc_write(codec, 0X14, 0x88);
+	snd_soc_write(codec, 0X15, 0x88);
+	snd_soc_write(codec, 0X16, 0xbb);
+    snd_soc_write(codec, 0X17, 0x66);
+	return 0;
+}
+
+static int es8316_suspend(struct snd_soc_codec *codec)
+{
+	printk("SUSPEND\n");
+	// snd_soc_write(codec, ES8316_CPHP_ICAL_VOL_REG18, 0x33);
+	if(es8316_init_reg>0){ 
+		/*if Codec has been initialized before, then enter into suspend directly */
+	snd_soc_write(codec, ES8316_CPHP_OUTEN_REG17, 0x00);
+	snd_soc_write(codec, 0x2f, 0x11);
+	snd_soc_write(codec, ES8316_CPHP_LDOCTL_REG1B, 0x03);
+	snd_soc_write(codec, ES8316_CPHP_PDN2_REG1A, 0x22);
+	snd_soc_write(codec, ES8316_CPHP_PDN1_REG19, 0x06);
+	snd_soc_write(codec, ES8316_HPMIX_SWITCH_REG14, 0x00);
+	snd_soc_write(codec, ES8316_HPMIX_PDN_REG15, 0x33);
+	snd_soc_write(codec, ES8316_HPMIX_VOL_REG16, 0x00);
+	snd_soc_update_bits(codec, ES8316_ADC_PDN_LINSEL_REG22, 0xC0, 0xc0);		
+	snd_soc_write(codec, ES8316_CLKMGR_CLKSW_REG01, 0x03);		
+ } else {
+		/*if Codec  has not been initialized before,  enter into normal mode firstly, then enter into suspend at last */
+		snd_soc_update_bits(codec, ES8316_ADC_PDN_LINSEL_REG22, 0xC0, 0x00);		
+		snd_soc_write(codec, 0x2F,	0x00);
+		snd_soc_write(codec, 0X18, 0x00);
+		snd_soc_write(codec, 0X1b, 0x30);
+		snd_soc_write(codec, 0X1a, 0x10);
+		snd_soc_write(codec, 0X19, 0x02);
+		snd_soc_write(codec, 0X14, 0x88);
+		snd_soc_write(codec, 0X15, 0x88);
+		snd_soc_write(codec, 0X16, 0xbb); 	 
+		snd_soc_write(codec, 0x00,0xC0);  //CHARGE PUMP DIVIDER
+		msleep(50);
+		snd_soc_write(codec, 0X17, 0x66);
+		msleep(50);			
+		snd_soc_write(codec, ES8316_CPHP_OUTEN_REG17, 0x00);
+		snd_soc_write(codec, 0x2f, 0x11);
+		snd_soc_write(codec, ES8316_CPHP_LDOCTL_REG1B, 0x03);
+		snd_soc_write(codec, ES8316_CPHP_PDN2_REG1A, 0x22);
+		snd_soc_write(codec, ES8316_CPHP_PDN1_REG19, 0x06);
+		snd_soc_write(codec, ES8316_HPMIX_SWITCH_REG14, 0x00);
+		snd_soc_write(codec, ES8316_HPMIX_PDN_REG15, 0x33);
+		snd_soc_write(codec, ES8316_HPMIX_VOL_REG16, 0x00);
+		snd_soc_update_bits(codec, ES8316_ADC_PDN_LINSEL_REG22, 0xC0, 0xc0);		
+		snd_soc_write(codec, ES8316_CLKMGR_CLKSW_REG01, 0x03);		
+		es8316_init_reg = 1;
+ 	}
+	return 0;
+}
+
+static int es8316_resume(struct snd_soc_codec *codec)
+{
+	if(es8316_init_reg>0)
+		{
+	snd_soc_write(codec, ES8316_CPHP_ICAL_VOL_REG18, 0x00);
+	snd_soc_write(codec, ES8316_CPHP_LDOCTL_REG1B, 0x30);		
+	snd_soc_write(codec, ES8316_CPHP_PDN2_REG1A, 0x10);
+	snd_soc_write(codec, ES8316_CPHP_PDN1_REG19, 0x02);
+	snd_soc_write(codec, ES8316_HPMIX_SWITCH_REG14, 0x88);
+	snd_soc_write(codec, ES8316_HPMIX_PDN_REG15, 0x88);
+	snd_soc_write(codec, ES8316_HPMIX_VOL_REG16, 0xbb);
+	snd_soc_update_bits(codec, ES8316_ADC_PDN_LINSEL_REG22, 0xc0, 0x00);
+	snd_soc_write(codec, ES8316_CLKMGR_CLKSW_REG01, 0x7f);
+	snd_soc_write(codec, 0x2f, 0x00);
+	snd_soc_write(codec, ES8316_CPHP_OUTEN_REG17, 0x66);
+}
+	return 0;
+}
+
+static int es8316_probe(struct snd_soc_codec *codec)
+{
+	int ret = 0,retv;
+	struct es8316_priv *es8316 = snd_soc_codec_get_drvdata(codec);
+ 	pr_debug("---%s--start--\n",__FUNCTION__);
+
+	printk("codec name is %s", codec->dev->init_name);
+	printk("codec driver name is %s", codec->dev->driver->name);
+
+#if 0
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_I2C);
+	if (ret < 0){
+		return ret;
+	}
+	if (ret < 0) {
+		dev_err(codec->dev,"fail to reset audio (%d)\n", ret);
+		goto err;
+	}
+#endif
+#if 0
+	retv = snd_soc_read(codec, ES8316_CLKMGR_ADCDIV2_REG05) ; 
+	pr_err("#######################################%s:%d,   retv=%x \n", __func__, __LINE__, retv);
+	if(retv == 0){
+#endif
+	codec->control_data = es8316->regmap;
+		retv = es8316_reset(codec); // UPDATED BY DAVID,15-3-5  
+		snd_soc_write(codec, 0x01, 0x7f); //setup adc volume
+   		snd_soc_write(codec, 0x02, 0x00);   //disable DAC ds and notch mode
+		snd_soc_write(codec, 0x03, 0x19);  //CHARGE PUMP DIVIDER
+    	snd_soc_write(codec, 0x04, 0x21);
+    	snd_soc_write(codec, 0x05, 0x90);
+   		snd_soc_write(codec, 0x06, 0x21);
+      	snd_soc_write(codec, 0x07, 0x90);
+		snd_soc_write(codec, 0x08, 0x00);
+    	snd_soc_write(codec, 0x09, 0x01);
+	
+		snd_soc_write(codec, 0x0A, 0x0C);//ADC FORMAT , i2s-16bit, 
+		snd_soc_write(codec, 0x0B, 0x0C);//DAC FORMAT, i2s-16bit
+		snd_soc_write(codec, 0x0D, 0x00);  //CLK CASE
+
+     	snd_soc_write(codec, 0x10, 0x11);
+      	snd_soc_write(codec, 0x12, 0x28);
+      	snd_soc_write(codec, 0x1C, 0x0F);
+      	snd_soc_write(codec, 0x1D, 0x0C);
+		msleep(50);
+	
+		snd_soc_write(codec, 0x23, 0x10);  //CLK ON
+		snd_soc_write(codec, 0x24, 0x01);  //VMID SEQUENCE
+		snd_soc_write(codec, 0x26, 0x00);      //ADC,DAC VREF SET, micbias pup
+		snd_soc_write(codec, 0x27, 0x00);  //CSM POWER UP
+		snd_soc_write(codec, 0x30, 0x10); //INPUT SELECT INPUT1:0X20,INPUT2:0X30, ain and adc power down
+		snd_soc_write(codec, 0x33, 0x00); //POWER UP DACPOWER
+		snd_soc_write(codec, 0x34, 0x00); //L,R MIXER SET
+		snd_soc_write(codec, 0X31, 0x00); //CHARGE PUMP 	
+		snd_soc_write(codec, 0X29, 0xD2); //CHARGE PUMP 
+		snd_soc_write(codec, 0X2A, 0x08); //vmidlow = 10'b
+		snd_soc_write(codec, 0X2B, 0xA0);  //HPOUT SET
+	
+		snd_soc_write(codec, 0X2C, 0x05);
+		snd_soc_write(codec, 0X2D, 0x06);
+		snd_soc_write(codec, 0X2E, 0x61);
+		/*alc set*/
+		snd_soc_write(codec, 0X4D, 0x00); 
+		snd_soc_write(codec, 0X4E, 0xF3); 
+		snd_soc_write(codec, 0X50, 0xA0); //adc ds mode, HPF enable
+		snd_soc_write(codec, 0X51, 0x00); //ALC ON,
+		snd_soc_write(codec, 0X52, 0x00);
+#if 0
+	 }
+#endif
+	codec->dapm.idle_bias_off = 0;
+#if defined(HS_IRQ)
+	det_initalize();
+#elif defined(HS_TIMER)
+	hsdet_init();
+#endif
+//err:	
+	return ret;
+}
+
+static int es8316_remove(struct snd_soc_codec *codec)
+{
+	es8316_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_es8316 = {
+	.probe =	es8316_probe,
+	.remove =	es8316_remove,
+	.suspend =	es8316_suspend,
+	.resume =	es8316_resume,
+	.set_bias_level = es8316_set_bias_level,	
+
+	.dapm_widgets = es8316_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(es8316_dapm_widgets),
+	.dapm_routes = es8316_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(es8316_dapm_routes),
+
+	.controls = es8316_snd_controls,
+	.num_controls = ARRAY_SIZE(es8316_snd_controls),
+};
+
+#if defined(CONFIG_SPI_MASTER)
+static int es8316_spi_probe(struct spi_device *spi)
+{
+	struct es8316_priv *es8316;
+	int ret;
+
+	es8316 = kzalloc(sizeof(struct es8316_priv), GFP_KERNEL);
+	if (es8316 == NULL)
+		return -ENOMEM;
+
+	spi_set_drvdata(spi, es8316);
+
+	ret = snd_soc_register_codec(&spi->dev,
+			&soc_codec_dev_es8316, &es8316_dai, 1);
+	if (ret < 0)
+		kfree(es8316);
+	return ret;
+}
+
+static int es8316_spi_remove(struct spi_device *spi)
+{
+	snd_soc_unregister_codec(&spi->dev);
+	kfree(spi_get_drvdata(spi));
+	return 0;
+}
+
+static struct spi_driver es8316_spi_driver = {
+	.driver = {
+		.name	= "es8316",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= es8316_spi_probe,
+	.remove		= es8316_spi_remove,
+};
+#endif /* CONFIG_SPI_MASTER */
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+
+static void es8316_i2c_shutdown(struct i2c_client *i2c)
+{
+	struct snd_soc_codec *codec;
+
+		if (!es8316_codec)
+		goto err;
+		codec = es8316_codec;
+		if(es8316_init_reg>0){
+		snd_soc_write(codec, ES8316_CPHP_ICAL_VOL_REG18, 0x33);
+		snd_soc_write(codec, ES8316_CPHP_OUTEN_REG17, 0x00);
+		snd_soc_write(codec, ES8316_CPHP_LDOCTL_REG1B, 0x03);
+		snd_soc_write(codec, ES8316_CPHP_PDN2_REG1A, 0x22);
+		snd_soc_write(codec, ES8316_CPHP_PDN1_REG19, 0x06);
+		snd_soc_write(codec, ES8316_HPMIX_SWITCH_REG14, 0x00);
+		snd_soc_write(codec, ES8316_HPMIX_PDN_REG15, 0x33);
+		snd_soc_write(codec, ES8316_HPMIX_VOL_REG16, 0x00);
+		snd_soc_write(codec, ES8316_ADC_PDN_LINSEL_REG22, 0xC0);
+		snd_soc_write(codec, ES8316_DAC_PDN_REG2F, 0x11);
+		snd_soc_write(codec, ES8316_SYS_PDN_REG0D, 0x3F);
+		snd_soc_write(codec, ES8316_CLKMGR_CLKSW_REG01, 0x03);
+		snd_soc_write(codec, ES8316_RESET_REG00, 0x7F);		
+	}
+		err:
+	return;
+}
+
+static struct regmap_config es8316_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = 84,
+	.reg_defaults = es8316_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(es8316_reg_defaults),
+	.volatile_reg = es8316_volatile,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int es8316_i2c_probe(struct i2c_client *i2c_client,
+				      const struct i2c_device_id *id)
+{
+	struct es8316_priv *es8316;
+
+	int ret = -1;
+ 	pr_debug("---%s---probe start\n",__FUNCTION__);
+
+	es8316 = kzalloc(sizeof(*es8316), GFP_KERNEL);
+	if (es8316 == NULL){
+		return -ENOMEM;
+		}
+	es8316->dmic_amic = amic_used;     //if internal mic is amic
+
+	i2c_set_clientdata(i2c_client, es8316);
+
+	es8316->regmap = devm_regmap_init_i2c(i2c_client, &es8316_regmap);
+	if (IS_ERR(es8316->regmap)) {
+		ret = PTR_ERR(es8316->regmap);
+		dev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);
+		return ret;
+	}
+
+	ret =  snd_soc_register_codec(&i2c_client->dev, &soc_codec_dev_es8316,
+	     &es8316_dai, 1);
+	if (ret < 0) {
+		kfree(es8316);
+		return ret;
+	}
+    
+ 	pr_debug("---%s---probe ok\n",__FUNCTION__);
+	return ret;
+}
+
+static  int es8316_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	kfree(i2c_get_clientdata(client));
+	return 0;
+}
+
+static const unsigned short normal_i2c[] = {0x11, I2C_CLIENT_END};
+static const struct i2c_device_id es8316_i2c_id[] = {
+	{"ESSX8316", 0},	
+	{" ", 0}
+};
+MODULE_DEVICE_TABLE(i2c, es8316_i2c_id);
+
+static struct i2c_driver es8316_i2c_driver = {
+	.driver = {
+		.name = "es8316",
+		.owner = THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(es8316_i2c_id),
+	},
+	.shutdown = es8316_i2c_shutdown,
+	.probe = es8316_i2c_probe,
+	.remove = es8316_i2c_remove,
+	.id_table = es8316_i2c_id,
+	.class 		= I2C_CLASS_HWMON,
+	.address_list = normal_i2c,
+};
+#endif
+
+static int __init es8316_init(void)
+{
+	pr_debug("--%s--start--\n",__FUNCTION__);
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	return i2c_add_driver(&es8316_i2c_driver);
+#endif
+#if defined(CONFIG_SPI_MASTER)
+	return spi_register_driver(&es8316_spi_driver);
+#endif
+}
+
+static void __exit es8316_exit(void)
+{
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	return i2c_del_driver(&es8316_i2c_driver);
+#endif
+#if defined(CONFIG_SPI_MASTER)
+	return spi_unregister_driver(&es8316_spi_driver);
+#endif
+}
+
+
+module_init(es8316_init);
+module_exit(es8316_exit);
+
+MODULE_DESCRIPTION("ASoC es8316 driver");
+MODULE_AUTHOR("Will <will@everset-semi.com>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/sound/soc/codecs/es8316.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/codecs/es8316.h	2017-11-21 20:13:12.450710527 +0800
@@ -0,0 +1,117 @@
+/*
+ * Copyright Everest Semiconductor Co.,Ltd
+ *
+ * Author: David Yang <yangxiaohua@everest-semi.com>
+ *
+ * Based on ES8323.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ES8316_H
+#define _ES8316_H
+
+/* ES8316 register space */
+/*
+* RESET Control
+*/
+#define ES8316_RESET_REG00             0x00
+/*
+* Clock Managerment
+*/
+#define ES8316_CLKMGR_CLKSW_REG01      0x01
+#define ES8316_CLKMGR_CLKSEL_REG02     0x02
+#define ES8316_CLKMGR_ADCOSR_REG03     0x03
+#define ES8316_CLKMGR_ADCDIV1_REG04    0x04
+#define ES8316_CLKMGR_ADCDIV2_REG05    0x05
+#define ES8316_CLKMGR_DACDIV1_REG06    0x06
+#define ES8316_CLKMGR_DACDIV2_REG07    0x07
+#define ES8316_CLKMGR_CPDIV_REG08      0x08
+/*
+* SDP Control
+*/
+#define ES8316_SDP_MS_BCKDIV_REG09     0x09
+#define ES8316_SDP_ADCFMT_REG0A        0x0a
+#define ES8316_SDP_DACFMT_REG0B        0x0b
+/*
+* System Control
+*/
+#define ES8316_SYS_VMIDSEL_REG0C       0x0c
+#define ES8316_SYS_PDN_REG0D           0x0d
+#define ES8316_SYS_LP1_REG0E           0x0e
+#define ES8316_SYS_LP2_REG0F           0x0f
+#define ES8316_SYS_VMIDLOW_REG10       0x10
+#define ES8316_SYS_VSEL_REG11          0x11
+#define ES8316_SYS_REF_REG12           0x12
+/*
+* HP Mixer
+*/
+#define ES8316_HPMIX_SEL_REG13         0x13
+#define ES8316_HPMIX_SWITCH_REG14      0x14
+#define ES8316_HPMIX_PDN_REG15         0x15
+#define ES8316_HPMIX_VOL_REG16         0x16
+/*
+* Charge Pump Headphone driver
+*/
+#define ES8316_CPHP_OUTEN_REG17        0x17
+#define ES8316_CPHP_ICAL_VOL_REG18     0x18
+#define ES8316_CPHP_PDN1_REG19         0x19
+#define ES8316_CPHP_PDN2_REG1A         0x1a
+#define ES8316_CPHP_LDOCTL_REG1B       0x1b
+/*
+* Calibration
+*/
+#define ES8316_CAL_TYPE_REG1C         0x1c
+#define ES8316_CAL_SET_REG1D          0x1d
+#define ES8316_CAL_HPLIV_REG1E        0x1e
+#define ES8316_CAL_HPRIV_REG1F        0x1f
+#define ES8316_CAL_HPLMV_REG20        0x20
+#define ES8316_CAL_HPRMV_REG21        0x21
+/*
+* ADC Control
+*/
+#define ES8316_ADC_PDN_LINSEL_REG22   0x22
+#define ES8316_ADC_PGAGAIN_REG23      0x23
+#define ES8316_ADC_D2SEPGA_REG24      0x24
+#define ES8316_ADC_DMIC_REG25         0x25
+#define ES8316_ADC_MUTE_REG26         0x26
+#define ES8316_ADC_VOLUME_REG27       0x27
+#define ES8316_ADC_ALC1_REG29         0x29
+#define ES8316_ADC_ALC2_REG2A         0x2a
+#define ES8316_ADC_ALC3_REG2B         0x2b
+#define ES8316_ADC_ALC4_REG2C         0x2c
+#define ES8316_ADC_ALC5_REG2D         0x2d
+#define ES8316_ADC_ALC6_REG2E         0x2e
+/*
+* DAC Control
+*/
+#define ES8316_DAC_PDN_REG2F          0x2f
+#define ES8316_DAC_SET1_REG30         0x30
+#define ES8316_DAC_SET2_REG31         0x31
+#define ES8316_DAC_SET3_REG32         0x32
+#define ES8316_DAC_VOLL_REG33         0x33
+#define ES8316_DAC_VOLR_REG34         0x34
+/*
+* GPIO
+*/
+#define ES8316_GPIO_SEL_REG4D         0x4D
+#define ES8316_GPIO_DEBUNCE_INT_REG4E 0x4E
+#define ES8316_GPIO_FLAG              0x4F
+/*
+* TEST MODE
+*/
+#define ES8316_TESTMODE_REG50         0x50
+#define ES8316_TEST1_REG51            0x51
+#define ES8316_TEST2_REG52            0x52
+#define ES8316_TEST3_REG53            0x53 
+
+#define ES8316_IFACE            ES8316_SDP_MS_BCKDIV_REG09
+#define ES8316_ADC_IFACE        ES8316_SDP_ADCFMT_REG0A
+#define ES8316_DAC_IFACE        ES8316_SDP_DACFMT_REG0B
+
+#define ES8316_REGNUM      84
+
+#endif
Index: linux-3.18.29/sound/soc/codecs/es8388s.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/codecs/es8388s.c	2017-11-21 20:13:12.450710527 +0800
@@ -0,0 +1,813 @@
+/*
+ * es8388s.c  --  ES8388s ALSA Soc Audio driver
+ *
+ * Copyright 2014 Ambarella Ltd.
+ *
+ * Author: Ken He <jianhe@ambarella.com>
+ *
+ * Based on es8388.c from Everest Semiconductor
+ *
+ * History:
+ *	2014/7/01 - [Ken He] Created file
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <linux/regmap.h>
+
+#include "es8388s.h"
+//#include "../sklsoundcard/es8388s.h"
+
+#define ES8388s_VERSION "v1.0"
+#define ES8388s_MAX_REGISTER  64
+/* codec private data */
+struct es8388s_priv {
+	struct regmap *regmap;
+	unsigned int sysclk;
+};
+
+/*
+ * es8388s register
+ */
+static struct reg_default  es8388s_reg_defaults[] = {
+	{ 0,  0x06 },
+	{ 1,  0x1c },
+	{ 2,  0xC3 },
+	{ 3,  0xFC },
+	{ 4,  0xC0 },
+	{ 5,  0x00 },
+	{ 6,  0x00 },
+	{ 7,  0x7C },
+	{ 8,  0x80 },
+	{ 9,  0x00 },
+	{ 10, 0x00 },
+	{ 11, 0x06 },
+	{ 12, 0x00 },
+	{ 13, 0x06 },
+	{ 14, 0x30 },
+	{ 15, 0x30 },
+	{ 16, 0xC0 },
+	{ 17, 0xC0 },
+	{ 18, 0x38 },
+	{ 19, 0xB0 },
+	{ 20, 0x32 },
+	{ 21, 0x06 },
+	{ 22, 0x00 },
+	{ 23, 0x00 },
+	{ 24, 0x06 },
+	{ 25, 0x32 },
+	{ 26, 0xC0 },
+	{ 27, 0xC0 },
+	{ 28, 0x08 },
+	{ 29, 0x06 },
+	{ 30, 0x1F },
+	{ 31, 0xF7 },
+	{ 32, 0xFD },
+	{ 33, 0xFF },
+	{ 34, 0x1F },
+	{ 35, 0xF7 },
+	{ 36, 0xFD },
+	{ 37, 0xFF },
+	{ 38, 0x00 },
+	{ 39, 0x38 },
+	{ 40, 0x38 },
+	{ 41, 0x38 },
+	{ 42, 0x38 },
+	{ 43, 0x38 },
+	{ 44, 0x38 },
+	{ 45, 0x00 },
+	{ 46, 0x00 },
+	{ 47, 0x00 },
+	{ 48, 0x00 },
+	{ 49, 0x00 },
+	{ 50, 0x00 },
+	{ 51, 0x00 },
+	{ 52, 0x00 },
+};
+
+static int spk_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
+{
+		int i;
+		/*
+		struct es8388s_priv *es8388s = snd_soc_codec_get_drvdata(w->codec);
+		*/
+		switch (event) {
+				case SND_SOC_DAPM_PRE_PMU:
+				    //please add speaker amplifier mute control
+				   // Set_GPIO(SPK_MUTE_IO, MUTE);   
+						break;
+				case SND_SOC_DAPM_POST_PMU:
+				    //please add speaker amplifier mute control
+						mdelay(100);
+	          for( i = 0; i < 0x1d; i++)
+	          {
+		          snd_soc_write(w->codec, ES8388s_DACCONTROL26, i);    //LOUT2/ROUT2 VOLUME
+		          snd_soc_write(w->codec, ES8388s_DACCONTROL27, i);
+		          mdelay(5);
+	          }    
+	          //please add speaker amplifier mute control
+				   // Set_GPIO(SPK_MUTE_IO, UN_MUTE);   
+						break;						
+				case SND_SOC_DAPM_PRE_PMD:
+				    //please add speaker amplifier mute control
+				   // Set_GPIO(SPK_MUTE_IO, MUTE);
+				    //snd_soc_write(w->codec, 0x04, 0x00); 
+					//	mdelay(100);
+	          for( i = 0; i < 0x1d; i++)
+	          {
+		         snd_soc_write(w->codec, ES8388s_DACCONTROL26,  0x1d-i);    //LOUT2/ROUT2 VOLUME
+		         snd_soc_write(w->codec, ES8388s_DACCONTROL27,  0x1d-i);
+		          mdelay(5);
+	          }    
+						break;
+				default:
+						break;
+		}
+		return 0;
+}
+static int adc_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
+{
+		unsigned int regv;
+		/*
+		struct es8388s_priv *es8388s = snd_soc_codec_get_drvdata(w->codec);
+		*/
+		switch (event) {
+				case SND_SOC_DAPM_POST_PMU:
+				    snd_soc_write(w->codec, 0x03, 0x00); 
+				    snd_soc_write(w->codec, 0x02, 0x00);
+						mdelay(100);
+						regv = snd_soc_read(w->codec, 0x0b);
+						regv &= 0xfb;
+						snd_soc_write(w->codec, 0x0b, regv);
+						break;
+				case SND_SOC_DAPM_POST_PMD:
+						regv = snd_soc_read(w->codec, 0x0b);
+						regv |= 0x4;
+						snd_soc_write(w->codec, 0x0b, regv);  
+						snd_soc_write(w->codec, 0x03, 0xf9); 
+						break;
+				default:
+						break;
+		}
+		return 0;
+}
+
+
+/* DAC/ADC Volume: min -96.0dB (0xC0) ~ max 0dB (0x00)  ( 0.5 dB step ) */
+static const DECLARE_TLV_DB_SCALE(digital_tlv, -9600, 50, 0);
+/* Analog Out Volume: min -30.0dB (0x00) ~ max 3dB (0x21)  ( 1 dB step ) */
+static const DECLARE_TLV_DB_SCALE(out_tlv, -3000, 100, 0);
+/* Analog In Volume: min 0dB (0x00) ~ max 24dB (0x08)  ( 3 dB step ) */
+static const DECLARE_TLV_DB_SCALE(in_tlv, 0, 300, 0);
+
+static const struct snd_kcontrol_new es8388s_snd_controls[] = {
+	SOC_DOUBLE_R_TLV("Playback Volume",
+		ES8388s_LDAC_VOL, ES8388s_RDAC_VOL, 0, 0xC0, 1, digital_tlv),
+	SOC_DOUBLE_R_TLV("Analog Out Volume",
+		ES8388s_LOUT1_VOL, ES8388s_ROUT1_VOL, 0, 0x1D, 0, out_tlv),
+
+	SOC_DOUBLE_R_TLV("Capture Volume",
+		ES8388s_LADC_VOL, ES8388s_RADC_VOL, 0, 0xC0, 1, digital_tlv),
+	SOC_DOUBLE_TLV("Analog In Volume",
+		ES8388s_ADCCONTROL1, 4, 0, 0x08, 0, in_tlv),
+};
+
+/*
+ * DAPM Controls
+ */
+
+/* Channel Input Mixer */
+static const char *es8388s_line_texts[] = { "Line 1", "Line 2", "Differential"};
+static const unsigned int es8388s_line_values[] = { 0, 1, 3};
+
+static const struct soc_enum es8388s_lline_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8388s_ADCCONTROL2, 6, 4,
+		ARRAY_SIZE(es8388s_line_texts), es8388s_line_texts,
+		es8388s_line_values);
+static const struct snd_kcontrol_new es8388s_left_line_controls =
+	SOC_DAPM_ENUM("Route", es8388s_lline_enum);
+
+static const struct soc_enum es8388s_rline_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8388s_ADCCONTROL2, 4, 4,
+		ARRAY_SIZE(es8388s_line_texts), es8388s_line_texts,
+		es8388s_line_values);
+static const struct snd_kcontrol_new es8388s_right_line_controls =
+	SOC_DAPM_ENUM("Route", es8388s_rline_enum);
+
+
+/* Left Mixer */
+static const struct snd_kcontrol_new es8388s_left_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left Playback Switch", ES8388s_DACCONTROL17, 7, 1, 0),
+	SOC_DAPM_SINGLE("Left Bypass Switch"  , ES8388s_DACCONTROL17, 6, 1, 0),
+};
+
+/* Right Mixer */
+static const struct snd_kcontrol_new es8388s_right_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Right Playback Switch", ES8388s_DACCONTROL20, 7, 1, 0),
+	SOC_DAPM_SINGLE("Right Bypass Switch"  , ES8388s_DACCONTROL20, 6, 1, 0),
+};
+#if 0
+/* Differential Mux */
+static const char *es8388s_diff_sel[] = {"Line 1", "Line 2"};
+static const struct soc_enum diffmux =
+	SOC_ENUM_SINGLE(ES8388s_ADCCONTROL3, 7, 2, es8388s_diff_sel);
+static const struct snd_kcontrol_new es8388s_diffmux_controls =
+	SOC_DAPM_ENUM("Route", diffmux);
+#endif
+/* Mono ADC Mux */
+static const char *es8388s_mono_mux[] = {"Stereo", "Mono (Left)", "Mono (Right)", "NONE"};
+static const unsigned int es8388s_monomux_values[] = { 0, 1, 2, 3};
+/*static const struct soc_enum monomux =
+	SOC_ENUM_SINGLE(ES8388s_ADCCONTROL3, 3, 4, es8388s_mono_mux);
+static const struct snd_kcontrol_new es8388s_monomux_controls =
+	SOC_DAPM_ENUM("Route", monomux);
+*/
+static const struct soc_enum monomux =
+	SOC_VALUE_ENUM_SINGLE(ES8388s_ADCCONTROL3, 3, 4,
+		ARRAY_SIZE(es8388s_mono_mux), es8388s_mono_mux,
+		es8388s_monomux_values);
+static const struct snd_kcontrol_new es8388s_monomux_controls =
+	SOC_DAPM_ENUM("Route", monomux);
+	
+static const struct snd_kcontrol_new adc_switch_ctl =
+SOC_DAPM_SINGLE("Switch",ES8388s_ADCCONTROL7, 2, 1, 1);	
+	
+static const struct snd_soc_dapm_widget es8388s_dapm_widgets[] = {
+	/* DAC Part */
+	SND_SOC_DAPM_MIXER("Left Mixer", SND_SOC_NOPM, 0, 0,
+		&es8388s_left_mixer_controls[0], ARRAY_SIZE(es8388s_left_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", SND_SOC_NOPM, 0, 0,
+		&es8388s_right_mixer_controls[0], ARRAY_SIZE(es8388s_right_mixer_controls)),
+
+	SND_SOC_DAPM_MUX("Left Line Mux", SND_SOC_NOPM, 0, 0, &es8388s_left_line_controls),
+	SND_SOC_DAPM_MUX("Right Line Mux", SND_SOC_NOPM, 0, 0, &es8388s_right_line_controls),
+
+	SND_SOC_DAPM_DAC("Left DAC"  , "Left Playback" , ES8388s_DACPOWER, 7, 1),
+	SND_SOC_DAPM_DAC("Right DAC" , "Right Playback", ES8388s_DACPOWER, 6, 1),
+	
+	//SND_SOC_DAPM_PGA("Left Out 1" , ES8388s_DACPOWER, 5, 0, NULL, 0),
+	//SND_SOC_DAPM_PGA("Right Out 1", ES8388s_DACPOWER, 4, 0, NULL, 0),
+	
+	SND_SOC_DAPM_PGA_E("Left Out 1", ES8388s_DACPOWER, 5, 0, NULL, 
+         0, spk_event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_PGA_E("Right Out 1", ES8388s_DACPOWER, 4, 0, NULL, 
+         0, spk_event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),	
+         
+	/* SND_SOC_DAPM_PGA("Left Out 2" , ES8388s_DACPOWER, 3, 0, NULL, 0), */
+	/* SND_SOC_DAPM_PGA("Right Out 2", ES8388s_DACPOWER, 2, 0, NULL, 0), */
+
+	SND_SOC_DAPM_OUTPUT("LOUT1"),
+	SND_SOC_DAPM_OUTPUT("ROUT1"),
+	SND_SOC_DAPM_OUTPUT("LOUT2"),
+	SND_SOC_DAPM_OUTPUT("ROUT2"),
+
+	/* ADC Part */
+//	SND_SOC_DAPM_MUX("Differential Mux", SND_SOC_NOPM, 0, 0,
+//		&es8388s_diffmux_controls),
+
+//	SND_SOC_DAPM_MUX("Left Line Mux", ES8388s_ADCPOWER, 7, 1, &es8388s_left_line_controls),
+//	SND_SOC_DAPM_MUX("Right Line Mux", ES8388s_ADCPOWER, 6, 1, &es8388s_right_line_controls),
+
+	SND_SOC_DAPM_MUX("Left ADC Mux", SND_SOC_NOPM, 0, 0, &es8388s_monomux_controls),
+	SND_SOC_DAPM_MUX("Right ADC Mux", SND_SOC_NOPM, 0, 0, &es8388s_monomux_controls),
+//SND_SOC_DAPM_MUX("Left ADC Mux", ES8388s_ADCPOWER, 7, 1, &es8388s_monomux_controls),
+//SND_SOC_DAPM_MUX("Right ADC Mux", ES8388s_ADCPOWER, 6, 1, &es8388s_monomux_controls),
+	SND_SOC_DAPM_PGA("Left Analog Input" , ES8388s_ADCPOWER, 7, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Analog Input", ES8388s_ADCPOWER, 6, 1, NULL, 0),
+	SND_SOC_DAPM_ADC_E("Left ADC" , "Left Capture" , ES8388s_ADCPOWER, 5, 1, 
+	                   adc_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_ADC_E("Right ADC", "Right Capture", ES8388s_ADCPOWER, 4, 1, 
+	                   adc_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+
+
+	SND_SOC_DAPM_MICBIAS("Mic Bias", ES8388s_ADCPOWER, 3, 1),
+
+	SND_SOC_DAPM_INPUT("MICIN"),
+	SND_SOC_DAPM_INPUT("LINPUT1"),
+	SND_SOC_DAPM_INPUT("LINPUT2"),
+	SND_SOC_DAPM_INPUT("RINPUT1"),
+	SND_SOC_DAPM_INPUT("RINPUT2"),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* left mixer */
+	{"Left Mixer", "Left Playback Switch", "Left DAC"},
+
+	/* right mixer */
+	{"Right Mixer", "Right Playback Switch", "Right DAC"},
+
+	/* left out 1 */
+	{"Left Out 1", NULL, "Left Mixer"},
+	{"LOUT1", NULL, "Left Out 1"},
+
+	/* right out 1 */
+	{"Right Out 1", NULL, "Right Mixer"},
+	{"ROUT1", NULL, "Right Out 1"},
+
+	/* Left Line Mux */
+	{"Left Line Mux", "Line 1", "LINPUT1"},
+	{"Left Line Mux", "Line 2", "LINPUT2"},
+	{"Left Line Mux", NULL, "MICIN"},
+
+	/* Right Line Mux */
+	{"Right Line Mux", "Line 1", "RINPUT1"},
+	{"Right Line Mux", "Line 2", "RINPUT2"},
+	{"Right Line Mux", NULL, "MICIN"},
+
+	/* Left ADC Mux */
+	{"Left ADC Mux", "Stereo", "Left Line Mux"},
+//	{"Left ADC Mux", "Mono (Left)" , "Left Line Mux"},
+
+	/* Right ADC Mux */
+	{"Right ADC Mux", "Stereo", "Right Line Mux"},
+//	{"Right ADC Mux", "Mono (Right)", "Right Line Mux"},
+
+	/* ADC */
+	{"Left ADC" , NULL, "Left ADC Mux"},
+	{"Right ADC", NULL, "Right ADC Mux"},
+
+
+	
+};
+
+static int es8388s_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct es8388s_priv *es8388s = snd_soc_codec_get_drvdata(codec);
+
+	es8388s->sysclk = freq;
+	return 0;
+}
+
+static int es8388s_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u8 iface = 0;
+	u8 adciface = 0;
+	u8 daciface = 0;
+	u32 snd_fmt;
+
+	iface = snd_soc_read(codec, ES8388s_IFACE);
+	adciface = snd_soc_read(codec, ES8388s_ADC_IFACE);
+	daciface = snd_soc_read(codec, ES8388s_DAC_IFACE);
+	snd_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:    // MASTER MODE
+		iface |= 0x80;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:    // SLAVE MODE
+		iface &= 0x7F;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (snd_fmt) {
+	case SND_SOC_DAIFMT_I2S:
+		adciface &= 0xFC;
+		daciface &= 0xF9;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+	case SND_SOC_DAIFMT_LEFT_J:
+	case SND_SOC_DAIFMT_DSP_A:
+		adciface |= 0x03;
+		daciface |= 0x06;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		adciface |= 0x23;
+		daciface |= 0x46;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		iface &= 0xDF;
+		if (snd_fmt != SND_SOC_DAIFMT_DSP_A && snd_fmt != SND_SOC_DAIFMT_DSP_B){
+			adciface &= 0xDF;
+			daciface &= 0xBF;
+		}
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x20;
+		if (snd_fmt != SND_SOC_DAIFMT_DSP_A && snd_fmt != SND_SOC_DAIFMT_DSP_B){
+			adciface |= 0x20;
+			daciface |= 0x40;
+		}
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x20;
+		if (snd_fmt != SND_SOC_DAIFMT_DSP_A && snd_fmt != SND_SOC_DAIFMT_DSP_B){
+			adciface &= 0xDF;
+			daciface &= 0xBF;
+		}
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface &= 0xDF;
+		if (snd_fmt != SND_SOC_DAIFMT_DSP_A && snd_fmt != SND_SOC_DAIFMT_DSP_B){
+			adciface |= 0x20;
+			daciface |= 0x40;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_soc_write(codec, ES8388s_IFACE    , iface);
+	snd_soc_write(codec, ES8388s_ADC_IFACE, adciface);
+	snd_soc_write(codec, ES8388s_DAC_IFACE, daciface);
+
+	return 0;
+}
+
+static int es8388s_pcm_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u16 iface;
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		iface = snd_soc_read(codec, ES8388s_DAC_IFACE) & 0xC7;
+		/* bit size */
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			iface |= 0x18;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			iface |= 0x08;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			iface |= 0x20;
+			break;
+		}
+		/* set iface & srate */
+		snd_soc_write(codec, ES8388s_DAC_IFACE, iface);
+	} else {
+		iface = snd_soc_read(codec, ES8388s_ADC_IFACE) & 0xE3;
+		/* bit size */
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			iface |= 0x0C;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			iface |= 0x04;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			iface |= 0x10;
+			break;
+		}
+		/* set iface */
+		snd_soc_write(codec, ES8388s_ADC_IFACE, iface);
+	}
+		snd_soc_write(codec, ES8388s_ADCPOWER, 0x59);
+		snd_soc_write(codec, ES8388s_DACPOWER , 0x0c);
+		snd_soc_write(codec, ES8388s_CHIPPOWER , 0x00);
+	return 0;
+}
+
+static int es8388s_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	unsigned char val = 0;
+
+	val = snd_soc_read(codec, ES8388s_DAC_MUTE);
+	if (mute){
+		val |= 0x04;
+	} else {
+		val &= ~0x04;
+	}
+
+	snd_soc_write(codec, ES8388s_DAC_MUTE, val);
+
+	return 0;
+}
+
+
+static int es8388s_set_bias_level(struct snd_soc_codec *codec,
+		enum snd_soc_bias_level level)
+{
+	switch(level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		if(codec->dapm.bias_level != SND_SOC_BIAS_ON) {
+			snd_soc_write(codec, ES8388s_ADCPOWER, 0x00);
+			snd_soc_write(codec, ES8388s_DACPOWER , 0x0c);
+			snd_soc_write(codec, ES8388s_CHIPPOWER , 0x00);
+		}
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		/*
+		// ADC/DAC DLL power on
+		snd_soc_write(codec, ES8388s_CONTROL2 , 0xFF);
+		// Chip Power off
+		snd_soc_write(codec, ES8388s_CHIPPOWER, 0xF3);
+		*/
+		snd_soc_write(codec, ES8388s_ADCPOWER, 0x00);
+		snd_soc_write(codec, ES8388s_DACPOWER , 0x0c);
+		snd_soc_write(codec, ES8388s_CHIPPOWER , 0x00);
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		/*
+		// ADC/DAC DLL power off
+		snd_soc_write(codec, ES8388s_CONTROL2 , 0xFF);
+		// Chip Control
+		snd_soc_write(codec, ES8388s_CONTROL1 , 0x00);
+		// Chip Power off
+		snd_soc_write(codec, ES8388s_CHIPPOWER, 0xFF);
+		*/
+		snd_soc_write(codec, ES8388s_ADCPOWER, 0xFF);
+		snd_soc_write(codec, ES8388s_DACPOWER , 0xC0);
+		snd_soc_write(codec, ES8388s_CHIPPOWER , 0xC3);
+		break;
+	}
+
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+
+#define ES8388s_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+                    SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
+                    SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define ES8388s_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+                    SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_dai_ops es8388s_dai_ops = {
+	.hw_params    = es8388s_pcm_hw_params,
+	.set_fmt      = es8388s_set_dai_fmt,
+	.set_sysclk   = es8388s_set_dai_sysclk,
+	.digital_mute = es8388s_mute,
+};
+
+
+struct snd_soc_dai_driver es8388s_dai = {
+	.name = "es8388s-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = ES8388s_RATES,
+		.formats = ES8388s_FORMATS,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = ES8388s_RATES,
+		.formats = ES8388s_FORMATS,},
+	.ops = &es8388s_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static int es8388s_suspend(struct snd_soc_codec *codec)
+{
+	es8388s_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int es8388s_resume(struct snd_soc_codec *codec)
+{
+	es8388s_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return 0;
+}
+
+static int es8388s_remove(struct snd_soc_codec *codec)
+{
+	es8388s_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static inline int es8388s_reset(struct regmap *map)
+{
+	int ret = 0;
+	regmap_write(map, 0x00, 0x80);
+	ret = regmap_write(map, 0x00, 0x00);
+	return ret;
+}
+
+static int es8388s_probe(struct snd_soc_codec *codec)
+{
+	struct es8388s_priv *es8388s = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+	unsigned int value = 0;
+	dev_info(codec->dev, "ES8388s Audio Codec %s", ES8388s_VERSION);
+	codec->control_data = es8388s->regmap;
+#if 0
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+#endif
+	//es8388s_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+    snd_soc_write(codec, ES8388s_REGCONTROL35,0xA0);   //Enable Diff PGA for ES8388sS
+    value = snd_soc_read(codec, ES8388s_REGCONTROL35);
+   	
+	snd_soc_write(codec, ES8388s_REGCONTROL38,0x02); 
+    
+	value = snd_soc_read(codec, ES8388s_REGCONTROL38);
+	
+	snd_soc_write(codec, ES8388s_MASTERMODE,0x00);
+	value = snd_soc_read(codec, ES8388s_MASTERMODE);
+
+	snd_soc_write(codec, ES8388s_CHIPPOWER, 0xF3);
+	snd_soc_write(codec, ES8388s_DACCONTROL23, 0x00);
+	snd_soc_write(codec, ES8388s_ANAVOLMANAG, 0x7a);
+	snd_soc_write(codec, ES8388s_DACCONTROL21, 0x80);
+	snd_soc_write(codec, ES8388s_CONTROL1, 0x30);
+	snd_soc_write(codec, ES8388s_CHIPLOPOW2, 0xFF);
+	snd_soc_write(codec, ES8388s_CHIPLOPOW1, 0x00);
+	//-------------ADC---------------------------//
+	snd_soc_write(codec, ES8388s_ADCCONTROL1, 0x40);
+	snd_soc_write(codec, ES8388s_ADCCONTROL2, 0xc1);
+	snd_soc_write(codec, ES8388s_ADCCONTROL3, 0x02);  //adc output in tri-state
+	snd_soc_write(codec, ES8388s_ADCCONTROL4, 0x4C);
+	snd_soc_write(codec, ES8388s_ADCCONTROL5, 0x02);  //compitable with 88s
+	snd_soc_write(codec, ES8388s_ADCCONTROL6, 0x2c);  
+	snd_soc_write(codec, ES8388s_ADCCONTROL8, 0x00);
+	snd_soc_write(codec, ES8388s_ADCCONTROL9, 0x00);
+	snd_soc_write(codec, ES8388s_ADCCONTROL10, 0xDa);
+	snd_soc_write(codec, ES8388s_ADCCONTROL11, 0xB0);
+	snd_soc_write(codec, ES8388s_ADCCONTROL12, 0x12);
+	snd_soc_write(codec, ES8388s_ADCCONTROL13, 0x06);
+	snd_soc_write(codec, ES8388s_ADCCONTROL14, 0x11);
+	//-------------DAC-----------------------------//
+	snd_soc_write(codec, ES8388s_DACCONTROL1, 0x18);
+	value = snd_soc_read(codec, ES8388s_DACCONTROL1);
+
+	snd_soc_write(codec, ES8388s_DACCONTROL2, 0x02);  //compitable with 88s
+	snd_soc_write(codec, ES8388s_DACCONTROL3, 0x76);
+	snd_soc_write(codec, ES8388s_DACCONTROL4, 0x00);
+	snd_soc_write(codec, ES8388s_DACCONTROL5, 0x00);
+	snd_soc_write(codec, ES8388s_DACCONTROL17, 0xB8);
+	snd_soc_write(codec, ES8388s_DACCONTROL20, 0xB8);
+
+	snd_soc_write(codec, ES8388s_CHIPPOWER, 0x00); snd_soc_write(codec, ES8388s_CONTROL1, 0x36);
+	snd_soc_write(codec, ES8388s_CONTROL2, 0x72);
+	snd_soc_write(codec, ES8388s_DACPOWER, 0x0C);    //only start up DAC, disable LOUT/ROUT
+	snd_soc_write(codec, ES8388s_ADCPOWER, 0x09);
+	snd_soc_write(codec, ES8388s_CONTROL1, 0x32);
+	snd_soc_write(codec, ES8388s_DACCONTROL3, 0x72);
+	snd_soc_write(codec, ES8388s_DACCONTROL26, 0x1e);    //LOUT2/ROUT2 VOLUME  es8388s LOUT1/ROUT1
+	snd_soc_write(codec, ES8388s_DACCONTROL27, 0x1e);
+		msleep(5);
+	
+
+	return ret;
+}
+
+static bool es8388s_volatile_register(struct device *dev,
+							unsigned int reg)
+{
+	switch (reg) {
+		case 0:
+		return true;
+
+	default:
+		break;
+	}
+
+	return false;
+}
+
+
+static struct snd_soc_codec_driver soc_codec_dev_es8388s = {
+	.probe =	es8388s_probe,
+	.remove =	es8388s_remove,
+	.suspend =	es8388s_suspend,
+	.resume =	es8388s_resume,
+	.set_bias_level = es8388s_set_bias_level,
+
+	.dapm_widgets = es8388s_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(es8388s_dapm_widgets),
+	.dapm_routes = audio_map,
+	.num_dapm_routes = ARRAY_SIZE(audio_map),
+
+	.controls = es8388s_snd_controls,
+	.num_controls = ARRAY_SIZE(es8388s_snd_controls),
+};
+
+static struct regmap_config es8388s_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = ES8388s_MAX_REGISTER,
+	.reg_defaults = es8388s_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(es8388s_reg_defaults),
+	.volatile_reg = es8388s_volatile_register,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+static int es8388s_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct es8388s_priv *es8388s;
+	int ret = 0;
+
+	es8388s = devm_kzalloc(&i2c->dev, sizeof(struct es8388s_priv), GFP_KERNEL);
+	if (es8388s == NULL)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, es8388s);
+	es8388s->regmap = devm_regmap_init_i2c(i2c, &es8388s_regmap);
+	if (IS_ERR(es8388s->regmap)) {
+		ret = PTR_ERR(es8388s->regmap);
+		dev_err(&i2c->dev, "regmap_init() failed: %d\n", ret);
+		return ret;
+	}
+
+	ret =  snd_soc_register_codec(&i2c->dev,
+			&soc_codec_dev_es8388s, &es8388s_dai, 1);
+
+	return ret;
+}
+
+static int es8388s_i2c_remove(struct i2c_client *i2c)
+{
+	snd_soc_unregister_codec(&i2c->dev);
+	return 0;
+}
+
+static struct of_device_id es8388s_of_match[] = {
+	{ .compatible = "ambarella,es8388s",},
+	{},
+};
+MODULE_DEVICE_TABLE(of, es8388s_of_match);
+static const struct i2c_device_id es8388s_i2c_id[] = {
+	{ "es8388s", 0x11 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, es8388s_i2c_id);
+
+static struct i2c_driver es8388s_i2c_driver = {
+	.driver = {
+		.name = "es8388s-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = es8388s_of_match,
+	},
+	.probe    = es8388s_i2c_probe,
+	.remove   = es8388s_i2c_remove,
+	.id_table = es8388s_i2c_id,
+};
+#endif
+
+static int __init es8388s_modinit(void)
+{
+	int ret = 0;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	ret = i2c_add_driver(&es8388s_i2c_driver);
+	if (ret != 0) {
+		pr_err("Failed to register ES8388s I2C driver: %d\n", ret);
+	}
+#endif
+	return ret;
+}
+module_init(es8388s_modinit);
+
+static void __exit es8388s_exit(void)
+{
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&es8388s_i2c_driver);
+#endif
+}
+module_exit(es8388s_exit);
+
+MODULE_DESCRIPTION("ASoC ES8388s driver");
+MODULE_AUTHOR("Ken He <jianhe@ambarella.com>");
+MODULE_LICENSE("GPL");
+
Index: linux-3.18.29/sound/soc/codecs/es8388s.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/codecs/es8388s.h	2017-11-21 20:13:12.450710527 +0800
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on ES8388s.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ES8388s_H
+#define _ES8388s_H
+
+#define CONFIG_HHTECH_MINIPMP	1
+#define DEBUG
+/* ES8388s register space */
+
+#define ES8388s_CONTROL1         0x00
+#define ES8388s_CONTROL2         0x01
+#define ES8388s_CHIPPOWER        0x02
+#define ES8388s_ADCPOWER         0x03
+#define ES8388s_DACPOWER         0x04
+#define ES8388s_CHIPLOPOW1       0x05
+#define ES8388s_CHIPLOPOW2       0x06
+#define ES8388s_ANAVOLMANAG      0x07
+#define ES8388s_MASTERMODE       0x08
+#define ES8388s_ADCCONTROL1      0x09
+#define ES8388s_ADCCONTROL2      0x0a
+#define ES8388s_ADCCONTROL3      0x0b
+#define ES8388s_ADCCONTROL4      0x0c
+#define ES8388s_ADCCONTROL5      0x0d
+#define ES8388s_ADCCONTROL6      0x0e
+#define ES8388s_ADCCONTROL7      0x0f
+#define ES8388s_ADCCONTROL8      0x10
+#define ES8388s_ADCCONTROL9      0x11
+#define ES8388s_ADCCONTROL10     0x12
+#define ES8388s_ADCCONTROL11     0x13
+#define ES8388s_ADCCONTROL12     0x14
+#define ES8388s_ADCCONTROL13     0x15
+#define ES8388s_ADCCONTROL14     0x16
+
+#define ES8388s_DACCONTROL1      0x17
+#define ES8388s_DACCONTROL2      0x18
+#define ES8388s_DACCONTROL3      0x19
+#define ES8388s_DACCONTROL4      0x1a
+#define ES8388s_DACCONTROL5      0x1b
+#define ES8388s_DACCONTROL6      0x1c
+#define ES8388s_DACCONTROL7      0x1d
+#define ES8388s_DACCONTROL8      0x1e
+#define ES8388s_DACCONTROL9      0x1f
+#define ES8388s_DACCONTROL10     0x20
+#define ES8388s_DACCONTROL11     0x21
+#define ES8388s_DACCONTROL12     0x22
+#define ES8388s_DACCONTROL13     0x23
+#define ES8388s_DACCONTROL14     0x24
+#define ES8388s_DACCONTROL15     0x25
+#define ES8388s_DACCONTROL16     0x26
+#define ES8388s_DACCONTROL17     0x27
+#define ES8388s_DACCONTROL18     0x28
+#define ES8388s_DACCONTROL19     0x29
+#define ES8388s_DACCONTROL20     0x2a
+#define ES8388s_DACCONTROL21     0x2b
+#define ES8388s_DACCONTROL22     0x2c
+#define ES8388s_DACCONTROL23     0x2d
+#define ES8388s_DACCONTROL24     0x2e
+#define ES8388s_DACCONTROL25     0x2f
+#define ES8388s_DACCONTROL26     0x30
+#define ES8388s_DACCONTROL27     0x31
+#define ES8388s_DACCONTROL28     0x32
+#define ES8388s_DACCONTROL29     0x33
+#define ES8388s_DACCONTROL30     0x34
+#define ES8388s_REGCONTROL35     0x35
+#define ES8388s_REGCONTROL38     0x38
+
+#define ES8388s_LADC_VOL         ES8388s_ADCCONTROL8
+#define ES8388s_RADC_VOL         ES8388s_ADCCONTROL9
+
+#define ES8388s_LDAC_VOL         ES8388s_DACCONTROL4
+#define ES8388s_RDAC_VOL         ES8388s_DACCONTROL5
+
+#define ES8388s_LOUT1_VOL        ES8388s_DACCONTROL24
+#define ES8388s_ROUT1_VOL        ES8388s_DACCONTROL25
+#define ES8388s_LOUT2_VOL        ES8388s_DACCONTROL26
+#define ES8388s_ROUT2_VOL        ES8388s_DACCONTROL27
+
+#define ES8388s_ADC_MUTE         ES8388s_ADCCONTROL7
+#define ES8388s_DAC_MUTE         ES8388s_DACCONTROL3
+
+
+
+#define ES8388s_IFACE            ES8388s_MASTERMODE
+
+#define ES8388s_ADC_IFACE        ES8388s_ADCCONTROL4
+#define ES8388s_ADC_SRATE        ES8388s_ADCCONTROL5
+
+#define ES8388s_DAC_IFACE        ES8388s_DACCONTROL1
+#define ES8388s_DAC_SRATE        ES8388s_DACCONTROL2
+
+
+
+#define ES8388s_CACHEREGNUM      53
+#define ES8388s_SYSCLK	        0
+
+struct es8388s_setup_data {
+	int i2c_bus;	
+	unsigned short i2c_address;
+};
+
+#if 1 //lzcx
+#define ES8388s_PLL1			0
+#define ES8388s_PLL2			1
+
+/* clock inputs */
+#define ES8388s_MCLK		0
+#define ES8388s_PCMCLK		1
+
+/* clock divider id's */
+#define ES8388s_PCMDIV		0
+#define ES8388s_BCLKDIV		1
+#define ES8388s_VXCLKDIV		2
+
+/* PCM clock dividers */
+#define ES8388s_PCM_DIV_1	(0 << 6)
+#define ES8388s_PCM_DIV_3	(2 << 6)
+#define ES8388s_PCM_DIV_5_5	(3 << 6)
+#define ES8388s_PCM_DIV_2	(4 << 6)
+#define ES8388s_PCM_DIV_4	(5 << 6)
+#define ES8388s_PCM_DIV_6	(6 << 6)
+#define ES8388s_PCM_DIV_8	(7 << 6)
+
+/* BCLK clock dividers */
+#define ES8388s_BCLK_DIV_1	(0 << 7)
+#define ES8388s_BCLK_DIV_2	(1 << 7)
+#define ES8388s_BCLK_DIV_4	(2 << 7)
+#define ES8388s_BCLK_DIV_8	(3 << 7)
+
+/* VXCLK clock dividers */
+#define ES8388s_VXCLK_DIV_1	(0 << 6)
+#define ES8388s_VXCLK_DIV_2	(1 << 6)
+#define ES8388s_VXCLK_DIV_4	(2 << 6)
+#define ES8388s_VXCLK_DIV_8	(3 << 6)
+#define ES8388s_VXCLK_DIV_16	(4 << 6)
+
+#define ES8388s_DAI_HIFI		0
+#define ES8388s_DAI_VOICE		1
+
+#define ES8388s_1536FS 1536
+#define ES8388s_1024FS	1024
+#define ES8388s_768FS	768
+#define ES8388s_512FS	512
+#define ES8388s_384FS	384
+#define ES8388s_256FS	256
+#define ES8388s_128FS	128
+#endif
+
+#endif
Index: linux-3.18.29/sound/soc/siflower/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/siflower/Kconfig	2017-11-21 20:13:12.450710527 +0800
@@ -0,0 +1,33 @@
+config SND_SOC_SFAX8_PCM
+		tristate "SoC PCM support for the Siflower SFAX8"
+		select SND_SOC_GENERIC_DMAENGINE_PCM
+		help 
+		   Say Y or M if you want to add support for PCM interface 
+		   You will also need to select the audio interfaces to support below.
+
+config SND_SOC_SFAX8_I2S
+		tristate "Siflower I2S Device Driver"
+		select SND_SOC_GENERIC_DMAENGINE_PCM
+		help
+		   Say Y or M if you want to add support for I2S driver for
+		   Siflower sfax8 I2S device. The device supports upto
+		   maximum of 8 channels each for play and record.
+
+config SND_SOC_SFAX8_SPDIF
+		tristate "SoC spdif support for Siflower SFAx8 serials"
+		select SND_SOC_GENERIC_DMAENGINE_PCM
+		help 
+		   Say Y or M if you want to add support for the spdif interface 
+		   You will also need to select the audio interfaces to support below.
+
+config SND_SOC_SFAX8_MACHINE
+		tristate "SoC machine support for the Siflower SFAX8"
+		help
+			Say Y or M if you want to add support for machine
+
+config SND_SOC_SFAX8_SPDIF_MACHINE
+		tristate "SoC machine support for the Siflower SFA18"
+		help
+			Say Y or M if you want to add support for machine
+
+
Index: linux-3.18.29/sound/soc/siflower/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/siflower/Makefile	2017-11-21 20:13:12.450710527 +0800
@@ -0,0 +1,13 @@
+obj-$(CONFIG_SND_SOC_SFAX8_I2S) += sfax8_i2s.o
+
+snd-soc-sfax8-pcm-objs := sfax8-pcm.o
+snd-soc-sfax8-spdif-objs := sfax8_spdif.o
+obj-$(CONFIG_SND_SOC_SFAX8_PCM) += snd-soc-sfax8-pcm.o
+obj-$(CONFIG_SND_SOC_SFAX8_SPDIF) += snd-soc-sfax8-spdif.o
+
+# machine codes
+
+snd-soc-sfax8-machine-objs := sfax8-machine.o
+snd-soc-sfax8-spdif-machine-objs := sfax8-spdif-machine.o
+obj-$(CONFIG_SND_SOC_SFAX8_MACHINE) += snd-soc-sfax8-machine.o
+obj-$(CONFIG_SND_SOC_SFAX8_SPDIF_MACHINE) += snd-soc-sfax8-spdif-machine.o
Index: linux-3.18.29/drivers/input/misc/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/input/misc/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/input/misc/Kconfig	2017-11-21 20:13:12.454710527 +0800
@@ -719,4 +719,35 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called drv260x-haptics.
 
+config INPUT_SFAX8_MISCDEV
+	tristate "SIFLOWER SF16ax8 misc device support"
+	depends on INPUT && I2C
+	select REGMAP_I2C
+	help
+	 Say Y to enable support for the SIFLOWER SF16ax8 misc device driver.
+
+	 To compile this driver as a module, choose M here: the
+	 module will be called sfax8-miscdev.
+
+if INPUT_SFAX8_MISCDEV
+
+choice
+prompt "Siflower IR work mode"
+default SF_IRC_MODE9012
+
+config SF_IRC_MODE9012
+	bool "IR mode is 9012"
+
+config SF_IRC_MODE8NEC
+	bool "IR mode is 8bit NEC"
+
+config SF_IRC_MODERC5
+	bool "IR mode is RC5"
+
+config SF_IRC_MODERC6
+	bool "IR mode is RC6"
+
+endchoice
+endif
+
 endif
Index: linux-3.18.29/drivers/input/misc/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/input/misc/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/input/misc/Makefile	2017-11-21 20:13:12.454710527 +0800
@@ -57,6 +57,7 @@
 obj-$(CONFIG_INPUT_GPIO_ROTARY_ENCODER)	+= rotary_encoder.o
 obj-$(CONFIG_INPUT_SGI_BTNS)		+= sgi_btns.o
 obj-$(CONFIG_INPUT_SIRFSOC_ONKEY)	+= sirfsoc-onkey.o
+obj-$(CONFIG_INPUT_SFAX8_MISCDEV) += sfax8-miscdev.o
 obj-$(CONFIG_INPUT_SOC_BUTTON_ARRAY)	+= soc_button_array.o
 obj-$(CONFIG_INPUT_SPARCSPKR)		+= sparcspkr.o
 obj-$(CONFIG_INPUT_TWL4030_PWRBUTTON)	+= twl4030-pwrbutton.o
Index: linux-3.18.29/drivers/mmc/host/dw_mmc.c
===================================================================
--- linux-3.18.29.orig/drivers/mmc/host/dw_mmc.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/mmc/host/dw_mmc.c	2017-11-21 20:13:12.454710527 +0800
@@ -44,9 +44,9 @@
 /* Common flag combinations */
 #define DW_MCI_DATA_ERROR_FLAGS	(SDMMC_INT_DRTO | SDMMC_INT_DCRC | \
 				 SDMMC_INT_HTO | SDMMC_INT_SBE  | \
-				 SDMMC_INT_EBE)
+				 SDMMC_INT_EBE | SDMMC_INT_HLE)
 #define DW_MCI_CMD_ERROR_FLAGS	(SDMMC_INT_RTO | SDMMC_INT_RCRC | \
-				 SDMMC_INT_RESP_ERR)
+				 SDMMC_INT_RESP_ERR | SDMMC_INT_HLE)
 #define DW_MCI_ERROR_FLAGS	(DW_MCI_DATA_ERROR_FLAGS | \
 				 DW_MCI_CMD_ERROR_FLAGS  | SDMMC_INT_HLE)
 #define DW_MCI_SEND_STATUS	1
@@ -82,6 +82,8 @@
 };
 #endif /* CONFIG_MMC_DW_IDMAC */
 
+static u64 read_count = 0;
+static u64 write_count = 0;
 static bool dw_mci_reset(struct dw_mci *host);
 
 #if defined(CONFIG_DEBUG_FS)
@@ -188,6 +190,14 @@
 	if (!node)
 		goto err;
 
+	node = debugfs_create_u64("write_count", S_IRUSR, root, (u64 *)&write_count);
+	if (!node)
+		goto err;
+
+	node = debugfs_create_u64("read_count", S_IRUSR, root, (u64 *)&read_count);
+	if (!node)
+		goto err;
+
 	node = debugfs_create_x32("pending_events", S_IRUSR, root,
 				  (u32 *)&host->pending_events);
 	if (!node)
@@ -1872,6 +1882,7 @@
 			data->bytes_xfered += len;
 			offset += len;
 			remain -= len;
+			read_count += len;
 		} while (remain);
 
 		sg_miter->consumed = offset;
@@ -1928,6 +1939,7 @@
 			data->bytes_xfered += len;
 			offset += len;
 			remain -= len;
+			write_count += len;
 		} while (remain);
 
 		sg_miter->consumed = offset;
@@ -2470,6 +2482,10 @@
 	const struct dw_mci_drv_data *drv_data = host->drv_data;
 	int idx, ret;
 	u32 clock_frequency;
+#ifdef CONFIG_SF16A18_MPW0
+	u32 read_delayline = 0;
+	u32 write_delayline = 0;
+#endif
 
 	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata) {
@@ -2496,6 +2512,14 @@
 
 	of_property_read_u32(np, "card-detect-delay", &pdata->detect_delay_ms);
 
+#ifdef CONFIG_SF16A18_MPW0
+	of_property_read_u32(np, "read-delayline", &read_delayline);
+
+	of_property_read_u32(np, "write-delayline", &write_delayline);
+
+	mci_writel(host,GPIO,((read_delayline << 8) | (write_delayline << 16)));
+#endif
+
 	if (!of_property_read_u32(np, "clock-frequency", &clock_frequency))
 		pdata->bus_hz = clock_frequency;
 
@@ -2550,7 +2574,11 @@
 		}
 	}
 
+#ifndef CONFIG_MMC_DW_SFAX8
 	host->ciu_clk = devm_clk_get(host->dev, "ciu");
+#else
+	host->ciu_clk = devm_clk_get(host->dev, NULL);
+#endif
 	if (IS_ERR(host->ciu_clk)) {
 		dev_dbg(host->dev, "ciu clock not available\n");
 		host->bus_hz = host->pdata->bus_hz;
Index: linux-3.18.29/drivers/rtc/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/rtc/Kconfig	2017-11-21 20:13:12.218710520 +0800
+++ linux-3.18.29/drivers/rtc/Kconfig	2017-11-21 20:13:12.454710527 +0800
@@ -576,6 +576,16 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-pt7c4338.
 
+config RTC_DRV_SFAX8
+	tristate "SFAX8"
+	depends on MFD_SFAX8
+	help
+	  If you say yes here you get support for the EM
+	  Microelectronic SFAX8 RTC chips.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-sfax8.
+
 endif # I2C
 
 comment "SPI RTC drivers"
Index: linux-3.18.29/drivers/rtc/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/rtc/Makefile	2017-11-21 20:13:12.218710520 +0800
+++ linux-3.18.29/drivers/rtc/Makefile	2017-11-21 20:13:12.454710527 +0800
@@ -151,3 +151,4 @@
 obj-$(CONFIG_RTC_DRV_XGENE)	+= rtc-xgene.o
 obj-$(CONFIG_RTC_DRV_SIRFSOC)	+= rtc-sirfsoc.o
 obj-$(CONFIG_RTC_DRV_MOXART)	+= rtc-moxart.o
+obj-$(CONFIG_RTC_DRV_SFAX8)	+= rtc-sfax8.o
Index: linux-3.18.29/include/linux/ieee80211.h
===================================================================
--- linux-3.18.29.orig/include/linux/ieee80211.h	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/include/linux/ieee80211.h	2017-11-21 20:13:12.454710527 +0800
@@ -1488,6 +1488,8 @@
 #define IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB	0x0c000000
 #define IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN			0x10000000
 #define IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN			0x20000000
+#define IEEE80211_VHT_CAP_NOT_SUP_WIDTH_80			0x80000000
+
 
 /* Authentication algorithms */
 #define WLAN_AUTH_OPEN 0
Index: linux-3.18.29/drivers/mfd/syscon.c
===================================================================
--- linux-3.18.29.orig/drivers/mfd/syscon.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/mfd/syscon.c	2017-11-21 20:13:12.454710527 +0800
@@ -5,6 +5,7 @@
  * Copyright (C) 2012 Linaro Ltd.
  *
  * Author: Dong Aisheng <dong.aisheng@linaro.org>
+ * Author: Xijun Guo <xijun.guo@siflower.com.cn>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -112,7 +113,7 @@
 
 static const struct of_device_id of_syscon_match[] = {
 	{ .compatible = "syscon", },
-	{ },
+	{ .compatible = "siflower,sfax8-syscon", },
 };
 
 static struct regmap_config syscon_regmap_config = {
@@ -186,5 +187,6 @@
 module_exit(syscon_exit);
 
 MODULE_AUTHOR("Dong Aisheng <dong.aisheng@linaro.org>");
+MODULE_AUTHOR("Xijun Guo <xijun.guo@siflower.com.cn>");
 MODULE_DESCRIPTION("System Control driver");
 MODULE_LICENSE("GPL v2");
Index: linux-3.18.29/drivers/net/ethernet/siflower/README
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/README	2017-11-21 20:13:12.454710527 +0800
@@ -0,0 +1,24 @@
+NPU  driver private sysfs node
+-----------------------------------------------
+If you define NPU_FUNC in sf_commom.c, you can get some special functions for NPU throught thoses nodes, with cat sys/npu_debug/read for help.
+If you don't define NPU_FUNC, you can get following functions.
+
+=== read/write register ===
+you can use "echo 'address' > sys/npu_debug/write" to read a register.address must 8 byte alignment.
+The 'address' has base addr 0xb0000000,so only npu register can be accessed.
+example : echo 00240048 > sys/npu_debug/write
+
+you can use "echo 'address value' > sys/npu_debug/write" to write value to a register in address.Both address and value must 8 byte alignment.
+example : echo 00240054 00000001 > sys/npu_debug/write
+
+=== dump some infomation ===
+you can  use "cat sys/npu_debug/read" to dump tx_header/bd_ctrl/bd_status/queue_status/rx_index and you can "cat sys/npu_debug/read" again to shutdown dump tx_header.
+
+=== enable npu debug log ===
+you can use "echo 'value' > sys/npu_debug/write" to enable some npu debug log.
+such as 0		 ---> tx_debug_log
+		00000001 ---> rx_debug_log
+		00000002 ---> irq_debug_log
+		00000003 ---> switch_debug_log
+		00000004 ---> poll_debug_log
+		00000005 ---> shutdown all log
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_debug.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_debug.c	2017-11-21 20:13:12.454710527 +0800
@@ -0,0 +1,670 @@
+/*************************************************************************
+	> File Name: sf_debug.h
+	> Author: Qin xia
+	> Mail: qin.xia@siflower.com.cn
+	> Created Time: 2017年01月19日 星期四 09时46分38秒
+ ************************************************************************/
+
+#include <linux/netdevice.h>
+#include <linux/kernel.h>
+#ifdef CONFIG_SFAX8_SWITCH_API
+#include "sf_api.h"
+#endif
+#include "sf_eth.h"
+#include "sf_debug.h"
+#include "sf_mdio.h"
+#ifdef CONFIG_SFAX8_SWITCH_VLAN
+#include "sf_switch.h"
+#endif
+#include "sf_eth_addr.h"
+
+int g_eth_init_debug = 1;
+int g_switch_init_debug = 1;
+int g_eth_poll_debug = 0;
+int g_eth_tx_debug = 0;
+int g_eth_rx_debug = 0;
+int g_eth_irq_debug = 0;
+int g_switch_debug = 0;
+int g_eth_reset_debug = 0;
+int g_i_tx_wake_time= 5;
+
+char lcp_configure[] = {
+	0xff,0xff,0xff,0xff,0xff,0xff,0x10,0x16,0x88,0xF5,0xC0,0x35,
+	0x81,0x00,0x00,0x02,
+	0x88,0x64,0x11,0x00,
+	0x00,0x03,0x00,0x10,0xc0,0x21,0x01,0x01,0x00,0x0e,0x01,0x04,0x05,0xd4,0x05,
+	0x06,0xf2,0x1c,0x5e,0x0a
+};
+
+extern struct sf_priv * g_sf_priv;
+void  print_msg(int mode, struct net_device *netdev, const char* fmt, ...)
+{
+	char * module_info = NULL;
+	char msg[1000] = {0};
+	va_list args;
+
+	switch (mode) {
+#ifdef SF_ETH_INIT_DEBUG
+		case ETH_INIT_DEBUG:
+			module_info = "INIT_INFO: ";
+			if(!g_eth_init_debug)
+			  return;
+			break;
+#endif
+
+#ifdef SF_ETH_POLL_DEBUG
+		case ETH_POLL_DEBUG:
+			module_info = "ETH_POLL_INFO: ";
+			if(!g_eth_poll_debug)
+			  return;
+			break;
+#endif
+
+#ifdef SF_ETH_TX_DEBUG
+#define SF_ETH_IRQ_DEBUG
+		case ETH_TX_DEBUG:
+			module_info = "ETH_TX_INFO: ";
+			if(!g_eth_tx_debug)
+			  return;
+			break;
+#endif
+
+#ifdef SF_ETH_RX_DEBUG
+#define SF_ETH_IRQ_DEBUG
+		case ETH_RX_DEBUG:
+			module_info = "ETH_RX_INFO: ";
+			if(!g_eth_rx_debug)
+			  return;
+			break;
+#endif
+
+#ifdef SF_ETH_IRQ_DEBUG
+		case ETH_IRQ_DEBUG:
+			module_info = "ETH_IRQ_INFO: ";
+			if(!g_eth_irq_debug)
+			  return;
+			break;
+#endif
+
+#ifdef SF_SWITCH_INIT_DEBUG
+		case SWITCH_INIT_DEBUG:
+			module_info = "SWITCH_INT_INFO: ";
+			if(!g_switch_init_debug)
+			  return;
+			break;
+#endif
+
+#ifdef SF_SWITCH_DEBUG
+		case SWITCH_DEBUG:
+			module_info = "SWITCH_INFO: ";
+			if(!g_switch_debug)
+			  return;
+			break;
+#endif
+
+#ifdef SF_ETH_RESET_DEBUG
+		case ETH_RESET_DEBUG:
+			module_info = "ETH_RESET_INFO: ";
+			if(!g_eth_reset_debug)
+			  return;
+			break;
+#endif
+
+		default:
+			return;
+	}
+
+	va_start(args, fmt);
+	vsprintf(msg, fmt, args);
+	netdev_info(netdev,"%s%s",module_info,msg);
+	va_end(args);
+
+}
+
+int dump_packet(unsigned char*buf , int len){
+	int i = 0;
+	printk("\n");
+	printk("======packet content=len is %d========\n",len);
+	for(;i < len; i++){
+		printk("0x%02x,", buf[i]);
+		if(((i+1)%16 == 0) && (i != 0)){
+			printk("\n");
+		}
+	}
+
+	printk("\n");
+	printk("==============dump end=============\n");
+	printk("\n");
+	return 0;
+}
+
+int sfax8_npu_debug_show(struct seq_file *m, void *v)
+{
+	seq_printf(m,"npu debug interface\n");
+	return 0;
+}
+
+int sfax8_npu_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sfax8_npu_debug_show, NULL);
+}
+
+//unsigned long g_address = 0;
+
+#ifdef NPU_FUNCS
+static int help =0;
+ssize_t sfax8_npu_debug_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	int enable = 0, ret = 0;
+
+	if(*ppos > 0)
+	  return 0;
+
+	if(!help){
+		ret = sprintf(buf, "%s\n", "\nHelp: Special function for NPU \
+					\nIn the sys/kernel/debug/ directories you can use 'echo xx > npu_debug' to choose which function to load \
+					\nlist for function: \
+					\n00 -- set global snoop special mac \
+					\n01 -- init global cutthru etype \
+					\n02 -- enable dos filter \
+					\n03 -- set dscp rule \
+					\n04 -- set global management ether type \
+					\n05 -- set port enable and set port vlan attribute \
+					\n06 -- set global snoop ethertype \
+					\n07 -- set port untag \
+					\n08 -- set valid prefix \
+					\n09 -- set tmu various configure \
+					\n0a -- set GPI ingress shaper configure \
+					\n0b -- set GPI flowcontrol \
+					\n0c -- set mac addr filter"
+					);
+		*ppos += ret;
+		return ret;
+	}
+	else{
+		enable = help - 1;
+	}
+	switch (enable) {
+		case SET_SPL_MAC:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+						\nExample:echo 00 00 01 3960c2000000 fffffffffff0 > write \
+						\n00 -- @enable this function \
+						\n00 -- @index decide which mac addr rejiester to choose, 0 for reg1, 1 for reg2 \
+						\n01 -- @ENABLE bit for snoop control register, 1 for enable, 0 for shutdown, always set to 1 \
+						\n3960c2000000 -- @mac mac addr \
+						\nfffffffffff0 -- @mask mask value \
+						\ncomments:you can call this function twice at most"
+						);
+			break;
+
+		case INIT_GLB_CUTTHRU:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+						\nExample:echo 01 99 > write \
+						\n01 -- @enable this function \
+						\n99 -- @cutthru_type cutthru type \
+						\ncomments:port always set to 0x3f"
+						);
+			break;
+
+		case SET_DOS_FIL:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function\n \
+						\nExample:echo 02 00 01 > write \
+						\n02 -- @enable this function \
+						\n00 -- @item decide dos filter type \
+						\n01 -- @value value set to register \
+						\nsuch as item 00 -- DOS_ENABLE -- value --01 \
+						\n        item 01 -- DOS_FILTER_ENABLE -- value --00 -- IPV4_SIP_EQ_DIP_EN \
+						\n                                                01 -- IPV4_ICMP_FRAG_EN \
+						\n                                                02 -- IPV4_ICMP_PING_TOO_BIG_EN \
+						\n                                                03 -- IPV4_UDP_SP_EQ_DP_EN \
+						\n                                                04 -- IPV4_TCP_FLAG_CHK \
+						\n                                                05 -- IPV4_TCP_SP_EQ_DP \
+						\n                                                06 -- IPV4_TCP_FRAG_OFF1 \
+						\n                                                07 -- IPV4_TCP_SYN_ERR \
+						\n                                                08 -- IPV4_TCP_XMAS \
+						\n                                                09 -- IPV4_TCP_NULL \
+						\n        item 02 -- DOS_COMB_FILTER_ENABLE -- value -- 00 -- COMB_FILTER_1 \
+						\n                                                      01 -- COMB_FILTER_2 \
+						\n                                                      02 -- COMB_FILTER_3 \
+						\n                                                      03 -- COMB_FILTER_4 \
+						\n        item 03 -- DOS_COMB_FILTER_VALUE -- value \
+						\n        item 04 -- DOS_ICMPV4_MAX_LEN -- value \
+						\ncomments:the value of IPV6 is omitted in DOS_FILTER_ENABLE,and you can call this function many times"
+						);
+			break;
+
+		case SET_DSCP_RULE:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+						\nExample:echo 03 00 > write \
+						\n03 -- @enable this function \
+						\n00 -- @port port number"
+						);
+			break;
+
+		case SET_GLB_MGMT_ETYE:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+						\nExample:echo 04 00 8100 > write \
+						\n04   -- @enable this function \
+						\n00   -- @port port number \
+						\n8100 -- @mgmt_etype global management ether type"
+						);
+			break;
+
+		case SET_PORT_CTL:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+						\nExample:echo 05 00 01 02 > write \
+						\n05 -- @enable this function \
+						\n00 -- @port port number \
+						\n01 -- @ENABLE 0 for shutdown, 1 for enable \
+						\n02 -- @attr set port vlan attribute \
+						\n      00 -- ANY_TAGGING \
+						\n      01 -- TAGGED_ONLY \
+						\n      02 -- UNTAGGED_ONLY"
+						);
+			break;
+
+		case SET_SNOOP_ETYE:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+						\nExample:echo 06 08 01 8623 > write \
+						\n06 -- @enable this function \
+						\n08 -- @idx decide snoop ethertype module \
+						\n      04 -- SNOOP_IGMP \
+						\n      05 -- SNOOP_MLDV2 \
+						\n      08 -- SNOOP_ETYPE0 \
+						\n      09 -- SNOOP_ETYPE1 \
+						\n      0a -- SNOOP_ETYPE2 \
+						\n      0b -- SNOOP_ETYPE3 \
+						\n      0c -- SNOOP_ETYPE_ARP \
+					\n      0d -- SNOOP_ETYPE_RARP \
+					\n      0e -- SNOOP_HOPOPTS \
+					\n01 -- @ENABLE 0 for shutdown, 1 for enable, always set to 1 \
+					\n8623 -- @snoop_etype decide snoop ethertype for SNOOP_ETYPE0/1/2/3,it is NULL for others"
+					);
+			break;
+
+		case SET_PORT_UNTAG:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+					\nExample:echo 07 05 > write \
+					\n07 -- @enable this function \
+					\n05 -- @port port number"
+					);
+			break;
+
+		case SET_VID_PFIX:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+					\nExample:echo 08 00 > write \
+					\n08 -- @enable this function \
+					\n00 -- @port port number"
+					);
+			break;
+
+		case SET_TMU_CFG:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+                    \nExample:echo 09 04 03fe 01 3ff000 00 64 01 02 64 3c 0a 14 1e 28 32 3c 46 50 3f > write \
+					\n09 -- @enable this function\n \
+					\n***for schduler set*** \
+					\n04 -- @tsch.tlsd_algo \
+					\n      00 -- Priority queue \
+					\n      02 -- DWRR \
+					\n      03 -- Round Robin \
+					\n      04 -- WRR \
+					\n03fe -- @tsch.tlsd_weight \
+					\n01 -- @tsch.tlsd_rate_units; 0 - data rate 1- packet rate\n \
+					\n***for shaper set*** \
+					\n3ff000 -- @tshp.tlsp_max_credit Maximum value of the credit that can accumulated per shaper \
+					\n00 -- @tshp.tlsp_rate_units 0 - data rate 1- packet rate \
+					\n64 -- @tshp.tlsp_rate Data rate for a given shaper packets per second or bits per second (Mbps) \
+					\n01 -- @tshp.tlsp_mode mode 0 for normal mode and 1 for credit mode\n \
+					\n***for class queue set*** \
+					\n02 -- @tque.tlcq_qmgmt 0 for NO_MGMT,1 for TMU_QUE_TAIL_DROP and 2 for TMU_QUE_WRED \
+					\n64 -- @tque.tlcq_max_len \
+					\n3c -- @tque.tlcq_min_len \
+					\n0a -- @tque.tlcq_prob_cfg0 If queue management is WRED,configure probability value cfg0 (max value 255) \
+					\n14 -- @tque.tlcq_prob_cfg1 as before \
+					\n1e -- @tque.tlcq_prob_cfg2 as before \
+					\n28 -- @tque.tlcq_prob_cfg3 as before \
+					\n32 -- @tque.tlcq_prob_cfg4 as before \
+					\n3c -- @tque.tlcq_prob_cfg5 as before \
+					\n46 -- @tque.tlcq_prob_cfg6 as before \
+					\n50 -- @tque.tlcq_prob_cfg7 as before \
+					\n3f -- @port_list \
+					\ncomment: If queue management is TMU_QUE_TAIL_DROP,the last will not be configured"
+					);
+			break;
+
+		case SET_GPI_INGRS_CFG:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+					\nExample:echo 0a 03ff00 00 64 00 09 > write \
+					\n0a -- @enable this function \
+					\n03ff00 -- @tshp.tlsp_max_credit Maximum value of the credit that can accumulated per shaper \
+					\n00 -- @tshp.tlsp_rate_units 0 - data rate 1- packet rate \
+					\n64 -- @tshp.tlsp_rate Data rate for a given shaper packets per second or bits per second (Mbps) \
+					\n00 -- @dev_no device number \
+					\n09 -- @effect Bits [1:0] value 00 Shaper0 is for port level data rate, value 01 Shaper0 is for BCAST Packets, value 10 Shaper0 is for MCAST Packets\
+					\n              Bits [3:2] value 00 Shaper1 is for port level data rate, value 01 Shaper1 is for BCAST Packets, value 10 Shaper1 is for MCAST Packets"
+					);
+			break;
+
+		case SET_GPI_FLW_CTL:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+					\nExample:echo 0b 00 0a 14 32 64>write \
+					\n0b -- @enable this function \
+					\n00 -- @dev_no device number \
+					\n0a -- @bmu_low_watermark \
+					\n14 -- @bmu_high_watermark \
+					\n32 -- @phy_low_watermark \
+					\n64 -- @phy_high_watermark"
+					);
+			break;
+
+		case SET_MAC_ADDR_FIL:
+			ret = sprintf(buf, "%s\n", "\nUsage:you can use 'echo xx > npu_debug' to pass parameters to this function \
+					\nExample:echo 0c 3960c2000000 > write \
+					\n0c -- @enable this function \
+					\n3960c2000000 -- @mac mac addr"
+					);
+			break;
+
+		default:
+			ret = sprintf(buf, "%s\n", "input error");
+	}
+
+	*ppos += ret;
+	return ret;
+}
+
+/*calling the write node will execute following function.
+ * @buf a pointer to the buf which we input,we transfer the buf to arg[20] (2 bits of buf corresponding to 1 bit of arg[20]).
+ * The arg[20] contain arguments we need;
+ * arg[0] == enable; decide which module to load;
+ * @count length of buf
+ *
+ * */
+ssize_t sfax8_npu_debug_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	int a = 0, i = 0, j = 0, ret = 0, enable = 0;
+	const char *str = buf;
+	char tmp_str[13] = {'\0'};
+	unsigned long long arg[20] = {0};
+	tmu_schd_params_t tsch;
+	tmu_shpr_params_t tshp;
+	tmu_classq_params_t tque;
+
+	if(count){
+		for(i = 1;i < count;i++){
+			if(buf[i-1] == ' '){
+				memcpy(tmp_str, str, (i-a-1));
+				ret = kstrtoull(tmp_str, 16, &arg[j]);
+				if(ret == -EINVAL)
+					goto err_parsing;
+				else if(ret == -ERANGE)
+					goto err_overflow;
+				memset(tmp_str,'\0',sizeof(tmp_str));
+				str = buf + i;
+				a = i;
+				j++;
+			}
+		}
+
+		ret = kstrtoull(str, 16, &arg[j]);
+		if(ret == -EINVAL)
+			goto err_parsing;
+		else if(ret == -ERANGE)
+			goto err_overflow;
+
+		enable = arg[0];
+	}
+	else
+		return count;
+
+	if(count == 3){
+		help = enable + 1;
+		printk("you can use 'cat npu_debug'  again to get more information about how to use this function\n");
+		return count;
+	}
+
+	/*Switch to select function module*/
+	switch (enable) {
+		case SET_SPL_MAC:
+			/*punt special mac packet to host*/
+			set_global_snoop_special_mac(arg[1], (arg+2), (arg+3), arg[4]);
+			break;
+
+		case INIT_GLB_CUTTHRU:
+			/*init global cutthru list
+			 *indicates etype/tpid will be rewritten on some egress ports */
+			set_cutthru(0x3f, arg[1]);
+			break;
+
+		case SET_DOS_FIL:
+			/*enable dos filter*/
+			set_dos_value(arg[1], arg[2]);
+			break;
+
+		case SET_DSCP_RULE:
+			// pcp0 ==> map bit 0:2 ==> tc 0
+			set_pcp2tc_map(arg[1],0xFAC688);
+			//port 0 => 0 port 6 ==6
+			set_pid2tc_map(0xFAC688);
+			set_tc_sel_one_to_one(arg[1], TC_MACDA);
+			break;
+
+		case SET_GLB_MGMT_ETYE:
+			/*set global management ether type*/
+			set_global_mgmt_port(arg[1], arg[2]);
+			break;
+
+		case SET_PORT_CTL:
+			/*set port enable && set port vlan attribute*/
+			set_port_enable(arg[1], arg[2]);
+			set_port_vlan_attr(arg[1], arg[3]);
+			break;
+
+		case SET_SNOOP_ETYE:
+			//set to reg 1
+			set_global_snoop_ethertype(arg[1],(arg+2),arg[3]);
+			break;
+
+		case SET_PORT_UNTAG:
+			set_port_untag(arg[1]);
+			break;
+
+		case SET_VID_PFIX:
+			set_port_vid_prefix(arg[1]);
+			break;
+
+		case SET_TMU_CFG:
+			//for schduler set
+			tsch.tlsd_algo = arg[1];
+			tsch.tlsd_weight = arg[2];
+			tsch.tlsd_rate_units = arg[3];
+			// for shaper set
+			tshp.tlsp_max_credit = arg[4];
+			tshp.tlsp_rate_units = arg[5];
+			tshp.tlsp_clk_frequency = 250; //mhz
+			tshp.tlsp_rate = arg[6] * 1000; /* kbps */
+			tshp.tlsp_mode = arg[7]; /*0x1-credit based mode */
+			//for class queue set
+			tque.tlcq_qmgmt	= arg[8];
+			tque.tlcq_max_len = arg[9];
+			tque.tlcq_min_len = arg[10];
+			if(tque.tlcq_qmgmt == TMU_QUE_WRED) {
+				tque.tlcq_prob_cfg0 = arg[11];
+				tque.tlcq_prob_cfg1 = arg[12];
+				tque.tlcq_prob_cfg2 = arg[13];
+				tque.tlcq_prob_cfg3 = arg[14];
+				tque.tlcq_prob_cfg4 = arg[15];
+				tque.tlcq_prob_cfg5 = arg[16];
+				tque.tlcq_prob_cfg6 = arg[17];
+				tque.tlcq_prob_cfg7 = arg[18];
+			}
+			else {
+				tque.tlcq_qmgmt = TMU_QUE_TAIL_DROP;
+			}
+
+			set_tmu_various_cfg(&tsch, &tshp, &tque, arg[19]);
+			break;
+
+		case SET_GPI_INGRS_CFG:
+			tshp.tlsp_max_credit = arg[1];
+			tshp.tlsp_rate_units = arg[2];
+			tshp.tlsp_clk_frequency = 250; //mhz
+			tshp.tlsp_rate = arg[3] * 1000; /* kbps */
+			npu_gpi_ingress_config(&tshp,arg[4],arg[5]);
+			break;
+
+		case SET_GPI_FLW_CTL:
+			set_bmu_watermark(arg[2], arg[3]);
+			init_gpi_fw_control(arg[1], arg[4], arg[5]);
+			break;
+
+		case SET_MAC_ADDR_FIL:
+			sf_writel(arg[1], REG_EMAC_FILTER(0)); //set_SA_DA_model
+			gmac_set_mac_addr1(arg+2);
+			break;
+
+		default:
+			break;
+	}
+	printk("from user,length=%d,content=%s\n",count,buf);
+	return count;
+
+err_parsing:
+	printk("parsing Error,please check your input!\n");
+err_overflow:
+	printk("convert overflow,please check your input!\n");
+
+	return count;
+}
+#else
+
+int send_pkt(char* buf, int len){
+	struct sk_buff *tmp_skb = dev_alloc_skb(MAX_FRAME_SIZE);
+	printk("============sent pppoe package len : %d=============l\n",len);
+	memcpy(tmp_skb->data, buf, len);
+	memcpy(tmp_skb->data + 6, g_sf_priv->netdev->dev_addr,6);
+	skb_put(tmp_skb, len);
+	sf_eth_xmit(tmp_skb,g_sf_priv->netdev);
+	// dev_queue_xmit(tmp_skb);
+	return 0;
+}
+
+ssize_t sfax8_npu_debug_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+/*	int i = 0;
+	struct bd *tmp_txd;
+	int status = netif_queue_stopped(g_sf_priv->netdev) ? 1 : 0;
+	printk("tmp_txd_index %d tmp_free_index %d tmp_rxd_index %d queue status %d\n",g_sf_priv->txd_index, g_sf_priv->txd_free_index, g_sf_priv->rxd_index,status);
+
+	for (i =0; i < 64; i++){
+		tmp_txd = g_sf_priv->tx_bd_tbl + i;
+		printk("index %d bd_ctrl 0x%08x bd_status 0x%08x\n",i, tmp_txd->bd_ctrl, tmp_txd->bd_status);
+	}
+
+	return sprintf(buf, "dump importent information \n");
+*/
+	int i, port_status, ret = 0;
+
+	if(*ppos > 0)
+	  return 0;
+
+	printk("check phy link status\n");
+	for(i = 0; i < 5; i++){
+		port_status = check_phy_linkup(i, g_sf_priv);
+		ret += sprintf(buf+ret, "phy%d    status %d\n", i, port_status);
+		*ppos += ret;
+	}
+
+	return ret;
+}
+
+ssize_t sfax8_npu_debug_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	unsigned long addr = 0, value = 0, i = 0, j = 0, ret = 0, last_i = 0, index_arg = 0;
+	char str[4][11] = {'\0'};
+
+	if(!count)
+	  return count;
+
+	// printk("cmd is %s\n", buf);
+
+	for(;i < count;i++){
+		if(buf[i] == ' '){
+			memcpy(str[index_arg], buf + last_i, i - last_i);
+			last_i=(i + 1);
+			index_arg++;
+		}
+	}
+	memcpy(str[index_arg], buf + last_i, count - last_i);
+	// printk("str1 %s str2 %s str3 %s str4 %s\n",str[0],str[1],str[2],str[3]);
+	ret = kstrtoul(str[0], 0, &addr);
+	if(ret == -EINVAL)
+	  goto err_parsing;
+	else if(ret == -ERANGE)
+	  goto err_overflow;
+
+	if (addr == 0){
+		g_eth_tx_debug = 1;
+	} else if (addr == 1){
+		g_eth_rx_debug = 1;
+	} else if (addr == 2){
+		g_eth_irq_debug = 1;
+	} else if (addr == 3){
+		g_switch_debug = 1;
+	} else if (addr == 4){
+		g_eth_poll_debug = 1;
+	} else if (addr == 5){
+		g_eth_poll_debug = 0;
+		g_eth_tx_debug = 0;
+		g_eth_rx_debug = 0;
+		g_eth_irq_debug = 0;
+		g_eth_reset_debug = 0;
+		g_switch_debug = 0;
+	} else if (addr == 6){
+		if(netif_queue_stopped(g_sf_priv->netdev))
+			netif_wake_queue(g_sf_priv->netdev);
+	} else if (addr == 7){
+		for (j = 0; j < 16; j++)
+			printk("dump buffer occupide by master%ld,read address 0x%lx, value 0x%x\n",j, (0x240060 + 4*j), sf_readl(0x240060 + 4*j));
+	} else if (addr == 8){
+		unsigned long phy_num=0, phy_addr=0, phy_value=0;
+		ret = kstrtoul(str[1], 0, &phy_num);
+		ret = kstrtoul(str[2], 0, &phy_addr);
+		if(str[3][0] != '\0'){
+			ret = kstrtoul(str[3], 0, &phy_value);
+			write_phy_reg(phy_num, phy_addr , phy_value , g_sf_priv->phy_dev);
+			printk("write phy %ld address %ld write value 0x%lx\n", phy_num, phy_addr, phy_value);
+		}else
+			printk("dump phy %ld address %ld read value 0x%x\n", phy_num, phy_addr, read_phy_reg(phy_num, phy_addr , g_sf_priv->phy_dev));
+
+	} else if (addr == 9){
+		ret = kstrtoul(str[1], 0, &value);
+		if(ret == -EINVAL)
+			goto err_parsing;
+		else if(ret == -ERANGE)
+			goto err_overflow;
+#ifdef CONFIG_SFAX8_SWITCH_POWERSAVE
+		sf_phy_energy_detect_disable(value, g_sf_priv->phy_dev);
+		printk("disable phy%ld energy detect mdoe\n",value);
+#else
+		g_i_tx_wake_time = value;
+		printk("set tx waketime %ld ms\n",value);
+#endif
+	} else if (addr == 0xa){
+		send_pkt(lcp_configure, sizeof(lcp_configure));
+	} else if (addr == 0xb){
+		g_eth_reset_debug = 1;
+	} else{
+
+		printk("error args\n");
+	}
+	return count;
+
+err_parsing:
+	printk("parsing Error,please check your input!\n");
+err_overflow:
+	printk("convert overflow,please check your input!\n");
+
+	return count;
+}
+#endif
Index: linux-3.18.29/drivers/net/ethernet/siflower/sf_debug.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/sf_debug.h	2017-11-21 20:13:12.454710527 +0800
@@ -0,0 +1,29 @@
+/*************************************************************************
+	> File Name: drivers/net/ethernet/siflower/sf_debug.h
+	> Author: Qin xia
+	> Mail: qin.xia@siflower.com.cn
+	> Created Time: 2017年01月21日 星期六 10时48分13秒
+ ************************************************************************/
+
+#include <linux/netdevice.h>
+#include <linux/kernel.h>
+#include "sf_common.h"
+
+enum DEBUG_MODL {
+	ETH_INIT_DEBUG,
+	ETH_POLL_DEBUG,
+	ETH_TX_DEBUG,
+	ETH_RX_DEBUG,
+	ETH_IRQ_DEBUG,
+	SWITCH_INIT_DEBUG,
+	SWITCH_DEBUG,
+	ETH_RESET_DEBUG,
+};
+
+void  print_msg(int mode, struct net_device *netdev, const char* fmt, ...);
+int sfax8_npu_debug_show(struct seq_file *m, void *v);
+int sfax8_npu_debug_open(struct inode *inode, struct file *file);
+ssize_t sfax8_npu_debug_read(struct file *file, char __user *buf, size_t count, loff_t *ppos);
+ssize_t sfax8_npu_debug_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos);
+
+extern int g_i_tx_wake_time;
Index: linux-3.18.29/net/mac80211/main.c
===================================================================
--- linux-3.18.29.orig/net/mac80211/main.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/net/mac80211/main.c	2017-11-21 20:13:12.454710527 +0800
@@ -796,7 +796,8 @@
 
 			comb = &local->hw.wiphy->iface_combinations[i];
 
-			if (comb->radar_detect_widths)
+			if (comb->radar_detect_widths &&
+                    comb->num_different_channels > 1)
 				return -EINVAL;
 		}
 	}
Index: linux-3.18.29/drivers/phy/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/phy/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/phy/Kconfig	2017-11-21 20:13:12.454710527 +0800
@@ -204,6 +204,14 @@
 	  This driver provides PHY interface for USB 3.0 DRD controller
 	  present on Exynos5 SoC series.
 
+config PHY_SFAX8_USB
+	tristate "SIFLOWER sfax8 USB2.0 PHY driver"
+	default n
+	depends on SIFLOWER
+	select GENERIC_PHY
+	help
+	  Enable this to support the USB2.0 PHY on the SIFLOWER sfax8 SoC.
+
 config PHY_QCOM_APQ8064_SATA
 	tristate "Qualcomm APQ8064 SATA SerDes/PHY driver"
 	depends on ARCH_QCOM
Index: linux-3.18.29/drivers/phy/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/phy/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/phy/Makefile	2017-11-21 20:13:12.454710527 +0800
@@ -31,3 +31,4 @@
 obj-$(CONFIG_PHY_XGENE)			+= phy-xgene.o
 obj-$(CONFIG_PHY_STIH407_USB)		+= phy-stih407-usb.o
 obj-$(CONFIG_PHY_STIH41X_USB)		+= phy-stih41x-usb.o
+obj-$(CONFIG_PHY_SFAX8_USB)		+= phy-sfax8-usb.o
Index: linux-3.18.29/drivers/pinctrl/pinctrl-sfax8.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/pinctrl/pinctrl-sfax8.c	2017-11-21 20:13:12.454710527 +0800
@@ -0,0 +1,1573 @@
+/*
+ * Driver for Broadcom SFAX8 GPIO unit (pinctrl + GPIO)
+ *
+ * Copyright (C) 2012 Chris Boot, Simon Arlott, Stephen Warren
+ *
+ * This driver is inspired by:
+ * pinctrl-nomadik.c, please see original file for copyright information
+ * pinctrl-tegra.c, please see original file for copyright information
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/bitmap.h>
+#include <linux/bug.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqdesc.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include <linux/clk.h>
+#include <linux/mfd/syscon.h>
+
+#include "core.h"
+#include "pinconf.h"
+#include "pinctrl-sfax8.h"
+
+#ifdef CLIB
+#include <stdio.h>
+#include <string.h>
+#endif
+
+#define MODULE_NAME "pinctrl-sfax8"
+#define SFAX8_NUM_GPIOS (PAD_INDEX_MAX + 1)
+#define SFAX8_NUM_BANKS 4
+#define SFAX8_GPIOS_PER_BANK 16
+
+#define SFAX8_PIN_BITMAP_SZ \
+	DIV_ROUND_UP(SFAX8_NUM_GPIOS, sizeof(unsigned long) * 8)
+
+/* GPIO register offsets */
+#if 1
+#define GPFSEL0		0x0	/* Function Select */
+#define GPSET0		0x1c	/* Pin Output Set */
+#define GPCLR0		0x28	/* Pin Output Clear */
+#define GPLEV0		0x34	/* Pin Level */
+#define GPEDS0		0x40	/* Pin Event Detect Status */
+#define GPREN0		0x4c	/* Pin Rising Edge Detect Enable */
+#define GPFEN0		0x58	/* Pin Falling Edge Detect Enable */
+#define GPHEN0		0x64	/* Pin High Detect Enable */
+#define GPLEN0		0x70	/* Pin Low Detect Enable */
+#define GPAREN0		0x7c	/* Pin Async Rising Edge Detect */
+#define GPAFEN0		0x88	/* Pin Async Falling Edge Detect */
+#define GPPUD		0x94	/* Pin Pull-up/down Enable */
+#define GPPUDCLK0	0x98	/* Pin Pull-up/down Enable Clock */
+#endif
+#define FSEL_REG(p)		(GPFSEL0 + (((p) / 10) * 4))
+#define FSEL_SHIFT(p)		(((p) % 10) * 3)
+#define GPIO_REG_OFFSET(p)	((p) / 32)
+#define GPIO_REG_SHIFT(p)	((p) % 32)
+
+enum sfax8_pinconf_param {
+	/* argument: sfax8_pinconf_pull */
+	SFAX8_PINCONF_PARAM_PULL,
+};
+
+enum sfax8_pinconf_pull {
+	SFAX8_PINCONFIG_PULL_NONE,
+	SFAX8_PINCONFIG_PULL_DOWN,
+	SFAX8_PINCONFIG_PULL_UP,
+};
+
+#define SFAX8_PINCONF_PACK(_param_, _arg_) ((_param_) << 16 | (_arg_))
+#define SFAX8_PINCONF_UNPACK_PARAM(_conf_) ((_conf_) >> 16)
+#define SFAX8_PINCONF_UNPACK_ARG(_conf_) ((_conf_) & 0xffff)
+
+#define IOMUX_GPIO_ONLY		BIT(0)
+#define IOMUX_WIDTH_4BIT	BIT(1)
+#define IOMUX_SOURCE_PMU	BIT(2)
+#define IOMUX_UNROUTED		BIT(3)
+
+#define PIN_BANK(id, pins, label)			\
+	{						\
+		.bank_num	= id,			\
+		.nr_pins	= pins,			\
+		.name		= label,		\
+		.iomux		= {			\
+			{ .offset = -1 },		\
+			{ .offset = -1 },		\
+			{ .offset = -1 },		\
+			{ .offset = -1 },		\
+		},					\
+	}
+
+struct sfax8_gpio_irqdata {
+	struct sfax8_pinctrl *pc;
+	int bank;
+};
+
+enum siflower_pinctrl_type {
+	sfax8,
+};
+
+struct siflower_iomux {
+	int				type;
+	int				offset;
+};
+
+struct siflower_pin_bank {
+	void __iomem			*reg_base;
+	struct regmap			*regmap_pull;
+	struct clk			*clk;
+	int				irq;
+	u32				pin_base;
+	u8				nr_pins;
+	char				*name;
+	u8				bank_num;
+	struct siflower_iomux		iomux[4];
+	bool				valid;
+	struct device_node		*of_node;
+	struct sfax8_pinctrl		*drvdata;
+	struct irq_domain		*domain;
+	struct gpio_chip		gpio_chip;
+	struct pinctrl_gpio_range	grange;
+	spinlock_t			slock;
+	u32				toggle_edge_mode;
+};
+
+struct siflower_pin_config {
+	unsigned int		func;
+	unsigned long		*configs;
+	unsigned int		nconfigs;
+};
+
+struct siflower_pin_ctrl {
+	struct siflower_pin_bank	*pin_banks;
+	u32				nr_banks;
+	u32				nr_pins;
+	char				*label;
+	enum siflower_pinctrl_type	type;
+	int				grf_mux_offset;
+	int				pmu_mux_offset;
+	void	(*pull_calc_reg)(struct siflower_pin_bank *bank,
+				    int pin_num, struct regmap **regmap,
+				    int *reg, u8 *bit);
+};
+
+struct siflower_pin_group {
+	const char			*name;
+	unsigned int			npins;
+	unsigned int			*pins;
+	struct siflower_pin_config	*data;
+};
+
+struct siflower_pmx_func {
+	const char		*name;
+	const char		**groups;
+	u8			ngroups;
+};
+
+struct sfax8_pinctrl {
+	struct device *dev;
+	void __iomem *base;
+	int irq[SFAX8_NUM_BANKS];
+
+	/* note: locking assumes each bank will have its own unsigned long */
+	unsigned long enabled_irq_map[SFAX8_NUM_BANKS];
+	unsigned int irq_type[SFAX8_NUM_GPIOS];
+
+	struct pinctrl_dev *pctl_dev;
+	struct irq_domain *irq_domain;
+	struct gpio_chip gpio_chip;
+	struct pinctrl_gpio_range gpio_range;
+
+	struct sfax8_gpio_irqdata irq_data[SFAX8_NUM_BANKS];
+	spinlock_t irq_lock[SFAX8_NUM_BANKS];
+
+	struct regmap			*regmap_base;
+	int				reg_size;
+	struct regmap			*regmap_pull;
+	struct regmap			*regmap_pmu;
+	struct siflower_pin_ctrl	*ctrl;
+	struct pinctrl_desc		pctl;
+	struct siflower_pin_group	*groups;
+	unsigned int			ngroups;
+	struct siflower_pmx_func	*functions;
+	unsigned int			nfunctions;
+};
+
+static struct lock_class_key gpio_lock_class;
+
+/* pins are just named GPIO0..GPIO62 */
+#define SFAX8_GPIO_PIN(a) PINCTRL_PIN(a, "gpio" #a)
+
+static const char * const irq_type_names[] = {
+	[IRQ_TYPE_NONE] = "none",
+	[IRQ_TYPE_EDGE_RISING] = "edge-rising",
+	[IRQ_TYPE_EDGE_FALLING] = "edge-falling",
+	[IRQ_TYPE_EDGE_BOTH] = "edge-both",
+	[IRQ_TYPE_LEVEL_HIGH] = "level-high",
+	[IRQ_TYPE_LEVEL_LOW] = "level-low",
+};
+
+static inline struct siflower_pin_bank *gc_to_pin_bank(struct gpio_chip *chip)
+{
+	return container_of(chip, struct siflower_pin_bank, gpio_chip);
+}
+
+/**************************************************************************************************
+*                                                                                                 *
+* -Description:                                                                                   *
+*    This part is used to set pin funciton.                                                       *
+*                                                                                                 *
+***************************************************************************************************/
+int sfax8_pad_set_func(struct sfax8_pinctrl *info, u32 index, pad_func func)
+{
+	int tmp;
+	int mod_cnt = 0;
+	int mod_num = 0;
+	int fun_cnt = 0;
+	int fun_num = 0;
+	u32 gpio_base = (u32)info->base;
+
+	if(index > PAD_INDEX_MAX)
+		return -EINVAL;
+
+	fun_cnt = index / 8;
+	fun_num = index % 8;
+	mod_cnt = index / PAD_PER_GROUP_PINS;
+	mod_num = index % PAD_PER_GROUP_PINS;
+
+	switch (func)
+	{
+		case FUNC0:
+		case FUNC1:
+		case FUNC2:
+		case FUNC3:
+		regmap_read(info->regmap_base, PAD_FUCN_SEL(fun_cnt), &tmp);
+		tmp &= ~(1 << fun_num);
+		regmap_write(info->regmap_base, PAD_FUCN_SEL(fun_cnt), tmp);
+
+		regmap_read(info->regmap_base, PAD_MODE_SEL(mod_cnt), &tmp);
+		tmp &= ~(0x3 << (mod_num * 2));
+		tmp |= (func << (mod_num * 2));
+		regmap_write(info->regmap_base, PAD_MODE_SEL(mod_cnt), tmp);
+		break;
+
+		case GPIO_INPUT:
+		regmap_read(info->regmap_base, PAD_FUCN_SEL(fun_cnt), &tmp);
+		tmp |= 1 << fun_num;
+		regmap_write(info->regmap_base, PAD_FUCN_SEL(fun_cnt), tmp);
+
+		writeb(1,(void *) (GPIO_DIR(index) + gpio_base));
+		break;
+
+		case GPIO_OUTPUT:
+		regmap_read(info->regmap_base, PAD_FUCN_SEL(fun_cnt), &tmp);
+		tmp |= 1 << fun_num;
+		regmap_write(info->regmap_base, PAD_FUCN_SEL(fun_cnt), tmp);
+
+		writeb(0,(void *) (GPIO_DIR(index) + gpio_base));
+		break;
+
+		default:
+		printk("sfax8_pad_set_func error! index:%d func:%d \n", index, func);
+		return -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sfax8_pad_set_func);
+
+/**************************************************************************************************
+*                                                                                                 *
+* -Description:                                                                                   *
+*    This part is used to get pin function.                                                       *
+*                                                                                                 *
+***************************************************************************************************/
+pad_func sfax8_pad_get_func(struct sfax8_pinctrl *info, u32 index)
+{
+	int tmp;
+	int fun_cnt = 0;
+	int fun_num = 0;
+	int mod_cnt = 0;
+	int mod_num = 0;
+	u32 gpio_base = (u32)info->base;
+
+	if(index > PAD_INDEX_MAX)
+		return -EINVAL;
+
+	fun_cnt = index / 8;
+	fun_num = index % 8;
+	mod_cnt = index / PAD_PER_GROUP_PINS;
+	mod_num = index / PAD_PER_GROUP_PINS;
+
+	regmap_read(info->regmap_base, PAD_FUCN_SEL(fun_cnt), &tmp);
+	if (tmp & (1 << fun_num))
+	{
+		tmp = readb((void *)(GPIO_DIR(index) + gpio_base));
+		if (tmp)
+			return GPIO_OUTPUT;
+		else
+			return GPIO_INPUT;
+	}
+	else
+	{
+		regmap_read(info->regmap_base, PAD_MODE_SEL(mod_cnt), &tmp);
+		switch((tmp & (0x11 <<mod_num)) >> mod_num)
+		{
+			case 0:
+			return FUNC0;
+			break;
+
+			case 1:
+			return FUNC1;
+			break;
+
+			case 2:
+			return FUNC2;
+			break;
+
+			case 3:
+			return FUNC3;
+			break;
+
+			default:
+			printk("sfax8_pad_get_func error! index:%d func:%d \n", index, tmp);
+			return FUNC0;
+			break;
+		}
+
+	}
+}
+
+/**************************************************************************************************
+*                                                                                                 *
+* -Description:                                                                                   *
+*    This part is used to set pin pull type.                                                      *
+*                                                                                                 *
+***************************************************************************************************/
+int sfax8_pad_set_pull(struct regmap *regmap_base, u32 index, pad_pull pull)
+{
+	int tmp = 0;
+	int cnt = 0;
+	int num = 0;
+
+	if(index > PAD_INDEX_MAX)
+		return -EINVAL;
+
+	cnt = index / 8;
+	num = index % 8;
+
+	switch (pull)
+	{
+		case NOPULL:
+		regmap_read(regmap_base, PAD_IO_PULLUP(cnt), &tmp);
+		tmp &= ~(1 << num);
+		regmap_write(regmap_base, PAD_IO_PULLUP(cnt), tmp);
+
+		regmap_read(regmap_base, PAD_IO_PULLDOWN(cnt), &tmp);
+		tmp &= ~(1 << num);
+		regmap_write(regmap_base, PAD_IO_PULLDOWN(cnt), tmp);
+		break;
+
+		case PULLUP:
+		regmap_read(regmap_base, PAD_IO_PULLDOWN(cnt), &tmp);
+		tmp &= ~(1 << num);
+		regmap_write(regmap_base, PAD_IO_PULLDOWN(cnt), tmp);
+
+		regmap_read(regmap_base, PAD_IO_PULLUP(cnt), &tmp);
+		tmp |= (1 << num);
+		regmap_write(regmap_base, PAD_IO_PULLUP(cnt), tmp);
+		break;
+
+		case PULLDOWN:
+		regmap_read(regmap_base, PAD_IO_PULLUP(cnt), &tmp);
+		tmp &= ~(1 << num);
+		regmap_write(regmap_base, PAD_IO_PULLUP(cnt), tmp);
+
+		regmap_read(regmap_base, PAD_IO_PULLDOWN(cnt), &tmp);
+		tmp |= (1 << num);
+		regmap_write(regmap_base, PAD_IO_PULLDOWN(cnt), tmp);
+		break;
+
+		default:
+		return -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+
+/**************************************************************************************************
+*                                                                                                 *
+* -Description:                                                                                   *
+*    This part is used to get pin pull type.                                                      *
+*                                                                                                 *
+***************************************************************************************************/
+pad_pull sfax8_pad_get_pull(struct regmap *regmap_base, u32 index)
+{
+	int tmpu = 0,tmpd = 0,tmp = 0;
+	int cnt = 0;
+	int num = 0;
+
+	if(index > PAD_INDEX_MAX)
+		return -EINVAL;
+
+
+	cnt = index / 8;
+	num = index % 8;
+
+	regmap_read(regmap_base, PAD_IO_PULLUP(cnt), &tmp);
+	tmpu = tmp & (1 << num);
+
+	regmap_read(regmap_base, PAD_IO_PULLDOWN(cnt), &tmp);
+	tmpd = tmp & (1 << num);
+
+	if((tmpu > 0) && (tmpd == 0))
+		return PULLUP;
+	else if((tmpu == 0) && (tmpd > 0))
+		return PULLDOWN;
+	else if((tmpu == 0) && (tmpd == 0))
+		return NOPULL;
+	else
+	{
+		printk("sf pad_%d pull status error!!\n",index);
+		return -EINVAL;
+	}
+}
+
+/**************************************************************************************************
+*                                                                                                 *
+* -Description:                                                                                   *
+*    This part is used to set pin output level.                                                   *
+*                                                                                                 *
+***************************************************************************************************/
+int sfax8_pad_set_value(struct sfax8_pinctrl *info, u32 index, pad_output_level level)
+{
+	u32 reg_base = (u32)info->base;
+
+	if(index > PAD_INDEX_MAX)
+		return -EINVAL;
+
+	writeb(level,(void *) (reg_base + GPIO_WDAT(index)));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sfax8_pad_set_value);
+
+/**************************************************************************************************
+*                                                                                                 *
+* -Description:                                                                                   *
+*    This part is used to get pin output level.                                                   *
+*                                                                                                 *
+***************************************************************************************************/
+u32 sfax8_pad_get_value(struct sfax8_pinctrl *info, u32 index)
+{
+	int tmp;
+	u8 tmp_gpio;
+	int cnt = 0;
+	int num = 0;
+	int level = 0;
+	u32 gpio_base = (u32)info->base;
+
+	if(index > PAD_INDEX_MAX)
+		return -EINVAL;
+
+	cnt = index / 8;
+	num = index % 8;
+
+	regmap_read(info->regmap_base, PAD_FUCN_SEL(cnt), &tmp);
+	if (tmp & (1 << num))
+	{
+		tmp_gpio = readb((void *)(gpio_base + GPIO_DIR(index)));
+		if (tmp_gpio)
+			level = readb((void *)(gpio_base + GPIO_RDAT(index)));
+		else
+			level = readb((void *)(gpio_base + GPIO_WDAT(index)));
+	}
+
+	return level;
+}
+
+static inline u32 sfax8_gpio_rd(struct sfax8_pinctrl *pc, unsigned reg)
+{
+	return readl(pc->base + reg);
+}
+
+static inline void sfax8_gpio_wr(struct sfax8_pinctrl *pc, unsigned reg,
+		u32 val)
+{
+	writel(val, pc->base + reg);
+}
+
+static inline enum sfax8_fsel sfax8_pinctrl_fsel_get(
+		struct sfax8_pinctrl *pc, unsigned pin)
+{
+	u32 val = sfax8_pad_get_func(pc, pin);
+	enum sfax8_fsel status = val;
+
+	dev_dbg(pc->dev, "get %08x (%u => %s)\n", val, pin,
+			sfax8_functions[status]);
+
+	return status;
+}
+
+static int sfax8_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	return pinctrl_request_gpio(chip->base + offset);
+}
+
+static void sfax8_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	pinctrl_free_gpio(chip->base + offset);
+}
+
+static int sfax8_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	return pinctrl_gpio_direction_input(chip->base + offset);
+}
+
+static int sfax8_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct sfax8_pinctrl *pc = dev_get_drvdata(chip->dev);
+
+	return sfax8_pad_get_value(pc, offset);
+}
+
+static int sfax8_gpio_direction_output(struct gpio_chip *chip,
+		unsigned offset, int value)
+{
+	struct sfax8_pinctrl *pc = dev_get_drvdata(chip->dev);
+
+	pinctrl_gpio_direction_output(chip->base + offset);
+
+	return sfax8_pad_set_value(pc, offset, value);
+}
+
+
+static void sfax8_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct sfax8_pinctrl *pc = dev_get_drvdata(chip->dev);
+
+	sfax8_pad_set_value(pc, offset, value);
+}
+
+static int sfax8_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct sfax8_pinctrl *pc = dev_get_drvdata(chip->dev);
+
+	return irq_linear_revmap(pc->irq_domain, offset);
+}
+
+static struct gpio_chip sfax8_gpio_chip = {
+	.label = MODULE_NAME,
+	.owner = THIS_MODULE,
+	.request = sfax8_gpio_request,
+	.free = sfax8_gpio_free,
+	.direction_input = sfax8_gpio_direction_input,
+	.direction_output = sfax8_gpio_direction_output,
+	.get = sfax8_gpio_get,
+	.set = sfax8_gpio_set,
+	.to_irq = sfax8_gpio_to_irq,
+	.base = -1,
+	.ngpio = SFAX8_NUM_GPIOS,
+	.can_sleep = false,
+};
+
+static irqreturn_t sfax8_gpio_irq_handler(int irq, void *dev_id)
+{
+	struct sfax8_gpio_irqdata *irqdata = dev_id;
+	struct sfax8_pinctrl *pc = irqdata->pc;
+	int bank = irqdata->bank;
+	unsigned long events;
+	unsigned offset;
+	unsigned gpio;
+	unsigned int type;
+
+	if(!pc)
+		return IRQ_NONE;
+
+	if(pc->irq[bank] != irq) {
+		printk("irq number error!\n");
+		return IRQ_NONE;
+	}
+
+	events = pc->enabled_irq_map[bank];
+	for_each_set_bit(offset, &events, 32) {
+		gpio = (SFAX8_GPIOS_PER_BANK * bank) + offset;
+		type = pc->irq_type[gpio];
+
+		/* ack edge triggered IRQs immediately */
+		if (!(type & IRQ_TYPE_LEVEL_MASK))
+			sfax8_gpio_wr(pc, GPIO_INTPEND(gpio), 0);
+
+		generic_handle_irq(irq_linear_revmap(pc->irq_domain, gpio));
+
+		/* ack level triggered IRQ after handling them */
+		if (type & IRQ_TYPE_LEVEL_MASK)
+			sfax8_gpio_wr(pc, GPIO_INTPEND(gpio), 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/* fast path for IRQ handler */
+static void sfax8_gpio_irq_enable(struct irq_data *data)
+{
+	struct sfax8_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned gpio = irqd_to_hwirq(data);
+	unsigned offset = gpio%SFAX8_GPIOS_PER_BANK;
+	unsigned bank = gpio/SFAX8_GPIOS_PER_BANK;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pc->irq_lock[bank], flags);
+	set_bit(offset, &pc->enabled_irq_map[bank]);
+	sfax8_gpio_wr(pc, GPIO_INTGMSK(gpio), 0);
+	sfax8_gpio_wr(pc, GPIO_INTMSK(gpio), 0);
+	spin_unlock_irqrestore(&pc->irq_lock[bank], flags);
+}
+
+static void sfax8_gpio_irq_disable(struct irq_data *data)
+{
+	struct sfax8_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned gpio = irqd_to_hwirq(data);
+	unsigned offset = gpio%SFAX8_GPIOS_PER_BANK;
+	unsigned bank = gpio/SFAX8_GPIOS_PER_BANK;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pc->irq_lock[bank], flags);
+	clear_bit(offset, &pc->enabled_irq_map[bank]);
+	sfax8_gpio_wr(pc, GPIO_INTMSK(gpio), 1);
+	sfax8_gpio_wr(pc, GPIO_INTGMSK(gpio), 1);
+	spin_unlock_irqrestore(&pc->irq_lock[bank], flags);
+}
+
+static int sfax8_gpio_irq_set_type(struct irq_data *data, unsigned int type)
+{
+	struct sfax8_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned gpio = irqd_to_hwirq(data);
+
+	switch (type) {
+		case IRQF_TRIGGER_NONE:
+			sfax8_gpio_wr(pc, GPIO_INTTYPE(gpio), 0);
+			break;
+		case IRQF_TRIGGER_RISING:
+			sfax8_gpio_wr(pc, GPIO_INTTYPE(gpio), 2);
+			break;
+		case IRQF_TRIGGER_FALLING:
+			sfax8_gpio_wr(pc, GPIO_INTTYPE(gpio), 4);
+			break;
+		case IRQF_TRIGGER_HIGH:
+			sfax8_gpio_wr(pc, GPIO_INTTYPE(gpio), 1);
+			break;
+		case IRQF_TRIGGER_LOW:
+			sfax8_gpio_wr(pc, GPIO_INTTYPE(gpio), 0);
+			break;
+
+		default:
+			pr_warn("IRQ trigger type not valid!\n");
+	}
+	pc->irq_type[gpio] = type;
+
+	return 0;
+}
+
+static struct irq_chip sfax8_gpio_irq_chip = {
+	.name = MODULE_NAME,
+	.irq_enable = sfax8_gpio_irq_enable,
+	.irq_disable = sfax8_gpio_irq_disable,
+	.irq_set_type = sfax8_gpio_irq_set_type,
+};
+
+static int sfax8_pctl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->ngroups;
+}
+
+static const char *sfax8_pctl_get_group_name(struct pinctrl_dev *pctldev,
+		unsigned selector)
+{
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->groups[selector].name;
+}
+
+static int sfax8_pctl_get_group_pins(struct pinctrl_dev *pctldev,
+		unsigned selector,
+		const unsigned **pins,
+		unsigned *num_pins)
+{
+#if 0 
+	*pins = &sfax8_gpio_pins[selector].number;
+	*num_pins = 1;
+#else
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	if(selector >= info->ngroups)
+		return -EINVAL;
+
+	*pins = info->groups[selector].pins;
+	*num_pins = info->groups[selector].npins;
+#endif
+	return 0;
+}
+
+static void sfax8_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,
+		struct seq_file *s,
+		unsigned offset)
+{
+	struct sfax8_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	enum sfax8_fsel fsel = sfax8_pinctrl_fsel_get(pc, offset);
+	const char *fname = sfax8_functions[fsel];
+	int value = sfax8_pad_get_value(pc, offset);
+	int irq = irq_find_mapping(pc->irq_domain, offset);
+
+	seq_printf(s, "function %s in %s; irq %d (%s)",
+		fname, value ? "hi" : "lo",
+		irq, irq_type_names[pc->irq_type[offset]]);
+}
+
+static void sfax8_pctl_dt_free_map(struct pinctrl_dev *pctldev,
+		struct pinctrl_map *maps, unsigned num_maps)
+{
+	/*
+	 * We must free maps here because when
+	 * alloc mem for maps, the dev is set to
+	 * pctldev->dev, which won't be removed while
+	 * create_pinctrl <=> pinctrl_free.So if not,
+	 * there will be a memory leak.
+	 */
+	devm_kfree(pctldev->dev, maps);
+	return;
+}
+
+static const inline struct siflower_pin_group *pinctrl_name_to_group(
+					const struct sfax8_pinctrl *info,
+					const char *name)
+{
+	int i;
+
+	for (i = 0; i < info->ngroups; i++) {
+		if (!strcmp(info->groups[i].name, name))
+			return &info->groups[i];
+	}
+
+	return NULL;
+}
+
+static int sfax8_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,
+		struct device_node *np,
+		struct pinctrl_map **map, unsigned *num_maps)
+{
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	const struct siflower_pin_group *grp;
+	struct pinctrl_map *new_map;
+	struct device_node *parent;
+	int map_num = 1;
+	int i;
+
+	/*
+	 * first find the group of this node and check if we need to create
+	 * config maps for pins
+	 */
+	grp = pinctrl_name_to_group(info, np->name);
+	if (!grp) {
+		dev_err(info->dev, "unable to find group for node %s\n",
+			np->name);
+		return -EINVAL;
+	}
+
+	map_num += grp->npins;
+	new_map = devm_kzalloc(pctldev->dev, sizeof(*new_map) * map_num,
+								GFP_KERNEL);
+	if (!new_map)
+		return -ENOMEM;
+
+	*map = new_map;
+	*num_maps = map_num;
+
+	/* create mux map */
+	parent = of_get_parent(np);
+	if (!parent) {
+		devm_kfree(pctldev->dev, new_map);
+		return -EINVAL;
+	}
+	new_map[0].type = PIN_MAP_TYPE_MUX_GROUP;
+	new_map[0].data.mux.function = parent->name;
+	new_map[0].data.mux.group = np->name;
+	of_node_put(parent);
+
+	/* create config map */
+	new_map++;
+	for (i = 0; i < grp->npins; i++) {
+		new_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;
+		new_map[i].data.configs.group_or_pin =
+				pin_get_name(pctldev, grp->pins[i]);
+		new_map[i].data.configs.configs = grp->data[i].configs;
+		new_map[i].data.configs.num_configs = grp->data[i].nconfigs;
+	}
+
+	dev_dbg(pctldev->dev, "maps: function %s group %s num %d\n",
+		(*map)->data.mux.function, (*map)->data.mux.group, map_num);
+
+	return 0;
+}
+
+static const struct pinctrl_ops sfax8_pctl_ops = {
+	.get_groups_count = sfax8_pctl_get_groups_count,
+	.get_group_name = sfax8_pctl_get_group_name,
+	.get_group_pins = sfax8_pctl_get_group_pins,
+	.pin_dbg_show = sfax8_pctl_pin_dbg_show,
+	.dt_node_to_map = sfax8_pctl_dt_node_to_map,
+	.dt_free_map = sfax8_pctl_dt_free_map,
+};
+
+static int sfax8_pmx_get_functions_count(struct pinctrl_dev *pctldev)
+{
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->nfunctions;
+}
+
+static const char *sfax8_pmx_get_function_name(struct pinctrl_dev *pctldev,
+		unsigned selector)
+{
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->functions[selector].name;
+}
+
+static int sfax8_pmx_get_function_groups(struct pinctrl_dev *pctldev,
+		unsigned selector,
+		const char * const **groups,
+		unsigned * const num_groups)
+{
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	*groups = info->functions[selector].groups;
+	*num_groups = info->functions[selector].ngroups;
+
+	return 0;
+}
+
+static int sfax8_pmx_set(struct pinctrl_dev *pctldev,
+		unsigned selector,
+		unsigned group)
+{
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	const unsigned int *pins = info->groups[group].pins;
+	const struct siflower_pin_config *data = info->groups[group].data;
+	int cnt, ret = 0;
+
+	dev_dbg(info->dev, "enable function %s group %s\n",
+		info->functions[selector].name, info->groups[group].name);
+
+	/*
+	 * for each pin in the pin group selected, program the correspoding pin
+	 * pin function number in the config register.
+	 */
+	for (cnt = 0; cnt < info->groups[group].npins; cnt++) {
+		sfax8_pad_set_func(info, pins[cnt], data[cnt].func);
+		if (ret)
+			break;
+	}
+
+	return 0;
+}
+
+static void sfax8_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range,
+		unsigned offset)
+{
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	/* disable by setting to GPIO_IN */
+	sfax8_pad_set_func(info, offset, SFAX8_FSEL_GPIO_IN);
+}
+
+static int sfax8_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range,
+		unsigned offset,
+		bool input)
+{
+	struct sfax8_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	enum sfax8_fsel fsel = input ?
+		SFAX8_FSEL_GPIO_IN : SFAX8_FSEL_GPIO_OUT;
+
+	sfax8_pad_set_func(info, offset, fsel);
+
+	return 0;
+}
+
+static const struct pinmux_ops sfax8_pmx_ops = {
+	.get_functions_count = sfax8_pmx_get_functions_count,
+	.get_function_name = sfax8_pmx_get_function_name,
+	.get_function_groups = sfax8_pmx_get_function_groups,
+	.set_mux = sfax8_pmx_set,
+	.gpio_disable_free = sfax8_pmx_gpio_disable_free,
+	.gpio_set_direction = sfax8_pmx_gpio_set_direction,
+};
+
+static int sfax8_pinconf_get(struct pinctrl_dev *pctldev,
+			unsigned pin, unsigned long *config)
+{
+	/* No way to read back config in HW */
+	return -ENOTSUPP;
+}
+
+static struct siflower_pin_bank *pin_to_bank(struct sfax8_pinctrl *info,
+								unsigned pin)
+{
+	struct siflower_pin_bank *b = info->ctrl->pin_banks;
+
+	while (pin >= (b->pin_base + b->nr_pins))
+		b++;
+
+	return b;
+}
+
+static void siflower_calc_pull_reg_and_bit(struct siflower_pin_bank *bank,
+				    int pin_num, struct regmap **regmap,
+				    int *reg, u8 *bit)
+{
+	struct sfax8_pinctrl *info = bank->drvdata;
+
+	/* The first 24 pins of the first bank are located in PMU */
+	if (bank->bank_num == 0) {
+		*regmap = info->regmap_pmu;
+		*reg = 0x64;//RK3188_PULL_PMU_OFFSET;
+
+		*reg += ((pin_num / 8) * 4);
+		*bit = pin_num % 8;
+		*bit *= 2;
+	} else {
+		*regmap = info->regmap_base;
+		*reg = 0x164;
+
+		/* correct the offset, as we're starting with the 2nd bank */
+		*reg -= 0x10;
+		*reg += bank->bank_num * 16;
+		*reg += ((pin_num / 8) * 4);
+
+		*bit = (pin_num % 8);
+		*bit *= 2;
+	}
+}
+
+static int siflower_set_pull(struct siflower_pin_bank *bank,
+					int pin_num, int pull, struct regmap *regmap_base)
+{
+	struct sfax8_pinctrl *info = bank->drvdata;
+	struct siflower_pin_ctrl *ctrl = info->ctrl;
+	int ret;
+	unsigned long flags;
+	u8 bit;
+	u32 data, rmask;
+
+	dev_dbg(info->dev, "setting pull of GPIO%d-%d to %d\n",
+		 bank->bank_num, pin_num, pull);
+
+	switch (ctrl->type) {
+	case sfax8:
+		spin_lock_irqsave(&bank->slock, flags);
+
+		/* enable the write to the equivalent lower bits */
+		data = 1 << (bit + 16);
+		rmask = data | (data >> 16);
+
+		switch (pull) {
+		case PIN_CONFIG_BIAS_DISABLE:
+			ret = sfax8_pad_set_pull(regmap_base,pin_num,NOPULL);
+			break;
+		case PIN_CONFIG_BIAS_PULL_UP:
+			ret = sfax8_pad_set_pull(regmap_base,pin_num,PULLUP);
+			break;
+		case PIN_CONFIG_BIAS_PULL_DOWN:
+			ret = sfax8_pad_set_pull(regmap_base,pin_num,PULLDOWN);
+			break;
+		case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
+			ret = 0;
+			break;
+		default:
+			spin_unlock_irqrestore(&bank->slock, flags);
+			dev_err(info->dev, "unsupported pull setting %d\n",
+				pull);
+			return -EINVAL;
+		}
+
+		spin_unlock_irqrestore(&bank->slock, flags);
+		break;
+	default:
+		dev_err(info->dev, "unsupported pinctrl type\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int sfax8_pinconf_set(struct pinctrl_dev *pctldev,
+			unsigned pin, unsigned long *configs,
+			unsigned num_configs)
+{
+	struct sfax8_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	struct siflower_pin_bank *bank = pin_to_bank(pc,pin);
+	enum pin_config_param param;
+	u16 arg;
+	int i;
+	int rc;
+
+	for (i = 0; i < num_configs; i++) {
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		switch (param) {
+		case PIN_CONFIG_BIAS_DISABLE:
+			rc = siflower_set_pull(bank, pin - bank->pin_base,
+				param, pc->regmap_base);
+			if (rc)
+				return rc;
+			break;
+		case PIN_CONFIG_BIAS_PULL_UP:
+		case PIN_CONFIG_BIAS_PULL_DOWN:
+		case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
+		case PIN_CONFIG_BIAS_BUS_HOLD:
+			//if (!siflower_pinconf_pull_valid(param))
+			//	return -ENOTSUPP;
+
+			if (!arg)
+				return -EINVAL;
+
+			rc = siflower_set_pull(bank, pin - bank->pin_base,
+				param, pc->regmap_base);
+			if (rc)
+				return rc;
+			break;
+		default:
+			return -ENOTSUPP;
+			break;
+		}
+	} /* for each config */
+	return 0;
+	
+}
+
+static const struct of_device_id sfax8_gpio_match[] = {
+	{ .compatible = "siflower,sfax8-gpio" },
+	{},
+};
+
+static void siflower_pinctrl_child_count(struct sfax8_pinctrl *info,
+						struct device_node *np)
+{
+	struct device_node *child;
+
+	for_each_child_of_node(np, child) {
+		if (of_match_node(sfax8_gpio_match, child))
+			continue;
+
+		info->nfunctions++;
+		info->ngroups += of_get_child_count(child);
+	}
+}
+
+static struct siflower_pin_bank *bank_num_to_bank(
+					struct sfax8_pinctrl *info,
+					unsigned num)
+{
+	struct siflower_pin_bank *b = info->ctrl->pin_banks;
+	int i;
+
+	for (i = 0; i < info->ctrl->nr_banks; i++, b++) {
+		if (b->bank_num == num)
+			return b;
+	}
+
+	return ERR_PTR(-EINVAL);
+}
+
+static int siflower_pinctrl_parse_groups(struct device_node *np,
+					      struct siflower_pin_group *grp,
+					      struct sfax8_pinctrl *info,
+					      u32 index)
+{
+	struct siflower_pin_bank *bank;
+	int size;
+	const __be32 *list;
+	int num;
+	int i, j;
+	int ret;
+
+	dev_dbg(info->dev, "group(%d): %s\n", index, np->name);
+
+	/* Initialise group */
+	grp->name = np->name;
+
+	/*
+	 * the binding format is sfax8,pins = <bank pin mux CONFIG>,
+	 * do sanity check and calculate pins number
+	 */
+	list = of_get_property(np, "sfax8,pins", &size);
+	/* we do not check return since it's safe node passed down */
+	size /= sizeof(*list);
+	if (!size || size % 4) {
+		dev_err(info->dev, "wrong pins number or pins and configs should be by 4\n");
+		return -EINVAL;
+	}
+
+	grp->npins = size / 4;
+
+	grp->pins = devm_kzalloc(info->dev, grp->npins * sizeof(unsigned int),
+						GFP_KERNEL);
+	grp->data = devm_kzalloc(info->dev, grp->npins *
+					  sizeof(struct siflower_pin_config),
+					GFP_KERNEL);
+	if (!grp->pins || !grp->data)
+		return -ENOMEM;
+
+	for (i = 0, j = 0; i < size; i += 4, j++) {
+		const __be32 *phandle;
+		struct device_node *np_config;
+
+		num = be32_to_cpu(*list++);
+		bank = bank_num_to_bank(info, num);
+		if (IS_ERR(bank))
+			return PTR_ERR(bank);
+
+		grp->pins[j] = bank->pin_base + be32_to_cpu(*list++);
+		grp->data[j].func = be32_to_cpu(*list++);
+
+		phandle = list++;
+		if (!phandle)
+			return -EINVAL;
+
+		np_config = of_find_node_by_phandle(be32_to_cpup(phandle));
+		ret = pinconf_generic_parse_dt_config(np_config,
+				&grp->data[j].configs, &grp->data[j].nconfigs);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+
+static int siflower_pinctrl_parse_functions(struct device_node *np,
+						struct sfax8_pinctrl *info,
+						u32 index)
+{
+	struct device_node *child;
+	struct siflower_pmx_func *func;
+	struct siflower_pin_group *grp;
+	int ret;
+	static u32 grp_index;
+	u32 i = 0;
+
+	dev_dbg(info->dev, "parse function(%d): %s\n", index, np->name);
+
+	func = &info->functions[index];
+
+	/* Initialise function */
+	func->name = np->name;
+	func->ngroups = of_get_child_count(np);
+	if (func->ngroups <= 0)
+		return 0;
+
+	func->groups = devm_kzalloc(info->dev,
+			func->ngroups * sizeof(char *), GFP_KERNEL);
+	if (!func->groups)
+		return -ENOMEM;
+
+	for_each_child_of_node(np, child) {
+		func->groups[i] = child->name;
+		grp = &info->groups[grp_index++];
+		ret = siflower_pinctrl_parse_groups(child, grp, info, i++);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int siflower_pinctrl_parse_dt(struct platform_device *pdev,
+					      struct sfax8_pinctrl *info)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *child;
+	int ret;
+	int i;
+
+	siflower_pinctrl_child_count(info, np);
+
+	dev_dbg(&pdev->dev, "nfunctions = %d\n", info->nfunctions);
+	dev_dbg(&pdev->dev, "ngroups = %d\n", info->ngroups);
+
+	info->functions = devm_kzalloc(dev, info->nfunctions *
+					      sizeof(struct siflower_pmx_func),
+					      GFP_KERNEL);
+	if (!info->functions) {
+		dev_err(dev, "failed to allocate memory for function list\n");
+		return -EINVAL;
+	}
+
+	info->groups = devm_kzalloc(dev, info->ngroups *
+					    sizeof(struct siflower_pin_group),
+					    GFP_KERNEL);
+	if (!info->groups) {
+		dev_err(dev, "failed allocate memory for ping group list\n");
+		return -EINVAL;
+	}
+
+	i = 0;
+
+	for_each_child_of_node(np, child) {
+		if (of_match_node(sfax8_gpio_match, child))
+			continue;
+
+		ret = siflower_pinctrl_parse_functions(child, info, i++);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to parse function\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int siflower_get_bank_data(struct siflower_pin_bank *bank,
+				  struct sfax8_pinctrl *info)
+{
+	struct resource res;
+
+	if (of_address_to_resource(bank->of_node, 0, &res)) {
+		dev_err(info->dev, "cannot find IO resource for bank\n");
+		return -ENOENT;
+	}
+
+	bank->reg_base = devm_ioremap_resource(info->dev, &res);
+	if (IS_ERR(bank->reg_base))
+		return PTR_ERR(bank->reg_base);
+
+	bank->irq = irq_of_parse_and_map(bank->of_node, 0);
+
+	bank->clk = of_clk_get(bank->of_node, 0);
+	if (IS_ERR(bank->clk))
+		return PTR_ERR(bank->clk);
+
+	return clk_prepare_enable(bank->clk);
+}
+
+
+static struct of_device_id sfax8_pinctrl_match[];
+
+static struct siflower_pin_ctrl *siflower_pinctrl_get_soc_data(
+						struct sfax8_pinctrl *d,
+						struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *np;
+	struct siflower_pin_ctrl *ctrl;
+	struct siflower_pin_bank *bank;
+	int grf_offs, pmu_offs, i, j;
+
+	match = of_match_node(sfax8_pinctrl_match, node);
+	ctrl = (struct siflower_pin_ctrl *)match->data;
+
+	for_each_child_of_node(node, np) {
+		if (!of_find_property(np, "gpio-controller", NULL))
+			continue;
+
+		bank = ctrl->pin_banks;
+		for (i = 0; i < ctrl->nr_banks; ++i, ++bank) {
+			if (!strcmp(bank->name, np->name)) {
+				bank->of_node = np;
+
+				if (!siflower_get_bank_data(bank, d))
+					bank->valid = true;
+
+				break;
+			}
+		}
+	}
+
+	bank = ctrl->pin_banks;
+	for (i = 0; i < ctrl->nr_banks; ++i, ++bank) {
+		int bank_pins = 0;
+
+		spin_lock_init(&bank->slock);
+		bank->drvdata = d;
+		bank->pin_base = ctrl->nr_pins;
+		ctrl->nr_pins += bank->nr_pins;
+
+		/* calculate iomux offsets */
+		for (j = 0; j < 4; j++) {
+			struct siflower_iomux *iom = &bank->iomux[j];
+			int inc;
+
+			if (bank_pins >= bank->nr_pins)
+				break;
+
+			/* preset offset value, set new start value */
+			if (iom->offset >= 0) {
+				if (iom->type & IOMUX_SOURCE_PMU)
+					pmu_offs = iom->offset;
+				else
+					grf_offs = iom->offset;
+			} else {
+			/* set current offset */
+				iom->offset = (iom->type & IOMUX_SOURCE_PMU) ?
+							pmu_offs : grf_offs;
+			}
+
+			dev_dbg(d->dev, "bank %d, iomux %d has offset 0x%x\n",
+				 i, j, iom->offset);
+
+			/*
+			 * Increase offset according to iomux width.
+			 * 4bit iomux'es are spread over two registers.
+			 */
+			inc = (iom->type & IOMUX_WIDTH_4BIT) ? 8 : 4;
+			if (iom->type & IOMUX_SOURCE_PMU)
+				pmu_offs += inc;
+			else
+				grf_offs += inc;
+
+			bank_pins += 8;
+		}
+	}
+
+	return ctrl;
+}
+
+
+
+static const struct pinconf_ops sfax8_pinconf_ops = {
+	.pin_config_get = sfax8_pinconf_get,
+	.pin_config_set = sfax8_pinconf_set,
+};
+
+static struct pinctrl_desc sfax8_pinctrl_desc = {
+	.name = MODULE_NAME,
+	//.pins = sfax8_gpio_pins,
+	//.npins = ARRAY_SIZE(sfax8_gpio_pins),
+	.pctlops = &sfax8_pctl_ops,
+	.pmxops = &sfax8_pmx_ops,
+	.confops = &sfax8_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static struct pinctrl_gpio_range sfax8_pinctrl_gpio_range = {
+	.name = MODULE_NAME,
+	.npins = SFAX8_NUM_GPIOS,
+};
+
+static int sfax8_pinctrl_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np_gpio, *np = dev->of_node, *node;
+	struct sfax8_pinctrl *pc;
+	struct siflower_pin_ctrl *ctrl;
+	//struct siflower_pin_bank *bank = pc->ctrl->pin_banks;
+	struct pinctrl_pin_desc *pdesc;
+	struct siflower_pin_bank *pin_bank;
+	int err, i, bank, k, pin;
+
+	pc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);
+	if (!pc){
+		printk("the pc is null!\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, pc);
+	pc->dev = dev;
+
+	ctrl = siflower_pinctrl_get_soc_data(pc, pdev);
+	if (!ctrl) {
+		dev_err(dev, "driver data not available\n");
+		return -EINVAL;
+	}
+	pc->ctrl = ctrl;
+
+	pc->base = pc->ctrl->pin_banks->reg_base;
+
+	node = of_parse_phandle(np, "pad-base", 0);
+	if (node) {
+		pc->regmap_base = syscon_node_to_regmap(node);
+		if (IS_ERR(pc->regmap_base))
+			return PTR_ERR(pc->regmap_base);
+	}
+
+	regcache_cache_bypass(pc->regmap_base, true);
+
+	pc->gpio_chip = sfax8_gpio_chip;
+	pc->gpio_chip.dev = dev;
+	pc->gpio_chip.of_node = pc->ctrl->pin_banks->of_node;//np;
+	pc->gpio_chip.base = pc->ctrl->pin_banks->pin_base;
+	pc->gpio_chip.ngpio = pc->ctrl->pin_banks->nr_pins;
+	pc->gpio_chip.label = pc->ctrl->pin_banks->name;
+
+	pc->irq_domain = irq_domain_add_linear(np, SFAX8_NUM_GPIOS,
+			&irq_domain_simple_ops, NULL);
+	if (!pc->irq_domain) {
+		dev_err(dev, "could not create IRQ domain\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < SFAX8_NUM_GPIOS; i++) {
+		int irq = irq_create_mapping(pc->irq_domain, i);
+		irq_set_lockdep_class(irq, &gpio_lock_class);
+		irq_set_chip_and_handler(irq, &sfax8_gpio_irq_chip,
+				handle_simple_irq);
+		irq_set_chip_data(irq, pc);
+	}
+
+	np_gpio = of_find_compatible_node(np, NULL, "siflower,sfax8-gpio");
+	if(!np_gpio)
+		printk("Can't get gpio configuration in dts.\n");
+
+	for (i = 0; i < SFAX8_NUM_BANKS; i++) {
+		int len;
+		char *name;
+
+		pc->irq[i] = of_irq_get(np_gpio, i);
+		pc->irq_data[i].pc = pc;
+		pc->irq_data[i].bank = i;
+		spin_lock_init(&pc->irq_lock[i]);
+
+		len = strlen(dev_name(pc->dev)) + 16;
+		name = devm_kzalloc(pc->dev, len, GFP_KERNEL);
+		if (!name)
+			return -ENOMEM;
+		snprintf(name, len, "%s:bank%d", dev_name(pc->dev), i);
+
+		err = devm_request_irq(dev, pc->irq[i],
+			sfax8_gpio_irq_handler, IRQF_SHARED,
+			name, &pc->irq_data[i]);
+		if (err) {
+			dev_err(dev, "unable to request IRQ %d\n", pc->irq[i]);
+			return err;
+		}
+	}
+
+	err = gpiochip_add(&pc->gpio_chip);
+	if (err) {
+		dev_err(dev, "could not add GPIO chip\n");
+		return err;
+	}
+
+	//add here for a test! Mark
+	pdesc = devm_kzalloc(&pdev->dev, sizeof(*pdesc) *
+			pc->ctrl->nr_pins, GFP_KERNEL);
+
+	sfax8_pinctrl_desc.pins = pdesc;
+	sfax8_pinctrl_desc.npins = pc->ctrl->nr_pins;
+
+	for (bank = 0 , k = 0; bank < pc->ctrl->nr_banks; bank++) {
+		pin_bank = &pc->ctrl->pin_banks[bank];
+		for (pin = 0; pin < pin_bank->nr_pins; pin++, k++) {
+			pdesc->number = k;
+			pdesc->name = kasprintf(GFP_KERNEL, "%s-%d",
+						pin_bank->name, pin);
+			pdesc++;
+		}
+	}
+
+	pc->pctl_dev = pinctrl_register(&sfax8_pinctrl_desc, dev, pc);
+	if (!pc->pctl_dev) {
+		gpiochip_remove(&pc->gpio_chip);
+		return -EINVAL;
+	}
+
+	pc->gpio_range = sfax8_pinctrl_gpio_range;
+	pc->gpio_range.base = pc->gpio_chip.base;
+	pc->gpio_range.gc = &pc->gpio_chip;
+	pinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);
+
+	for (bank = 0; bank < pc->ctrl->nr_banks; ++bank) {
+		pin_bank = &pc->ctrl->pin_banks[bank];
+		pin_bank->grange.name = pin_bank->name;
+		pin_bank->grange.id = bank;
+		pin_bank->grange.pin_base = pin_bank->pin_base;
+		pin_bank->grange.base = pin_bank->gpio_chip.base;
+		pin_bank->grange.npins = pin_bank->gpio_chip.ngpio;
+		pin_bank->grange.gc = &pin_bank->gpio_chip;
+		pinctrl_add_gpio_range(pc->pctl_dev, &pin_bank->grange);
+	}
+
+	siflower_pinctrl_parse_dt(pdev, pc);
+
+	return 0;
+}
+
+static int sfax8_pinctrl_remove(struct platform_device *pdev)
+{
+	struct sfax8_pinctrl *pc = platform_get_drvdata(pdev);
+
+	pinctrl_unregister(pc->pctl_dev);
+	gpiochip_remove(&pc->gpio_chip);
+
+	return 0;
+}
+
+static struct siflower_pin_bank sfax8_pin_banks[] = {
+	PIN_BANK(0, 62, "gpio"),
+};
+
+static struct siflower_pin_ctrl sfax8_pin_ctrl = {
+		.pin_banks		= sfax8_pin_banks,
+		.nr_banks		= ARRAY_SIZE(sfax8_pin_banks),
+		.label			= "SFAX8-GPIO",
+		.type			= 0,
+		.pull_calc_reg		= siflower_calc_pull_reg_and_bit,
+};
+
+static struct of_device_id sfax8_pinctrl_match[] = {
+	{ .compatible = "siflower,sfax8-pinctrl",
+		.data = (void *)&sfax8_pin_ctrl },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sfax8_pinctrl_match);
+
+static struct platform_driver sfax8_pinctrl_driver = {
+	.probe = sfax8_pinctrl_probe,
+	.remove = sfax8_pinctrl_remove,
+	.driver = {
+		.name = MODULE_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sfax8_pinctrl_match,
+	},
+};
+//module_platform_driver(sfax8_pinctrl_driver);
+static int __init sfax8_pinctrl_drv_register(void)
+{
+	return platform_driver_register(&sfax8_pinctrl_driver);
+}
+postcore_initcall(sfax8_pinctrl_drv_register);
+
+MODULE_AUTHOR("Mark.cai");
+MODULE_DESCRIPTION("SFAX8 Pin control driver");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/pinctrl/pinctrl-sfax8.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/pinctrl/pinctrl-sfax8.h	2017-11-21 20:13:12.454710527 +0800
@@ -0,0 +1,168 @@
+#ifndef __PAD_H__
+#define __PAD_H__
+#include <linux/types.h>
+
+#ifdef CONFIG_SOC_SF16A18
+#include <sf16a18.h>
+#endif
+
+enum sfax8_fsel {
+	SFAX8_FSEL_FUNC0 = 0,
+	SFAX8_FSEL_FUNC1 = 1,
+	SFAX8_FSEL_FUNC2 = 2,
+	SFAX8_FSEL_FUNC3 = 3,
+	SFAX8_FSEL_GPIO_IN = 4,
+	SFAX8_FSEL_GPIO_OUT = 5,
+	SFAX8_FSEL_COUNT = 6,
+	SFAX8_FSEL_MASK = 0x7,
+};
+
+static const char * const sfax8_functions[SFAX8_FSEL_COUNT] = {
+	[SFAX8_FSEL_FUNC0] = "func0",
+	[SFAX8_FSEL_FUNC1] = "func1",
+	[SFAX8_FSEL_FUNC2] = "func2",
+	[SFAX8_FSEL_FUNC3] = "func3",
+	[SFAX8_FSEL_GPIO_IN] = "gpio_in",
+	[SFAX8_FSEL_GPIO_OUT] = "gpio_out",
+};
+
+#define PAD_FUCN_SEL(n)     (n < 8 ? (0xF60 + (n)*(0x4)) : (0xB60 + (n-8)*(0x4)))
+#define PAD_MODE_SEL(n)     (n < 16 ? (0xC00 + (n)*(0x4)) : (0x800 + (n-16)*(0x4)))
+#define PAD_OFFSET          (4)
+#define PAD_PER_GROUP_PINS  (4)
+
+#ifdef CONFIG_SF16A18_MPW0
+#define PAD_INDEX_MAX		62
+#else
+#define PAD_INDEX_MAX		70
+#endif
+
+#define PAD_INDEX_INVALID	0xFF
+#define PAD_IRQ_PER_GROUP	16
+
+#define PAD_IO_PULLUP(n)	(n < 8 ? (0xDE0 + (n)*(0x4)) : (0x9E0 + (n-8)*(0x4)))
+#define PAD_IO_PULLDOWN(n)	(n < 8 ? (0xE40 + (n)*(0x4)) : (0xA40 + (n-8)*(0x4)))
+
+#define FUNC_SW_SEL(n)		(n < 8 ? (0xC40 + (n)*(0x4)) : (0x840 + (n-8)*(0x4)))
+#define FUNC_SW_OEN(n)		(n < 8 ? (0xC80 + (n)*(0x4)) : (0x880 + (n-8)*(0x4)))
+#define FUNC_SW_IE(n)		(n < 8 ? (0xEA0 + (n)*(0x4)) : (0xAA0 + (n-8)*(0x4)))
+
+
+#define GPIO_RDAT(n)		((n)*(0x40) + 0x0)
+#define GPIO_WDAT(n)		((n)*(0x40) + 0x4)
+#define GPIO_DIR(n)         ((n)*(0x40) + 0x8)
+
+#define GPIO_INTMSK(n)		((n)*(0x40) + 0xC)
+#define GPIO_INTGMSK(n)		((n)*(0x40) + 0x10)
+#define GPIO_INTPEND(n)		((n)*(0x40) + 0x14)
+#define GPIO_INTTYPE(n)		((n)*(0x40) + 0x18)
+#define GPIO_FILTER(n)		((n)*(0x40) + 0x1C)
+#define GPIO_CLKDIV(n)		((n)*(0x40) + 0x20)
+#define GPIO_INTPENDGLB(n)	((n)*4 + 0x4000)
+
+
+#define PADSRANGE(a, b)	\
+	((abs(b) << 16) | abs(a) | (a < 0 && b < 0 && a < b) ? 0x80000000 : 0)
+
+#define PAD_INIT(_index, _name, _module, _func, _pull, _io, _level)	\
+{                                       \
+		.index	= _index,					\
+		.pad_name = _name,					\
+		.module	= _module,					\
+		.func	= _func,					\
+		.pull	= _pull,					\
+		.io     = _io,                      \
+		.level	= _level,					\
+}
+
+
+typedef enum pad_trigger_type_t
+{
+	EINT_TRIGGER_LOW =0,
+	EINT_TRIGGER_HIGH,
+	EINT_TRIGGER_FALLING = 3,
+	EINT_TRIGGER_RISING = 5,
+	EINT_TRIGGER_DOUBLE = 7
+} pad_trigger_type;
+
+
+typedef enum pad_func_t{
+	FUNC0,
+	FUNC1,
+	FUNC2,
+	FUNC3,
+	GPIO_INPUT,
+	GPIO_OUTPUT
+} pad_func;
+
+typedef enum pad_io_t{
+	INPUT,
+	OUTPUT,
+	TRISTATE
+} pad_io;
+
+typedef enum pad_pull_t{
+	NOPULL,
+	PULLUP,
+	PULLDOWN
+} pad_pull;
+
+typedef enum pad_output_levet_t{
+	LOW_LEVEL,
+	HIGH_LEVEL,
+} pad_output_level;
+
+typedef enum pad_group_t{
+	group0,
+	group1,
+	group2,
+	group3
+} pad_pad_group;
+
+
+struct pad_init_info {
+	int index;
+	const char pad_name[16];
+	const char module[16];
+	pad_func func;
+	pad_pull pull;
+	pad_io io;
+	int level;
+};
+
+typedef struct pad_index_t {
+	u16 high;
+	u16 low;
+	pad_func func;
+} pad_index;
+
+typedef enum sf_module_t{
+	SF_SPI0,
+	SF_EMMC,
+	SF_SDIO,
+	SF_UART0,
+	SF_I2C0,
+	SF_I2C1,
+	SF_I2C2,
+	SF_SPI1,
+	SF_I2S0,
+	SF_PCM0,
+	SF_UART1,
+	SF_I2S1,
+	SF_PCM1,
+	SF_UART2,
+	SF_SPDIF,
+	SF_UART3,
+	SF_PWM0,
+	SF_PWM1,
+	SF_RTC,
+	SF_ETH_LED,
+	SF_JTAG,
+	SF_USB,
+	SF_DDR,
+	SF_RGMII,
+	SF_RMII
+
+} sf_module;
+
+#endif
Index: linux-3.18.29/drivers/usb/dwc2/core.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/core.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/core.c	2017-11-21 20:13:12.454710527 +0800
@@ -56,6 +56,371 @@
 #include "core.h"
 #include "hcd.h"
 
+#if IS_ENABLED(CONFIG_USB_DWC2_HOST) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+/**
+ * dwc2_backup_host_registers() - Backup controller host registers.
+ * When suspending usb bus, registers needs to be backuped
+ * if controller power is disabled once suspended.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ */
+static int dwc2_backup_host_registers(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_hregs_backup *hr;
+	int i;
+
+	dev_dbg(hsotg->dev, "%s\n", __func__);
+
+	/* Backup Host regs */
+	hr = &hsotg->hr_backup;
+	hr->hcfg = dwc2_readl(hsotg->regs + HCFG);
+	hr->haintmsk = dwc2_readl(hsotg->regs + HAINTMSK);
+	for (i = 0; i < hsotg->core_params->host_channels; ++i)
+		hr->hcintmsk[i] = dwc2_readl(hsotg->regs + HCINTMSK(i));
+
+	hr->hprt0 = dwc2_read_hprt0(hsotg);
+	hr->hfir = dwc2_readl(hsotg->regs + HFIR);
+	hr->valid = true;
+
+	return 0;
+}
+
+/**
+ * dwc2_restore_host_registers() - Restore controller host registers.
+ * When resuming usb bus, device registers needs to be restored
+ * if controller power were disabled.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ */
+static int dwc2_restore_host_registers(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_hregs_backup *hr;
+	int i;
+
+	dev_dbg(hsotg->dev, "%s\n", __func__);
+
+	/* Restore host regs */
+	hr = &hsotg->hr_backup;
+	if (!hr->valid) {
+		dev_err(hsotg->dev, "%s: no host registers to restore\n",
+				__func__);
+		return -EINVAL;
+	}
+	hr->valid = false;
+
+	dwc2_writel(hr->hcfg, hsotg->regs + HCFG);
+	dwc2_writel(hr->haintmsk, hsotg->regs + HAINTMSK);
+
+	for (i = 0; i < hsotg->core_params->host_channels; ++i)
+		dwc2_writel(hr->hcintmsk[i], hsotg->regs + HCINTMSK(i));
+
+	dwc2_writel(hr->hprt0, hsotg->regs + HPRT0);
+	dwc2_writel(hr->hfir, hsotg->regs + HFIR);
+	hsotg->frame_number = 0;
+
+	return 0;
+}
+#else
+static inline int dwc2_backup_host_registers(struct dwc2_hsotg *hsotg)
+{ return 0; }
+
+static inline int dwc2_restore_host_registers(struct dwc2_hsotg *hsotg)
+{ return 0; }
+#endif
+
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
+	IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+/**
+ * dwc2_backup_device_registers() - Backup controller device registers.
+ * When suspending usb bus, registers needs to be backuped
+ * if controller power is disabled once suspended.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ */
+static int dwc2_backup_device_registers(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_dregs_backup *dr;
+	int i;
+
+	dev_dbg(hsotg->dev, "%s\n", __func__);
+
+	/* Backup dev regs */
+	dr = &hsotg->dr_backup;
+
+	dr->dcfg = dwc2_readl(hsotg->regs + DCFG);
+	dr->dctl = dwc2_readl(hsotg->regs + DCTL);
+	dr->daintmsk = dwc2_readl(hsotg->regs + DAINTMSK);
+	dr->diepmsk = dwc2_readl(hsotg->regs + DIEPMSK);
+	dr->doepmsk = dwc2_readl(hsotg->regs + DOEPMSK);
+
+	for (i = 0; i < hsotg->num_of_eps; i++) {
+		/* Backup IN EPs */
+		dr->diepctl[i] = dwc2_readl(hsotg->regs + DIEPCTL(i));
+
+		/* Ensure DATA PID is correctly configured */
+		if (dr->diepctl[i] & DXEPCTL_DPID)
+			dr->diepctl[i] |= DXEPCTL_SETD1PID;
+		else
+			dr->diepctl[i] |= DXEPCTL_SETD0PID;
+
+		dr->dieptsiz[i] = dwc2_readl(hsotg->regs + DIEPTSIZ(i));
+		dr->diepdma[i] = dwc2_readl(hsotg->regs + DIEPDMA(i));
+
+		/* Backup OUT EPs */
+		dr->doepctl[i] = dwc2_readl(hsotg->regs + DOEPCTL(i));
+
+		/* Ensure DATA PID is correctly configured */
+		if (dr->doepctl[i] & DXEPCTL_DPID)
+			dr->doepctl[i] |= DXEPCTL_SETD1PID;
+		else
+			dr->doepctl[i] |= DXEPCTL_SETD0PID;
+
+		dr->doeptsiz[i] = dwc2_readl(hsotg->regs + DOEPTSIZ(i));
+		dr->doepdma[i] = dwc2_readl(hsotg->regs + DOEPDMA(i));
+	}
+	dr->valid = true;
+	return 0;
+}
+
+/**
+ * dwc2_restore_device_registers() - Restore controller device registers.
+ * When resuming usb bus, device registers needs to be restored
+ * if controller power were disabled.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ */
+static int dwc2_restore_device_registers(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_dregs_backup *dr;
+	u32 dctl;
+	int i;
+
+	dev_dbg(hsotg->dev, "%s\n", __func__);
+
+	/* Restore dev regs */
+	dr = &hsotg->dr_backup;
+	if (!dr->valid) {
+		dev_err(hsotg->dev, "%s: no device registers to restore\n",
+				__func__);
+		return -EINVAL;
+	}
+	dr->valid = false;
+
+	dwc2_writel(dr->dcfg, hsotg->regs + DCFG);
+	dwc2_writel(dr->dctl, hsotg->regs + DCTL);
+	dwc2_writel(dr->daintmsk, hsotg->regs + DAINTMSK);
+	dwc2_writel(dr->diepmsk, hsotg->regs + DIEPMSK);
+	dwc2_writel(dr->doepmsk, hsotg->regs + DOEPMSK);
+
+	for (i = 0; i < hsotg->num_of_eps; i++) {
+		/* Restore IN EPs */
+		dwc2_writel(dr->diepctl[i], hsotg->regs + DIEPCTL(i));
+		dwc2_writel(dr->dieptsiz[i], hsotg->regs + DIEPTSIZ(i));
+		dwc2_writel(dr->diepdma[i], hsotg->regs + DIEPDMA(i));
+
+		/* Restore OUT EPs */
+		dwc2_writel(dr->doepctl[i], hsotg->regs + DOEPCTL(i));
+		dwc2_writel(dr->doeptsiz[i], hsotg->regs + DOEPTSIZ(i));
+		dwc2_writel(dr->doepdma[i], hsotg->regs + DOEPDMA(i));
+	}
+
+	/* Set the Power-On Programming done bit */
+	dctl = dwc2_readl(hsotg->regs + DCTL);
+	dctl |= DCTL_PWRONPRGDONE;
+	dwc2_writel(dctl, hsotg->regs + DCTL);
+
+	return 0;
+}
+#else
+static inline int dwc2_backup_device_registers(struct dwc2_hsotg *hsotg)
+{ return 0; }
+
+static inline int dwc2_restore_device_registers(struct dwc2_hsotg *hsotg)
+{ return 0; }
+#endif
+
+/**
+ * dwc2_backup_global_registers() - Backup global controller registers.
+ * When suspending usb bus, registers needs to be backuped
+ * if controller power is disabled once suspended.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ */
+static int dwc2_backup_global_registers(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_gregs_backup *gr;
+	int i;
+
+	/* Backup global regs */
+	gr = &hsotg->gr_backup;
+
+	gr->gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
+	gr->gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
+	gr->gahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
+	gr->gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
+	gr->grxfsiz = dwc2_readl(hsotg->regs + GRXFSIZ);
+	gr->gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
+	gr->hptxfsiz = dwc2_readl(hsotg->regs + HPTXFSIZ);
+	gr->gdfifocfg = dwc2_readl(hsotg->regs + GDFIFOCFG);
+	for (i = 0; i < MAX_EPS_CHANNELS; i++)
+		gr->dtxfsiz[i] = dwc2_readl(hsotg->regs + DPTXFSIZN(i));
+
+	gr->valid = true;
+	return 0;
+}
+
+/**
+ * dwc2_restore_global_registers() - Restore controller global registers.
+ * When resuming usb bus, device registers needs to be restored
+ * if controller power were disabled.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ */
+static int dwc2_restore_global_registers(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_gregs_backup *gr;
+	int i;
+
+	dev_dbg(hsotg->dev, "%s\n", __func__);
+
+	/* Restore global regs */
+	gr = &hsotg->gr_backup;
+	if (!gr->valid) {
+		dev_err(hsotg->dev, "%s: no global registers to restore\n",
+				__func__);
+		return -EINVAL;
+	}
+	gr->valid = false;
+
+	dwc2_writel(0xffffffff, hsotg->regs + GINTSTS);
+	dwc2_writel(gr->gotgctl, hsotg->regs + GOTGCTL);
+	dwc2_writel(gr->gintmsk, hsotg->regs + GINTMSK);
+	dwc2_writel(gr->gusbcfg, hsotg->regs + GUSBCFG);
+	dwc2_writel(gr->gahbcfg, hsotg->regs + GAHBCFG);
+	dwc2_writel(gr->grxfsiz, hsotg->regs + GRXFSIZ);
+	dwc2_writel(gr->gnptxfsiz, hsotg->regs + GNPTXFSIZ);
+	dwc2_writel(gr->hptxfsiz, hsotg->regs + HPTXFSIZ);
+	dwc2_writel(gr->gdfifocfg, hsotg->regs + GDFIFOCFG);
+	for (i = 0; i < MAX_EPS_CHANNELS; i++)
+		dwc2_writel(gr->dtxfsiz[i], hsotg->regs + DPTXFSIZN(i));
+
+	return 0;
+}
+
+/**
+ * dwc2_exit_hibernation() - Exit controller from Partial Power Down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @restore: Controller registers need to be restored
+ */
+int dwc2_exit_hibernation(struct dwc2_hsotg *hsotg, bool restore)
+{
+	u32 pcgcctl;
+	int ret = 0;
+
+	if (!hsotg->core_params->hibernation)
+		return -ENOTSUPP;
+
+	pcgcctl = dwc2_readl(hsotg->regs + PCGCTL);
+	pcgcctl &= ~PCGCTL_STOPPCLK;
+	dwc2_writel(pcgcctl, hsotg->regs + PCGCTL);
+
+	pcgcctl = dwc2_readl(hsotg->regs + PCGCTL);
+	pcgcctl &= ~PCGCTL_PWRCLMP;
+	dwc2_writel(pcgcctl, hsotg->regs + PCGCTL);
+
+	pcgcctl = dwc2_readl(hsotg->regs + PCGCTL);
+	pcgcctl &= ~PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(pcgcctl, hsotg->regs + PCGCTL);
+
+	udelay(100);
+	if (restore) {
+		ret = dwc2_restore_global_registers(hsotg);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to restore registers\n",
+					__func__);
+			return ret;
+		}
+		if (dwc2_is_host_mode(hsotg)) {
+			ret = dwc2_restore_host_registers(hsotg);
+			if (ret) {
+				dev_err(hsotg->dev, "%s: failed to restore host registers\n",
+						__func__);
+				return ret;
+			}
+		} else {
+			ret = dwc2_restore_device_registers(hsotg);
+			if (ret) {
+				dev_err(hsotg->dev, "%s: failed to restore device registers\n",
+						__func__);
+				return ret;
+			}
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * dwc2_enter_hibernation() - Put controller in Partial Power Down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ */
+int dwc2_enter_hibernation(struct dwc2_hsotg *hsotg)
+{
+	u32 pcgcctl;
+	int ret = 0;
+
+	if (!hsotg->core_params->hibernation)
+		return -ENOTSUPP;
+
+	/* Backup all registers */
+	ret = dwc2_backup_global_registers(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to backup global registers\n",
+				__func__);
+		return ret;
+	}
+
+	if (dwc2_is_host_mode(hsotg)) {
+		ret = dwc2_backup_host_registers(hsotg);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to backup host registers\n",
+					__func__);
+			return ret;
+		}
+	} else {
+		ret = dwc2_backup_device_registers(hsotg);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to backup device registers\n",
+					__func__);
+			return ret;
+		}
+	}
+
+	/*
+	 * Clear any pending interrupts since dwc2 will not be able to
+	 * clear them after entering hibernation.
+	 */
+	dwc2_writel(0xffffffff, hsotg->regs + GINTSTS);
+
+	/* Put the controller in low power state */
+	pcgcctl = dwc2_readl(hsotg->regs + PCGCTL);
+
+	pcgcctl |= PCGCTL_PWRCLMP;
+	dwc2_writel(pcgcctl, hsotg->regs + PCGCTL);
+	ndelay(20);
+
+	pcgcctl |= PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(pcgcctl, hsotg->regs + PCGCTL);
+	ndelay(20);
+
+	pcgcctl |= PCGCTL_STOPPCLK;
+	dwc2_writel(pcgcctl, hsotg->regs + PCGCTL);
+
+	return ret;
+}
+
 /**
  * dwc2_enable_common_interrupts() - Initializes the commmon interrupts,
  * used in both device and host modes
@@ -67,21 +432,23 @@
 	u32 intmsk;
 
 	/* Clear any pending OTG Interrupts */
-	writel(0xffffffff, hsotg->regs + GOTGINT);
+	dwc2_writel(0xffffffff, hsotg->regs + GOTGINT);
 
 	/* Clear any pending interrupts */
-	writel(0xffffffff, hsotg->regs + GINTSTS);
+	dwc2_writel(0xffffffff, hsotg->regs + GINTSTS);
 
 	/* Enable the interrupts in the GINTMSK */
 	intmsk = GINTSTS_MODEMIS | GINTSTS_OTGINT;
 
 	if (hsotg->core_params->dma_enable <= 0)
 		intmsk |= GINTSTS_RXFLVL;
+	if (hsotg->core_params->external_id_pin_ctl <= 0)
+		intmsk |= GINTSTS_CONIDSTSCHNG;
 
-	intmsk |= GINTSTS_CONIDSTSCHNG | GINTSTS_WKUPINT | GINTSTS_USBSUSP |
+	intmsk |= GINTSTS_WKUPINT | GINTSTS_USBSUSP |
 		  GINTSTS_SESSREQINT;
 
-	writel(intmsk, hsotg->regs + GINTMSK);
+	dwc2_writel(intmsk, hsotg->regs + GINTMSK);
 }
 
 /*
@@ -104,10 +471,10 @@
 	}
 
 	dev_dbg(hsotg->dev, "Initializing HCFG.FSLSPClkSel to %08x\n", val);
-	hcfg = readl(hsotg->regs + HCFG);
+	hcfg = dwc2_readl(hsotg->regs + HCFG);
 	hcfg &= ~HCFG_FSLSPCLKSEL_MASK;
 	hcfg |= val << HCFG_FSLSPCLKSEL_SHIFT;
-	writel(hcfg, hsotg->regs + HCFG);
+	dwc2_writel(hcfg, hsotg->regs + HCFG);
 }
 
 /*
@@ -125,7 +492,7 @@
 	/* Wait for AHB master IDLE state */
 	do {
 		usleep_range(20000, 40000);
-		greset = readl(hsotg->regs + GRSTCTL);
+		greset = dwc2_readl(hsotg->regs + GRSTCTL);
 		if (++count > 50) {
 			dev_warn(hsotg->dev,
 				 "%s() HANG! AHB Idle GRSTCTL=%0x\n",
@@ -137,10 +504,10 @@
 	/* Core Soft Reset */
 	count = 0;
 	greset |= GRSTCTL_CSFTRST;
-	writel(greset, hsotg->regs + GRSTCTL);
+	dwc2_writel(greset, hsotg->regs + GRSTCTL);
 	do {
 		usleep_range(20000, 40000);
-		greset = readl(hsotg->regs + GRSTCTL);
+		greset = dwc2_readl(hsotg->regs + GRSTCTL);
 		if (++count > 50) {
 			dev_warn(hsotg->dev,
 				 "%s() HANG! Soft Reset GRSTCTL=%0x\n",
@@ -150,20 +517,20 @@
 	} while (greset & GRSTCTL_CSFTRST);
 
 	if (hsotg->dr_mode == USB_DR_MODE_HOST) {
-		gusbcfg = readl(hsotg->regs + GUSBCFG);
+		gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 		gusbcfg &= ~GUSBCFG_FORCEDEVMODE;
 		gusbcfg |= GUSBCFG_FORCEHOSTMODE;
-		writel(gusbcfg, hsotg->regs + GUSBCFG);
+		dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
 	} else if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) {
-		gusbcfg = readl(hsotg->regs + GUSBCFG);
+		gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 		gusbcfg &= ~GUSBCFG_FORCEHOSTMODE;
 		gusbcfg |= GUSBCFG_FORCEDEVMODE;
-		writel(gusbcfg, hsotg->regs + GUSBCFG);
+		dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
 	} else if (hsotg->dr_mode == USB_DR_MODE_OTG) {
-		gusbcfg = readl(hsotg->regs + GUSBCFG);
+		gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 		gusbcfg &= ~GUSBCFG_FORCEHOSTMODE;
 		gusbcfg &= ~GUSBCFG_FORCEDEVMODE;
-		writel(gusbcfg, hsotg->regs + GUSBCFG);
+		dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
 	}
 
 	/*
@@ -186,9 +553,9 @@
 	 */
 	if (select_phy) {
 		dev_dbg(hsotg->dev, "FS PHY selected\n");
-		usbcfg = readl(hsotg->regs + GUSBCFG);
+		usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 		usbcfg |= GUSBCFG_PHYSEL;
-		writel(usbcfg, hsotg->regs + GUSBCFG);
+		dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
 
 		/* Reset after a PHY select */
 		retval = dwc2_core_reset(hsotg);
@@ -211,18 +578,18 @@
 		dev_dbg(hsotg->dev, "FS PHY enabling I2C\n");
 
 		/* Program GUSBCFG.OtgUtmiFsSel to I2C */
-		usbcfg = readl(hsotg->regs + GUSBCFG);
+		usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 		usbcfg |= GUSBCFG_OTG_UTMI_FS_SEL;
-		writel(usbcfg, hsotg->regs + GUSBCFG);
+		dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
 
 		/* Program GI2CCTL.I2CEn */
-		i2cctl = readl(hsotg->regs + GI2CCTL);
+		i2cctl = dwc2_readl(hsotg->regs + GI2CCTL);
 		i2cctl &= ~GI2CCTL_I2CDEVADDR_MASK;
 		i2cctl |= 1 << GI2CCTL_I2CDEVADDR_SHIFT;
 		i2cctl &= ~GI2CCTL_I2CEN;
-		writel(i2cctl, hsotg->regs + GI2CCTL);
+		dwc2_writel(i2cctl, hsotg->regs + GI2CCTL);
 		i2cctl |= GI2CCTL_I2CEN;
-		writel(i2cctl, hsotg->regs + GI2CCTL);
+		dwc2_writel(i2cctl, hsotg->regs + GI2CCTL);
 	}
 
 	return retval;
@@ -236,7 +603,7 @@
 	if (!select_phy)
 		return 0;
 
-	usbcfg = readl(hsotg->regs + GUSBCFG);
+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 
 	/*
 	 * HS PHY parameters. These parameters are preserved during soft reset
@@ -264,7 +631,7 @@
 		break;
 	}
 
-	writel(usbcfg, hsotg->regs + GUSBCFG);
+	dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
 
 	/* Reset after setting the PHY parameters */
 	retval = dwc2_core_reset(hsotg);
@@ -299,15 +666,15 @@
 	    hsotg->hw_params.fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED &&
 	    hsotg->core_params->ulpi_fs_ls > 0) {
 		dev_dbg(hsotg->dev, "Setting ULPI FSLS\n");
-		usbcfg = readl(hsotg->regs + GUSBCFG);
+		usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 		usbcfg |= GUSBCFG_ULPI_FS_LS;
 		usbcfg |= GUSBCFG_ULPI_CLK_SUSP_M;
-		writel(usbcfg, hsotg->regs + GUSBCFG);
+		dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
 	} else {
-		usbcfg = readl(hsotg->regs + GUSBCFG);
+		usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 		usbcfg &= ~GUSBCFG_ULPI_FS_LS;
 		usbcfg &= ~GUSBCFG_ULPI_CLK_SUSP_M;
-		writel(usbcfg, hsotg->regs + GUSBCFG);
+		dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
 	}
 
 	return retval;
@@ -315,7 +682,7 @@
 
 static int dwc2_gahbcfg_init(struct dwc2_hsotg *hsotg)
 {
-	u32 ahbcfg = readl(hsotg->regs + GAHBCFG);
+	u32 ahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
 
 	switch (hsotg->hw_params.arch) {
 	case GHWCFG2_EXT_DMA_ARCH:
@@ -354,7 +721,7 @@
 	if (hsotg->core_params->dma_enable > 0)
 		ahbcfg |= GAHBCFG_DMA_EN;
 
-	writel(ahbcfg, hsotg->regs + GAHBCFG);
+	dwc2_writel(ahbcfg, hsotg->regs + GAHBCFG);
 
 	return 0;
 }
@@ -363,7 +730,7 @@
 {
 	u32 usbcfg;
 
-	usbcfg = readl(hsotg->regs + GUSBCFG);
+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 	usbcfg &= ~(GUSBCFG_HNPCAP | GUSBCFG_SRPCAP);
 
 	switch (hsotg->hw_params.op_mode) {
@@ -391,7 +758,7 @@
 		break;
 	}
 
-	writel(usbcfg, hsotg->regs + GUSBCFG);
+	dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
 }
 
 /**
@@ -409,7 +776,7 @@
 
 	dev_dbg(hsotg->dev, "%s(%p)\n", __func__, hsotg);
 
-	usbcfg = readl(hsotg->regs + GUSBCFG);
+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 
 	/* Set ULPI External VBUS bit if needed */
 	usbcfg &= ~GUSBCFG_ULPI_EXT_VBUS_DRV;
@@ -422,7 +789,7 @@
 	if (hsotg->core_params->ts_dline > 0)
 		usbcfg |= GUSBCFG_TERMSELDLPULSE;
 
-	writel(usbcfg, hsotg->regs + GUSBCFG);
+	dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
 
 	/* Reset the Controller */
 	retval = dwc2_core_reset(hsotg);
@@ -448,31 +815,21 @@
 	dwc2_gusbcfg_init(hsotg);
 
 	/* Program the GOTGCTL register */
-	otgctl = readl(hsotg->regs + GOTGCTL);
+	otgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 	otgctl &= ~GOTGCTL_OTGVER;
 	if (hsotg->core_params->otg_ver > 0)
 		otgctl |= GOTGCTL_OTGVER;
-	writel(otgctl, hsotg->regs + GOTGCTL);
+	dwc2_writel(otgctl, hsotg->regs + GOTGCTL);
 	dev_dbg(hsotg->dev, "OTG VER PARAM: %d\n", hsotg->core_params->otg_ver);
 
 	/* Clear the SRP success bit for FS-I2c */
 	hsotg->srp_success = 0;
 
-	if (irq >= 0) {
-		dev_dbg(hsotg->dev, "registering common handler for irq%d\n",
-			irq);
-		retval = devm_request_irq(hsotg->dev, irq,
-					  dwc2_handle_common_intr, IRQF_SHARED,
-					  dev_name(hsotg->dev), hsotg);
-		if (retval)
-			return retval;
-	}
-
 	/* Enable common interrupts */
 	dwc2_enable_common_interrupts(hsotg);
 
 	/*
-	 * Do device or host intialization based on mode during PCD and
+	 * Do device or host initialization based on mode during PCD and
 	 * HCD initialization
 	 */
 	if (dwc2_is_host_mode(hsotg)) {
@@ -498,16 +855,16 @@
 	dev_dbg(hsotg->dev, "%s()\n", __func__);
 
 	/* Disable all interrupts */
-	writel(0, hsotg->regs + GINTMSK);
-	writel(0, hsotg->regs + HAINTMSK);
+	dwc2_writel(0, hsotg->regs + GINTMSK);
+	dwc2_writel(0, hsotg->regs + HAINTMSK);
 
 	/* Enable the common interrupts */
 	dwc2_enable_common_interrupts(hsotg);
 
 	/* Enable host mode interrupts without disturbing common interrupts */
-	intmsk = readl(hsotg->regs + GINTMSK);
+	intmsk = dwc2_readl(hsotg->regs + GINTMSK);
 	intmsk |= GINTSTS_DISCONNINT | GINTSTS_PRTINT | GINTSTS_HCHINT;
-	writel(intmsk, hsotg->regs + GINTMSK);
+	dwc2_writel(intmsk, hsotg->regs + GINTMSK);
 }
 
 /**
@@ -517,12 +874,12 @@
  */
 void dwc2_disable_host_interrupts(struct dwc2_hsotg *hsotg)
 {
-	u32 intmsk = readl(hsotg->regs + GINTMSK);
+	u32 intmsk = dwc2_readl(hsotg->regs + GINTMSK);
 
 	/* Disable host mode interrupts without disturbing common interrupts */
 	intmsk &= ~(GINTSTS_SOF | GINTSTS_PRTINT | GINTSTS_HCHINT |
-		    GINTSTS_PTXFEMP | GINTSTS_NPTXFEMP);
-	writel(intmsk, hsotg->regs + GINTMSK);
+		    GINTSTS_PTXFEMP | GINTSTS_NPTXFEMP | GINTSTS_DISCONNINT);
+	dwc2_writel(intmsk, hsotg->regs + GINTMSK);
 }
 
 /*
@@ -602,36 +959,37 @@
 	dwc2_calculate_dynamic_fifo(hsotg);
 
 	/* Rx FIFO */
-	grxfsiz = readl(hsotg->regs + GRXFSIZ);
+	grxfsiz = dwc2_readl(hsotg->regs + GRXFSIZ);
 	dev_dbg(hsotg->dev, "initial grxfsiz=%08x\n", grxfsiz);
 	grxfsiz &= ~GRXFSIZ_DEPTH_MASK;
 	grxfsiz |= params->host_rx_fifo_size <<
 		   GRXFSIZ_DEPTH_SHIFT & GRXFSIZ_DEPTH_MASK;
-	writel(grxfsiz, hsotg->regs + GRXFSIZ);
-	dev_dbg(hsotg->dev, "new grxfsiz=%08x\n", readl(hsotg->regs + GRXFSIZ));
+	dwc2_writel(grxfsiz, hsotg->regs + GRXFSIZ);
+	dev_dbg(hsotg->dev, "new grxfsiz=%08x\n",
+		dwc2_readl(hsotg->regs + GRXFSIZ));
 
 	/* Non-periodic Tx FIFO */
 	dev_dbg(hsotg->dev, "initial gnptxfsiz=%08x\n",
-		readl(hsotg->regs + GNPTXFSIZ));
+		dwc2_readl(hsotg->regs + GNPTXFSIZ));
 	nptxfsiz = params->host_nperio_tx_fifo_size <<
 		   FIFOSIZE_DEPTH_SHIFT & FIFOSIZE_DEPTH_MASK;
 	nptxfsiz |= params->host_rx_fifo_size <<
 		    FIFOSIZE_STARTADDR_SHIFT & FIFOSIZE_STARTADDR_MASK;
-	writel(nptxfsiz, hsotg->regs + GNPTXFSIZ);
+	dwc2_writel(nptxfsiz, hsotg->regs + GNPTXFSIZ);
 	dev_dbg(hsotg->dev, "new gnptxfsiz=%08x\n",
-		readl(hsotg->regs + GNPTXFSIZ));
+		dwc2_readl(hsotg->regs + GNPTXFSIZ));
 
 	/* Periodic Tx FIFO */
 	dev_dbg(hsotg->dev, "initial hptxfsiz=%08x\n",
-		readl(hsotg->regs + HPTXFSIZ));
+		dwc2_readl(hsotg->regs + HPTXFSIZ));
 	hptxfsiz = params->host_perio_tx_fifo_size <<
 		   FIFOSIZE_DEPTH_SHIFT & FIFOSIZE_DEPTH_MASK;
 	hptxfsiz |= (params->host_rx_fifo_size +
 		     params->host_nperio_tx_fifo_size) <<
 		    FIFOSIZE_STARTADDR_SHIFT & FIFOSIZE_STARTADDR_MASK;
-	writel(hptxfsiz, hsotg->regs + HPTXFSIZ);
+	dwc2_writel(hptxfsiz, hsotg->regs + HPTXFSIZ);
 	dev_dbg(hsotg->dev, "new hptxfsiz=%08x\n",
-		readl(hsotg->regs + HPTXFSIZ));
+		dwc2_readl(hsotg->regs + HPTXFSIZ));
 
 	if (hsotg->core_params->en_multiple_tx_fifo > 0 &&
 	    hsotg->hw_params.snpsid <= DWC2_CORE_REV_2_94a) {
@@ -639,14 +997,14 @@
 		 * Global DFIFOCFG calculation for Host mode -
 		 * include RxFIFO, NPTXFIFO and HPTXFIFO
 		 */
-		dfifocfg = readl(hsotg->regs + GDFIFOCFG);
+		dfifocfg = dwc2_readl(hsotg->regs + GDFIFOCFG);
 		dfifocfg &= ~GDFIFOCFG_EPINFOBASE_MASK;
 		dfifocfg |= (params->host_rx_fifo_size +
 			     params->host_nperio_tx_fifo_size +
 			     params->host_perio_tx_fifo_size) <<
 			    GDFIFOCFG_EPINFOBASE_SHIFT &
 			    GDFIFOCFG_EPINFOBASE_MASK;
-		writel(dfifocfg, hsotg->regs + GDFIFOCFG);
+		dwc2_writel(dfifocfg, hsotg->regs + GDFIFOCFG);
 	}
 }
 
@@ -667,14 +1025,14 @@
 	dev_dbg(hsotg->dev, "%s(%p)\n", __func__, hsotg);
 
 	/* Restart the Phy Clock */
-	writel(0, hsotg->regs + PCGCTL);
+	dwc2_writel(0, hsotg->regs + PCGCTL);
 
 	/* Initialize Host Configuration Register */
 	dwc2_init_fs_ls_pclk_sel(hsotg);
 	if (hsotg->core_params->speed == DWC2_SPEED_PARAM_FULL) {
-		hcfg = readl(hsotg->regs + HCFG);
+		hcfg = dwc2_readl(hsotg->regs + HCFG);
 		hcfg |= HCFG_FSLSSUPP;
-		writel(hcfg, hsotg->regs + HCFG);
+		dwc2_writel(hcfg, hsotg->regs + HCFG);
 	}
 
 	/*
@@ -683,9 +1041,9 @@
 	 * and its value must not be changed during runtime.
 	 */
 	if (hsotg->core_params->reload_ctl > 0) {
-		hfir = readl(hsotg->regs + HFIR);
+		hfir = dwc2_readl(hsotg->regs + HFIR);
 		hfir |= HFIR_RLDCTRL;
-		writel(hfir, hsotg->regs + HFIR);
+		dwc2_writel(hfir, hsotg->regs + HFIR);
 	}
 
 	if (hsotg->core_params->dma_desc_enable > 0) {
@@ -701,9 +1059,9 @@
 				"falling back to buffer DMA mode.\n");
 			hsotg->core_params->dma_desc_enable = 0;
 		} else {
-			hcfg = readl(hsotg->regs + HCFG);
+			hcfg = dwc2_readl(hsotg->regs + HCFG);
 			hcfg |= HCFG_DESCDMA;
-			writel(hcfg, hsotg->regs + HCFG);
+			dwc2_writel(hcfg, hsotg->regs + HCFG);
 		}
 	}
 
@@ -712,18 +1070,18 @@
 
 	/* TODO - check this */
 	/* Clear Host Set HNP Enable in the OTG Control Register */
-	otgctl = readl(hsotg->regs + GOTGCTL);
+	otgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 	otgctl &= ~GOTGCTL_HSTSETHNPEN;
-	writel(otgctl, hsotg->regs + GOTGCTL);
+	dwc2_writel(otgctl, hsotg->regs + GOTGCTL);
 
 	/* Make sure the FIFOs are flushed */
 	dwc2_flush_tx_fifo(hsotg, 0x10 /* all TX FIFOs */);
 	dwc2_flush_rx_fifo(hsotg);
 
 	/* Clear Host Set HNP Enable in the OTG Control Register */
-	otgctl = readl(hsotg->regs + GOTGCTL);
+	otgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 	otgctl &= ~GOTGCTL_HSTSETHNPEN;
-	writel(otgctl, hsotg->regs + GOTGCTL);
+	dwc2_writel(otgctl, hsotg->regs + GOTGCTL);
 
 	if (hsotg->core_params->dma_desc_enable <= 0) {
 		int num_channels, i;
@@ -732,25 +1090,25 @@
 		/* Flush out any leftover queued requests */
 		num_channels = hsotg->core_params->host_channels;
 		for (i = 0; i < num_channels; i++) {
-			hcchar = readl(hsotg->regs + HCCHAR(i));
+			hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
 			hcchar &= ~HCCHAR_CHENA;
 			hcchar |= HCCHAR_CHDIS;
 			hcchar &= ~HCCHAR_EPDIR;
-			writel(hcchar, hsotg->regs + HCCHAR(i));
+			dwc2_writel(hcchar, hsotg->regs + HCCHAR(i));
 		}
 
 		/* Halt all channels to put them into a known state */
 		for (i = 0; i < num_channels; i++) {
 			int count = 0;
 
-			hcchar = readl(hsotg->regs + HCCHAR(i));
+			hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
 			hcchar |= HCCHAR_CHENA | HCCHAR_CHDIS;
 			hcchar &= ~HCCHAR_EPDIR;
-			writel(hcchar, hsotg->regs + HCCHAR(i));
+			dwc2_writel(hcchar, hsotg->regs + HCCHAR(i));
 			dev_dbg(hsotg->dev, "%s: Halt channel %d\n",
 				__func__, i);
 			do {
-				hcchar = readl(hsotg->regs + HCCHAR(i));
+				hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
 				if (++count > 1000) {
 					dev_err(hsotg->dev,
 						"Unable to clear enable on channel %d\n",
@@ -771,7 +1129,7 @@
 			!!(hprt0 & HPRT0_PWR));
 		if (!(hprt0 & HPRT0_PWR)) {
 			hprt0 |= HPRT0_PWR;
-			writel(hprt0, hsotg->regs + HPRT0);
+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
 		}
 	}
 
@@ -851,7 +1209,7 @@
 		break;
 	}
 
-	writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
+	dwc2_writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
 	if (dbg_hc(chan))
 		dev_vdbg(hsotg->dev, "set HCINTMSK to %08x\n", hcintmsk);
 }
@@ -888,7 +1246,7 @@
 		}
 	}
 
-	writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
+	dwc2_writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
 	if (dbg_hc(chan))
 		dev_vdbg(hsotg->dev, "set HCINTMSK to %08x\n", hcintmsk);
 }
@@ -909,16 +1267,16 @@
 	}
 
 	/* Enable the top level host channel interrupt */
-	intmsk = readl(hsotg->regs + HAINTMSK);
+	intmsk = dwc2_readl(hsotg->regs + HAINTMSK);
 	intmsk |= 1 << chan->hc_num;
-	writel(intmsk, hsotg->regs + HAINTMSK);
+	dwc2_writel(intmsk, hsotg->regs + HAINTMSK);
 	if (dbg_hc(chan))
 		dev_vdbg(hsotg->dev, "set HAINTMSK to %08x\n", intmsk);
 
 	/* Make sure host channel interrupts are enabled */
-	intmsk = readl(hsotg->regs + GINTMSK);
+	intmsk = dwc2_readl(hsotg->regs + GINTMSK);
 	intmsk |= GINTSTS_HCHINT;
-	writel(intmsk, hsotg->regs + GINTMSK);
+	dwc2_writel(intmsk, hsotg->regs + GINTMSK);
 	if (dbg_hc(chan))
 		dev_vdbg(hsotg->dev, "set GINTMSK to %08x\n", intmsk);
 }
@@ -947,7 +1305,7 @@
 	/* Clear old interrupt conditions for this host channel */
 	hcintmsk = 0xffffffff;
 	hcintmsk &= ~HCINTMSK_RESERVED14_31;
-	writel(hcintmsk, hsotg->regs + HCINT(hc_num));
+	dwc2_writel(hcintmsk, hsotg->regs + HCINT(hc_num));
 
 	/* Enable channel interrupts required for this transfer */
 	dwc2_hc_enable_ints(hsotg, chan);
@@ -964,7 +1322,7 @@
 		hcchar |= HCCHAR_LSPDDEV;
 	hcchar |= chan->ep_type << HCCHAR_EPTYPE_SHIFT & HCCHAR_EPTYPE_MASK;
 	hcchar |= chan->max_packet << HCCHAR_MPS_SHIFT & HCCHAR_MPS_MASK;
-	writel(hcchar, hsotg->regs + HCCHAR(hc_num));
+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(hc_num));
 	if (dbg_hc(chan)) {
 		dev_vdbg(hsotg->dev, "set HCCHAR(%d) to %08x\n",
 			 hc_num, hcchar);
@@ -1018,7 +1376,7 @@
 		}
 	}
 
-	writel(hcsplt, hsotg->regs + HCSPLT(hc_num));
+	dwc2_writel(hcsplt, hsotg->regs + HCSPLT(hc_num));
 }
 
 /**
@@ -1070,14 +1428,14 @@
 		u32 hcintmsk = HCINTMSK_CHHLTD;
 
 		dev_vdbg(hsotg->dev, "dequeue/error\n");
-		writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
+		dwc2_writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
 
 		/*
 		 * Make sure no other interrupts besides halt are currently
 		 * pending. Handling another interrupt could cause a crash due
 		 * to the QTD and QH state.
 		 */
-		writel(~hcintmsk, hsotg->regs + HCINT(chan->hc_num));
+		dwc2_writel(~hcintmsk, hsotg->regs + HCINT(chan->hc_num));
 
 		/*
 		 * Make sure the halt status is set to URB_DEQUEUE or AHB_ERR
@@ -1086,7 +1444,7 @@
 		 */
 		chan->halt_status = halt_status;
 
-		hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
+		hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
 		if (!(hcchar & HCCHAR_CHENA)) {
 			/*
 			 * The channel is either already halted or it hasn't
@@ -1114,7 +1472,7 @@
 		return;
 	}
 
-	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
 
 	/* No need to set the bit in DDMA for disabling the channel */
 	/* TODO check it everywhere channel is disabled */
@@ -1137,7 +1495,7 @@
 		if (chan->ep_type == USB_ENDPOINT_XFER_CONTROL ||
 		    chan->ep_type == USB_ENDPOINT_XFER_BULK) {
 			dev_vdbg(hsotg->dev, "control/bulk\n");
-			nptxsts = readl(hsotg->regs + GNPTXSTS);
+			nptxsts = dwc2_readl(hsotg->regs + GNPTXSTS);
 			if ((nptxsts & TXSTS_QSPCAVAIL_MASK) == 0) {
 				dev_vdbg(hsotg->dev, "Disabling channel\n");
 				hcchar &= ~HCCHAR_CHENA;
@@ -1145,7 +1503,7 @@
 		} else {
 			if (dbg_perio())
 				dev_vdbg(hsotg->dev, "isoc/intr\n");
-			hptxsts = readl(hsotg->regs + HPTXSTS);
+			hptxsts = dwc2_readl(hsotg->regs + HPTXSTS);
 			if ((hptxsts & TXSTS_QSPCAVAIL_MASK) == 0 ||
 			    hsotg->queuing_high_bandwidth) {
 				if (dbg_perio())
@@ -1158,7 +1516,7 @@
 			dev_vdbg(hsotg->dev, "DMA enabled\n");
 	}
 
-	writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
 	chan->halt_status = halt_status;
 
 	if (hcchar & HCCHAR_CHENA) {
@@ -1205,10 +1563,10 @@
 	 * Clear channel interrupt enables and any unhandled channel interrupt
 	 * conditions
 	 */
-	writel(0, hsotg->regs + HCINTMSK(chan->hc_num));
+	dwc2_writel(0, hsotg->regs + HCINTMSK(chan->hc_num));
 	hcintmsk = 0xffffffff;
 	hcintmsk &= ~HCINTMSK_RESERVED14_31;
-	writel(hcintmsk, hsotg->regs + HCINT(chan->hc_num));
+	dwc2_writel(hcintmsk, hsotg->regs + HCINT(chan->hc_num));
 }
 
 /**
@@ -1294,13 +1652,13 @@
 	if (((unsigned long)data_buf & 0x3) == 0) {
 		/* xfer_buf is DWORD aligned */
 		for (i = 0; i < dword_count; i++, data_buf++)
-			writel(*data_buf, data_fifo);
+			dwc2_writel(*data_buf, data_fifo);
 	} else {
 		/* xfer_buf is not DWORD aligned */
 		for (i = 0; i < dword_count; i++, data_buf++) {
 			u32 data = data_buf[0] | data_buf[1] << 8 |
 				   data_buf[2] << 16 | data_buf[3] << 24;
-			writel(data, data_fifo);
+			dwc2_writel(data, data_fifo);
 		}
 	}
 
@@ -1453,7 +1811,7 @@
 	hctsiz |= num_packets << TSIZ_PKTCNT_SHIFT & TSIZ_PKTCNT_MASK;
 	hctsiz |= chan->data_pid_start << TSIZ_SC_MC_PID_SHIFT &
 		  TSIZ_SC_MC_PID_MASK;
-	writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
+	dwc2_writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
 	if (dbg_hc(chan)) {
 		dev_vdbg(hsotg->dev, "Wrote %08x to HCTSIZ(%d)\n",
 			 hctsiz, chan->hc_num);
@@ -1481,7 +1839,7 @@
 		} else {
 			dma_addr = chan->xfer_dma;
 		}
-		writel((u32)dma_addr, hsotg->regs + HCDMA(chan->hc_num));
+		dwc2_writel((u32)dma_addr, hsotg->regs + HCDMA(chan->hc_num));
 		if (dbg_hc(chan))
 			dev_vdbg(hsotg->dev, "Wrote %08lx to HCDMA(%d)\n",
 				 (unsigned long)dma_addr, chan->hc_num);
@@ -1489,13 +1847,13 @@
 
 	/* Start the split */
 	if (chan->do_split) {
-		u32 hcsplt = readl(hsotg->regs + HCSPLT(chan->hc_num));
+		u32 hcsplt = dwc2_readl(hsotg->regs + HCSPLT(chan->hc_num));
 
 		hcsplt |= HCSPLT_SPLTENA;
-		writel(hcsplt, hsotg->regs + HCSPLT(chan->hc_num));
+		dwc2_writel(hcsplt, hsotg->regs + HCSPLT(chan->hc_num));
 	}
 
-	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
 	hcchar &= ~HCCHAR_MULTICNT_MASK;
 	hcchar |= chan->multi_count << HCCHAR_MULTICNT_SHIFT &
 		  HCCHAR_MULTICNT_MASK;
@@ -1515,7 +1873,7 @@
 			 (hcchar & HCCHAR_MULTICNT_MASK) >>
 			 HCCHAR_MULTICNT_SHIFT);
 
-	writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
 	if (dbg_hc(chan))
 		dev_vdbg(hsotg->dev, "Wrote %08x to HCCHAR(%d)\n", hcchar,
 			 chan->hc_num);
@@ -1574,18 +1932,18 @@
 		dev_vdbg(hsotg->dev, "	 NTD: %d\n", chan->ntd - 1);
 	}
 
-	writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
+	dwc2_writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
 
 	hc_dma = (u32)chan->desc_list_addr & HCDMA_DMA_ADDR_MASK;
 
 	/* Always start from first descriptor */
 	hc_dma &= ~HCDMA_CTD_MASK;
-	writel(hc_dma, hsotg->regs + HCDMA(chan->hc_num));
+	dwc2_writel(hc_dma, hsotg->regs + HCDMA(chan->hc_num));
 	if (dbg_hc(chan))
 		dev_vdbg(hsotg->dev, "Wrote %08x to HCDMA(%d)\n",
 			 hc_dma, chan->hc_num);
 
-	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
 	hcchar &= ~HCCHAR_MULTICNT_MASK;
 	hcchar |= chan->multi_count << HCCHAR_MULTICNT_SHIFT &
 		  HCCHAR_MULTICNT_MASK;
@@ -1604,7 +1962,7 @@
 			 (hcchar & HCCHAR_MULTICNT_MASK) >>
 			 HCCHAR_MULTICNT_SHIFT);
 
-	writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
 	if (dbg_hc(chan))
 		dev_vdbg(hsotg->dev, "Wrote %08x to HCCHAR(%d)\n", hcchar,
 			 chan->hc_num);
@@ -1661,7 +2019,7 @@
 		 * transfer completes, the extra requests for the channel will
 		 * be flushed.
 		 */
-		u32 hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
+		u32 hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
 
 		dwc2_hc_set_even_odd_frame(hsotg, chan, &hcchar);
 		hcchar |= HCCHAR_CHENA;
@@ -1669,7 +2027,7 @@
 		if (dbg_hc(chan))
 			dev_vdbg(hsotg->dev, "	 IN xfer: hcchar = 0x%08x\n",
 				 hcchar);
-		writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
+		dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
 		chan->requests++;
 		return 1;
 	}
@@ -1679,8 +2037,8 @@
 	if (chan->xfer_count < chan->xfer_len) {
 		if (chan->ep_type == USB_ENDPOINT_XFER_INT ||
 		    chan->ep_type == USB_ENDPOINT_XFER_ISOC) {
-			u32 hcchar = readl(hsotg->regs +
-					   HCCHAR(chan->hc_num));
+			u32 hcchar = dwc2_readl(hsotg->regs +
+						HCCHAR(chan->hc_num));
 
 			dwc2_hc_set_even_odd_frame(hsotg, chan,
 						   &hcchar);
@@ -1716,12 +2074,12 @@
 
 	hctsiz = TSIZ_DOPNG;
 	hctsiz |= 1 << TSIZ_PKTCNT_SHIFT;
-	writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
+	dwc2_writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
 
-	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
 	hcchar |= HCCHAR_CHENA;
 	hcchar &= ~HCCHAR_CHDIS;
-	writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
 }
 
 /**
@@ -1740,8 +2098,8 @@
 	u32 hprt0;
 	int clock = 60;	/* default value */
 
-	usbcfg = readl(hsotg->regs + GUSBCFG);
-	hprt0 = readl(hsotg->regs + HPRT0);
+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
+	hprt0 = dwc2_readl(hsotg->regs + HPRT0);
 
 	if (!(usbcfg & GUSBCFG_PHYSEL) && (usbcfg & GUSBCFG_ULPI_UTMI_SEL) &&
 	    !(usbcfg & GUSBCFG_PHYIF16))
@@ -1797,7 +2155,7 @@
 	dev_vdbg(hsotg->dev, "%s(%p,%p,%d)\n", __func__, hsotg, dest, bytes);
 
 	for (i = 0; i < word_count; i++, data_buf++)
-		*data_buf = readl(fifo);
+		*data_buf = dwc2_readl(fifo);
 }
 
 /**
@@ -1817,56 +2175,56 @@
 	dev_dbg(hsotg->dev, "Host Global Registers\n");
 	addr = hsotg->regs + HCFG;
 	dev_dbg(hsotg->dev, "HCFG	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + HFIR;
 	dev_dbg(hsotg->dev, "HFIR	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + HFNUM;
 	dev_dbg(hsotg->dev, "HFNUM	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + HPTXSTS;
 	dev_dbg(hsotg->dev, "HPTXSTS	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + HAINT;
 	dev_dbg(hsotg->dev, "HAINT	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + HAINTMSK;
 	dev_dbg(hsotg->dev, "HAINTMSK	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	if (hsotg->core_params->dma_desc_enable > 0) {
 		addr = hsotg->regs + HFLBADDR;
 		dev_dbg(hsotg->dev, "HFLBADDR @0x%08lX : 0x%08X\n",
-			(unsigned long)addr, readl(addr));
+			(unsigned long)addr, dwc2_readl(addr));
 	}
 
 	addr = hsotg->regs + HPRT0;
 	dev_dbg(hsotg->dev, "HPRT0	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 
 	for (i = 0; i < hsotg->core_params->host_channels; i++) {
 		dev_dbg(hsotg->dev, "Host Channel %d Specific Registers\n", i);
 		addr = hsotg->regs + HCCHAR(i);
 		dev_dbg(hsotg->dev, "HCCHAR	 @0x%08lX : 0x%08X\n",
-			(unsigned long)addr, readl(addr));
+			(unsigned long)addr, dwc2_readl(addr));
 		addr = hsotg->regs + HCSPLT(i);
 		dev_dbg(hsotg->dev, "HCSPLT	 @0x%08lX : 0x%08X\n",
-			(unsigned long)addr, readl(addr));
+			(unsigned long)addr, dwc2_readl(addr));
 		addr = hsotg->regs + HCINT(i);
 		dev_dbg(hsotg->dev, "HCINT	 @0x%08lX : 0x%08X\n",
-			(unsigned long)addr, readl(addr));
+			(unsigned long)addr, dwc2_readl(addr));
 		addr = hsotg->regs + HCINTMSK(i);
 		dev_dbg(hsotg->dev, "HCINTMSK	 @0x%08lX : 0x%08X\n",
-			(unsigned long)addr, readl(addr));
+			(unsigned long)addr, dwc2_readl(addr));
 		addr = hsotg->regs + HCTSIZ(i);
 		dev_dbg(hsotg->dev, "HCTSIZ	 @0x%08lX : 0x%08X\n",
-			(unsigned long)addr, readl(addr));
+			(unsigned long)addr, dwc2_readl(addr));
 		addr = hsotg->regs + HCDMA(i);
 		dev_dbg(hsotg->dev, "HCDMA	 @0x%08lX : 0x%08X\n",
-			(unsigned long)addr, readl(addr));
+			(unsigned long)addr, dwc2_readl(addr));
 		if (hsotg->core_params->dma_desc_enable > 0) {
 			addr = hsotg->regs + HCDMAB(i);
 			dev_dbg(hsotg->dev, "HCDMAB	 @0x%08lX : 0x%08X\n",
-				(unsigned long)addr, readl(addr));
+				(unsigned long)addr, dwc2_readl(addr));
 		}
 	}
 #endif
@@ -1888,80 +2246,80 @@
 	dev_dbg(hsotg->dev, "Core Global Registers\n");
 	addr = hsotg->regs + GOTGCTL;
 	dev_dbg(hsotg->dev, "GOTGCTL	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GOTGINT;
 	dev_dbg(hsotg->dev, "GOTGINT	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GAHBCFG;
 	dev_dbg(hsotg->dev, "GAHBCFG	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GUSBCFG;
 	dev_dbg(hsotg->dev, "GUSBCFG	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GRSTCTL;
 	dev_dbg(hsotg->dev, "GRSTCTL	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GINTSTS;
 	dev_dbg(hsotg->dev, "GINTSTS	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GINTMSK;
 	dev_dbg(hsotg->dev, "GINTMSK	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GRXSTSR;
 	dev_dbg(hsotg->dev, "GRXSTSR	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GRXFSIZ;
 	dev_dbg(hsotg->dev, "GRXFSIZ	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GNPTXFSIZ;
 	dev_dbg(hsotg->dev, "GNPTXFSIZ	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GNPTXSTS;
 	dev_dbg(hsotg->dev, "GNPTXSTS	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GI2CCTL;
 	dev_dbg(hsotg->dev, "GI2CCTL	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GPVNDCTL;
 	dev_dbg(hsotg->dev, "GPVNDCTL	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GGPIO;
 	dev_dbg(hsotg->dev, "GGPIO	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GUID;
 	dev_dbg(hsotg->dev, "GUID	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GSNPSID;
 	dev_dbg(hsotg->dev, "GSNPSID	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GHWCFG1;
 	dev_dbg(hsotg->dev, "GHWCFG1	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GHWCFG2;
 	dev_dbg(hsotg->dev, "GHWCFG2	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GHWCFG3;
 	dev_dbg(hsotg->dev, "GHWCFG3	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GHWCFG4;
 	dev_dbg(hsotg->dev, "GHWCFG4	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GLPMCFG;
 	dev_dbg(hsotg->dev, "GLPMCFG	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GPWRDN;
 	dev_dbg(hsotg->dev, "GPWRDN	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + GDFIFOCFG;
 	dev_dbg(hsotg->dev, "GDFIFOCFG	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 	addr = hsotg->regs + HPTXFSIZ;
 	dev_dbg(hsotg->dev, "HPTXFSIZ	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 
 	addr = hsotg->regs + PCGCTL;
 	dev_dbg(hsotg->dev, "PCGCTL	 @0x%08lX : 0x%08X\n",
-		(unsigned long)addr, readl(addr));
+		(unsigned long)addr, dwc2_readl(addr));
 #endif
 }
 
@@ -1980,15 +2338,15 @@
 
 	greset = GRSTCTL_TXFFLSH;
 	greset |= num << GRSTCTL_TXFNUM_SHIFT & GRSTCTL_TXFNUM_MASK;
-	writel(greset, hsotg->regs + GRSTCTL);
+	dwc2_writel(greset, hsotg->regs + GRSTCTL);
 
 	do {
-		greset = readl(hsotg->regs + GRSTCTL);
+		greset = dwc2_readl(hsotg->regs + GRSTCTL);
 		if (++count > 10000) {
 			dev_warn(hsotg->dev,
 				 "%s() HANG! GRSTCTL=%0x GNPTXSTS=0x%08x\n",
 				 __func__, greset,
-				 readl(hsotg->regs + GNPTXSTS));
+				 dwc2_readl(hsotg->regs + GNPTXSTS));
 			break;
 		}
 		udelay(1);
@@ -2011,10 +2369,10 @@
 	dev_vdbg(hsotg->dev, "%s()\n", __func__);
 
 	greset = GRSTCTL_RXFFLSH;
-	writel(greset, hsotg->regs + GRSTCTL);
+	dwc2_writel(greset, hsotg->regs + GRSTCTL);
 
 	do {
-		greset = readl(hsotg->regs + GRSTCTL);
+		greset = dwc2_readl(hsotg->regs + GRSTCTL);
 		if (++count > 10000) {
 			dev_warn(hsotg->dev, "%s() HANG! GRSTCTL=%0x\n",
 				 __func__, greset);
@@ -2612,6 +2970,40 @@
 	hsotg->core_params->uframe_sched = val;
 }
 
+static void dwc2_set_param_external_id_pin_ctl(struct dwc2_hsotg *hsotg,
+		int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"'%d' invalid for parameter external_id_pin_ctl\n",
+				val);
+			dev_err(hsotg->dev, "external_id_pin_ctl must be 0 or 1\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev, "Setting external_id_pin_ctl to %d\n", val);
+	}
+
+	hsotg->core_params->external_id_pin_ctl = val;
+}
+
+static void dwc2_set_param_hibernation(struct dwc2_hsotg *hsotg,
+		int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"'%d' invalid for parameter hibernation\n",
+				val);
+			dev_err(hsotg->dev, "hibernation must be 0 or 1\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev, "Setting hibernation to %d\n", val);
+	}
+
+	hsotg->core_params->hibernation = val;
+}
+
 /*
  * This function is called during module intialization to pass module parameters
  * for the DWC_otg core.
@@ -2656,6 +3048,8 @@
 	dwc2_set_param_ahbcfg(hsotg, params->ahbcfg);
 	dwc2_set_param_otg_ver(hsotg, params->otg_ver);
 	dwc2_set_param_uframe_sched(hsotg, params->uframe_sched);
+	dwc2_set_param_external_id_pin_ctl(hsotg, params->external_id_pin_ctl);
+	dwc2_set_param_hibernation(hsotg, params->hibernation);
 }
 
 /**
@@ -2676,7 +3070,7 @@
 	 * 0x45f42xxx or 0x45f43xxx, which corresponds to either "OT2" or "OT3",
 	 * as in "OTG version 2.xx" or "OTG version 3.xx".
 	 */
-	hw->snpsid = readl(hsotg->regs + GSNPSID);
+	hw->snpsid = dwc2_readl(hsotg->regs + GSNPSID);
 	if ((hw->snpsid & 0xfffff000) != 0x4f542000 &&
 	    (hw->snpsid & 0xfffff000) != 0x4f543000) {
 		dev_err(hsotg->dev, "Bad value for GSNPSID: 0x%08x\n",
@@ -2688,11 +3082,11 @@
 		hw->snpsid >> 12 & 0xf, hw->snpsid >> 8 & 0xf,
 		hw->snpsid >> 4 & 0xf, hw->snpsid & 0xf, hw->snpsid);
 
-	hwcfg1 = readl(hsotg->regs + GHWCFG1);
-	hwcfg2 = readl(hsotg->regs + GHWCFG2);
-	hwcfg3 = readl(hsotg->regs + GHWCFG3);
-	hwcfg4 = readl(hsotg->regs + GHWCFG4);
-	grxfsiz = readl(hsotg->regs + GRXFSIZ);
+	hwcfg1 = dwc2_readl(hsotg->regs + GHWCFG1);
+	hwcfg2 = dwc2_readl(hsotg->regs + GHWCFG2);
+	hwcfg3 = dwc2_readl(hsotg->regs + GHWCFG3);
+	hwcfg4 = dwc2_readl(hsotg->regs + GHWCFG4);
+	grxfsiz = dwc2_readl(hsotg->regs + GRXFSIZ);
 
 	dev_dbg(hsotg->dev, "hwcfg1=%08x\n", hwcfg1);
 	dev_dbg(hsotg->dev, "hwcfg2=%08x\n", hwcfg2);
@@ -2701,18 +3095,18 @@
 	dev_dbg(hsotg->dev, "grxfsiz=%08x\n", grxfsiz);
 
 	/* Force host mode to get HPTXFSIZ / GNPTXFSIZ exact power on value */
-	gusbcfg = readl(hsotg->regs + GUSBCFG);
+	gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 	gusbcfg |= GUSBCFG_FORCEHOSTMODE;
-	writel(gusbcfg, hsotg->regs + GUSBCFG);
+	dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
 	usleep_range(100000, 150000);
 
-	gnptxfsiz = readl(hsotg->regs + GNPTXFSIZ);
-	hptxfsiz = readl(hsotg->regs + HPTXFSIZ);
+	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
+	hptxfsiz = dwc2_readl(hsotg->regs + HPTXFSIZ);
 	dev_dbg(hsotg->dev, "gnptxfsiz=%08x\n", gnptxfsiz);
 	dev_dbg(hsotg->dev, "hptxfsiz=%08x\n", hptxfsiz);
-	gusbcfg = readl(hsotg->regs + GUSBCFG);
+	gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
 	gusbcfg &= ~GUSBCFG_FORCEHOSTMODE;
-	writel(gusbcfg, hsotg->regs + GUSBCFG);
+	dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
 	usleep_range(100000, 150000);
 
 	/* hwcfg2 */
@@ -2789,7 +3183,7 @@
 		hw->hs_phy_type);
 	dev_dbg(hsotg->dev, "  fs_phy_type=%d\n",
 		hw->fs_phy_type);
-	dev_dbg(hsotg->dev, "  utmi_phy_data_wdith=%d\n",
+	dev_dbg(hsotg->dev, "  utmi_phy_data_width=%d\n",
 		hw->utmi_phy_data_width);
 	dev_dbg(hsotg->dev, "  num_dev_ep=%d\n",
 		hw->num_dev_ep);
@@ -2824,6 +3218,22 @@
 	return 0;
 }
 
+/*
+ * Sets all parameters to the given value.
+ *
+ * Assumes that the dwc2_core_params struct contains only integers.
+ */
+void dwc2_set_all_params(struct dwc2_core_params *params, int value)
+{
+	int *p = (int *)params;
+	size_t size = sizeof(*params) / sizeof(*p);
+	int i;
+
+	for (i = 0; i < size; i++)
+		p[i] = value;
+}
+
+
 u16 dwc2_get_otg_version(struct dwc2_hsotg *hsotg)
 {
 	return hsotg->core_params->otg_ver == 1 ? 0x0200 : 0x0103;
@@ -2831,7 +3241,7 @@
 
 bool dwc2_is_controller_alive(struct dwc2_hsotg *hsotg)
 {
-	if (readl(hsotg->regs + GSNPSID) == 0xffffffff)
+	if (dwc2_readl(hsotg->regs + GSNPSID) == 0xffffffff)
 		return false;
 	else
 		return true;
@@ -2845,10 +3255,10 @@
  */
 void dwc2_enable_global_interrupts(struct dwc2_hsotg *hsotg)
 {
-	u32 ahbcfg = readl(hsotg->regs + GAHBCFG);
+	u32 ahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
 
 	ahbcfg |= GAHBCFG_GLBL_INTR_EN;
-	writel(ahbcfg, hsotg->regs + GAHBCFG);
+	dwc2_writel(ahbcfg, hsotg->regs + GAHBCFG);
 }
 
 /**
@@ -2859,10 +3269,10 @@
  */
 void dwc2_disable_global_interrupts(struct dwc2_hsotg *hsotg)
 {
-	u32 ahbcfg = readl(hsotg->regs + GAHBCFG);
+	u32 ahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
 
 	ahbcfg &= ~GAHBCFG_GLBL_INTR_EN;
-	writel(ahbcfg, hsotg->regs + GAHBCFG);
+	dwc2_writel(ahbcfg, hsotg->regs + GAHBCFG);
 }
 
 MODULE_DESCRIPTION("DESIGNWARE HS OTG Core");
Index: linux-3.18.29/drivers/usb/dwc2/core_intr.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/core_intr.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/core_intr.c	2017-11-21 20:13:12.458710527 +0800
@@ -80,15 +80,15 @@
  */
 static void dwc2_handle_usb_port_intr(struct dwc2_hsotg *hsotg)
 {
-	u32 hprt0 = readl(hsotg->regs + HPRT0);
+	u32 hprt0 = dwc2_readl(hsotg->regs + HPRT0);
 
 	if (hprt0 & HPRT0_ENACHG) {
 		hprt0 &= ~HPRT0_ENA;
-		writel(hprt0, hsotg->regs + HPRT0);
+		dwc2_writel(hprt0, hsotg->regs + HPRT0);
 	}
 
 	/* Clear interrupt */
-	writel(GINTSTS_PRTINT, hsotg->regs + GINTSTS);
+	dwc2_writel(GINTSTS_PRTINT, hsotg->regs + GINTSTS);
 }
 
 /**
@@ -102,7 +102,7 @@
 		 dwc2_is_host_mode(hsotg) ? "Host" : "Device");
 
 	/* Clear interrupt */
-	writel(GINTSTS_MODEMIS, hsotg->regs + GINTSTS);
+	dwc2_writel(GINTSTS_MODEMIS, hsotg->regs + GINTSTS);
 }
 
 /**
@@ -117,8 +117,8 @@
 	u32 gotgctl;
 	u32 gintmsk;
 
-	gotgint = readl(hsotg->regs + GOTGINT);
-	gotgctl = readl(hsotg->regs + GOTGCTL);
+	gotgint = dwc2_readl(hsotg->regs + GOTGINT);
+	gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 	dev_dbg(hsotg->dev, "++OTG Interrupt gotgint=%0x [%s]\n", gotgint,
 		dwc2_op_state_str(hsotg));
 
@@ -126,7 +126,10 @@
 		dev_dbg(hsotg->dev,
 			" ++OTG Interrupt: Session End Detected++ (%s)\n",
 			dwc2_op_state_str(hsotg));
-		gotgctl = readl(hsotg->regs + GOTGCTL);
+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
+
+		if (dwc2_is_device_mode(hsotg))
+			dwc2_hsotg_disconnect(hsotg);
 
 		if (hsotg->op_state == OTG_STATE_B_HOST) {
 			hsotg->op_state = OTG_STATE_B_PERIPHERAL;
@@ -149,15 +152,15 @@
 			hsotg->lx_state = DWC2_L0;
 		}
 
-		gotgctl = readl(hsotg->regs + GOTGCTL);
+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 		gotgctl &= ~GOTGCTL_DEVHNPEN;
-		writel(gotgctl, hsotg->regs + GOTGCTL);
+		dwc2_writel(gotgctl, hsotg->regs + GOTGCTL);
 	}
 
 	if (gotgint & GOTGINT_SES_REQ_SUC_STS_CHNG) {
 		dev_dbg(hsotg->dev,
 			" ++OTG Interrupt: Session Request Success Status Change++\n");
-		gotgctl = readl(hsotg->regs + GOTGCTL);
+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 		if (gotgctl & GOTGCTL_SESREQSCS) {
 			if (hsotg->core_params->phy_type ==
 					DWC2_PHY_TYPE_PARAM_FS
@@ -165,9 +168,9 @@
 				hsotg->srp_success = 1;
 			} else {
 				/* Clear Session Request */
-				gotgctl = readl(hsotg->regs + GOTGCTL);
+				gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 				gotgctl &= ~GOTGCTL_SESREQ;
-				writel(gotgctl, hsotg->regs + GOTGCTL);
+				dwc2_writel(gotgctl, hsotg->regs + GOTGCTL);
 			}
 		}
 	}
@@ -177,7 +180,7 @@
 		 * Print statements during the HNP interrupt handling
 		 * can cause it to fail
 		 */
-		gotgctl = readl(hsotg->regs + GOTGCTL);
+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 		/*
 		 * WA for 3.00a- HW is not setting cur_mode, even sometimes
 		 * this does not help
@@ -197,9 +200,9 @@
 				 * interrupt does not get handled and Linux
 				 * complains loudly.
 				 */
-				gintmsk = readl(hsotg->regs + GINTMSK);
+				gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 				gintmsk &= ~GINTSTS_SOF;
-				writel(gintmsk, hsotg->regs + GINTMSK);
+				dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 
 				/*
 				 * Call callback function with spin lock
@@ -213,9 +216,9 @@
 				hsotg->op_state = OTG_STATE_B_HOST;
 			}
 		} else {
-			gotgctl = readl(hsotg->regs + GOTGCTL);
+			gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 			gotgctl &= ~(GOTGCTL_HNPREQ | GOTGCTL_DEVHNPEN);
-			writel(gotgctl, hsotg->regs + GOTGCTL);
+			dwc2_writel(gotgctl, hsotg->regs + GOTGCTL);
 			dev_dbg(hsotg->dev, "HNP Failed\n");
 			dev_err(hsotg->dev,
 				"Device Not Connected/Responding\n");
@@ -241,9 +244,9 @@
 			hsotg->op_state = OTG_STATE_A_PERIPHERAL;
 		} else {
 			/* Need to disable SOF interrupt immediately */
-			gintmsk = readl(hsotg->regs + GINTMSK);
+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 			gintmsk &= ~GINTSTS_SOF;
-			writel(gintmsk, hsotg->regs + GINTMSK);
+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 			spin_unlock(&hsotg->lock);
 			dwc2_hcd_start(hsotg);
 			spin_lock(&hsotg->lock);
@@ -258,7 +261,7 @@
 		dev_dbg(hsotg->dev, " ++OTG Interrupt: Debounce Done++\n");
 
 	/* Clear GOTGINT */
-	writel(gotgint, hsotg->regs + GOTGINT);
+	dwc2_writel(gotgint, hsotg->regs + GOTGINT);
 }
 
 /**
@@ -273,11 +276,11 @@
  */
 static void dwc2_handle_conn_id_status_change_intr(struct dwc2_hsotg *hsotg)
 {
-	u32 gintmsk = readl(hsotg->regs + GINTMSK);
+	u32 gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 
 	/* Need to disable SOF interrupt immediately */
 	gintmsk &= ~GINTSTS_SOF;
-	writel(gintmsk, hsotg->regs + GINTMSK);
+	dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 
 	dev_dbg(hsotg->dev, " ++Connector ID Status Change Interrupt++  (%s)\n",
 		dwc2_is_host_mode(hsotg) ? "Host" : "Device");
@@ -287,12 +290,14 @@
 	 * Release lock before scheduling workq as it holds spinlock during
 	 * scheduling.
 	 */
-	spin_unlock(&hsotg->lock);
-	queue_work(hsotg->wq_otg, &hsotg->wf_otg);
-	spin_lock(&hsotg->lock);
+	if (hsotg->wq_otg) {
+		spin_unlock(&hsotg->lock);
+		queue_work(hsotg->wq_otg, &hsotg->wf_otg);
+		spin_lock(&hsotg->lock);
+	}
 
 	/* Clear interrupt */
-	writel(GINTSTS_CONIDSTSCHNG, hsotg->regs + GINTSTS);
+	dwc2_writel(GINTSTS_CONIDSTSCHNG, hsotg->regs + GINTSTS);
 }
 
 /**
@@ -308,10 +313,28 @@
  */
 static void dwc2_handle_session_req_intr(struct dwc2_hsotg *hsotg)
 {
-	dev_dbg(hsotg->dev, "++Session Request Interrupt++\n");
+	int ret;
+
+	dev_dbg(hsotg->dev, "Session request interrupt - lx_state=%d\n",
+							hsotg->lx_state);
 
 	/* Clear interrupt */
-	writel(GINTSTS_SESSREQINT, hsotg->regs + GINTSTS);
+	dwc2_writel(GINTSTS_SESSREQINT, hsotg->regs + GINTSTS);
+
+	if (dwc2_is_device_mode(hsotg)) {
+		if (hsotg->lx_state == DWC2_L2) {
+			ret = dwc2_exit_hibernation(hsotg, true);
+			if (ret && (ret != -ENOTSUPP))
+				dev_err(hsotg->dev,
+					"exit hibernation failed\n");
+		}
+
+		/*
+		 * Report disconnect if there is any previous session
+		 * established
+		 */
+		dwc2_hsotg_disconnect(hsotg);
+	}
 }
 
 /*
@@ -323,27 +346,38 @@
  */
 static void dwc2_handle_wakeup_detected_intr(struct dwc2_hsotg *hsotg)
 {
+	int ret;
 	dev_dbg(hsotg->dev, "++Resume or Remote Wakeup Detected Interrupt++\n");
 	dev_dbg(hsotg->dev, "%s lxstate = %d\n", __func__, hsotg->lx_state);
 
 	if (dwc2_is_device_mode(hsotg)) {
-		dev_dbg(hsotg->dev, "DSTS=0x%0x\n", readl(hsotg->regs + DSTS));
+		dev_dbg(hsotg->dev, "DSTS=0x%0x\n",
+			dwc2_readl(hsotg->regs + DSTS));
 		if (hsotg->lx_state == DWC2_L2) {
-			u32 dctl = readl(hsotg->regs + DCTL);
+			u32 dctl = dwc2_readl(hsotg->regs + DCTL);
 
 			/* Clear Remote Wakeup Signaling */
 			dctl &= ~DCTL_RMTWKUPSIG;
-			writel(dctl, hsotg->regs + DCTL);
+			dwc2_writel(dctl, hsotg->regs + DCTL);
+			ret = dwc2_exit_hibernation(hsotg, true);
+			if (ret && (ret != -ENOTSUPP))
+				dev_err(hsotg->dev, "exit hibernation failed\n");
+
+			call_gadget(hsotg, resume);
 		}
 		/* Change to L0 state */
 		hsotg->lx_state = DWC2_L0;
 	} else {
+		if (hsotg->core_params->hibernation) {
+			dwc2_writel(GINTSTS_WKUPINT, hsotg->regs + GINTSTS);
+			return;
+		}
 		if (hsotg->lx_state != DWC2_L1) {
-			u32 pcgcctl = readl(hsotg->regs + PCGCTL);
+			u32 pcgcctl = dwc2_readl(hsotg->regs + PCGCTL);
 
 			/* Restart the Phy Clock */
 			pcgcctl &= ~PCGCTL_STOPPCLK;
-			writel(pcgcctl, hsotg->regs + PCGCTL);
+			dwc2_writel(pcgcctl, hsotg->regs + PCGCTL);
 			mod_timer(&hsotg->wkp_timer,
 				  jiffies + msecs_to_jiffies(71));
 		} else {
@@ -353,7 +387,7 @@
 	}
 
 	/* Clear interrupt */
-	writel(GINTSTS_WKUPINT, hsotg->regs + GINTSTS);
+	dwc2_writel(GINTSTS_WKUPINT, hsotg->regs + GINTSTS);
 }
 
 /*
@@ -366,10 +400,10 @@
 		dwc2_is_host_mode(hsotg) ? "Host" : "Device",
 		dwc2_op_state_str(hsotg));
 
-	/* Change to L3 (OFF) state */
-	hsotg->lx_state = DWC2_L3;
+	if (hsotg->op_state == OTG_STATE_A_HOST)
+		dwc2_hcd_disconnect(hsotg);
 
-	writel(GINTSTS_DISCONNINT, hsotg->regs + GINTSTS);
+	dwc2_writel(GINTSTS_DISCONNINT, hsotg->regs + GINTSTS);
 }
 
 /*
@@ -383,6 +417,7 @@
 static void dwc2_handle_usb_suspend_intr(struct dwc2_hsotg *hsotg)
 {
 	u32 dsts;
+	int ret;
 
 	dev_dbg(hsotg->dev, "USB SUSPEND\n");
 
@@ -391,16 +426,49 @@
 		 * Check the Device status register to determine if the Suspend
 		 * state is active
 		 */
-		dsts = readl(hsotg->regs + DSTS);
+		dsts = dwc2_readl(hsotg->regs + DSTS);
 		dev_dbg(hsotg->dev, "DSTS=0x%0x\n", dsts);
 		dev_dbg(hsotg->dev,
 			"DSTS.Suspend Status=%d HWCFG4.Power Optimize=%d\n",
 			!!(dsts & DSTS_SUSPSTS),
 			hsotg->hw_params.power_optimized);
+		if ((dsts & DSTS_SUSPSTS) && hsotg->hw_params.power_optimized) {
+			/* Ignore suspend request before enumeration */
+			if (!dwc2_is_device_connected(hsotg)) {
+				dev_dbg(hsotg->dev,
+						"ignore suspend request before enumeration\n");
+				goto clear_int;
+			}
+
+			ret = dwc2_enter_hibernation(hsotg);
+			if (ret) {
+				if (ret != -ENOTSUPP)
+					dev_err(hsotg->dev,
+							"enter hibernation failed\n");
+				goto skip_power_saving;
+			}
+
+			udelay(100);
+
+			/* Ask phy to be suspended */
+			if (!IS_ERR_OR_NULL(hsotg->uphy))
+				usb_phy_set_suspend(hsotg->uphy, true);
+skip_power_saving:
+			/*
+			 * Change to L2 (suspend) state before releasing
+			 * spinlock
+			 */
+			hsotg->lx_state = DWC2_L2;
+
+			/* Call gadget suspend callback */
+			call_gadget(hsotg, suspend);
+		}
 	} else {
 		if (hsotg->op_state == OTG_STATE_A_PERIPHERAL) {
 			dev_dbg(hsotg->dev, "a_peripheral->a_host\n");
 
+			/* Change to L2 (suspend) state */
+			hsotg->lx_state = DWC2_L2;
 			/* Clear the a_peripheral flag, back to a_host */
 			spin_unlock(&hsotg->lock);
 			dwc2_hcd_start(hsotg);
@@ -409,11 +477,9 @@
 		}
 	}
 
-	/* Change to L2 (suspend) state */
-	hsotg->lx_state = DWC2_L2;
-
+clear_int:
 	/* Clear interrupt */
-	writel(GINTSTS_USBSUSP, hsotg->regs + GINTSTS);
+	dwc2_writel(GINTSTS_USBSUSP, hsotg->regs + GINTSTS);
 }
 
 #define GINTMSK_COMMON	(GINTSTS_WKUPINT | GINTSTS_SESSREQINT |		\
@@ -431,9 +497,9 @@
 	u32 gahbcfg;
 	u32 gintmsk_common = GINTMSK_COMMON;
 
-	gintsts = readl(hsotg->regs + GINTSTS);
-	gintmsk = readl(hsotg->regs + GINTMSK);
-	gahbcfg = readl(hsotg->regs + GAHBCFG);
+	gintsts = dwc2_readl(hsotg->regs + GINTSTS);
+	gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
+	gahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
 
 	/* If any common interrupts set */
 	if (gintsts & gintmsk_common)
@@ -462,15 +528,24 @@
 irqreturn_t dwc2_handle_common_intr(int irq, void *dev)
 {
 	struct dwc2_hsotg *hsotg = dev;
-	u32 gintsts;
+	u32 gintsts, gotgint;
 	irqreturn_t retval = IRQ_NONE;
 
+	spin_lock(&hsotg->lock);
+
 	if (!dwc2_is_controller_alive(hsotg)) {
 		dev_warn(hsotg->dev, "Controller is dead\n");
 		goto out;
 	}
 
-	spin_lock(&hsotg->lock);
+	/*
+	 * Modified by nevermore.
+	 * The GOTGINT_MULTVALLPCHNG int can't trigger a irq in gintsts.otgint,
+	 * so we deal with it here.
+	 */
+	gotgint = dwc2_readl(hsotg->regs + GOTGINT);
+	if(gotgint & GOTGINT_MULTVALLPCHNG)
+		dwc2_writel(GOTGINT_MULTVALLPCHNG, hsotg->regs + GOTGINT);
 
 	gintsts = dwc2_read_common_intr(hsotg);
 	if (gintsts & ~GINTSTS_PRTINT)
@@ -504,8 +579,7 @@
 		}
 	}
 
-	spin_unlock(&hsotg->lock);
 out:
+	spin_unlock(&hsotg->lock);
 	return retval;
 }
-EXPORT_SYMBOL_GPL(dwc2_handle_common_intr);
Index: linux-3.18.29/drivers/usb/dwc2/hcd.h
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/hcd.h	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/hcd.h	2017-11-21 20:13:12.458710527 +0800
@@ -371,10 +371,10 @@
  */
 static inline void disable_hc_int(struct dwc2_hsotg *hsotg, int chnum, u32 intr)
 {
-	u32 mask = readl(hsotg->regs + HCINTMSK(chnum));
+	u32 mask = dwc2_readl(hsotg->regs + HCINTMSK(chnum));
 
 	mask &= ~intr;
-	writel(mask, hsotg->regs + HCINTMSK(chnum));
+	dwc2_writel(mask, hsotg->regs + HCINTMSK(chnum));
 }
 
 /*
@@ -382,11 +382,11 @@
  */
 static inline int dwc2_is_host_mode(struct dwc2_hsotg *hsotg)
 {
-	return (readl(hsotg->regs + GINTSTS) & GINTSTS_CURMODE_HOST) != 0;
+	return (dwc2_readl(hsotg->regs + GINTSTS) & GINTSTS_CURMODE_HOST) != 0;
 }
 static inline int dwc2_is_device_mode(struct dwc2_hsotg *hsotg)
 {
-	return (readl(hsotg->regs + GINTSTS) & GINTSTS_CURMODE_HOST) == 0;
+	return (dwc2_readl(hsotg->regs + GINTSTS) & GINTSTS_CURMODE_HOST) == 0;
 }
 
 /*
@@ -395,7 +395,7 @@
  */
 static inline u32 dwc2_read_hprt0(struct dwc2_hsotg *hsotg)
 {
-	u32 hprt0 = readl(hsotg->regs + HPRT0);
+	u32 hprt0 = dwc2_readl(hsotg->regs + HPRT0);
 
 	hprt0 &= ~(HPRT0_ENA | HPRT0_CONNDET | HPRT0_ENACHG | HPRT0_OVRCURRCHG);
 	return hprt0;
@@ -451,13 +451,8 @@
 	return !dwc2_hcd_is_pipe_in(pipe);
 }
 
-extern int dwc2_hcd_init(struct dwc2_hsotg *hsotg, int irq,
-			 const struct dwc2_core_params *params);
+extern int dwc2_hcd_init(struct dwc2_hsotg *hsotg, int irq);
 extern void dwc2_hcd_remove(struct dwc2_hsotg *hsotg);
-extern void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
-				const struct dwc2_core_params *params);
-extern void dwc2_set_all_params(struct dwc2_core_params *params, int value);
-extern int dwc2_get_hwparams(struct dwc2_hsotg *hsotg);
 
 /* Transaction Execution Functions */
 extern enum dwc2_transaction_type dwc2_hcd_select_transactions(
@@ -468,6 +463,9 @@
 /* Schedule Queue Functions */
 /* Implemented in hcd_queue.c */
 extern void dwc2_hcd_init_usecs(struct dwc2_hsotg *hsotg);
+extern struct dwc2_qh *dwc2_hcd_qh_create(struct dwc2_hsotg *hsotg,
+					  struct dwc2_hcd_urb *urb,
+					  gfp_t mem_flags);
 extern void dwc2_hcd_qh_free(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh);
 extern int dwc2_hcd_qh_add(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh);
 extern void dwc2_hcd_qh_unlink(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh);
@@ -476,7 +474,7 @@
 
 extern void dwc2_hcd_qtd_init(struct dwc2_qtd *qtd, struct dwc2_hcd_urb *urb);
 extern int dwc2_hcd_qtd_add(struct dwc2_hsotg *hsotg, struct dwc2_qtd *qtd,
-			    struct dwc2_qh **qh, gfp_t mem_flags);
+			    struct dwc2_qh *qh);
 
 /* Unlinks and frees a QTD */
 static inline void dwc2_hcd_qtd_unlink_and_free(struct dwc2_hsotg *hsotg,
@@ -582,7 +580,8 @@
  */
 static inline u32 dwc2_read_core_intr(struct dwc2_hsotg *hsotg)
 {
-	return readl(hsotg->regs + GINTSTS) & readl(hsotg->regs + GINTMSK);
+	return dwc2_readl(hsotg->regs + GINTSTS) &
+	       dwc2_readl(hsotg->regs + GINTMSK);
 }
 
 static inline u32 dwc2_hcd_urb_get_status(struct dwc2_hcd_urb *dwc2_urb)
@@ -668,9 +667,6 @@
  */
 extern void dwc2_hcd_stop(struct dwc2_hsotg *hsotg);
 
-extern void dwc2_hcd_start(struct dwc2_hsotg *hsotg);
-extern void dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg);
-
 /**
  * dwc2_hcd_is_b_host() - Returns 1 if core currently is acting as B host,
  * and 0 otherwise
@@ -680,13 +676,6 @@
 extern int dwc2_hcd_is_b_host(struct dwc2_hsotg *hsotg);
 
 /**
- * dwc2_hcd_get_frame_number() - Returns current frame number
- *
- * @hsotg: The DWC2 HCD
- */
-extern int dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg);
-
-/**
  * dwc2_hcd_dump_state() - Dumps hsotg state
  *
  * @hsotg: The DWC2 HCD
@@ -744,7 +733,7 @@
 			   qtd_list_entry);				\
 	if (usb_pipeint(_qtd_->urb->pipe) &&				\
 	    (_qh_)->start_split_frame != 0 && !_qtd_->complete_split) {	\
-		_hfnum_.d32 = readl((_hcd_)->regs + HFNUM);		\
+		_hfnum_.d32 = dwc2_readl((_hcd_)->regs + HFNUM);	\
 		switch (_hfnum_.b.frnum & 0x7) {			\
 		case 7:							\
 			(_hcd_)->hfnum_7_samples_##_letter_++;		\
Index: linux-3.18.29/drivers/char/hw_random/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/char/hw_random/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/char/hw_random/Kconfig	2017-11-21 20:13:12.458710527 +0800
@@ -346,6 +346,19 @@
 
 	  If unsure, say Y.
 
+config HW_RANDOM_SF
+	tristate "Siflower Socs Random Number Generator support"
+	default HW_RANDOM
+	---help---
+	 This driver provides the kernel-side support for the TRNG hardware
+	 found in the security function of some sfax8 SoCs.
+
+	 To compile this driver as a module, choose M here: the
+	 module will be called sfax8-rng.
+
+	 If unsure, say N.
+
+
 endif # HW_RANDOM
 
 config UML_RANDOM
Index: linux-3.18.29/drivers/char/hw_random/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/char/hw_random/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/char/hw_random/Makefile	2017-11-21 20:13:12.458710527 +0800
@@ -30,3 +30,4 @@
 obj-$(CONFIG_HW_RANDOM_BCM2835) += bcm2835-rng.o
 obj-$(CONFIG_HW_RANDOM_MSM) += msm-rng.o
 obj-$(CONFIG_HW_RANDOM_XGENE) += xgene-rng.o
+obj-$(CONFIG_HW_RANDOM_SF) += sfax8-rng.o
Index: linux-3.18.29/drivers/pinctrl/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/pinctrl/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/pinctrl/Kconfig	2017-11-21 20:13:12.458710527 +0800
@@ -203,6 +203,11 @@
 	  open drain configuration for the Palmas series devices like
 	  TPS65913, TPS80036 etc.
 
+config PINCTRL_SFAX8
+	bool
+	select PINMUX
+	select PINCONF
+
 source "drivers/pinctrl/berlin/Kconfig"
 source "drivers/pinctrl/freescale/Kconfig"
 source "drivers/pinctrl/mvebu/Kconfig"
Index: linux-3.18.29/drivers/pinctrl/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/pinctrl/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/pinctrl/Makefile	2017-11-21 20:13:12.458710527 +0800
@@ -36,6 +36,7 @@
 obj-$(CONFIG_PINCTRL_LANTIQ)	+= pinctrl-lantiq.o
 obj-$(CONFIG_PINCTRL_TB10X)	+= pinctrl-tb10x.o
 obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
+obj-$(CONFIG_PINCTRL_SFAX8) += pinctrl-sfax8.o
 
 obj-$(CONFIG_ARCH_BERLIN)	+= berlin/
 obj-y				+= freescale/
Index: linux-3.18.29/sound/soc/siflower/sfax8-spdif-machine.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/siflower/sfax8-spdif-machine.c	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,122 @@
+/*
+ *
+ * Copyright (C) 2016 Shanghai Siflower Communication Technology Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <sound/soc.h>
+
+struct sf_audio_data {
+	struct snd_soc_dai_link dai;
+	struct snd_soc_card card;
+};
+
+static int sf_audio_probe(struct platform_device *pdev)
+{
+	struct device_node *audio_np, *codec_np, *np = pdev->dev.of_node;
+	struct sf_audio_data *data;
+	int ret = 0;
+
+	dev_dbg(&pdev->dev, "Enter %s\n", __func__);
+	audio_np = of_parse_phandle(np, "audio-controller", 0);
+	if (!audio_np) {
+		dev_err(&pdev->dev, "failed to find audio-controller\n");
+		ret = -EINVAL;
+		goto end;
+	}
+
+	codec_np = of_parse_phandle(np, "audio-codec", 0);
+	if (!codec_np) {
+		dev_err(&pdev->dev, "failed to find audio-codec\n");
+		ret = -EINVAL;
+		goto end;
+	}
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	data->dai.name = "HIFI";
+	data->dai.stream_name = "HIFI";
+	data->dai.codec_dai_name = "dit-hifi";
+	data->dai.codec_of_node = codec_np;
+	data->dai.cpu_of_node = audio_np;
+	data->dai.platform_of_node = audio_np;
+	data->dai.playback_only = true;
+	data->dai.capture_only = true;
+
+	if (of_property_read_bool(np, "audio-out"))
+		data->dai.capture_only = false;
+
+	if (of_property_read_bool(np, "audio-in"))
+		data->dai.playback_only = false;
+
+	if (!data->dai.playback_only && !data->dai.capture_only) {
+		dev_err(&pdev->dev, "no enabled AUDIO DAI link\n");
+		goto end;
+	}
+
+	data->card.dev = &pdev->dev;
+	data->card.dai_link = &data->dai;
+	data->card.num_links = 1;
+
+	ret = snd_soc_of_parse_card_name(&data->card, "model");
+	if (ret)
+		goto end;
+
+	ret = devm_snd_soc_register_card(&pdev->dev, &data->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed: %d\n", ret);
+		goto end;
+	}
+
+	platform_set_drvdata(pdev, data);
+
+end:
+	if (audio_np)
+		of_node_put(audio_np);
+
+	return ret;
+}
+
+static const struct of_device_id sfax8_of_match[] = {
+	{ .compatible = "siflower,siflower-audio", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sfax8_of_match);
+
+static struct platform_driver sf_snd_card_driver = {
+	.driver = {
+		.name = "siflower-audio",
+		.owner = THIS_MODULE,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = sfax8_of_match,
+	},
+	.probe = sf_audio_probe,
+};
+
+module_platform_driver(sf_snd_card_driver);
+
+MODULE_AUTHOR("Qi Zhang<qi.zhang@siflower.com.cn>");
+MODULE_DESCRIPTION("Siflower Ax8 series machine driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:siflower-audio");
Index: linux-3.18.29/sound/soc/siflower/sfax8_spdif.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/siflower/sfax8_spdif.c	2017-11-15 17:26:54.373090000 +0800
@@ -0,0 +1,553 @@
+/* sound/soc/sfax8/spdif.c
+ *
+ * ALSA SoC Audio Layer - Siflower S/PDIF Controller driver
+ *
+ * Copyright (c) 2016 Shanghai Siflower Communication Technology Co., Ltd.
+ *		http://www.siflower.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+
+#include <sound/asoundef.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sf16a18.h>
+
+#include "sfax8_spdif.h"
+
+/*
+ * SPDIF control structure
+ * Defines channel status, subcode
+ */
+struct spdif_mixer_control {
+	/* spinlock to access control data */
+	spinlock_t ctl_lock;
+
+	/* IEC958 channel tx status bit */
+	unsigned char ch_status[24];
+
+	/* User bits */
+	unsigned char subcode[147];
+
+	/* Buffer offset for U */
+	u32 upos;
+
+	/* Ready buffer index of the two buffers */
+	u32 ready_buf;
+};
+
+/**
+ * struct sfax8_spdif_info - Siflower S/PDIF Controller information
+ * @lock: Spin lock for S/PDIF.
+ * @dev: The parent device passed to use from the probe.
+ * @regs: The pointer to the device register block.
+ * @clk_rate: Current clock rate for calcurate ratio.
+ * @pclk: The peri-clock pointer for spdif master operation.
+ * @dma_playback: DMA information for playback channel.
+ */
+struct sfax8_spdif_info {
+	struct spdif_mixer_control sf_spdif_control;
+	spinlock_t	lock;
+	struct device	*dev;
+	void __iomem	*regs;
+	unsigned long	clk_rate;
+	struct clk	*pclk;
+	struct snd_dmaengine_dai_dma_data dma_playback;
+};
+
+static struct sfax8_spdif_info spdif_info;
+
+static inline struct sfax8_spdif_info *to_info(struct snd_soc_dai *cpu_dai)
+{
+	return snd_soc_dai_get_drvdata(cpu_dai);
+}
+
+static void sfax8_pdif_write_channel_status(struct sfax8_spdif_info *spdif)
+{
+	struct spdif_mixer_control *ctrl = &spdif->sf_spdif_control;
+	void __iomem *regs = spdif->regs;
+	u32 ch_status, i;
+
+	for (i = 0; i < 6; i++) {
+		ch_status = (ctrl->ch_status[i * 4 + 3] << 24) |
+			    (ctrl->ch_status[i * 4 + 2] << 16) |
+			    (ctrl->ch_status[i * 4 + 1] << 8) |
+			    (ctrl->ch_status[i * 4]);
+		writel(ch_status, regs + TX_CHST_A(i));
+	}
+}
+
+/* Get valid good bit from interrupt status register */
+static int sfax8_spdif_vbit_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct sfax8_spdif_info *spdif = to_info(cpu_dai);
+	void __iomem *regs = spdif->regs;
+	u32 val;
+
+	val = readl(regs + INT_STAT);
+	ucontrol->value.integer.value[0] = ((val & CHB_PARITY_ERROR) != 0);
+
+	return 0;
+}
+
+static void sfax8_spdif_snd_txctrl(struct sfax8_spdif_info *spdif, int on)
+{
+	void __iomem *regs = spdif->regs;
+	u32 clkcon;
+	u32 enable_bits = CLK_EN;
+
+	clkcon = readl(regs + CTRL);
+	if (on)
+		writel(clkcon | enable_bits, regs + CTRL);
+	else
+		writel(clkcon & ~enable_bits, regs + CTRL);
+}
+
+static int sfax8_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sfax8_spdif_info *spdif = to_info(rtd->cpu_dai);
+	unsigned long flags;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		spin_lock_irqsave(&spdif->lock, flags);
+		sfax8_spdif_snd_txctrl(spdif, 1);
+		spin_unlock_irqrestore(&spdif->lock, flags);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		spin_lock_irqsave(&spdif->lock, flags);
+		sfax8_spdif_snd_txctrl(spdif, 0);
+		spin_unlock_irqrestore(&spdif->lock, flags);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sfax8_spdif_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *socdai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sfax8_spdif_info *spdif = to_info(rtd->cpu_dai);
+	void __iomem *regs = spdif->regs;
+	u32 ctrl, tx_config, tx_channel_status;
+	unsigned long flags;
+	int ratio;
+	u32 param_width, param_rate, param_channel;
+
+	dev_dbg(spdif->dev, "Entered %s\n", __func__);
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK) {
+		dev_err(spdif->dev, "Capture is not supported\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	ctrl = readl(regs + CTRL) & CTRL_MASK;
+	tx_config = readl(regs + TX_CONFIG) & TX_CONFIG_MASK;
+	tx_channel_status = readl(regs + TXCHST) & TXCHST_MASK;
+
+	ctrl |= SPDIF_EN | TXFIFO_EN | TX_EN;
+
+	tx_config |= (DEFAULT_FIFO_DEPTH << TX_DIPSTICK_SHIFT) |
+		     TX_DMA_EN | (TX_VALIDITY << TX_VALIDITY_SHIFT);
+
+	param_width = params_width(params);
+	if (param_width < 16 || param_width > 24) {
+		dev_err(spdif->dev, "Unsupported data size.\n");
+		goto err;
+	}
+	tx_config |= (param_width - 16) << TX_MODE_SHIFT;
+
+	param_rate = params_rate(params);
+	ratio = clk_get_rate(spdif->pclk) / (param_rate * 128) - 1;
+	if (ratio <= 0 || ratio > 255) {
+		dev_err(spdif->dev, "Invalid clock ratio %ld/%d\n",
+				spdif->clk_rate, params_rate(params));
+		goto err;
+	}
+	tx_config |= ratio << TX_RATIO_SHIFT;
+
+	switch (param_rate) {
+	case 32000:
+		tx_channel_status |= 2 << TX_FREQUENCY_SHIFT;
+		break;
+	case 44100:
+		tx_channel_status |= 0 << TX_FREQUENCY_SHIFT;
+		break;
+	case 48000:
+		tx_channel_status |= 1 << TX_FREQUENCY_SHIFT;
+		break;
+	default:
+		tx_channel_status |= 3 << TX_FREQUENCY_SHIFT;
+	}
+
+	param_channel = params_channels(params);
+	switch (param_channel) {
+	case 1:
+		tx_config |= TX_ONLY_CHANNEL_A;
+		break;
+	case 2:
+		tx_config &= ~TX_ONLY_CHANNEL_A;
+		break;
+	default:
+		dev_err(spdif->dev, "Unsupported channel number %d\n",
+		    param_channel);
+		goto err;
+	}
+
+	tx_channel_status &= ~TX_CATEGORY_MASK;
+	tx_channel_status |= 0x1 << TX_CATEGORY_SHIFT;
+	tx_channel_status |= TX_NO_COPYRIGHT;
+
+	dev_dbg(spdif->dev, "CTRL=%x,TX_CONFIG=%x,TXCHST=%x\n",
+	    ctrl, tx_config, tx_channel_status);
+	writel(ctrl, regs + CTRL);
+	writel(tx_config, regs + TX_CONFIG);
+	writel(tx_channel_status, regs + TXCHST);
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+err:
+	spin_unlock_irqrestore(&spdif->lock, flags);
+	return -EINVAL;
+}
+
+static void sfax8_spdif_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sfax8_spdif_info *spdif = to_info(rtd->cpu_dai);
+	void __iomem *regs = spdif->regs;
+
+	dev_dbg(spdif->dev, "Entered %s\n", __func__);
+
+	writel(0, regs + CTRL);
+}
+
+/*
+ * Siflower SPDIF IEC958 controller(mixer) functions
+ *
+ *	Channel status get/put control
+ *	User bit value get/put control
+ *	Valid bit value get control
+ *	DPLL lock status get control
+ *	User bit sync mode selection control
+ */
+
+static int sfax8_spdif_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+static int sfax8_spdif_pb_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *uvalue)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct sfax8_spdif_info *spdif = to_info(cpu_dai);
+	struct spdif_mixer_control *ctrl = &spdif->sf_spdif_control;
+	int i = 0;
+
+	for (i = 0; i < 24; i++)
+		uvalue->value.iec958.status[i] = ctrl->ch_status[i];
+
+	return 0;
+}
+
+static int sfax8_spdif_pb_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *uvalue)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct sfax8_spdif_info *spdif = to_info(cpu_dai);
+	struct spdif_mixer_control *ctrl = &spdif->sf_spdif_control;
+	int i = 0;
+
+	for (i = 0; i < 24; i++)
+		ctrl->ch_status[i] = uvalue->value.iec958.status[i];
+
+	sfax8_pdif_write_channel_status(&spdif_info);
+
+	return 0;
+}
+
+/* Valid bit infomation */
+static int sfax8_spdif_vbit_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+/* User bit sync mode info */
+static int sfax8_spdif_usync_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+/* Siflower SPDIF IEC958 controller defines */
+static struct snd_kcontrol_new sf_spdif_ctrls[] = {
+    /* Channel status controller */
+    {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+	.access = SNDRV_CTL_ELEM_ACCESS_READ |
+		  SNDRV_CTL_ELEM_ACCESS_WRITE |
+		  SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.info = sfax8_spdif_info,
+	.get = sfax8_spdif_pb_get,
+	.put = sfax8_spdif_pb_put,
+    },
+    /* Valid bit error controller */
+    {
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.name = "IEC958 V-Bit Errors",
+	.access = SNDRV_CTL_ELEM_ACCESS_READ |
+		  SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.info = sfax8_spdif_vbit_info,
+	.get = sfax8_spdif_vbit_get,
+    },
+    /* User bit sync mode controller */
+    {
+	.iface = SNDRV_CTL_ELEM_IFACE_HWDEP,
+	.name = SNDRV_CTL_NAME_IEC958("U-bit Sync Mode", NONE, SWITCH),
+	.access = SNDRV_CTL_ELEM_ACCESS_READ |
+		  SNDRV_CTL_ELEM_ACCESS_WRITE |
+		  SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.info = sfax8_spdif_usync_info,
+	.get = NULL,
+	.put = NULL,
+    },
+};
+
+static int sfax8_spdif_dai_probe(struct snd_soc_dai *dai)
+{
+    struct sfax8_spdif_info *spdif = to_info(dai);
+
+    snd_soc_dai_init_dma_data(dai, &spdif->dma_playback, NULL);
+
+    snd_soc_add_dai_controls(dai, sf_spdif_ctrls, ARRAY_SIZE(sf_spdif_ctrls));
+
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int sfax8_spdif_suspend(struct snd_soc_dai *cpu_dai)
+{
+	struct sfax8_spdif_info *spdif = to_info(cpu_dai);
+/* 	u32 con = spdif->saved_con;
+ */
+
+	dev_dbg(spdif->dev, "Entered %s\n", __func__);
+
+/* 	spdif->saved_clkcon = readl(spdif->regs	+ CLKCON) & CLKCTL_MASK;
+ * 	spdif->saved_con = readl(spdif->regs + CON) & CON_MASK;
+ * 	spdif->saved_cstas = readl(spdif->regs + CSTAS) & CSTAS_MASK;
+ * 
+ * 	writel(con | CON_SW_RESET, spdif->regs + CON);
+ * 	cpu_relax();
+ */
+
+	return 0;
+}
+
+static int sfax8_spdif_resume(struct snd_soc_dai *cpu_dai)
+{
+	struct sfax8_spdif_info *spdif = to_info(cpu_dai);
+
+	dev_dbg(spdif->dev, "Entered %s\n", __func__);
+
+/* 	writel(spdif->saved_clkcon, spdif->regs	+ CLKCON);
+ * 	writel(spdif->saved_con, spdif->regs + CON);
+ * 	writel(spdif->saved_cstas, spdif->regs + CSTAS);
+ */
+
+	return 0;
+}
+#else
+#define sfax8_spdif_suspend NULL
+#define sfax8_spdif_resume NULL
+#endif
+
+static const struct snd_soc_dai_ops sfax8_spdif_dai_ops = {
+	.trigger	= sfax8_spdif_trigger,
+	.hw_params	= sfax8_spdif_hw_params,
+	.shutdown	= sfax8_spdif_shutdown,
+};
+
+static struct snd_soc_dai_driver sfax8_spdif_dai = {
+	.name = "sfax8-spdif",
+	.playback = {
+		.stream_name = "S/PDIF Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000 ),
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_S20_3LE |
+				SNDRV_PCM_FMTBIT_S24_LE ), 
+	},
+	.probe = sfax8_spdif_dai_probe,
+	.ops = &sfax8_spdif_dai_ops,
+	.suspend = sfax8_spdif_suspend,
+	.resume = sfax8_spdif_resume,
+};
+
+static const struct snd_soc_component_driver sfax8_spdif_component = {
+	.name		= "sfax8-spdif",
+};
+
+static int sfax8_spdif_probe(struct platform_device *pdev)
+{
+	struct resource *mem_res;
+	struct sfax8_spdif_info *spdif;
+	int ret;
+
+	dev_dbg(&pdev->dev, "Entered %s\n", __func__);
+
+	if(release_reset(SF_SPDIF_SOFT_RESET))
+		return -EFAULT;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "Unable to get register resource.\n");
+		return -ENXIO;
+	}
+
+	/* TODO: Use gpio drivers */
+	//sf_module_set_pad_func(SF_SPDIF);
+
+	spdif = &spdif_info;
+	spdif->dev = &pdev->dev;
+
+	spin_lock_init(&spdif->lock);
+
+	spdif->pclk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(spdif->pclk)) {
+		dev_err(&pdev->dev, "failed to get spdif clock\n");
+		ret = -ENOENT;
+		goto err0;
+	}
+	clk_prepare_enable(spdif->pclk);
+	spdif->clk_rate = clk_get_rate(spdif->pclk);
+
+	/* Request S/PDIF Register's memory region */
+	if (!request_mem_region(mem_res->start,
+				resource_size(mem_res), "sfax8-spdif")) {
+		dev_err(&pdev->dev, "Unable to request register region\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	spdif->regs = ioremap(mem_res->start, 0x100);
+	if (spdif->regs == NULL) {
+		dev_err(&pdev->dev, "Cannot ioremap registers\n");
+		ret = -ENXIO;
+		goto err2;
+	}
+
+	dev_set_drvdata(&pdev->dev, spdif);
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+			&sfax8_spdif_component, &sfax8_spdif_dai, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "fail to register dai\n");
+		goto err3;
+	}
+
+	spdif->dma_playback.addr = mem_res->start + TX_FIFO;
+	spdif->dma_playback.maxburst = 8;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register DMA: %d\n", ret);
+		goto err3;
+	}
+
+	return 0;
+err3:
+	iounmap(spdif->regs);
+err2:
+	release_mem_region(mem_res->start, resource_size(mem_res));
+err1:
+	clk_disable_unprepare(spdif->pclk);
+err0:
+	return ret;
+}
+
+static int sfax8_spdif_remove(struct platform_device *pdev)
+{
+	struct sfax8_spdif_info *spdif = &spdif_info;
+	struct resource *mem_res;
+
+	iounmap(spdif->regs);
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (mem_res)
+		release_mem_region(mem_res->start, resource_size(mem_res));
+
+	clk_disable_unprepare(spdif->pclk);
+
+	if(hold_reset(SF_SPDIF_SOFT_RESET))
+		return -EFAULT;
+
+	return 0;
+}
+
+static const struct of_device_id sfax8_spdif_of_match[] = {
+	{ .compatible = "siflower,sfax8-spdif", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sfspi_of_match);
+
+static struct platform_driver sfax8_spdif_driver = {
+    .probe = sfax8_spdif_probe,
+    .remove = sfax8_spdif_remove,
+    .driver = {
+		.name = "sfax8-spdif",
+		.owner = THIS_MODULE,
+		.of_match_table = sfax8_spdif_of_match,
+    },
+};
+
+module_platform_driver(sfax8_spdif_driver);
+
+MODULE_AUTHOR("Qi Zhang<qi.zhang@siflower.com.cn>");
+MODULE_DESCRIPTION("Siflower S/PDIF CPU DAI Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sfax8-spdif-dai");
+
Index: linux-3.18.29/sound/soc/siflower/sfax8_spdif.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/siflower/sfax8_spdif.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,134 @@
+/* sound/soc/siflower/sfax8_spdif.h
+ *
+ * ALSA SoC Audio Layer - Siflower S/PDIF Controller driver
+ *
+ * Copyright (c) 2016 Shanghai Siflower Communication Technology Co., Ltd.
+ *		http://www.siflower.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __SND_SOC_SFAX8_SPDIF_H
+#define __SND_SOC_SFAX8_SPDIF_H
+
+/* Registers */
+#define CTRL		0x00
+#define TX_CONFIG	0x04
+#define RX_CONFIG	0x08
+#define TXCHST		0x0C
+#define RXCHST		0x10
+#define FIFO_STAT	0x14
+#define INT_MASK	0x18
+#define INT_STAT	0x1C
+#define TX_FIFO		0x20
+#define RX_FIFO		0x24
+#define TX_CHST_A(n)	(0x30 + n * 4)
+#define TX_CHST_B(n)	(0x50 + n * 4)
+#define TX_UDAT_A(n)	(0x70 + n * 4)
+#define TX_UDAT_B(n)	(0x90 + n * 4)
+
+/* CTRL */
+#define CTRL_MASK		    0xff
+#define CLK_EN			    (0x1 << 5)
+#define RXFIFO_EN		    (0x1 << 4)
+#define TXFIFO_EN		    (0x1 << 3)
+#define RX_EN			    (0x1 << 2)
+#define TX_EN			    (0x1 << 1)
+#define SPDIF_EN		    (0x1 << 0)
+
+/* TX_CONFIG */
+#define TX_CONFIG_MASK		    0xfff200ff
+#define TX_DIPSTICK_SHIFT	    0
+#define TX_DIPSTICK_MASK	    (0x1f)
+#define TX_VALIDITY			0x2
+#define TX_VALIDITY_SHIFT	    5
+#define TX_DMA_EN		    (0x1 << 7)
+#define TX_USER_DATA_MODE_SHIFT	    8
+#define TX_CHST_MODE_SHIFT	    10
+#define TX_PARITY_MODE		    (0x1 << 12)
+#define TX_VALIDITY_MODE	    (0x1 << 13)
+#define TX_AUX_EN		    (0x1 << 14)
+#define TX_DUPLICATE		    (0x1 << 16)
+#define TX_ONLY_CHANNEL_A	    (0x1 << 17)
+#define TX_SWAP_SHIFT		    18
+#define TX_RATIO_SHIFT		    20
+#define TX_MODE_SHIFT		    28
+
+/* RX_CONFIG */
+#define RX_DIPSTICK_SHIFT	    0
+#define RX_MODE_SHIFT		    5
+#define RX_DMA_EN		    (0x1 << 16)
+#define RX_USER_DATA_MODE_SHIFT	    18
+#define RX_CHST_MODE_SHIFT	    20
+#define RX_PARITY_CHECK_EN	    (0x1 << 22)
+#define RX_ALWAYS_STORE_DATA	    (0x1 << 23)
+#define RX_STORE_VALIDITY_BIT	    (0x1 << 24)
+#define RX_STORE_USER_DATA_BIT	    (0x1 << 25)
+#define RX_STORE_CHST_BIT	    (0x1 << 26)
+#define RX_STORE_PARITY_BIT	    (0x1 << 27)
+#define RX_STORE_BLOCK_START_MARK   (0x1 << 28)
+#define RX_STORE_CHANNEL_ID	    (0x1 << 29)
+#define RX_SWAP_SHIFT		    30
+
+/* TXCHST */
+#define TXCHST_MASK		    0x3000
+#define TX_PCM_FORMAT		    (0x1 << 0)
+#define TX_NO_COPYRIGHT		    (0x1 << 1)
+#define TX_ADD_INFO		    (0x1 << 2)
+#define TX_CATEGORY_MASK	    0xff
+#define TX_CATEGORY_SHIFT	    4
+#define TX_FREQUENCY_SHIFT	    12
+#define TX_CLOCK_ACCURACY_SHIFT	    14
+
+/* FIFO_STAT */
+#define TX_FIFO_EMPTY		    (0x1 << 0)
+#define TX_FIFO_FULL		    (0x1 << 1)
+#define TX_FIFO_ALMOST_EMPTY	    (0x1 << 2)
+#define TX_FIFO_ALMOST_FULL	    (0x1 << 3)
+#define TX_FIFO_OVER_FLOW	    (0x1 << 4)
+#define TX_FIFO_UNDER_FLOW	    (0x1 << 5)
+#define RX_FIFO_EMPTY		    (0x1 << 6)
+#define RX_FIFO_FULL		    (0x1 << 7)
+#define RX_FIFO_ALMOST_EMPTY	    (0x1 << 8)
+#define RX_FIFO_ALMOST_FULL	    (0x1 << 9)
+#define RX_FIFO_OVER_FLOW	    (0x1 << 10)
+#define RX_FIFO_UNDER_FLOW	    (0x1 << 11)
+#define TX_FREE_COUNT_SHIFT	    12
+#define RX_WORD_COUNT_SHIFT	    20
+
+/* INT_MASK */
+#define SPDIF_INT_MASK		    (0x1 << 0)
+#define CHANGE_MODE_SHIFT	    24
+
+/* INT_STAT */
+#define SPDIF_INT		    (0x1 << 0)
+#define TX_FIFO_EMPTY_INT	    (0x1 << 1)
+#define TX_FIFO_FULL_INT	    (0x1 << 2)
+#define TX_FIFO_ALMOST_EMPTY_INT    (0x1 << 3)
+#define TX_FIFO_ALMOST_FULL_INT	    (0x1 << 4)
+#define TX_FIFO_OVER_FLOW_INT	    (0x1 << 5)
+#define TX_FIFO_UNDER_FLOW_INT	    (0x1 << 6)
+#define RX_FIFO_EMPTY_INT	    (0x1 << 7)
+#define RX_FIFO_FULL_INT	    (0x1 << 8)
+#define RX_FIFO_ALMOST_EMPTY_INT    (0x1 << 9)
+#define RX_FIFO_ALMOST_FULL_INT	    (0x1 << 10)
+#define RX_FIFO_OVER_FLOW_INT	    (0x1 << 11)
+#define RX_FIFO_UNDER_FLOW_INT	    (0x1 << 12)
+#define CHB_PARITY_ERROR	    (0x1 << 14)
+#define CHA_PARITY_ERROR	    (0x1 << 15)
+#define RX_ERROR		    (0x1 << 16)
+#define BLOCK_START		    (0x1 << 17)
+#define CHANGE_MODE_INT_SHIFT	    20
+#define CHB_USER_DATA_CHANGE_INT    (0x1 << 26)
+#define CHA_USER_DATA_CHANGE_INT    (0x1 << 27)
+#define CHB_CHST_CHANGE_INT	    (0x1 << 28)
+#define CHA_CHST_CHANGE_INT	    (0x1 << 29)
+#define CHST_UPDATE_INT		    (0x1 << 30)
+#define USER_DATA_UPDATE_INT	    (0x1 << 31)
+
+/* default value */
+#define DEFAULT_FIFO_DEPTH	    8
+
+#endif
Index: linux-3.18.29/arch/mips/include/asm/mach-siflower/cpu-feature-overrides.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/include/asm/mach-siflower/cpu-feature-overrides.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,70 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003, 2004 Chris Dearman
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ */
+#ifndef __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H
+
+
+/*
+ * CPU feature overrides for MIPS boards
+ */
+#ifdef CONFIG_CPU_MIPS32
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4k_cache	1
+/* #define cpu_has_fpu		? */
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p ? */
+/* #define cpu_has_cache_cdex_s ? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_clo_clz		1
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_inclusive_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
+#endif
+
+#ifdef CONFIG_CPU_MIPS64
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4k_cache	1
+/* #define cpu_has_fpu		? */
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p ? */
+/* #define cpu_has_cache_cdex_s ? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_clo_clz		1
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_inclusive_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
+#endif
+
+#endif /* __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H */
Index: linux-3.18.29/arch/mips/include/asm/mach-siflower/generic.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/include/asm/mach-siflower/generic.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,83 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Defines of the MIPS boards specific address-MAP, registers, etc.
+ *
+ * Copyright (C) 2000,2012 MIPS Technologies, Inc.
+ * All rights reserved.
+ * Authors: Carsten Langgaard <carstenl@mips.com>
+ *          Steven J. Hill <sjhill@mips.com>
+ */
+#ifndef __ASM_MIPS_BOARDS_GENERIC_H
+#define __ASM_MIPS_BOARDS_GENERIC_H
+
+#include <asm/addrspace.h>
+#include <asm/byteorder.h>
+#include <asm/mips-boards/bonito64.h>
+
+/*
+ * Display register base.
+ */
+#define ASCII_DISPLAY_WORD_BASE	   0x1f000410
+#define ASCII_DISPLAY_POS_BASE	   0x1f000418
+
+/*
+ * Revision register.
+ */
+#define MIPS_REVISION_REG		   0x1fc00010
+#define MIPS_REVISION_CORID_QED_RM5261	   0
+#define MIPS_REVISION_CORID_CORE_LV	   1
+#define MIPS_REVISION_CORID_BONITO64	   2
+#define MIPS_REVISION_CORID_CORE_20K	   3
+#define MIPS_REVISION_CORID_CORE_FPGA	   4
+#define MIPS_REVISION_CORID_CORE_MSC	   5
+#define MIPS_REVISION_CORID_CORE_EMUL	   6
+#define MIPS_REVISION_CORID_CORE_FPGA2	   7
+#define MIPS_REVISION_CORID_CORE_FPGAR2	   8
+#define MIPS_REVISION_CORID_CORE_FPGA3	   9
+#define MIPS_REVISION_CORID_CORE_24K	   10
+#define MIPS_REVISION_CORID_CORE_FPGA4	   11
+#define MIPS_REVISION_CORID_CORE_FPGA5	   12
+#define MIPS_REVISION_CORID_CORE_SF16A18 0x28
+
+
+/**** Artificial corid defines ****/
+/*
+ *  CoreEMUL with   Bonito   System Controller is treated like a Core20K
+ *  CoreEMUL with SOC-it 101 System Controller is treated like a CoreMSC
+ */
+#define MIPS_REVISION_CORID_CORE_EMUL_BON  -1
+#define MIPS_REVISION_CORID_CORE_EMUL_MSC  -2
+
+#define MIPS_REVISION_CORID (((*(volatile u32 *)ioremap(MIPS_REVISION_REG, 4)) >> 10) & 0x3f)
+
+#define MIPS_REVISION_SCON_OTHER	   0
+#define MIPS_REVISION_SCON_SOCITSC	   1
+#define MIPS_REVISION_SCON_SOCITSCP	   2
+#define MIPS_REVISION_SCON_SF16A18    0x53
+
+
+/* Artificial SCON defines for MIPS_REVISION_SCON_OTHER */
+#define MIPS_REVISION_SCON_UNKNOWN	   -1
+#define MIPS_REVISION_SCON_GT64120	   -2
+#define MIPS_REVISION_SCON_BONITO	   -3
+#define MIPS_REVISION_SCON_BRTL		   -4
+#define MIPS_REVISION_SCON_SOCIT	   -5
+#define MIPS_REVISION_SCON_ROCIT	   -6
+
+#define MIPS_REVISION_SCONID (((*(volatile u32 *)ioremap(MIPS_REVISION_REG, 4)) >> 24) & 0xff)
+
+extern int mips_revision_sconid;
+
+#ifdef CONFIG_PCI
+extern void mips_pcibios_init(void);
+#else
+#define mips_pcibios_init() do { } while (0)
+#endif
+
+extern void mips_scroll_message(void);
+extern void mips_display_message(const char *str);
+
+#endif	/* __ASM_MIPS_BOARDS_GENERIC_H */
Index: linux-3.18.29/arch/mips/include/asm/mach-siflower/irq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/include/asm/mach-siflower/irq.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,11 @@
+#ifndef __ASM_MACH_MIPS_IRQ_H
+#define __ASM_MACH_MIPS_IRQ_H
+
+#define CPU_HW_INTRS (8)
+#define GIC_NUM_INTRS (256)
+#define GPIO_NUM_INTRS (64)
+#define NR_IRQS (CPU_HW_INTRS + GIC_NUM_INTRS + GPIO_NUM_INTRS)
+
+#include_next <irq.h>
+
+#endif /* __ASM_MACH_MIPS_IRQ_H */
Index: linux-3.18.29/arch/mips/include/asm/mach-siflower/kernel-entry-init.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/include/asm/mach-siflower/kernel-entry-init.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,145 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Chris Dearman (chris@mips.com)
+ * Copyright (C) 2007 Mips Technologies, Inc.
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ */
+#ifndef __ASM_MACH_MIPS_KERNEL_ENTRY_INIT_H
+#define __ASM_MACH_MIPS_KERNEL_ENTRY_INIT_H
+
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+	/*
+	 * Prepare segments for EVA boot:
+	 *
+	 * This is in case the processor boots in legacy configuration
+	 * (SI_EVAReset is de-asserted and CONFIG5.K == 0)
+	 *
+	 * ========================= Mappings =============================
+	 * Virtual memory           Physical memory           Mapping
+	 * 0x00000000 - 0x7fffffff  0x80000000 - 0xfffffffff   MUSUK (kuseg)
+	 *                          Flat 2GB physical memory
+	 *
+	 * 0x80000000 - 0x9fffffff  0x00000000 - 0x1ffffffff   MUSUK (kseg0)
+	 * 0xa0000000 - 0xbf000000  0x00000000 - 0x1ffffffff   MUSUK (kseg1)
+	 * 0xc0000000 - 0xdfffffff             -                 MK  (kseg2)
+	 * 0xe0000000 - 0xffffffff             -                 MK  (kseg3)
+	 *
+	 *
+	 * Lowmem is expanded to 2GB
+	 *
+	 * The following code uses the t0, t1, t2 and ra registers without
+	 * previously preserving them.
+	 *
+	 */
+	.macro	platform_eva_init
+
+	.set	push
+	.set	reorder
+	/*
+	 * Get Config.K0 value and use it to program
+	 * the segmentation registers
+	 */
+	mfc0    t1, CP0_CONFIG
+	andi	t1, 0x7 /* CCA */
+	move	t2, t1
+	ins	t2, t1, 16, 3
+	/* SegCtl0 */
+	li      t0, ((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |		\
+		(0 << MIPS_SEGCFG_PA_SHIFT) |				\
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |				\
+		(((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |		\
+		(0 << MIPS_SEGCFG_PA_SHIFT) |				\
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+	or	t0, t2
+	mtc0	t0, $5, 2
+
+	/* SegCtl1 */
+	li      t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |	\
+		(0 << MIPS_SEGCFG_PA_SHIFT) |				\
+		(2 << MIPS_SEGCFG_C_SHIFT) |				\
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |				\
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |		\
+		(0 << MIPS_SEGCFG_PA_SHIFT) |				\
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+	ins	t0, t1, 16, 3
+	mtc0	t0, $5, 3
+
+	/* SegCtl2 */
+	li	t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |	\
+		(6 << MIPS_SEGCFG_PA_SHIFT) |				\
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |				\
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |		\
+		(4 << MIPS_SEGCFG_PA_SHIFT) |				\
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+	or	t0, t2
+	mtc0	t0, $5, 4
+
+	jal	mips_ihb
+	mfc0    t0, $16, 5
+	li      t2, 0x40000000      /* K bit */
+	or      t0, t0, t2
+	mtc0    t0, $16, 5
+	sync
+	jal	mips_ihb
+
+	.set	pop
+	.endm
+
+	.macro	kernel_entry_setup
+
+#ifdef CONFIG_EVA
+	sync
+	ehb
+
+	mfc0    t1, CP0_CONFIG
+	bgez    t1, 9f
+	mfc0	t0, CP0_CONFIG, 1
+	bgez	t0, 9f
+	mfc0	t0, CP0_CONFIG, 2
+	bgez	t0, 9f
+	mfc0	t0, CP0_CONFIG, 3
+	sll     t0, t0, 6   /* SC bit */
+	bgez    t0, 9f
+
+	platform_eva_init
+	b       0f
+9:
+	/* Assume we came from YAMON... */
+	PTR_LA	v0, 0x9fc00534	/* YAMON print */
+	lw	v0, (v0)
+	move	a0, zero
+	PTR_LA  a1, nonsc_processor
+	jal	v0
+
+	PTR_LA	v0, 0x9fc00520	/* YAMON exit */
+	lw	v0, (v0)
+	li	a0, 1
+	jal	v0
+
+1:	b	1b
+	nop
+	__INITDATA
+nonsc_processor:
+	.asciz  "EVA kernel requires a MIPS core with Segment Control implemented\n"
+	__FINIT
+#endif /* CONFIG_EVA */
+0:
+	.endm
+
+/*
+ * Do SMP slave processor setup necessary before we can safely execute C code.
+ */
+	.macro	smp_slave_setup
+#ifdef CONFIG_EVA
+	sync
+	ehb
+	platform_eva_init
+#endif
+	.endm
+
+#endif /* __ASM_MACH_MIPS_KERNEL_ENTRY_INIT_H */
Index: linux-3.18.29/arch/mips/include/asm/mach-siflower/sf16a18/sf16a18.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/include/asm/mach-siflower/sf16a18/sf16a18.h	2017-11-21 20:11:40.378707000 +0800
@@ -0,0 +1,160 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Defines of the sf16a18 soc specific address-MAP, registers, etc.
+ */
+#ifndef __ASM_MIPS_SF16A18_H
+#define __ASM_MIPS_SF16A18_H
+
+#include <asm/addrspace.h>
+#include <asm/io.h>
+
+
+/*
+ * GCMP Specific definitions
+ */
+#define GCMP_BASE_ADDR			0x1fbf8000
+#define GCMP_ADDRSPACE_SZ		(256 * 1024)
+
+/*
+ * GIC Specific definitions
+ */
+#define GIC_BASE_ADDR			0x1bdc0000
+#define GIC_ADDRSPACE_SZ		(128 * 1024)
+
+/*
+ * CPC Specific definitions
+ */
+#define CPC_BASE_ADDR           0x1bde0000
+
+/*system controller address*/
+#define SIFLOWER_SYSCTL_BASE    0xB9E00000
+#define SIFLOWER_WIFI_SHARE_RAM_SEL      (SIFLOWER_SYSCTL_BASE + 0x242C)
+#define SIFLOWER_SW_RESET       (SIFLOWER_SYSCTL_BASE + 0x2030)
+#define SIFLOWER_SW_TRIG_RESET  0x1
+
+/*
+ * These are used for sys reboot event record when
+ * syscon driver not initialised.
+ */
+#define SOFT_EVENTS_RO			(SIFLOWER_SYSCTL_BASE + 0x2054) //soft reboot
+#define SYS_EVTS70			(SIFLOWER_SYSCTL_BASE + 0x2058)
+#define SYS_EVTS158			(SIFLOWER_SYSCTL_BASE + 0x205C)
+#define SYS_EVTS2316			(SIFLOWER_SYSCTL_BASE + 0x2060)
+#define SYS_EVTS3124			(SIFLOWER_SYSCTL_BASE + 0x2064)
+#define SYS_EVTS3932			(SIFLOWER_SYSCTL_BASE + 0x2068)
+#define SYS_EVTS4740			(SIFLOWER_SYSCTL_BASE + 0x206C)
+#define SYS_EVTS5548			(SIFLOWER_SYSCTL_BASE + 0x2070)
+#define SYS_EVTS6356			(SIFLOWER_SYSCTL_BASE + 0x2074) //bit 63:wdt; bit 62: catip
+
+//MPW1 M_SFDSP syscon
+#ifdef CONFIG_SF16A18_MPW1
+#define M_SFDSP_0_POR_RESETN                      (SIFLOWER_SYSCTL_BASE + 0x30000)
+//don't reset ARESETN to zero by single when m_SFDSP is powerup,the b1m2 reset will reset m_SFDSP state in siflower wireless driver
+#define M_SFDSP_0_ARESETN                         (SIFLOWER_SYSCTL_BASE + 0x30004)
+#define M_SFDSP_0_SI_ExceptionBase_12_19          (SIFLOWER_SYSCTL_BASE + 0x3003C)
+#define M_SFDSP_0_SI_ExceptionBase_20_27          (SIFLOWER_SYSCTL_BASE + 0x30040)
+#define M_SFDSP_0_SI_ExceptionBase_28             (SIFLOWER_SYSCTL_BASE + 0x30044)
+#define M_SFDSP_1_POR_RESETN                      (SIFLOWER_SYSCTL_BASE + 0x30400)
+#define M_SFDSP_1_ARESETN                         (SIFLOWER_SYSCTL_BASE + 0x30404)
+#define M_SFDSP_1_SI_ExceptionBase_12_19          (SIFLOWER_SYSCTL_BASE + 0x3043C)
+#define M_SFDSP_1_SI_ExceptionBase_20_27          (SIFLOWER_SYSCTL_BASE + 0x30440)
+#define M_SFDSP_1_SI_ExceptionBase_28             (SIFLOWER_SYSCTL_BASE + 0x30444)
+#define SYS_MISC_CTRL				(SIFLOWER_SYSCTL_BASE + 0x202C)
+#endif /* CONFIG_SF16A18_MPW1 */
+
+//module reset
+#define SF_IRAM_SOFT_RESET      (0x0C00)
+#define SF_IRAM_SYSM_RESET      (0x2C30)
+
+
+#define SF_NPU_SOFT_RESET		(0x4000)
+#define SF_NPU_SYSM_RESET       (0x2C44) 
+
+#define SF_EMAC_SOFT_RESET		(0x4400)
+#define SF_EMAC_SYSM_RESET		(0x2C48)
+
+#define SF_GDU_SOFT_RESET		(0x4800)
+#define SF_GDU_SYSM_RESET       (0x2C4C)
+
+#define SF_CRYPTO_SOFT_RESET	(0x4C00)
+#define SF_CRYPTO_SYSM_RESET    (0x2C50)
+
+#define SF_WIFI_1_SOFT_RESET	(0x8000)
+#define SF_WIFI_1_SYSM_RESET    (0x2C64)
+
+#define SF_WIFI_2_SOFT_RESET	(0x8400)
+#define SF_WIFI_2_SYSM_RESET    (0x2C68)
+
+#define SF_GDMA_SOFT_RESET		(0x8800)
+#define SF_GDMA_SYSM_RESET      (0x2C6C)
+
+#define SF_SCDMA_SOFT_RESET		(0x8C00)
+#define SF_SCDMA_SYSM_RESET     (0x2C70)
+
+#ifndef CONFIG_SF16A18_MPW0
+#define SF_USB_SOFT_RESET		(0xC000)
+#define SF_USB_SYSM_RESET       (0x2C84)
+#define SF_EMMC_SOFT_RESET		(0xC400)
+#define SF_EMMC_SYSM_RESET      (0x2C88)
+#define SF_SDIO_SOFT_RESET		(0xC800)
+#define SF_SDIO_SYSM_RESET      (0x2C8C)
+#define SF_CATIP_SOFT_RESET		(0x8C00)
+#define SF_CATIP_SYSM_RESET     (0x2C70)
+#else
+#define SF_USB_SOFT_RESET		(0xC800)
+#define SF_USB_SYSM_RESET       (0x2C8C)
+#define SF_EMMC_SOFT_RESET		(0xCC00)
+#define SF_EMMC_SYSM_RESET      (0x2C90)
+#define SF_SDIO_SOFT_RESET		(0xD000)
+#define SF_SDIO_SYSM_RESET      (0x2C94)
+#define SF_CATIP_SOFT_RESET		(0xD400)
+#define SF_CATIP_SYSM_RESET     (0x2C98)
+#endif
+
+#define SF_IIS_SOFT_RESET		(0x24000)
+#define SF_IIS_SYSM_RESET       (0x02D44)
+
+#define SF_IIC_SOFT_RESET		(0x24400)
+#define SF_IIC_SYSM_RESET       (0x02D48)
+
+#define SF_SPI_SOFT_RESET		(0x24800)
+#define SF_SPI_SYSM_RESET       (0x02D4C)
+
+#define SF_UART_SOFT_RESET		(0x24C00)
+#define SF_UART_SYSM_RESET      (0x02D50)
+
+#define SF_PCM_SOFT_RESET		(0x25000)
+#define SF_PCM_SYSM_RESET       (0x02D54)
+
+#define SF_PWM_SOFT_RESET		(0x25400)
+#define SF_PWM_SYSM_RESET       (0x02D58)
+
+#define SF_TIMER_SOFT_RESET		(0x25800)
+#define SF_TIMER_SYSM_RESET     (0x02D5C)
+
+#define SF_WDT_SOFT_RESET		(0x25C00)
+#define SF_WDT_SYSM_RESET       (0x02D60)
+
+#define SF_SPDIF_SOFT_RESET		(0x26000)
+#define SF_SPDIF_SYSM_RESET     (0x02D64)
+
+
+extern int release_reset(unsigned int offset);
+extern int hold_reset(unsigned int offset);
+
+#endif /* __ASM_MIPS_BOARDS_SF16A18_H */
Index: linux-3.18.29/arch/mips/include/asm/mach-siflower/sf16a18/sf16a18int.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/include/asm/mach-siflower/sf16a18/sf16a18int.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,205 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000,2012 MIPS Technologies, Inc.  All rights reserved.
+ *	Carsten Langgaard <carstenl@mips.com>
+ *	Steven J. Hill <sjhill@mips.com>
+ */
+#ifndef _MIPS_SF16A18INT_H
+#define _MIPS_SF16A18INT_H
+
+#define MIPS_GIC_IRQ_BASE	(MIPS_CPU_IRQ_BASE + 8)
+
+/*
+ * Interrupts 0..15 are used for sf16a18 ISA compatible interrupts
+ */
+#define SF16A18_INT_BASE		0
+
+/* CPU interrupt offsets */
+#define MIPSCPU_INT_SW0		0
+#define MIPSCPU_INT_SW1		1
+#define MIPSCPU_INT_MB0		2
+#define MIPSCPU_INT_I8259A	MIPSCPU_INT_MB0
+#define MIPSCPU_INT_MB1		3
+#define MIPSCPU_INT_SMI		MIPSCPU_INT_MB1
+#define MIPSCPU_INT_IPI0	MIPSCPU_INT_MB1 /* GIC IPI */
+#define MIPSCPU_INT_MB2		4
+#define MIPSCPU_INT_IPI1	MIPSCPU_INT_MB2 /* GIC IPI */
+#define MIPSCPU_INT_MB3		5
+#define MIPSCPU_INT_COREHI	MIPSCPU_INT_MB3
+#define MIPSCPU_INT_MB4		6
+#define MIPSCPU_INT_CORELO	MIPSCPU_INT_MB4
+
+/*
+ * Interrupts 64..127 are used for Soc-it Classic interrupts
+ */
+#define MSC01C_INT_BASE		64
+
+/* SOC-it Classic interrupt offsets */
+#define MSC01C_INT_TMR		0
+#define MSC01C_INT_PCI		1
+
+/*
+ * Interrupts 64..127 are used for Soc-it EIC interrupts
+ */
+#define MSC01E_INT_BASE		64
+
+/* SOC-it EIC interrupt offsets */
+#define MSC01E_INT_SW0		1
+#define MSC01E_INT_SW1		2
+#define MSC01E_INT_MB0		3
+#define MSC01E_INT_I8259A	MSC01E_INT_MB0
+#define MSC01E_INT_MB1		4
+#define MSC01E_INT_SMI		MSC01E_INT_MB1
+#define MSC01E_INT_MB2		5
+#define MSC01E_INT_MB3		6
+#define MSC01E_INT_COREHI	MSC01E_INT_MB3
+#define MSC01E_INT_MB4		7
+#define MSC01E_INT_CORELO	MSC01E_INT_MB4
+#define MSC01E_INT_TMR		8
+#define MSC01E_INT_PCI		9
+#define MSC01E_INT_PERFCTR	10
+#define MSC01E_INT_CPUCTR	11
+
+/* External Interrupts used for IPI */
+#define GIC_IPI_EXT_INTR_RESCHED_VPE0	16
+#define GIC_IPI_EXT_INTR_CALLFNC_VPE0	17
+#define GIC_IPI_EXT_INTR_RESCHED_VPE1	18
+#define GIC_IPI_EXT_INTR_CALLFNC_VPE1	19
+#define GIC_IPI_EXT_INTR_RESCHED_VPE2	20
+#define GIC_IPI_EXT_INTR_CALLFNC_VPE2	21
+#define GIC_IPI_EXT_INTR_RESCHED_VPE3	22
+#define GIC_IPI_EXT_INTR_CALLFNC_VPE3	23
+
+/* SF16A18 UART Interrupts */
+#define SF16A18_UART_FIFOSIZE (32)
+#define SF16A18_UART_CLK (60000000)
+#define SF16A18_UART_BASEADDR    (0x18300000)
+#define SF16A18_UART_ENDADDR     (0x18303999)
+#define SF16A18_UART0_IRQ    (226+MIPS_GIC_IRQ_BASE)
+
+/* SF16A18 ETH Interrupts */
+//TODO: this is hif irq, should add bmu_irq
+#define SF16A18_ETH_IRQ    (16+MIPS_GIC_IRQ_BASE)
+#define SF16A18_ETH_BASEADDR (0x10000000)
+#define SF16A18_ETH_ENDADDR (0x106CFFFF)
+
+/*SF16A18 GMAC Interrupts */
+#define SF16A18_GMAC_SBD_IRQ			(32 + MIPS_GIC_IRQ_BASE)
+#define SF16A18_GMAC_LPI_IRQ			(33 + MIPS_GIC_IRQ_BASE)
+#define SF16A18_GMAC_PMT_IRQ			(34 + MIPS_GIC_IRQ_BASE)
+#define SF16A18_GMAC_BASEADDR			0x10800000
+#define SF16A18_GMAC_ENDADDR			0x109FFFFF
+
+#define SIFLOWER_WIFI_INTC_CPU_SINGLE	 (48 + MIPS_GIC_IRQ_BASE)
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC_HOST      (49 + MIPS_GIC_IRQ_BASE)
+
+//WIFI End Of Transfer interrupts: Last fragment of the channel link list has been processed
+#define SIFLOWER_WIFI_INTC_DMA_CH0_EOT   (50 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_DMA_CH1_EOT   (51 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_DMA_CH2_EOT   (52 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_DMA_CH3_EOT   (53 + MIPS_GIC_IRQ_BASE)
+
+#define SIFLOWER_WIFI_INTC_LLI0          (54 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI1          (55 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI2          (56 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI3          (57 + MIPS_GIC_IRQ_BASE) 
+#define SIFLOWER_WIFI_INTC_LLI4          (58 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI5          (59 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI6          (60 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI7          (61 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI8          (62 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI9          (63 + MIPS_GIC_IRQ_BASE)
+
+#define SIFLOWER_WIFI_INTC_CPU_SINGLE_5G    (64 + MIPS_GIC_IRQ_BASE)
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC_HOST_5G      (65 + MIPS_GIC_IRQ_BASE)
+//WIFI End Of Transfer interrupts: Last fragment of the channel link list has been processed
+#define SIFLOWER_WIFI_INTC_DMA_CH0_EOT_5G   (66 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_DMA_CH1_EOT_5G   (67 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_DMA_CH2_EOT_5G   (68 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_DMA_CH3_EOT_5G   (69 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI0_5G          (70 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI1_5G          (71 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI2_5G          (72 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI3_5G          (73 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI4_5G          (74 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI5_5G          (75 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI6_5G          (76 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI7_5G          (77 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI8_5G          (78 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI9_5G          (79 + MIPS_GIC_IRQ_BASE)
+
+//WIFI LLI interrupts: Specific fragment of link list item has been processed
+#define SIFLOWER_WIFI_INTC_LLI10         (96 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI11         (97 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI12         (98 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI13         (99 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI14         (100 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI15         (101 + MIPS_GIC_IRQ_BASE)
+
+//WIFI DMA
+#define SIFLOWER_WIFI_INTC_DMA_BUSERR    (102 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_DMA_CH4_EOT   (103 + MIPS_GIC_IRQ_BASE)
+// MAC HW
+#define SIFLOWER_WIFI_INTC_MACTIMER      (104 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACOTHER      (105 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACRX         (106 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACTX         (107 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACINTGEN     (108 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACPROT       (109 + MIPS_GIC_IRQ_BASE)
+
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC0          (110 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_IPC1          (111 + MIPS_GIC_IRQ_BASE)
+
+//WIFI LLI interrupts: Specific fragment of link list item has been processed
+#define SIFLOWER_WIFI_INTC_LLI10_5G         (112 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI11_5G         (113 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI12_5G         (114 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI13_5G         (115 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI14_5G         (116 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_LLI15_5G         (117 + MIPS_GIC_IRQ_BASE)
+
+//WIFI DMA
+#define SIFLOWER_WIFI_INTC_DMA_BUSERR_5G    (118 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_DMA_CH4_EOT_5G   (119 + MIPS_GIC_IRQ_BASE)
+
+// MAC HW
+#define SIFLOWER_WIFI_INTC_MACTIMER_5G      (120 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACOTHER_5G      (121 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACRX_5G         (122 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACTX_5G         (123 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACINTGEN_5G     (124 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_MACPROT_5G       (125 + MIPS_GIC_IRQ_BASE)
+
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC0_5G          (126 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_IPC1_5G          (127 + MIPS_GIC_IRQ_BASE)
+
+//WIFI IQ TEST ENGINE buffer full interruption
+#define SIFLOWER_WIFI_INTC_IQR_LOWRAM_FULL   (192 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_IQR_HIGHRAM_FULL  (193 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_IQP_LOWRAM_FULL   (194 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_IQP_HIGHRAM_FULL  (195 + MIPS_GIC_IRQ_BASE)
+
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC2          (200 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_IPC3          (201 + MIPS_GIC_IRQ_BASE)
+
+//WIFI PHY HW
+#define SIFLOWER_WIFI_INTC_MODEM         (202 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_RC            (203 + MIPS_GIC_IRQ_BASE)
+
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC2_5G          (204 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_IPC3_5G          (205 + MIPS_GIC_IRQ_BASE)
+
+//WIFI PHY HW
+#define SIFLOWER_WIFI_INTC_MODEM_5G         (206 + MIPS_GIC_IRQ_BASE)
+#define SIFLOWER_WIFI_INTC_RC_5G            (207 + MIPS_GIC_IRQ_BASE)
+
+#endif /* !(_MIPS_SF16A18INT_H) */
Index: linux-3.18.29/arch/mips/include/asm/mach-siflower/spaces.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/include/asm/mach-siflower/spaces.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,46 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ */
+
+#ifndef _ASM_SF16A18_SPACES_H
+#define _ASM_SF16A18_SPACES_H
+
+#ifdef CONFIG_EVA
+
+/*
+ * Traditional sf16a18 Board Memory Map for EVA
+ *
+ * 0x00000000 - 0x0fffffff: 1st RAM region, 256MB
+ * 0x10000000 - 0x1bffffff: GIC and CPC Control Registers
+ * 0x1c000000 - 0x1fffffff: I/O And Flash
+ * 0x20000000 - 0x7fffffff: 2nd RAM region, 1.5GB
+ * 0x80000000 - 0xffffffff: Physical memory aliases to 0x0 (2GB)
+ *
+ * The kernel is still located in 0x80000000(kseg0). However,
+ * the physical mask has been shifted to 0x80000000 which exploits the alias
+ * on the sf16a18 board. As a result of which, we override the __pa_symbol
+ * to peform direct mapping from virtual to physical addresses. In other
+ * words, the 0x80000000 virtual address maps to 0x80000000 physical address
+ * which in turn aliases to 0x0. We do this in order to be able to use a flat
+ * 2GB of memory (0x80000000 - 0xffffffff) so we can avoid the I/O hole in
+ * 0x10000000 - 0x1fffffff.
+ * The last 64KB of physical memory are reserved for correct HIGHMEM
+ * macros arithmetics.
+ *
+ */
+
+#define PAGE_OFFSET	_AC(0x0, UL)
+#define PHYS_OFFSET	_AC(0x80000000, UL)
+#define HIGHMEM_START	_AC(0xffff0000, UL)
+
+#define __pa_symbol(x)	(RELOC_HIDE((unsigned long)(x), 0))
+
+#endif /* CONFIG_EVA */
+
+#include <asm/mach-generic/spaces.h>
+
+#endif /* _ASM_SF16A18_SPACES_H */
Index: linux-3.18.29/arch/mips/include/asm/mach-siflower/war.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/include/asm/mach-siflower/war.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,24 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_MIPS_WAR_H
+#define __ASM_MIPS_MACH_MIPS_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	1
+#define MIPS_CACHE_SYNC_WAR		1
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define ICACHE_REFILLS_WORKAROUND_WAR	1
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_MIPS_WAR_H */
Index: linux-3.18.29/arch/mips/siflower/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/Kconfig	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,139 @@
+if SIFLOWER
+
+choice
+	prompt "Siflower SoC selection"
+	default SOC_SF16A18
+	help
+	  Select Siflower MIPS SoC type.
+
+	config SOC_SF16A18
+		bool "SF16A18"
+
+	config SOC_SF16A28
+		bool "SF16A28"
+
+endchoice
+
+if SOC_SF16A18
+
+choice
+	prompt "Siflower SoC_SF16A18 selection"
+	default SF16A18_MPW0
+	help
+	  Select MPW0/MPW1 SF16A18 SoC
+
+	config SF16A18_MPW0
+		bool "SF16A18_MPW0"
+
+	config SF16A18_MPW1
+		bool "SF16A18_MPW1"
+
+endchoice
+
+if SF16A18_MPW0
+
+config DT_SF16A18_MPW0_P10
+	bool "Built-in device tree for sf16a18 p10 boards"
+	default n
+	select BUILTIN_DTB
+	help
+	  Add an FDT blob for XLP EVP boards into the kernel.
+	  This DTB will be used if the firmware does not pass in a DTB
+	  pointer to the kernel.  The corresponding DTS file is at
+	  arch/mips/boot/dts/sf16a18_p10.dts
+
+config DT_SF16A18_MPW0_P10_RN5T567
+	bool "Built-in device tree for sf16a18 p10 boards"
+	default n
+	select BUILTIN_DTB
+	help
+	  Add an FDT blob for XLP EVP boards into the kernel.
+	  This DTB will be used if the firmware does not pass in a DTB
+	  pointer to the kernel.  The corresponding DTS file is at
+	  arch/mips/boot/dts/sf16a18_p10_rn5t567.dts
+
+
+config DT_SF16A18_MPW0_P20
+	bool "Built-in device tree for sf16a18 p20 boards"
+	default n
+	select BUILTIN_DTB
+	help
+	  Add an FDT blob for XLP EVP boards into the kernel.
+	  This DTB will be used if the firmware does not pass in a DTB
+	  pointer to the kernel.  The corresponding DTS file is at
+	  arch/mips/boot/dts/sf16a18_p20.dts
+
+endif #SF16A18_MPW0
+
+if SF16A18_MPW1
+
+config DT_SF16A18_MPW1_FPGA
+	bool "Built-in device tree for sf16a18 mpw1 fpga"
+	default n
+	select BUILTIN_DTB
+	help
+	  Add an FDT blob for XLP EVP boards into the kernel.
+	  This DTB will be used if the firmware does not pass in a DTB
+	  pointer to the kernel.  The corresponding DTS file is at
+	  arch/mips/boot/dts/sf16a18_fpga_mpw1.dts
+
+config DT_SF16A18_MPW1_P10
+	bool "Built-in device tree for sf16a18 mpw1 p10 boards"
+	default n
+	select BUILTIN_DTB
+	help
+	  Add an FDT blob for XLP EVP boards into the kernel.
+	  This DTB will be used if the firmware does not pass in a DTB
+	  pointer to the kernel.  The corresponding DTS file is at
+	  arch/mips/boot/dts/sf16a18_p10.dts
+
+config DT_SF16A18_MPW1_P20
+	bool "Built-in device tree for sf16a18 mpw1 p20 boards"
+	default n
+	select BUILTIN_DTB
+	help
+	  Add an FDT blob for XLP EVP boards into the kernel.
+	  This DTB will be used if the firmware does not pass in a DTB
+	  pointer to the kernel.  The corresponding DTS file is at
+	  arch/mips/boot/dts/sf16a18_p20.dts
+
+endif #SF16A18_MPW1
+
+endif #SOC_SF16A18
+
+config FIRMWARE_SIZE
+	int "CORE 1 FIRMWARE SIZE (0-16 MB)"
+	range 0 16
+	default 8
+	help
+	  This is the firmware size for core 1. If firmware size is
+	  set to zero, core 1 will not be powered up.
+
+config CORE1_MEM_RES
+	bool "CORE 1 MEM RESERVE"
+	default n
+
+config SIFLOWER_CPUFREQ_DEBUGFS
+	tristate "Configurable cpu frequency support"
+	help
+	  This config will create a file in debugfs.Write a cpu
+	  frequency into this file will set the frequency.The minimum
+	  frequency is 100MHZ.
+
+config SIFLOWER_PWMTIMER_CLKSRC
+	bool "Enable SiFlower PWM Timer based clocksource"
+	depends on SOC_SF16A18
+	select SFAX8_TIMER
+	select CLKSRC_SFAX8_PWM
+	select MIPS_EXTERNAL_TIMER
+	select SIFLOWER_CPUFREQ_DEBUGFS
+	help
+	  This option enables a clocksource driver based on a SiFlower
+	  PWM external timer.
+
+	  If you want to enable the CPUFreq, you need to enable
+	  this option.
+
+	  If you don't want to enable CPUFreq, you can leave this disabled.
+
+endif #SIFLOWER
Index: linux-3.18.29/arch/mips/siflower/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/Makefile	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,18 @@
+#
+# Carsten Langgaard, carstenl@mips.com
+# Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+#
+# Copyright (C) 2008 Wind River Systems, Inc.
+#   written by Ralf Baechle <ralf@linux-mips.org>
+#
+obj-y			:= init.o time.o init.o \
+				   reset.o setup.o
+
+obj-$(CONFIG_SIFLOWER_CPUFREQ_DEBUGFS)	+= cpufreq_debugfs.o
+
+obj-$(CONFIG_OF)    += of.o
+
+obj-$(CONFIG_MIPS_CMP)		+= sf16a18-amon.o
+obj-$(CONFIG_SOC_SF16A18) += sf16a18-clk.o sf16a18-memory.o sf16a18-int.o
+obj-$(CONFIG_SOC_SF16A28) += sf16a28-clk.o sf16a28-memory.o sf16a28-int.o
+
Index: linux-3.18.29/arch/mips/siflower/common.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/common.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,14 @@
+
+#ifndef _SIFLOWER_COMMON_H__
+#define _SIFLOWER_COMMON_H__
+
+struct siflower_soc_info {
+	unsigned char *compatible;
+
+	unsigned long mem_base;
+	unsigned long mem_size;
+	unsigned long mem_size_min;
+	unsigned long mem_size_max;
+};
+
+#endif
Index: linux-3.18.29/arch/mips/siflower/include/sf_mmap.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/include/sf_mmap.h	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,959 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     register definition for Siflower SF-series SoC
+ *
+ *  Copyright 2015 Siflower Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ */
+
+#ifndef __SIFLOWER_MMAP__
+#define __SIFLOWER_MMAP__
+
+/*****************************************************************************************
+*                                                                                        *
+*  SF memory map address                                                                 *
+*                                                                                        *
+******************************************************************************************/
+#define SIFLOWER_NPU_BASE                 0xB0000000
+#define SIFLOWER_GMAC_BASE                0xB0800000
+#define SIFLOWER_WIFI1_BASE               0xB1000000//wifi 2.4G
+#define SIFLOWER_WIFI2_BASE               0xB1400000//wifi 5.0G
+#define SIFLOWER_GDMA_BASE                0xB1800000
+#define SIFLOWER_SCDMA_BASE               0xB1C00000
+#define SIFLOWER_USB_BASE                 0xB7400000
+#define SIFLOWER_EMMC_BASE                0xB7600000
+#define SIFLOWER_SDIO_BASE                0xB7800000
+#define SIFLOWER_CATRF_BASE               0xB7A00000
+#define SIFLOWER_I2S_BASE                 0xB8000000
+#define SIFLOWER_I2C_BASE                 0xB8100000
+#define SIFLOWER_I2C_OFFSET               0x1000
+#define SIFLOWER_SPI_BASE                 0xB8200000
+#define SIFLOWER_SPI_OFFSET               0x1000
+#define SIFLOWER_UART_BASE                0xB8300000
+#define SIFLOWER_UART_OFFSET              0x1000
+#define SIFLOWER_PCM_BASE                 0xB8400000
+#define SIFLOWER_PCM_OFFSET               0x1000
+#define SIFLOWER_PWM_BASE                 0xB8500000
+#define SIFLOWER_PWM_OFFSET               0x1000
+#define SIFLOWER_TIMER_BASE               0xB8600000
+#define SIFLOWER_TIMER_OFFSET             0x1000
+#define SIFLOWER_WDT_BASE                 0xB8700000
+#define SIFLOWER_SPDIF_BASE               0xB8800000
+#define SIFLOWER_GPIO_BASE                0xB9D00000
+#define SIFLOWER_SYSCTL_BASE              0xB9E00000
+#define SIFLOWER_DDR_CTL_BASE             0xB9F00000
+#define SIFLOWER_DDR_PHY_BASE             0xB9F80000
+
+//IRAM MAP
+#ifdef WIFI_24G
+#define SIFLOWER_IRAM_BASE                0xBC018000
+#else
+#define SIFLOWER_IRAM_BASE                0xBC000000
+#endif
+
+#if (defined(WIFI_24G) || defined(WIFI_5G))
+#define SIFLOWER_IRAM_SIZE                0x18000
+#else
+#define SIFLOWER_IRAM_SIZE                0x30000
+#endif
+
+//in any case,simulaiton log always save at the last 32 byte,becase we use shadow ram for log, not real space.
+#define SIFLOWER_LOG_SIZE                 (32)
+
+#ifdef WIFI_5G
+#define SIFLOWER_SIM_LOG_BASE             (SIFLOWER_IRAM_BASE + (SIFLOWER_IRAM_SIZE * 2) - SIFLOWER_LOG_SIZE)
+#define SIFLOWER_SIM_LOG_TRIG             (SIFLOWER_IRAM_BASE + (SIFLOWER_IRAM_SIZE * 2) - 1)
+#else
+#define SIFLOWER_SIM_LOG_BASE             (SIFLOWER_IRAM_BASE + SIFLOWER_IRAM_SIZE - SIFLOWER_LOG_SIZE)
+#define SIFLOWER_SIM_LOG_TRIG             (SIFLOWER_IRAM_BASE + SIFLOWER_IRAM_SIZE - 1)
+#endif
+
+//in any case,hardwre memory operation code set at the last fix addr,becase we use shadow ram for log, not real space.
+#define SIFLOWER_HW_COPY_SIZE             (32)
+#define SIFLOWER_HW_COPY_BASE			  (SIFLOWER_SIM_LOG_BASE - SIFLOWER_HW_COPY_SIZE)
+
+
+#if (defined(DDR) && defined(BOOT_DDR))
+//boot from ddr,not iram
+#define SIFLOWER_STACK_SIZE               (0x20000)//stack upgrade low addrres. 64K
+#define SIFLOWER_STACK_BASE               (SIFLOWER_IRAM_BASE + 0x1000) //this is an temp sp point,befort ddr intit
+#define SIFLOWER_STACK_BASE1              (0xa0030000) //this is an common sp point,after ddr init
+#define SIFLOWER_DATA_BASE                (0xa0040000)
+
+#define SIFLOWER_INT_CONTEXT_SIZE         (256)//for interrupt context
+#define SIFLOWER_INT_CONTEXT_BASE         (0xa0000000)
+
+#define SIFLOWER_IRAM_RESERVE_SIZE        (736)//resver for msic
+#define SIFLOWER_IRAM_RESVERVE_BASE       (0xa0001000)
+
+#else
+
+#define SIFLOWER_IRAM_RESERVE_SIZE        (704)//resver for msic
+#define SIFLOWER_IRAM_RESVERVE_BASE       (SIFLOWER_IRAM_BASE + SIFLOWER_IRAM_SIZE - SIFLOWER_LOG_SIZE- SIFLOWER_HW_COPY_SIZE - SIFLOWER_IRAM_RESERVE_SIZE)
+
+#define SIFLOWER_INT_CONTEXT_SIZE         (256)//for interrupt context
+#define SIFLOWER_INT_CONTEXT_BASE         (SIFLOWER_STACK_BASE + 4)
+
+#ifdef WIFI
+#define SIFLOWER_STACK_SIZE               (0x800000)//stack upgrade low addrres.
+#define SIFLOWER_STACK_BASE               (0xaf000000)
+#else
+#define SIFLOWER_STACK_SIZE               (0x8000)//stack upgrade low addrres.
+#define SIFLOWER_STACK_BASE               (SIFLOWER_IRAM_RESVERVE_BASE - SIFLOWER_INT_CONTEXT_SIZE)
+#endif /* WIFI */
+#endif
+
+
+//hardware memory copy or set key addr
+//0x0000_0077 - copy memory data from source address to destination address
+//0x0000_0088 - load memory data from source file to destination address
+//0x0000_0099 - save memory data from source address to destination file
+#define SIFLOWER_HW_COPY_TIRG             (SIFLOWER_HW_COPY_BASE + 16 )
+#define SIFLOWER_HW_COPY_SRC              (SIFLOWER_HW_COPY_BASE + 16 + 4)//Source Address
+#define SIFLOWER_HW_COPY_DST              (SIFLOWER_HW_COPY_BASE + 16 + 8)//Destination Address
+#define SIFLOWER_HW_COPY_LEN              (SIFLOWER_HW_COPY_BASE + 16 + 12)//Data Length (Byte)
+
+
+/*****************************************************************************************
+*                                                                                        *
+*  SF Interrupt Controller                                                               *
+*                                                                                        *
+******************************************************************************************/
+#define SIFLOWER_NPU_HIF_IRQ             16
+#define SIFLOWER_NPU_RES1_IRQ            17
+#define SIFLOWER_NPU_RES2_IRQ            18
+#define SIFLOWER_NPU_RES3_IRQ            19
+#define SIFLOWER_NPU_RES4_IRQ            20
+#define SIFLOWER_NPU_RES5_IRQ            21
+#define SIFLOWER_NPU_RES6_IRQ            22
+#define SIFLOWER_NPU_RES7_IRQ            23
+#define SIFLOWER_NPU_BMU_IRQ             24
+#define SIFLOWER_NPU_PHY1_IRQ            25
+#define SIFLOWER_NPU_PHY2_IRQ            26
+#define SIFLOWER_NPU_PHY3_IRQ            27
+#define SIFLOWER_NPU_PHY4_IRQ            28
+#define SIFLOWER_NPU_PHY5_IRQ            29
+
+#define SIFLOWER_EMAC_SBD_IRQ            32
+#define SIFLOWER_EMAC_LPI_IRQ            33
+#define SIFLOWER_EMAC_PMT_IRQ            34
+
+#define SIFLOWER_WIFI_INTC_CPU_SINGLE	 48
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC_HOST      49
+
+//WIFI End Of Transfer interrupts: Last fragment of the channel link list has been processed
+#define SIFLOWER_WIFI_INTC_DMA_CH0_EOT   50
+#define SIFLOWER_WIFI_INTC_DMA_CH1_EOT   51
+#define SIFLOWER_WIFI_INTC_DMA_CH2_EOT   52
+#define SIFLOWER_WIFI_INTC_DMA_CH3_EOT   53
+
+#define SIFLOWER_WIFI_INTC_LLI0          54
+#define SIFLOWER_WIFI_INTC_LLI1          55
+#define SIFLOWER_WIFI_INTC_LLI2          56
+#define SIFLOWER_WIFI_INTC_LLI3          57
+#define SIFLOWER_WIFI_INTC_LLI4          58
+#define SIFLOWER_WIFI_INTC_LLI5          59
+#define SIFLOWER_WIFI_INTC_LLI6          60
+#define SIFLOWER_WIFI_INTC_LLI7          61
+#define SIFLOWER_WIFI_INTC_LLI8          62
+#define SIFLOWER_WIFI_INTC_LLI9          63
+
+#define SIFLOWER_WIFI_INTC_CPU_SINGLE_5G    64
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC_HOST_5G      65
+//WIFI End Of Transfer interrupts: Last fragment of the channel link list has been processed
+#define SIFLOWER_WIFI_INTC_DMA_CH0_EOT_5G   66
+#define SIFLOWER_WIFI_INTC_DMA_CH1_EOT_5G   67
+#define SIFLOWER_WIFI_INTC_DMA_CH2_EOT_5G   68
+#define SIFLOWER_WIFI_INTC_DMA_CH3_EOT_5G   69
+#define SIFLOWER_WIFI_INTC_LLI0_5G          70
+#define SIFLOWER_WIFI_INTC_LLI1_5G          71
+#define SIFLOWER_WIFI_INTC_LLI2_5G          72
+#define SIFLOWER_WIFI_INTC_LLI3_5G          73
+#define SIFLOWER_WIFI_INTC_LLI4_5G          74
+#define SIFLOWER_WIFI_INTC_LLI5_5G          75
+#define SIFLOWER_WIFI_INTC_LLI6_5G          76
+#define SIFLOWER_WIFI_INTC_LLI7_5G          77
+#define SIFLOWER_WIFI_INTC_LLI8_5G          78
+#define SIFLOWER_WIFI_INTC_LLI9_5G          79
+
+#define SIFLOWER_GDMA_IRQ0               80
+#define SIFLOWER_GDMA_IRQ1               81
+#define SIFLOWER_GDMA_IRQ2               82
+#define SIFLOWER_GDMA_IRQ3               83
+#define SIFLOWER_GDMA_IRQ4               84
+#define SIFLOWER_GDMA_IRQ5               85
+#define SIFLOWER_GDMA_IRQ6               86
+#define SIFLOWER_GDMA_IRQ7               87
+#define SIFLOWER_GDMA_IRQ8               88
+#define SIFLOWER_GDMA_IRQ9               89
+#define SIFLOWER_GDMA_IRQ10              90
+#define SIFLOWER_GDMA_IRQ11              91
+#define SIFLOWER_GDMA_ABR_IRQ            92
+
+//WIFI LLI interrupts: Specific fragment of link list item has been processed
+#define SIFLOWER_WIFI_INTC_LLI10         96
+#define SIFLOWER_WIFI_INTC_LLI11         97
+#define SIFLOWER_WIFI_INTC_LLI12         98
+#define SIFLOWER_WIFI_INTC_LLI13         99
+#define SIFLOWER_WIFI_INTC_LLI14         100
+#define SIFLOWER_WIFI_INTC_LLI15         101
+
+//WIFI DMA
+#define SIFLOWER_WIFI_INTC_DMA_BUSERR    102
+#define SIFLOWER_WIFI_INTC_DMA_CH4_EOT   103
+// MAC HW
+#define SIFLOWER_WIFI_INTC_MACTIMER      104
+#define SIFLOWER_WIFI_INTC_MACOTHER      105
+#define SIFLOWER_WIFI_INTC_MACRX         106
+#define SIFLOWER_WIFI_INTC_MACTX         107
+#define SIFLOWER_WIFI_INTC_MACINTGEN     108
+#define SIFLOWER_WIFI_INTC_MACPROT       109
+
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC0          110
+#define SIFLOWER_WIFI_INTC_IPC1          111
+
+//WIFI LLI interrupts: Specific fragment of link list item has been processed
+#define SIFLOWER_WIFI_INTC_LLI10_5G         112
+#define SIFLOWER_WIFI_INTC_LLI11_5G         113
+#define SIFLOWER_WIFI_INTC_LLI12_5G         114
+#define SIFLOWER_WIFI_INTC_LLI13_5G         115
+#define SIFLOWER_WIFI_INTC_LLI14_5G         116
+#define SIFLOWER_WIFI_INTC_LLI15_5G         117
+
+//WIFI DMA
+#define SIFLOWER_WIFI_INTC_DMA_BUSERR_5G    118
+#define SIFLOWER_WIFI_INTC_DMA_CH4_EOT_5G   119
+
+// MAC HW
+#define SIFLOWER_WIFI_INTC_MACTIMER_5G      120
+#define SIFLOWER_WIFI_INTC_MACOTHER_5G      121
+#define SIFLOWER_WIFI_INTC_MACRX_5G         122
+#define SIFLOWER_WIFI_INTC_MACTX_5G         123
+#define SIFLOWER_WIFI_INTC_MACINTGEN_5G     124
+#define SIFLOWER_WIFI_INTC_MACPROT_5G       125
+
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC0_5G          126
+#define SIFLOWER_WIFI_INTC_IPC1_5G          127
+
+#define SIFLOWER_USB_IRQ                 128
+
+#define SIFLOWER_SDIO0_IRQ               144
+#define SIFLOWER_SDIO1_IRQ               160
+
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC2          200
+#define SIFLOWER_WIFI_INTC_IPC3          201
+
+//WIFI IQ TEST ENGINE buffer full interruption
+#define SIFLOWER_WIFI_INTC_IQR_LOWRAM_FULL   192
+#define SIFLOWER_WIFI_INTC_IQR_HIGHRAM_FULL  193
+#define SIFLOWER_WIFI_INTC_IQP_LOWRAM_FULL   194
+#define SIFLOWER_WIFI_INTC_IQP_HIGHRAM_FULL  195
+
+//WIFI PHY HW
+#define SIFLOWER_WIFI_INTC_MODEM         202
+#define SIFLOWER_WIFI_INTC_RC            203
+
+//WIFI Inter Processor Communication
+#define SIFLOWER_WIFI_INTC_IPC2_5G          204
+#define SIFLOWER_WIFI_INTC_IPC3_5G          205
+
+//WIFI PHY HW
+#define SIFLOWER_WIFI_INTC_MODEM_5G         206
+#define SIFLOWER_WIFI_INTC_RC_5G            207
+
+#define SIFLOWER_I2S_M_IRQ	             208
+#define SIFLOWER_I2S_S_IRQ	             211
+
+#define SIFLOWER_I2C0_IRQ	  	         217
+#define SIFLOWER_I2C1_IRQ	             218
+#define SIFLOWER_I2C2_IRQ	             219
+
+#define SIFLOWER_SPI0_IRQ                223
+#define SIFLOWER_SPI1_IRQ                224
+#define SIFLOWER_SPI2_IRQ                225
+#define SIFLOWER_UART0_IRQ	             226
+#define SIFLOWER_UART1_IRQ	             227
+#define SIFLOWER_UART2_IRQ	             228
+#define SIFLOWER_UART3_IRQ	             229
+#define SIFLOWER_PCM0_IRQ                230
+#define SIFLOWER_PCM1_IRQ                231
+#define SIFLOWER_PWM0_IRQ                232
+#define SIFLOWER_PWM1_IRQ                233
+#define SIFLOWER_TIMER00_IRQ             234
+#define SIFLOWER_TIMER01_IRQ             235
+#define SIFLOWER_TIMER10_IRQ             236
+#define SIFLOWER_TIMER11_IRQ             237
+#define SIFLOWER_WDT_IRQ                 238
+#define SIFLOWER_SPDIF_IRQ	             239
+
+#define SIFLOWER_GPIO_GRA_IRQ            245//for all gpios
+#define SIFLOWER_GPIO_GR0_IRQ            246
+#define SIFLOWER_GPIO_GR1_IRQ            247
+#define SIFLOWER_GPIO_GR2_IRQ            248
+#define SIFLOWER_GPIO_GR3_IRQ            249
+#define SIFLOWER_GPIO_GR4_IRQ            250
+#define SIFLOWER_GPIO_GR5_IRQ            251
+#define SIFLOWER_GPIO_GR6_IRQ            252
+#define SIFLOWER_GPIO_GR7_IRQ            253
+#define SIFLOWER_GPIO_GR8_IRQ            254
+#define SIFLOWER_GPIO_GR9_IRQ            255
+
+
+
+
+/*****************************************************************************************
+*                                                                                        *
+*  SF System Manager                                                                     *
+*                                                                                        *
+******************************************************************************************/
+//CM_PwrOn_n
+#define CORE_CM_PWRON_N                  (SIFLOWER_SYSCTL_BASE + 0x0000)
+
+//SI_CPCReset
+#define CORE_CPC_RESET                   (SIFLOWER_SYSCTL_BASE + 0x0004)
+
+//bit4		 for SI_CM_PwrUp
+//bit3-bit2  = 0
+//bit1       for SI1_PwrUp
+//bit0       for SI0_PwrUp
+#define CORE_POWER_CTRL                  (SIFLOWER_SYSCTL_BASE + 0x0010)
+
+//SI_PwrOn_Reset
+#define CORE_PWRON_RESET                 (SIFLOWER_SYSCTL_BASE + 0x001C)
+
+//core cold powerup
+//bit3-bit2 for SI1_ColdPwrUp
+//bit1-bit0 for SI0_ColdPwrUp
+#define CORE_CLOD_POWERUP                (SIFLOWER_SYSCTL_BASE + 0x0020)
+
+//SI_WDTReset[7:0]
+#define CORE_WDG_RESET                   (SIFLOWER_SYSCTL_BASE + 0x0024)
+
+//SI_L2_ClkRatio
+#define CORE_L2_CLK_RATIO                (SIFLOWER_SYSCTL_BASE + 0x0038)
+
+//SI_L2_SetClkRatio
+#define CORE_L2_SET_CLK_RATIO            (SIFLOWER_SYSCTL_BASE + 0x003C)
+
+//bit4      for SI0_DisableVPE
+//bit3-bit0 for SI0_DisableTCs
+#define CORE0_VPE_TC_DISABLE             (SIFLOWER_SYSCTL_BASE + 0x004C)
+#define CORE1_VPE_TC_DISABLE             (SIFLOWER_SYSCTL_BASE + 0x0050)
+
+//SI*_Vpe0MaxTC[3:0]
+#define CORE0_VPE0_MAX_TC                (SIFLOWER_SYSCTL_BASE + 0x0054)
+#define CORE1_VPE0_MAX_TC                (SIFLOWER_SYSCTL_BASE + 0x0058)
+
+//for irom ctrl
+#define IROM_SOFT_RESET                  (SIFLOWER_SYSCTL_BASE + 0x0800)
+#define IROM_CLK_EN                      (SIFLOWER_SYSCTL_BASE + 0x0804)
+#define IROM_SOFT_BOE                    (SIFLOWER_SYSCTL_BASE + 0x080C)
+
+//before cpu up,irom use 12M,then use cpu clk. this reg can be set in irom fix code
+#define IROM_BOOT_CLK_SEL                (SIFLOWER_SYSCTL_BASE + 0x2028)
+
+#define REMAP_N                          (SIFLOWER_SYSCTL_BASE + 0x202C)
+
+#define SOFT_REBOOT                      (SIFLOWER_SYSCTL_BASE + 0x2030)
+#define SYS_EVTS_MASK70                  (SIFLOWER_SYSCTL_BASE + 0x2034)
+#define SYS_EVTS_MASK158                 (SIFLOWER_SYSCTL_BASE + 0x2038)
+#define SYS_EVTS_MASK2316                (SIFLOWER_SYSCTL_BASE + 0x203C)
+#define SYS_EVTS_MASK3124                (SIFLOWER_SYSCTL_BASE + 0x2040)
+#define SYS_EVTS_MASK3932                (SIFLOWER_SYSCTL_BASE + 0x2044)
+#define SYS_EVTS_MASK4740                (SIFLOWER_SYSCTL_BASE + 0x2048)
+#define SYS_EVTS_MASK5548                (SIFLOWER_SYSCTL_BASE + 0x204C)
+#define SYS_EVTS_MASK6356                (SIFLOWER_SYSCTL_BASE + 0x2050)
+
+//int_laram1_sel,  int_laram0_sel  bit3-bit2 LA mode 0->iram 1->LA
+//fram1_sel,       fram0_sel       bit1-bit0 share/iram mode 0->iram 1->share
+#define WIFI_SHARE_RAM_SEL               (SIFLOWER_SYSCTL_BASE + 0x242C)
+//int_player1_sel, int_player0_sel,int_recorder1_sel, int_recorder0_sel
+#define WIFI_SYSM_IQ_ENGINE_SEL          (SIFLOWER_SYSCTL_BASE + 0x2430)
+//int_rp_enable, int_bb_sel
+#define WIFI_SYSM_IQ_ENGINE_CONF         (SIFLOWER_SYSCTL_BASE + 0x2434)
+
+//cpu sys manager module
+#define CPU_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x2C28)
+
+//ddr sys manager module
+#define MPU_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x2C2C)
+
+//irom sys manager module
+#define IROM_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x2C34)
+
+//irom sys manager module --not use
+#define BROM_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x2C3C)
+
+//iram sys manager module --not use
+#define MPOL_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x2C40)
+
+//clock sys manager module --not use
+#define CM_SYSM_RESET                    (SIFLOWER_SYSCTL_BASE + 0x2DF0)
+
+//io sys manager module
+#define IO_SYSM_RESET                    (SIFLOWER_SYSCTL_BASE + 0x2DF4)
+
+//ddr
+#define MEM_RESET                        (SIFLOWER_SYSCTL_BASE + 0x2DC8)
+
+//cpu --in irom fixed code
+#define CPU_RESET                        (SIFLOWER_SYSCTL_BASE + 0x2DCC)
+
+#define BUS1_RESET                       (SIFLOWER_SYSCTL_BASE + 0x2DD0)
+#define BUS2_RESET                       (SIFLOWER_SYSCTL_BASE + 0x2DD4)
+#define BUS3_RESET                       (SIFLOWER_SYSCTL_BASE + 0x2DD8)
+#define BUS4_RESET                       (SIFLOWER_SYSCTL_BASE + 0x2DDC)
+#define BUS5_RESET                       (SIFLOWER_SYSCTL_BASE + 0x2DE0)
+#define BUS6_RESET                       (SIFLOWER_SYSCTL_BASE + 0x2DE4)
+#define BUS7_RESET                       (SIFLOWER_SYSCTL_BASE + 0x2DE8)
+#define BUS8_RESET                       (SIFLOWER_SYSCTL_BASE + 0x2DEC)
+
+//iram sys manager module
+#define IRAM_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x2C30)
+#define IRAM_SOFT_RESET                  (SIFLOWER_SYSCTL_BASE + 0x0C00)
+#define IRAM_SOFT_CLK_EN                 (SIFLOWER_SYSCTL_BASE + 0x0C04)
+#define IRAM_SOFT_BOE                    (SIFLOWER_SYSCTL_BASE + 0x0C0C)
+#define IRAM_SOFT_RESET1                 (SIFLOWER_SYSCTL_BASE + 0x0C1C)
+#define IRAM_SOFT_CLK_EN1                (SIFLOWER_SYSCTL_BASE + 0x0C20)
+
+//NPU
+#define NPU_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x2C44)
+#define NPU_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0x4000)
+#define NPU_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0x4004)
+#define NPU_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0x400C)
+#define NPU_HW_RST_PGM_EN                (SIFLOWER_SYSCTL_BASE + 0x40CC)
+
+//OMINI PHY
+#define OMINI_PHY_ENABLE                 (SIFLOWER_SYSCTL_BASE + 0x4040)
+#define OMINI_PHY_CFG_POWERDOWN          (SIFLOWER_SYSCTL_BASE + 0x4044)
+#define OMINI_PHY_CFG_POWERUP_RESET      (SIFLOWER_SYSCTL_BASE + 0x4048)
+
+#define OMINI_PHY1_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x404C)
+#define OMINI_PHY2_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x4050)
+#define OMINI_PHY3_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x4054)
+#define OMINI_PHY4_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x4058)
+#define OMINI_PHY5_CFG_ADDR              (SIFLOWER_SYSCTL_BASE + 0x405C)
+
+#define OMINI_PHY1_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x4060)
+#define OMINI_PHY2_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x4064)
+#define OMINI_PHY3_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x4068)
+#define OMINI_PHY4_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x406C)
+#define OMINI_PHY5_CFG_FX_PLL_MODE       (SIFLOWER_SYSCTL_BASE + 0x4070)
+
+#define OMINI_PHY_CFG_CLK_FREQ           (SIFLOWER_SYSCTL_BASE + 0x4074)
+#define OMINI_PHY_CFG_CLK_REF_SEL        (SIFLOWER_SYSCTL_BASE + 0x4078)
+
+#define OMINI_PHY1_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x407C)
+#define OMINI_PHY1_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x4080)
+#define OMINI_PHY1_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x4084)
+#define OMINI_PHY1_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x4088)
+
+#define OMINI_PHY2_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x408C)
+#define OMINI_PHY2_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x4090)
+#define OMINI_PHY2_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x4094)
+#define OMINI_PHY2_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x4098)
+
+#define OMINI_PHY3_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x409C)
+#define OMINI_PHY3_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x40A0)
+#define OMINI_PHY3_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x40A4)
+#define OMINI_PHY3_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x40A8)
+
+#define OMINI_PHY4_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x40AC)
+#define OMINI_PHY4_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x40B0)
+#define OMINI_PHY4_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x40B4)
+#define OMINI_PHY4_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x40B8)
+
+#define OMINI_PHY5_CFG_PHY_ID_LOW8       (SIFLOWER_SYSCTL_BASE + 0x40BC)
+#define OMINI_PHY5_CFG_PHY_ID_HIGH8      (SIFLOWER_SYSCTL_BASE + 0x40C0)
+#define OMINI_PHY5_CFG_MODEL_NR          (SIFLOWER_SYSCTL_BASE + 0x40C4)
+#define OMINI_PHY5_CFG_REV_NR            (SIFLOWER_SYSCTL_BASE + 0x40C8)
+
+//GMAC
+#define EMAC_SYSM_RESETN                 (SIFLOWER_SYSCTL_BASE + 0x2C48)
+#define EMAC_SOFT_RESET                  (SIFLOWER_SYSCTL_BASE + 0x4400)
+#define EMAC_SOFT_CLKGATE_EN             (SIFLOWER_SYSCTL_BASE + 0x4404)
+#define EMAC_SOFT_BOE                    (SIFLOWER_SYSCTL_BASE + 0x440C)
+#define EMAC_PHY_INTF_SEL_I              (SIFLOWER_SYSCTL_BASE + 0x4440)
+
+//WIFI DMA
+#define SCDMA_SYSM_RESET                 (SIFLOWER_SYSCTL_BASE + 0x2C70)  //[0:0] Active Low
+#define SCDMA_SOFT_RESET                 (SIFLOWER_SYSCTL_BASE + 0x8C00)  //[2:0] Active High
+#define SCDMA_SOFT_CLK_EN                (SIFLOWER_SYSCTL_BASE + 0x8C04)  //[2:0] Active High
+#define SCDMA_SOFT_BOE                   (SIFLOWER_SYSCTL_BASE + 0x8C0C)  //[1:0] Active High
+
+//WIFI1 2.4G
+#define WIFI_1_SYSM_RESET                (SIFLOWER_SYSCTL_BASE + 0x2C64)  //[0:0] Active Low
+#define WIFI_1_SOFT_RESET                (SIFLOWER_SYSCTL_BASE + 0x8000)  //[2:0] Active High
+#define WIFI_1_SOFT_CLK_EN               (SIFLOWER_SYSCTL_BASE + 0x8004)  //[7:0] Active High
+#define WIFI_1_SOFT_BOE                  (SIFLOWER_SYSCTL_BASE + 0x800C)  //[1:0] Active High
+// wifi2.4 iqdump for simulation
+#define WIFI_1_LA_CLK_SEL                (SIFLOWER_SYSCTL_BASE + 0x8040)
+#define WIFI_1_IQ_GEN_DUMP_EN            (SIFLOWER_SYSCTL_BASE + 0x8044)
+#define WIFI_1_IQ_DUMP_LENGTH_0          (SIFLOWER_SYSCTL_BASE + 0x8048)
+#define WIFI_1_IQ_DUMP_LENGTH_1          (SIFLOWER_SYSCTL_BASE + 0x804C)
+#define WIFI_1_IQ_DUMP_LENGTH_2          (SIFLOWER_SYSCTL_BASE + 0x8050)
+#define WIFI_1_IQ_DUMP_LENGTH_3          (SIFLOWER_SYSCTL_BASE + 0x8054)
+#define WIFI_1_IQ_GEN_LENGTH_0           (SIFLOWER_SYSCTL_BASE + 0x8058)
+#define WIFI_1_IQ_GEN_LENGTH_1           (SIFLOWER_SYSCTL_BASE + 0x805C)
+#define WIFI_1_IQ_GEN_LENGTH_2           (SIFLOWER_SYSCTL_BASE + 0x8060)
+#define WIFI_1_IQ_GEN_LENGTH_3           (SIFLOWER_SYSCTL_BASE + 0x8064)
+// wifi2.4G iq test engine
+#define WIFI_1_IQ_ENGINE_RECORD_MODE     (SIFLOWER_SYSCTL_BASE + 0x3800)
+#define WIFI_1_IQ_ENGINE_RECORD_TRIGGER  (SIFLOWER_SYSCTL_BASE + 0x3804)
+#define WIFI_1_IQ_ENGINE_RECORD_DMAREQ   (SIFLOWER_SYSCTL_BASE + 0x3808)
+#define WIFI_1_IQ_ENGINE_RECORD_DMAACK   (SIFLOWER_SYSCTL_BASE + 0x380C)
+#define WIFI_1_IQ_ENGINE_RECORD_OFFSET_0 (SIFLOWER_SYSCTL_BASE + 0x3810)
+#define WIFI_1_IQ_ENGINE_RECORD_OFFSET_1 (SIFLOWER_SYSCTL_BASE + 0x3814)
+#define WIFI_1_IQ_ENGINE_RECORD_OFFSET_2 (SIFLOWER_SYSCTL_BASE + 0x3818)
+#define WIFI_1_IQ_ENGINE_RECORD_OFFSET_3 (SIFLOWER_SYSCTL_BASE + 0x381C)
+#define WIFI_1_IQ_ENGINE_RECORD_LENGTH_0 (SIFLOWER_SYSCTL_BASE + 0x3820)
+#define WIFI_1_IQ_ENGINE_RECORD_LENGTH_1 (SIFLOWER_SYSCTL_BASE + 0x3824)
+#define WIFI_1_IQ_ENGINE_RECORD_LENGTH_2 (SIFLOWER_SYSCTL_BASE + 0x3828)
+#define WIFI_1_IQ_ENGINE_RECORD_LENGTH_3 (SIFLOWER_SYSCTL_BASE + 0x382C)
+#define WIFI_1_IQ_ENGINE_RECORD_DMAADEAD (SIFLOWER_SYSCTL_BASE + 0x3830)
+
+#define WIFI_1_IQ_ENGINE_PLAYER_MODE     (SIFLOWER_SYSCTL_BASE + 0x3A00)
+#define WIFI_1_IQ_ENGINE_PLAYER_TRIGGER  (SIFLOWER_SYSCTL_BASE + 0x3A04)
+#define WIFI_1_IQ_ENGINE_PLAYER_DMAREQ   (SIFLOWER_SYSCTL_BASE + 0x3A08)
+#define WIFI_1_IQ_ENGINE_PLAYER_DMAACK   (SIFLOWER_SYSCTL_BASE + 0x3A0C)
+#define WIFI_1_IQ_ENGINE_PLAYER_OFFSET_0 (SIFLOWER_SYSCTL_BASE + 0x3A10)
+#define WIFI_1_IQ_ENGINE_PLAYER_OFFSET_1 (SIFLOWER_SYSCTL_BASE + 0x3A14)
+#define WIFI_1_IQ_ENGINE_PLAYER_OFFSET_2 (SIFLOWER_SYSCTL_BASE + 0x3A18)
+#define WIFI_1_IQ_ENGINE_PLAYER_OFFSET_3 (SIFLOWER_SYSCTL_BASE + 0x3A1C)
+#define WIFI_1_IQ_ENGINE_PLAYER_LENGTH_0 (SIFLOWER_SYSCTL_BASE + 0x3A20)
+#define WIFI_1_IQ_ENGINE_PLAYER_LENGTH_1 (SIFLOWER_SYSCTL_BASE + 0x3A24)
+#define WIFI_1_IQ_ENGINE_PLAYER_LENGTH_2 (SIFLOWER_SYSCTL_BASE + 0x3A28)
+#define WIFI_1_IQ_ENGINE_PLAYER_LENGTH_3 (SIFLOWER_SYSCTL_BASE + 0x3A2C)
+#define WIFI_1_IQ_ENGINE_PLAYER_DMAADEAD (SIFLOWER_SYSCTL_BASE + 0x3A30)
+
+
+//WIFI2 5.0G
+#define WIFI_2_SYSM_RESET                (SIFLOWER_SYSCTL_BASE + 0x2C68)  //[0:0] Active Low
+#define WIFI_2_SOFT_RESET                (SIFLOWER_SYSCTL_BASE + 0x8400)  //[2:0] Active High
+#define WIFI_2_SOFT_CLK_EN               (SIFLOWER_SYSCTL_BASE + 0x8404)  //[7:0] Active High
+#define WIFI_2_SOFT_BOE                  (SIFLOWER_SYSCTL_BASE + 0x840C)  //[1:0] Active High
+// wifi5G iqdump for simulation
+#define WIFI_2_LA_CLK_SEL                (SIFLOWER_SYSCTL_BASE + 0x8440)
+#define WIFI_2_IQ_GEN_DUMP_EN            (SIFLOWER_SYSCTL_BASE + 0x8444)
+#define WIFI_2_IQ_DUMP_LENGTH_0          (SIFLOWER_SYSCTL_BASE + 0x8448)
+#define WIFI_2_IQ_DUMP_LENGTH_1          (SIFLOWER_SYSCTL_BASE + 0x844C)
+#define WIFI_2_IQ_DUMP_LENGTH_2          (SIFLOWER_SYSCTL_BASE + 0x8450)
+#define WIFI_2_IQ_DUMP_LENGTH_3          (SIFLOWER_SYSCTL_BASE + 0x8454)
+#define WIFI_2_IQ_GEN_LENGTH_0           (SIFLOWER_SYSCTL_BASE + 0x8458)
+#define WIFI_2_IQ_GEN_LENGTH_1           (SIFLOWER_SYSCTL_BASE + 0x845C)
+#define WIFI_2_IQ_GEN_LENGTH_2           (SIFLOWER_SYSCTL_BASE + 0x8460)
+#define WIFI_2_IQ_GEN_LENGTH_3           (SIFLOWER_SYSCTL_BASE + 0x8464)
+// wifi5G iq test engine
+#define WIFI_2_IQ_ENGINE_RECORD_MODE     (SIFLOWER_SYSCTL_BASE + 0x3900)
+#define WIFI_2_IQ_ENGINE_RECORD_TRIGGER  (SIFLOWER_SYSCTL_BASE + 0x3904)
+#define WIFI_2_IQ_ENGINE_RECORD_DMAREQ   (SIFLOWER_SYSCTL_BASE + 0x3908)
+#define WIFI_2_IQ_ENGINE_RECORD_DMAACK   (SIFLOWER_SYSCTL_BASE + 0x390C)
+#define WIFI_2_IQ_ENGINE_RECORD_OFFSET_0 (SIFLOWER_SYSCTL_BASE + 0x3910)
+#define WIFI_2_IQ_ENGINE_RECORD_OFFSET_1 (SIFLOWER_SYSCTL_BASE + 0x3914)
+#define WIFI_2_IQ_ENGINE_RECORD_OFFSET_2 (SIFLOWER_SYSCTL_BASE + 0x3918)
+#define WIFI_2_IQ_ENGINE_RECORD_OFFSET_3 (SIFLOWER_SYSCTL_BASE + 0x391C)
+#define WIFI_2_IQ_ENGINE_RECORD_LENGTH_0 (SIFLOWER_SYSCTL_BASE + 0x3920)
+#define WIFI_2_IQ_ENGINE_RECORD_LENGTH_1 (SIFLOWER_SYSCTL_BASE + 0x3924)
+#define WIFI_2_IQ_ENGINE_RECORD_LENGTH_2 (SIFLOWER_SYSCTL_BASE + 0x3928)
+#define WIFI_2_IQ_ENGINE_RECORD_LENGTH_3 (SIFLOWER_SYSCTL_BASE + 0x392C)
+#define WIFI_2_IQ_ENGINE_RECORD_DMAADEAD (SIFLOWER_SYSCTL_BASE + 0x3930)
+
+#define WIFI_2_IQ_ENGINE_PLAYER_MODE     (SIFLOWER_SYSCTL_BASE + 0x3B00)
+#define WIFI_2_IQ_ENGINE_PLAYER_TRIGGER  (SIFLOWER_SYSCTL_BASE + 0x3B04)
+#define WIFI_2_IQ_ENGINE_PLAYER_DMAREQ   (SIFLOWER_SYSCTL_BASE + 0x3B08)
+#define WIFI_2_IQ_ENGINE_PLAYER_DMAACK   (SIFLOWER_SYSCTL_BASE + 0x3B0C)
+#define WIFI_2_IQ_ENGINE_PLAYER_OFFSET_0 (SIFLOWER_SYSCTL_BASE + 0x3B10)
+#define WIFI_2_IQ_ENGINE_PLAYER_OFFSET_1 (SIFLOWER_SYSCTL_BASE + 0x3B14)
+#define WIFI_2_IQ_ENGINE_PLAYER_OFFSET_2 (SIFLOWER_SYSCTL_BASE + 0x3B18)
+#define WIFI_2_IQ_ENGINE_PLAYER_OFFSET_3 (SIFLOWER_SYSCTL_BASE + 0x3B1C)
+#define WIFI_2_IQ_ENGINE_PLAYER_LENGTH_0 (SIFLOWER_SYSCTL_BASE + 0x3B20)
+#define WIFI_2_IQ_ENGINE_PLAYER_LENGTH_1 (SIFLOWER_SYSCTL_BASE + 0x3B24)
+#define WIFI_2_IQ_ENGINE_PLAYER_LENGTH_2 (SIFLOWER_SYSCTL_BASE + 0x3B28)
+#define WIFI_2_IQ_ENGINE_PLAYER_LENGTH_3 (SIFLOWER_SYSCTL_BASE + 0x3B2C)
+#define WIFI_2_IQ_ENGINE_PLAYER_DMAADEAD (SIFLOWER_SYSCTL_BASE + 0x3B30)
+
+
+//DMA
+#define DMA_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x2C6C)
+#define DMA_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0x8800)
+#define DMA_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0x8804)
+#define DMA_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0x880C)
+#define DMA_BOOT_MANAGER_NS              (SIFLOWER_SYSCTL_BASE + 0x8840) //[0:0] Active High
+#define DMA_BOOT_FROM_PC                 (SIFLOWER_SYSCTL_BASE + 0x8844) //[0:0] Active High
+#define DMA_BOOT_IRQ_NS70                (SIFLOWER_SYSCTL_BASE + 0x8848) //[7:0] Active High
+#define DMA_BOOT_IRQ_NS158               (SIFLOWER_SYSCTL_BASE + 0x884C) //[15:8] Active High
+#define DMA_BOOT_IRQ_NS2316              (SIFLOWER_SYSCTL_BASE + 0x8850) //[23:16] Active High
+#define DMA_BOOT_PERIPH_NS70             (SIFLOWER_SYSCTL_BASE + 0x8854) //[7:0] Active High
+#define DMA_BOOT_PERIPH_NS158            (SIFLOWER_SYSCTL_BASE + 0x8858) //[15:8] Active High
+#define DMA_BOOT_PERIPH_NS2316           (SIFLOWER_SYSCTL_BASE + 0x885C) //[23:16] Active High
+#define DMA_BOOT_ADDR70                  (SIFLOWER_SYSCTL_BASE + 0x8860) //[7:0] Active High
+#define DMA_BOOT_ADDR158                 (SIFLOWER_SYSCTL_BASE + 0x8864) //[15:8] Active High
+#define DMA_BOOT_ADDR2316                (SIFLOWER_SYSCTL_BASE + 0x8868) //[23:16] Active High
+#define DMA_BOOT_ADDR3124                (SIFLOWER_SYSCTL_BASE + 0x886C) //[31:24] Active High
+
+
+//usb
+#define USB_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x2C8C)
+#define USB_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0xC800)
+#define USB_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0xC804)
+#define USB_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0xC80C)
+#define USB_SLEEPM0                      (SIFLOWER_SYSCTL_BASE + 0xC844)
+#define USB_DEBUG_EN                     (SIFLOWER_SYSCTL_BASE + 0xC88C)
+
+//SDIO & EMMC
+#define EMMC_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x2C90)
+#define EMMC_SOFT_RESET                  (SIFLOWER_SYSCTL_BASE + 0xCC00)
+#define EMMC_SOFT_CLK_EN                 (SIFLOWER_SYSCTL_BASE + 0xCC04)
+#define EMMC_SOFT_BOE                    (SIFLOWER_SYSCTL_BASE + 0xCC0C)
+
+#define SDIO_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x2C94)
+#define SDIO_SOFT_RESET                  (SIFLOWER_SYSCTL_BASE + 0xD000)
+#define SDIO_SOFT_CLK_EN                 (SIFLOWER_SYSCTL_BASE + 0xD004)
+#define SDIO_SOFT_BOE                    (SIFLOWER_SYSCTL_BASE + 0xD00C)
+
+//catena rf modem
+#define CATIP_SYSM_RESET                 (SIFLOWER_SYSCTL_BASE + 0x2C98)
+#define CATIP_SOFT_RESET                 (SIFLOWER_SYSCTL_BASE + 0xD400)
+#define CATIP_SOFT_CLK_EN                (SIFLOWER_SYSCTL_BASE + 0xD404)
+#define CATIP_SOFT_BOE                   (SIFLOWER_SYSCTL_BASE + 0xD40C)
+
+//SATA
+#define SATA_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x2C68)
+#define SATA_SOFT_RESET                  (SIFLOWER_SYSCTL_BASE + 0x8400)
+#define SATA_SOFT_CLK_EN                 (SIFLOWER_SYSCTL_BASE + 0x8404)
+#define SATA_SOFT_BOE                    (SIFLOWER_SYSCTL_BASE + 0x840C)
+#define SATA_PHY_RESET                   (SIFLOWER_SYSCTL_BASE + 0x8440)
+#define SATA_PHY_READY                   (SIFLOWER_SYSCTL_BASE + 0x8444)
+
+//APB bus reset reg
+#define PBUS_RESET                       (SIFLOWER_SYSCTL_BASE + 0x2DC4)
+#define PBUS_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x2C38)
+
+//apb modules manager
+#define IIS_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x02D44)
+#define IIS_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0x24000)
+#define IIS_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0x24004)
+#define IIS_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0x2400C)
+
+#define IIC_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x02D48)
+#define IIC_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0x24400)
+#define IIC_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0x24404)
+#define IIC_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0x2440C)
+
+#define SPI_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x02D4C)
+#define SPI_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0x24800)
+#define SPI_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0x24804)
+#define SPI_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0x2480C)
+#define SPI0_CS_SEL	                     (SIFLOWER_SYSCTL_BASE + 0x24840)
+#define SSP_FSSOUT_NTXDOE_SEL            (SIFLOWER_SYSCTL_BASE + 0x24844)
+
+#define UART_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x02D50)
+#define UART_SOFT_RESET                  (SIFLOWER_SYSCTL_BASE + 0x24C00)
+#define UART_SOFT_CLK_EN                 (SIFLOWER_SYSCTL_BASE + 0x24C04)
+#define UART_SOFT_BOE                    (SIFLOWER_SYSCTL_BASE + 0x24C0C)
+
+#define PCM_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x02D54)
+#define PCM_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0x25000)
+#define PCM_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0x25004)
+#define PCM_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0x2500C)
+
+#define PWM_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x02D58)
+#define PWM_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0x25400)
+#define PWM_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0x25404)
+#define PWM_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0x2540C)
+
+#define TIMER_SYSM_RESET                 (SIFLOWER_SYSCTL_BASE + 0x02D5C)
+#define TIMER_SOFT_RESET                 (SIFLOWER_SYSCTL_BASE + 0x25800)
+#define TIMER_SOFT_CLK_EN                (SIFLOWER_SYSCTL_BASE + 0x25804)
+#define TIMER_SOFT_BOE                   (SIFLOWER_SYSCTL_BASE + 0x2580C)
+
+#define WDT_SYSM_RESET                   (SIFLOWER_SYSCTL_BASE + 0x02D60)
+#define WDT_SOFT_RESET                   (SIFLOWER_SYSCTL_BASE + 0x25C00)
+#define WDT_SOFT_CLK_EN                  (SIFLOWER_SYSCTL_BASE + 0x25C04)
+#define WDT_SOFT_BOE                     (SIFLOWER_SYSCTL_BASE + 0x25C0C)
+
+#define SPDIF_SYSM_RESET                 (SIFLOWER_SYSCTL_BASE + 0x02D64)
+#define SPDIF_SOFT_RESET                 (SIFLOWER_SYSCTL_BASE + 0x26000)
+#define SPDIF_SOFT_CLK_EN                (SIFLOWER_SYSCTL_BASE + 0x26004)
+#define SPDIF_SOFT_BOE                   (SIFLOWER_SYSCTL_BASE + 0x2600C)
+
+#define GPIO_SYSM_RESET                  (SIFLOWER_SYSCTL_BASE + 0x02DB8)
+#define GPIO_SOFT_RESET                  (SIFLOWER_SYSCTL_BASE + 0x2B400)
+#define GPIO_SOFT_CLK_EN                 (SIFLOWER_SYSCTL_BASE + 0x2B404)
+#define GPIO_SOFT_BOE                    (SIFLOWER_SYSCTL_BASE + 0x2B40C)
+
+#define PAD_SW_IE_EN                     (SIFLOWER_SYSCTL_BASE + 0x3FEA0)
+
+
+/*****************************************************************************************
+*                                                                                        *
+*  SF Clock System Manager                                                               *
+*                                                                                        *
+******************************************************************************************/
+
+/***********************************************************************************************
+
+XXX_PLL_POWER  power down signals for PLL
+bit[5]:int_dsmpd
+bit[4]:int_dacpd
+bit[3]:int_fout4phased
+bit[2]:int_foutpostdivpd
+bit[1]:int_foutvcopd
+bit[0]:int_pd
+
+XXX_PLL_PARA70 bit7--bit0 parameter signals for PLL
+
+XXX_PLL_CONFIG
+bit[5]: load enable signal for int_pll_para
+bit[4]: clock gating signal for pll_clk_out
+bit[3]: select clock signal from pll_clk_out and reference clock
+bit[2:1] 00 : reference clock = ext_osc_clk_12MHz 01 : reference clock = ext_osc_clk_40MHz
+         10 : reference clock = ext_clk 11 : reference clock = ext_clk
+bit[0]: bypass signal for PLL
+
+************************************************************************************************/
+
+#define CPU_PLL_POWER             (SIFLOWER_SYSCTL_BASE + 0x1000)
+#define CPU_PLL_PARA70            (SIFLOWER_SYSCTL_BASE + 0x1004)
+#define CPU_PLL_PARA158           (SIFLOWER_SYSCTL_BASE + 0x1008)
+#define CPU_PLL_PARA2316          (SIFLOWER_SYSCTL_BASE + 0x100C)
+#define CPU_PLL_PARA3124          (SIFLOWER_SYSCTL_BASE + 0x1010)
+#define CPU_PLL_PARA3932          (SIFLOWER_SYSCTL_BASE + 0x1014)
+#define CPU_PLL_PARA4740          (SIFLOWER_SYSCTL_BASE + 0x1018)
+#define CPU_PLL_CONFIG            (SIFLOWER_SYSCTL_BASE + 0x101C)
+
+#define DDR_PLL_POWER             (SIFLOWER_SYSCTL_BASE + 0x1040)
+#define DDR_PLL_PARA70            (SIFLOWER_SYSCTL_BASE + 0x1044)
+#define DDR_PLL_PARA158           (SIFLOWER_SYSCTL_BASE + 0x1048)
+#define DDR_PLL_PARA2316          (SIFLOWER_SYSCTL_BASE + 0x104C)
+#define DDR_PLL_PARA3124          (SIFLOWER_SYSCTL_BASE + 0x1050)
+#define DDR_PLL_PARA3932          (SIFLOWER_SYSCTL_BASE + 0x1054)
+#define DDR_PLL_PARA4740          (SIFLOWER_SYSCTL_BASE + 0x1058)
+#define DDR_PLL_CONFIG            (SIFLOWER_SYSCTL_BASE + 0x105C)
+
+#define CMN_PLL_POWER             (SIFLOWER_SYSCTL_BASE + 0x1080)
+#define CMN_PLL_PARA70            (SIFLOWER_SYSCTL_BASE + 0x1084)
+#define CMN_PLL_PARA158           (SIFLOWER_SYSCTL_BASE + 0x1088)
+#define CMN_PLL_PARA2316          (SIFLOWER_SYSCTL_BASE + 0x108C)
+#define CMN_PLL_PARA3124          (SIFLOWER_SYSCTL_BASE + 0x1090)
+#define CMN_PLL_PARA3932          (SIFLOWER_SYSCTL_BASE + 0x1094)
+#define CMN_PLL_PARA4740          (SIFLOWER_SYSCTL_BASE + 0x1098)
+#define CMN_PLL_CONFIG            (SIFLOWER_SYSCTL_BASE + 0x109C)
+
+#define SPC_PLL_POWER             (SIFLOWER_SYSCTL_BASE + 0x10C0)
+#define SPC_PLL_PARA70            (SIFLOWER_SYSCTL_BASE + 0x10C4)
+#define SPC_PLL_PARA158           (SIFLOWER_SYSCTL_BASE + 0x10C8)
+#define SPC_PLL_PARA2316          (SIFLOWER_SYSCTL_BASE + 0x10CC)
+#define SPC_PLL_PARA3124          (SIFLOWER_SYSCTL_BASE + 0x10D0)
+#define SPC_PLL_PARA3932          (SIFLOWER_SYSCTL_BASE + 0x10D4)
+#define SPC_PLL_PARA4740          (SIFLOWER_SYSCTL_BASE + 0x10D8)
+#define SPC_PLL_CONFIG            (SIFLOWER_SYSCTL_BASE + 0x10DC)
+
+
+/***************************************************************************************************************
+
+XXX_XN_CLK_CONFIG
+use_nco[3] 0 : clk_out = div_clk 1 : clk_out = nco_div_clk
+src_sel[2:0] 000 : mux_clk_s2 = pll_cpu_clk 001 : mux_clk_s2 = pll_ddr_clk 010 : mux_clk_s2 = pll_cmn_clk
+             011 : mux_clk_s2 = pll_spc_clk 100 : mux_clk_s2 = ext_clk 101 : mux_clk_s2 = ext_osc_clk_12MHz
+             110 : mux_clk_s2 = ext_osc_clk_40MHz 111 : mux_clk_s2 = 0
+
+XXX_XN_CLK_DIV
+clk_ratio[7:0] clock ratio for div_clk from mux_clk_s2
+
+XXX_XN_CLK_NCO_DIV
+clk_nco_v[7:0] acc value for nco_div_clk from mux_clk_s2
+
+XXX_XN_CLK_ENABLE
+clock_enable[0:0] clock enable for both clk_out and xn_div_clk_out
+
+XXX_XN_CLK_XN_DIV
+xn_div_clk_ratio[1:0] clock ratio for xn_div_clk_out from clk_out
+
+******************************************************************************************************************/
+
+#define BUS1_XN_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x1400)
+#define BUS1_XN_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x1404)
+#define BUS1_XN_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x1408)
+#define BUS1_XN_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x140C)
+#define BUS1_XN_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x1410)
+
+#define BUS2_XN_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x1420)
+#define BUS2_XN_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x1424)
+#define BUS2_XN_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x1428)
+#define BUS2_XN_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x142C)
+#define BUS2_XN_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x1430)
+
+#define BUS3_XN_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x1440)
+#define BUS3_XN_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x1444)
+#define BUS3_XN_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x1448)
+#define BUS3_XN_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x144C)
+#define BUS3_XN_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x1450)
+
+#define BUS4_XN_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x1460)
+#define BUS4_XN_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x1464)
+#define BUS4_XN_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x1468)
+#define BUS4_XN_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x146C)
+#define BUS4_XN_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x1470)
+
+#define BUS5_XN_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x1480)
+#define BUS5_XN_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x1484)
+#define BUS5_XN_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x1488)
+#define BUS5_XN_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x148C)
+#define BUS5_XN_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x1490)
+
+#define BUS6_XN_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x14A0)
+#define BUS6_XN_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x14A4)
+#define BUS6_XN_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x14A8)
+#define BUS6_XN_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x14AC)
+#define BUS6_XN_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x14B0)
+
+#define BUS7_XN_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x14C0)
+#define BUS7_XN_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x14C4)
+#define BUS7_XN_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x14C8)
+#define BUS7_XN_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x14CC)
+#define BUS7_XN_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x14D0)
+
+#define BUS8_XN_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x14E0)
+#define BUS8_XN_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x14E4)
+#define BUS8_XN_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x14E8)
+#define BUS8_XN_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x14EC)
+#define BUS8_XN_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x14F0)
+
+#define CPU_CLK_CONFIG            (SIFLOWER_SYSCTL_BASE + 0x1500)
+#define CPU_CLK_DIV               (SIFLOWER_SYSCTL_BASE + 0x1504)
+#define CPU_CLK_NCO_DIV           (SIFLOWER_SYSCTL_BASE + 0x1508)
+#define CPU_CLK_ENABLE            (SIFLOWER_SYSCTL_BASE + 0x150C)
+#define CPU_CLK_XN_DIV            (SIFLOWER_SYSCTL_BASE + 0x1510)
+
+#define PBUS_CLK_CONFIG           (SIFLOWER_SYSCTL_BASE + 0x1520)
+#define PBUS_CLK_DIV              (SIFLOWER_SYSCTL_BASE + 0x1524)
+#define PBUS_CLK_NCO_DIV          (SIFLOWER_SYSCTL_BASE + 0x1528)
+#define PBUS_CLK_ENABLE           (SIFLOWER_SYSCTL_BASE + 0x152C)
+#define PBUS_CLK_XN_DIV           (SIFLOWER_SYSCTL_BASE + 0x1530)
+
+#define MEM_PHY_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x1540)
+#define MEM_PHY_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x1544)
+#define MEM_PHY_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x1548)
+#define MEM_PHY_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x154C)
+#define MEM_PHY_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x1550)
+
+#define AUDIO_EXTCLK_CONFIG       (SIFLOWER_SYSCTL_BASE + 0x1560)
+#define AUDIO_EXTCLK_DIV          (SIFLOWER_SYSCTL_BASE + 0x1564)
+#define AUDIO_EXTCLK_NCO_DIV      (SIFLOWER_SYSCTL_BASE + 0x1568)
+#define AUDIO_EXTCLK_ENABLE       (SIFLOWER_SYSCTL_BASE + 0x156C)
+#define AUDIO_EXTCLK_XN_DIV       (SIFLOWER_SYSCTL_BASE + 0x1570)
+
+#define UART_EXTCLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x1580)
+#define UART_EXTCLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x1584)
+#define UART_EXTCLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x1588)
+#define UART_EXTCLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x158C)
+#define UART_EXTCLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x1590)
+
+#define SPDIF_EXTCLK_CONFIG       (SIFLOWER_SYSCTL_BASE + 0x15A0)
+#define SPDIF_EXTCLK_DIV          (SIFLOWER_SYSCTL_BASE + 0x15A4)
+#define SPDIF_EXTCLK_NCO_DIV      (SIFLOWER_SYSCTL_BASE + 0x15A8)
+#define SPDIF_EXTCLK_ENABLE       (SIFLOWER_SYSCTL_BASE + 0x15AC)
+#define SPDIF_EXTCLK_XN_DIV       (SIFLOWER_SYSCTL_BASE + 0x15B0)
+
+#define SDHC_EXT_CLK_CONFIG       (SIFLOWER_SYSCTL_BASE + 0x15C0)
+#define SDHC_EXT_CLK_DIV          (SIFLOWER_SYSCTL_BASE + 0x15C4)
+#define SDHC_EXT_CLK_NCO_DIV      (SIFLOWER_SYSCTL_BASE + 0x15C8)
+#define SDHC_EXT_CLK_ENABLE       (SIFLOWER_SYSCTL_BASE + 0x15CC)
+#define SDHC_EXT_CLK_XN_DIV       (SIFLOWER_SYSCTL_BASE + 0x15D0)
+
+#define EMMC_EXT_CLK_CONFIG       (SIFLOWER_SYSCTL_BASE + 0x15E0)
+#define EMMC_EXT_CLK_DIV          (SIFLOWER_SYSCTL_BASE + 0x15E4)
+#define EMMC_EXT_CLK_NCO_DIV      (SIFLOWER_SYSCTL_BASE + 0x15E8)
+#define EMMC_EXT_CLK_ENABLE       (SIFLOWER_SYSCTL_BASE + 0x15EC)
+#define EMMC_EXT_CLK_XN_DIV       (SIFLOWER_SYSCTL_BASE + 0x15F0)
+
+#define ETH_REF_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x1600)
+#define ETH_REF_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x1604)
+#define ETH_REF_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x1608)
+#define ETH_REF_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x160C)
+#define ETH_REF_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x1610)
+
+#define ETH_BYP_REF_CLK_CONFIG    (SIFLOWER_SYSCTL_BASE + 0x1620)
+#define ETH_BYP_REF_CLK_DIV       (SIFLOWER_SYSCTL_BASE + 0x1624)
+#define ETH_BYP_REF_CLK_NCO_DIV   (SIFLOWER_SYSCTL_BASE + 0x1628)
+#define ETH_BYP_REF_CLK_ENABLE    (SIFLOWER_SYSCTL_BASE + 0x162C)
+#define ETH_BYP_REF_CLK_XN_DIV    (SIFLOWER_SYSCTL_BASE + 0x1630)
+
+#define ETH_TSU_CLK_CONFIG        (SIFLOWER_SYSCTL_BASE + 0x1640)
+#define ETH_TSU_CLK_DIV           (SIFLOWER_SYSCTL_BASE + 0x1644)
+#define ETH_TSU_CLK_NCO_DIV       (SIFLOWER_SYSCTL_BASE + 0x1648)
+#define ETH_TSU_CLK_ENABLE        (SIFLOWER_SYSCTL_BASE + 0x164C)
+#define ETH_TSU_CLK_XN_DIV        (SIFLOWER_SYSCTL_BASE + 0x1650)
+
+#define COMBO_REF_CLK_CONFIG      (SIFLOWER_SYSCTL_BASE + 0x1660)
+#define COMBO_REF_CLK_DIV         (SIFLOWER_SYSCTL_BASE + 0x1664)
+#define COMBO_REF_CLK_NCO_DIV     (SIFLOWER_SYSCTL_BASE + 0x1668)
+#define COMBO_REF_CLK_ENABLE      (SIFLOWER_SYSCTL_BASE + 0x166C)
+#define COMBO_REF_CLK_XN_DIV      (SIFLOWER_SYSCTL_BASE + 0x1670)
+
+#define PCIE_AUX_CLK_CONFIG       (SIFLOWER_SYSCTL_BASE + 0x1680)
+#define PCIE_AUX_CLK_DIV          (SIFLOWER_SYSCTL_BASE + 0x1684)
+#define PCIE_AUX_CLK_NCO_DIV      (SIFLOWER_SYSCTL_BASE + 0x1688)
+#define PCIE_AUX_CLK_ENABLE       (SIFLOWER_SYSCTL_BASE + 0x168C)
+#define PCIE_AUX_CLK_XN_DIV       (SIFLOWER_SYSCTL_BASE + 0x1690)
+
+#define SATA_PMALIVE_CLK_CONFIG   (SIFLOWER_SYSCTL_BASE + 0x16A0)
+#define SATA_PMALIVE_CLK_DIV      (SIFLOWER_SYSCTL_BASE + 0x16A4)
+#define SATA_PMALIVE_CLK_NCO_DIV  (SIFLOWER_SYSCTL_BASE + 0x16A8)
+#define SATA_PMALIVE_CLK_ENABLE   (SIFLOWER_SYSCTL_BASE + 0x16AC)
+#define SATA_PMALIVE_CLK_XN_DIV   (SIFLOWER_SYSCTL_BASE + 0x16B0)
+
+#define WLAN24_MAC_WT_CLK_CONFIG  (SIFLOWER_SYSCTL_BASE + 0x16C0)
+#define WLAN24_MAC_WT_CLK_DIV     (SIFLOWER_SYSCTL_BASE + 0x16C4)
+#define WLAN24_MAC_WT_CLK_NCO_DIV (SIFLOWER_SYSCTL_BASE + 0x16C8)
+#define WLAN24_MAC_WT_CLK_ENABLE  (SIFLOWER_SYSCTL_BASE + 0x16CC)
+#define WLAN24_MAC_WT_CLK_XN_DIV  (SIFLOWER_SYSCTL_BASE + 0x16D0)
+
+#define WLAN5_MAC_WT_CLK_CONFIG   (SIFLOWER_SYSCTL_BASE + 0x16E0)
+#define WLAN5_MAC_WT_CLK_DIV      (SIFLOWER_SYSCTL_BASE + 0x16E4)
+#define WLAN5_MAC_WT_CLK_NCO_DIV  (SIFLOWER_SYSCTL_BASE + 0x16E8)
+#define WLAN5_MAC_WT_CLK_ENABLE   (SIFLOWER_SYSCTL_BASE + 0x16EC)
+#define WLAN5_MAC_WT_CLK_XN_DIV   (SIFLOWER_SYSCTL_BASE + 0x16F0)
+
+#define USBPHY_REF_CLK_CONFIG     (SIFLOWER_SYSCTL_BASE + 0x1700)
+#define USBPHY_REF_CLK_DIV        (SIFLOWER_SYSCTL_BASE + 0x1704)
+#define USBPHY_REF_CLK_NCO_DIV    (SIFLOWER_SYSCTL_BASE + 0x1708)
+#define USBPHY_REF_CLK_ENABLE     (SIFLOWER_SYSCTL_BASE + 0x170C)
+#define USBPHY_REF_CLK_XN_DIV     (SIFLOWER_SYSCTL_BASE + 0x1710)
+
+#define TCLK_CONFIG               (SIFLOWER_SYSCTL_BASE + 0x1720)
+#define TCLK_DIV                  (SIFLOWER_SYSCTL_BASE + 0x1724)
+#define TCLK_NCO_DIV              (SIFLOWER_SYSCTL_BASE + 0x1728)
+#define TCLK_ENABLE               (SIFLOWER_SYSCTL_BASE + 0x172C)
+#define TCLK_XN_DIV               (SIFLOWER_SYSCTL_BASE + 0x1730)
+
+#endif // __SIFLOWER_MMAP__
Index: linux-3.18.29/arch/mips/siflower/init.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/init.c	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,78 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * PROM library initialisation code.
+ *
+ * Copyright (C) 1999,2000,2004,2005,2012  MIPS Technologies, Inc.
+ * All rights reserved.
+ * Authors: Carsten Langgaard <carstenl@mips.com>
+ *         Maciej W. Rozycki <macro@mips.com>
+ *          Steven J. Hill <sjhill@mips.com>
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+#include <asm/cacheflush.h>
+#include <asm/smp-ops.h>
+#include <asm/traps.h>
+#include <asm/fw/fw.h>
+#include <asm/mips-cm.h>
+#include <asm/mips-cpc.h>
+#include <generic.h>
+
+#ifdef CONFIG_SOC_SF16A18
+#include <sf16a18.h>
+#endif
+
+static void __init mips_nmi_setup(void)
+{
+	void *base;
+	extern char except_vec_nmi;
+
+	base = cpu_has_veic ?
+		(void *)(CAC_BASE + 0xa80) :
+		(void *)(CAC_BASE + 0x380);
+	memcpy(base, &except_vec_nmi, 0x80);
+	flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
+}
+
+static void __init mips_ejtag_setup(void)
+{
+	void *base;
+	extern char except_vec_ejtag_debug;
+
+	base = cpu_has_veic ?
+		(void *)(CAC_BASE + 0xa00) :
+		(void *)(CAC_BASE + 0x300);
+	memcpy(base, &except_vec_ejtag_debug, 0x80);
+	flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
+}
+
+phys_t mips_cpc_default_phys_base(void)
+{
+	return CPC_BASE_ADDR;
+}
+
+void __init prom_init(void)
+{
+	board_nmi_handler_setup = mips_nmi_setup;
+	board_ejtag_handler_setup = mips_ejtag_setup;
+
+	fw_init_cmdline();
+	fw_meminit();
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	console_config();
+#endif
+	mips_cm_probe();
+	mips_cpc_probe();
+
+	if (!register_cps_smp_ops())
+		return;
+	if (!register_cmp_smp_ops())
+		return;
+	if (!register_vsmp_smp_ops())
+		return;
+}
Index: linux-3.18.29/arch/mips/siflower/of.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/of.c	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,87 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/sizes.h>
+#include <linux/of_fdt.h>
+#include <linux/kernel.h>
+#include <linux/bootmem.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_net.h>
+
+#include <asm/reboot.h>
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+#include <asm/prom.h>
+
+#include "common.h"
+
+__iomem void *rt_sysc_membase;
+__iomem void *rt_memc_membase;
+
+__iomem void *plat_of_remap_node(const char *node)
+{
+	struct resource res;
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, node);
+	if (!np)
+		panic("Failed to find %s node", node);
+
+	if (of_address_to_resource(np, 0, &res))
+		panic("Failed to get resource for %s", node);
+
+	if ((request_mem_region(res.start,
+				resource_size(&res),
+				res.name) < 0))
+		panic("Failed to request resources for %s", node);
+
+	return ioremap_nocache(res.start, resource_size(&res));
+}
+
+void __init device_tree_init(void)
+{
+	unflatten_and_copy_device_tree();
+}
+
+void __init of_setup(void)
+{
+	set_io_port_base(KSEG1);
+
+#ifdef CONFIG_BUILTIN_DTB
+	/*
+	 * Load the builtin devicetree. This causes the chosen node to be
+	 * parsed resulting in our memory appearing
+	 */
+	__dt_setup_arch(__dtb_start);
+#endif
+}
+
+static const struct of_device_id siflower_of_match[] = {
+	{ .compatible = "siflower,sf16a18-soc", },
+	{ .compatible = "palmbus", },
+	{},
+};
+
+static int __init plat_of_setup(void)
+{
+	if (!of_have_populated_dt())
+		panic("device tree not present");
+
+	platform_device_register_simple("cpufreq-dt", -1, NULL, 0);
+
+	return of_platform_populate(NULL, siflower_of_match, NULL, NULL);
+}
+
+arch_initcall(plat_of_setup);
+
Index: linux-3.18.29/arch/mips/siflower/reset.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/reset.c	2017-11-21 20:11:40.378707000 +0800
@@ -0,0 +1,321 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ */
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <asm/reboot.h>
+//kmalloc/kfree
+#include <linux/slab.h>
+
+#ifdef CONFIG_SOC_SF16A18
+#include <sf16a18.h>
+#endif
+
+#define CLK_EN_OFFSET			0x04
+#define	BOE_OFFSET				0x0C
+#define IRAM_SOFT_RESET1_OFFSET	0x1C
+#define IRAM_CLK1_EN_OFFSET		0x20
+
+struct reset{
+	unsigned int soft_reset;
+	unsigned int sysm_reset;
+};
+
+static struct reset resets[] = 
+{
+	{
+		.soft_reset = SF_IRAM_SOFT_RESET,
+		.sysm_reset = SF_IRAM_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_NPU_SOFT_RESET,
+		.sysm_reset = SF_NPU_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_EMAC_SOFT_RESET,
+		.sysm_reset = SF_EMAC_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_GDU_SOFT_RESET,
+		.sysm_reset = SF_GDU_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_CRYPTO_SOFT_RESET,
+		.sysm_reset = SF_CRYPTO_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_WIFI_1_SOFT_RESET,
+		.sysm_reset = SF_WIFI_1_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_WIFI_2_SOFT_RESET,
+		.sysm_reset = SF_WIFI_2_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_GDMA_SOFT_RESET,
+		.sysm_reset = SF_GDMA_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_SCDMA_SOFT_RESET,
+		.sysm_reset = SF_SCDMA_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_USB_SOFT_RESET,
+		.sysm_reset = SF_USB_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_EMMC_SOFT_RESET,
+		.sysm_reset = SF_EMMC_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_SDIO_SOFT_RESET,
+		.sysm_reset = SF_SDIO_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_CATIP_SOFT_RESET,
+		.sysm_reset = SF_CATIP_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_IIS_SOFT_RESET,
+		.sysm_reset = SF_IIS_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_IIC_SOFT_RESET,
+		.sysm_reset = SF_IIC_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_SPI_SOFT_RESET,
+		.sysm_reset = SF_SPI_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_UART_SOFT_RESET,
+		.sysm_reset = SF_UART_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_PCM_SOFT_RESET,
+		.sysm_reset = SF_PCM_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_PWM_SOFT_RESET,
+		.sysm_reset = SF_PWM_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_TIMER_SOFT_RESET,
+		.sysm_reset = SF_TIMER_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_WDT_SOFT_RESET,
+		.sysm_reset = SF_WDT_SYSM_RESET,
+	},
+	{
+		.soft_reset = SF_SPDIF_SOFT_RESET,
+		.sysm_reset = SF_SPDIF_SYSM_RESET,
+	},
+};
+static void mips_machine_restart(char *command)
+{
+#ifdef CONFIG_SF16A18_MPW0
+	/* workaround:20170322 SW Reset peration only trig cpu core reset
+	   Don't reinit system manager, So we should resume iram mode
+	   Otherwise cpu can't access iram durning irom booting */
+	__raw_writel(0x0, (void *)SIFLOWER_WIFI_SHARE_RAM_SEL);
+	pr_info("MPW0 soft reboot workaround done!\n");
+#endif
+
+	__raw_writel(SIFLOWER_SW_TRIG_RESET, (void *)SIFLOWER_SW_RESET);
+}
+
+static void mips_machine_halt(void)
+{
+	while (true);
+}
+
+static void mips_machine_power_off(void)
+{
+	//TODO use pmu to power off all soc by i2c interface.
+	pr_info("Failed to power down, resetting\n");
+	mips_machine_restart(NULL);
+}
+
+#ifndef CONFIG_SF16A18_MPW0
+static int print_reboot_event(void)
+{
+	int soft_reboot, wdt_reboot, catip_reboot;
+
+	soft_reboot = __raw_readl((void *)SOFT_EVENTS_RO);
+	if(soft_reboot) {
+		pr_info("Reboot from soft reboot sys-manager, val is %d\n", soft_reboot);
+		return soft_reboot;
+	}
+
+	wdt_reboot = __raw_readl((void *)SYS_EVTS6356);
+	catip_reboot = wdt_reboot & (1 << 6);
+	if(catip_reboot) {
+		pr_info("Reboot from catip\n");
+		return catip_reboot;
+	}
+
+	wdt_reboot = wdt_reboot & (1 << 7);
+	if(wdt_reboot) {
+		pr_info("Reboot from watchdog\n");
+		return catip_reboot;
+	}
+
+	pr_info("Reboot with unknown events!\n");
+	return 0;
+}
+EXPORT_SYMBOL(print_reboot_event);
+#endif
+
+static int __init mips_reboot_setup(void)
+{
+	_machine_restart = mips_machine_restart;
+	_machine_halt = mips_machine_halt;
+	pm_power_off = mips_machine_power_off;
+
+#ifndef CONFIG_SF16A18_MPW0
+	print_reboot_event();
+#endif
+
+	return 0;
+}
+arch_initcall(mips_reboot_setup);
+
+static LIST_HEAD(rst_list_head);
+struct sf_rst_offset {
+	struct list_head list;
+	unsigned int rst_offset;
+	int cnt; //the num of module
+	spinlock_t    lock;
+};
+
+static struct sf_rst_offset *get_rst_by_offset(unsigned int offset)
+{
+	struct sf_rst_offset *cur;
+	struct list_head *head;
+
+	list_for_each(head, &rst_list_head) {
+		cur = list_entry(head, struct sf_rst_offset, list);
+		if(cur->rst_offset == offset) {
+			return cur;
+		}
+	}
+
+	return NULL;
+}
+unsigned int sf_get_sysm_offset(unsigned int offset)
+{
+	int i = 0;
+	for( ; i < ARRAY_SIZE(resets); i++)
+		if(resets[i].soft_reset == offset)
+			return resets[i].sysm_reset;
+	return 0;
+}
+
+int release_reset(unsigned int offset)
+{
+	struct sf_rst_offset *rst_node;
+	unsigned int ret;
+
+	rst_node = get_rst_by_offset(offset);
+	if(rst_node) {
+		spin_lock(&rst_node->lock);
+		if(!rst_node->cnt){
+			ret = sf_get_sysm_offset(rst_node->rst_offset);
+			if(ret)
+				writel(0x1, (void*)(SIFLOWER_SYSCTL_BASE + ret));
+			else
+				printk(KERN_ERR "Can not get sysm reset offset by soft reset offset!\n");
+			writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset));
+			writel(0xFF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + CLK_EN_OFFSET));
+			if(rst_node->rst_offset == SF_IRAM_SOFT_RESET){
+				writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + IRAM_SOFT_RESET1_OFFSET));
+				writel(0xFF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + IRAM_CLK1_EN_OFFSET));
+			}
+			writel(0xF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + BOE_OFFSET));
+				
+		}
+	} else {
+		rst_node = kmalloc(sizeof(struct sf_rst_offset), GFP_KERNEL);
+		if(!rst_node)
+			return -ENOMEM;
+		spin_lock_init(&rst_node->lock);
+		spin_lock(&rst_node->lock);
+		rst_node->rst_offset = offset;
+		rst_node->cnt = 0;
+		list_add(&rst_node->list, &rst_list_head);
+		ret = sf_get_sysm_offset(rst_node->rst_offset);
+		if(ret)
+			writel(0x1, (void*)(SIFLOWER_SYSCTL_BASE + ret));
+		else
+			printk(KERN_ERR "Can not get sysm reset offset by soft reset offset!\n");
+		writel(0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset));
+		writel(0xFF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + CLK_EN_OFFSET));
+		if(rst_node->rst_offset == SF_IRAM_SOFT_RESET){
+			writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + IRAM_SOFT_RESET1_OFFSET));
+			writel(0xFF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + IRAM_CLK1_EN_OFFSET));
+		}
+		writel(0xF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + BOE_OFFSET));
+	}
+	rst_node->cnt++;
+	spin_unlock(&rst_node->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(release_reset);
+
+int hold_reset(unsigned int offset)
+{
+	struct sf_rst_offset *rst_node;
+	unsigned int ret;
+
+	rst_node = get_rst_by_offset(offset);
+	if(rst_node) {
+		spin_lock(&rst_node->lock);
+		if(rst_node->cnt > 0){
+			if(--(rst_node->cnt) == 0){
+				writel(0xFF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset));
+				writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + CLK_EN_OFFSET));
+				if(rst_node->rst_offset == SF_IRAM_SOFT_RESET){
+					writel(0xFF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + IRAM_SOFT_RESET1_OFFSET));
+					writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + IRAM_CLK1_EN_OFFSET));
+				}
+				writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + BOE_OFFSET));
+				ret = sf_get_sysm_offset(rst_node->rst_offset);
+				if(ret)
+					writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + ret));
+				else
+					printk(KERN_ERR "Can not get sysm reset offset by soft reset offset!\n");
+			}
+		}
+	} else {
+		rst_node = kmalloc(sizeof(struct sf_rst_offset), GFP_KERNEL);
+		if(!rst_node)
+			return -ENOMEM;
+		spin_lock_init(&rst_node->lock);
+		spin_lock(&rst_node->lock);
+		rst_node->rst_offset = offset;
+		rst_node->cnt = 0;
+		list_add(&rst_node->list, &rst_list_head);
+		writel(0xFF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset));
+		writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + CLK_EN_OFFSET));
+		if(rst_node->rst_offset == SF_IRAM_SOFT_RESET){
+			writel(0xFF, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + IRAM_SOFT_RESET1_OFFSET));
+			writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + IRAM_CLK1_EN_OFFSET));
+		}
+		writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + rst_node->rst_offset + BOE_OFFSET));
+		ret = sf_get_sysm_offset(rst_node->rst_offset);
+		if(ret)
+			writel(0x0, (void*)(SIFLOWER_SYSCTL_BASE + ret));
+		else
+			printk(KERN_ERR "Can not get sysm reset offset by soft reset offset!\n");
+	}
+	spin_unlock(&rst_node->lock);
+	return 0;
+}
+EXPORT_SYMBOL(hold_reset);
Index: linux-3.18.29/arch/mips/siflower/setup.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/setup.c	2017-11-21 20:11:40.378707000 +0800
@@ -0,0 +1,328 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2008 Dmitri Vorobiev
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/cpu.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/pci.h>
+#include <linux/screen_info.h>
+#include <linux/time.h>
+
+#include <asm/fw/fw.h>
+#include <asm/mips-cm.h>
+#include <asm/mips-cpc.h>
+#include <generic.h>
+#include <asm/dma.h>
+#include <asm/traps.h>
+#ifdef CONFIG_VT
+#include <linux/console.h>
+#endif
+
+#ifdef CONFIG_CORE1_MEM_RES
+#include <asm/gic.h>
+#endif
+
+#ifdef CONFIG_SOC_SF16A18
+#include <sf16a18.h>
+#include <sf16a18int.h>
+#endif
+
+extern void sf16a18_be_init(void);
+extern int sf16a18_be_handler(struct pt_regs *regs, int is_fixup);
+
+static struct resource standard_io_resources[] = {
+	{
+		.name = "dma1",
+		.start = 0x00,
+		.end = 0x1f,
+		.flags = IORESOURCE_BUSY
+	},
+	{
+		.name = "timer",
+		.start = 0x40,
+		.end = 0x5f,
+		.flags = IORESOURCE_BUSY
+	},
+	{
+		.name = "keyboard",
+		.start = 0x60,
+		.end = 0x6f,
+		.flags = IORESOURCE_BUSY
+	},
+	{
+		.name = "dma page reg",
+		.start = 0x80,
+		.end = 0x8f,
+		.flags = IORESOURCE_BUSY
+	},
+	{
+		.name = "dma2",
+		.start = 0xc0,
+		.end = 0xdf,
+		.flags = IORESOURCE_BUSY
+	},
+};
+
+const char *get_system_type(void)
+{
+	return "MIPS sf16a18";
+}
+
+const char display_string[] = "	       LINUX ON SF16A18	    ";
+
+#ifdef CONFIG_BLK_DEV_FD
+static void __init fd_activate(void)
+{
+	/*
+	 * Activate Floppy Controller in the SMSC FDC37M817 Super I/O
+	 * Controller.
+	 * Done by YAMON 2.00 onwards
+	 */
+	/* Entering config state. */
+	SMSC_WRITE(SMSC_CONFIG_ENTER, SMSC_CONFIG_REG);
+
+	/* Activate floppy controller. */
+	SMSC_WRITE(SMSC_CONFIG_DEVNUM, SMSC_CONFIG_REG);
+	SMSC_WRITE(SMSC_CONFIG_DEVNUM_FLOPPY, SMSC_DATA_REG);
+	SMSC_WRITE(SMSC_CONFIG_ACTIVATE, SMSC_CONFIG_REG);
+	SMSC_WRITE(SMSC_CONFIG_ACTIVATE_ENABLE, SMSC_DATA_REG);
+
+	/* Exit config state. */
+	SMSC_WRITE(SMSC_CONFIG_EXIT, SMSC_CONFIG_REG);
+}
+#endif
+
+static int __init plat_enable_iocoherency(void)
+{
+	/*
+	int supported = 0;
+    if (mips_cm_numiocu() != 0) {
+		pr_info("CMP IOCU detected\n");
+		if ((*(unsigned int *)0xbf403000 & 0x81) != 0x81) {
+			pr_crit("IOCU OPERATION DISABLED BY SWITCH - DEFAULTING TO SW IO COHERENCY\n");
+			return 0;
+		}
+		supported = 1;
+	}
+	hw_coherentio = supported;
+	*/
+	//SF16A18 don't have a IOCU.
+	return 0;
+}
+
+static void __init plat_setup_iocoherency(void)
+{
+	if(0)
+	{
+#ifdef CONFIG_DMA_NONCOHERENT
+	/*
+	 * Kernel has been configured with software coherency
+	 * but we might choose to turn it off and use hardware
+	 * coherency instead.
+	 */
+	if (plat_enable_iocoherency()) {
+		if (coherentio == 0)
+			pr_info("Hardware DMA cache coherency disabled\n");
+		else
+			pr_info("Hardware DMA cache coherency enabled\n");
+	} else {
+		if (coherentio == 1)
+			pr_info("Hardware DMA cache coherency unsupported, but enabled from command line!\n");
+		else
+			pr_info("Software DMA cache coherency enabled\n");
+	}
+#else
+	if (!plat_enable_iocoherency())
+		panic("Hardware DMA cache coherency not supported!");
+#endif
+	}
+}
+
+static void __init pci_clock_check(void)
+{
+	/*
+	unsigned int __iomem *jmpr_p =
+		(unsigned int *) ioremap(SF16A18_JMPRS_REG, sizeof(unsigned int));
+	int jmpr = (__raw_readl(jmpr_p) >> 2) & 0x07;
+	static const int pciclocks[] __initconst = {
+		33, 20, 25, 30, 12, 16, 37, 10
+	};
+	int pciclock = pciclocks[jmpr];
+	char *optptr, *argptr = fw_getcmdline();
+
+	optptr = strstr(argptr, "pci_clock=");
+	if (optptr && (optptr == argptr || optptr[-1] == ' '))
+		return;
+
+	if (pciclock != 33) {
+		pr_warn("WARNING: PCI clock is %dMHz, setting pci_clock\n",
+			pciclock);
+		argptr += strlen(argptr);
+		sprintf(argptr, " pci_clock=%d", pciclock);
+		if (pciclock < 20 || pciclock > 66)
+			pr_warn("WARNING: IDE timing calculations will be "
+			        "incorrect\n");
+	}
+	*/
+}
+
+#if defined(CONFIG_VT) && defined(CONFIG_VGA_CONSOLE)
+static void __init screen_info_setup(void)
+{
+	screen_info = (struct screen_info) {
+		.orig_x = 0,
+		.orig_y = 25,
+		.ext_mem_k = 0,
+		.orig_video_page = 0,
+		.orig_video_mode = 0,
+		.orig_video_cols = 80,
+		.unused2 = 0,
+		.orig_video_ega_bx = 0,
+		.unused3 = 0,
+		.orig_video_lines = 25,
+		.orig_video_isVGA = VIDEO_TYPE_VGAC,
+		.orig_video_points = 16
+	};
+}
+#endif
+/*
+static void __init bonito_quirks_setup(void)
+{
+	char *argptr;
+
+	argptr = fw_getcmdline();
+	if (strstr(argptr, "debug")) {
+		BONITO_BONGENCFG |= BONITO_BONGENCFG_DEBUGMODE;
+		pr_info("Enabled Bonito debug mode\n");
+	} else
+		BONITO_BONGENCFG &= ~BONITO_BONGENCFG_DEBUGMODE;
+
+#ifdef CONFIG_DMA_COHERENT
+	if (BONITO_PCICACHECTRL & BONITO_PCICACHECTRL_CPUCOH_PRES) {
+		BONITO_PCICACHECTRL |= BONITO_PCICACHECTRL_CPUCOH_EN;
+		pr_info("Enabled Bonito CPU coherency\n");
+
+		argptr = fw_getcmdline();
+		if (strstr(argptr, "iobcuncached")) {
+			BONITO_PCICACHECTRL &= ~BONITO_PCICACHECTRL_IOBCCOH_EN;
+			BONITO_PCIMEMBASECFG = BONITO_PCIMEMBASECFG &
+				~(BONITO_PCIMEMBASECFG_MEMBASE0_CACHED |
+					BONITO_PCIMEMBASECFG_MEMBASE1_CACHED);
+			pr_info("Disabled Bonito IOBC coherency\n");
+		} else {
+			BONITO_PCICACHECTRL |= BONITO_PCICACHECTRL_IOBCCOH_EN;
+			BONITO_PCIMEMBASECFG |=
+				(BONITO_PCIMEMBASECFG_MEMBASE0_CACHED |
+					BONITO_PCIMEMBASECFG_MEMBASE1_CACHED);
+			pr_info("Enabled Bonito IOBC coherency\n");
+		}
+	} else
+		panic("Hardware DMA cache coherency not supported");
+#endif
+}
+*/
+
+#ifdef CONFIG_CORE1_MEM_RES
+/**
+ * Power up/down core1.
+ * Attention! This is used to start core1 for wifi firmware.
+ * If you don't actually know what they are, DO NOT use them!
+ */
+int core_pwrup(unsigned long entry)
+{
+	unsigned long core_entry = entry;
+	int core = 1;
+
+	//set core other access
+	write_cpc_cl_other(core << CPC_Cx_OTHER_CORENUM_SHF);
+
+	//set power down
+	write_cpc_co_cmd(CPC_Cx_CMD_PWRDOWN);
+
+	//config the reset base for core1 with GC:
+	write_gcr_co_reset_base(CKSEG0ADDR((unsigned long)core_entry));
+
+	//set power up
+	write_cpc_co_cmd(CPC_Cx_CMD_PWRUP);
+
+	return 0;
+}
+EXPORT_SYMBOL(core_pwrup);
+
+int core_pwrdown(void)
+{
+	int core = 1;
+
+	//set core other access
+	write_cpc_cl_other(core << CPC_Cx_OTHER_CORENUM_SHF);
+
+	//set power down
+	write_cpc_co_cmd(CPC_Cx_CMD_PWRDOWN);
+
+	return 0;
+}
+EXPORT_SYMBOL(core_pwrdown);
+
+int set_ipi(unsigned int intr)
+{
+	writel(GIC_SH_WEDGE_SET(intr), (void*)GIC_ABS_REG(SHARED, GIC_SH_WEDGE));
+	return 0;
+}
+EXPORT_SYMBOL(set_ipi);
+
+#endif
+
+void __init plat_mem_setup(void)
+{
+	unsigned int i;
+
+#ifdef CONFIG_OF
+	extern void of_setup(void);
+	of_setup();
+#endif
+	if (config_enabled(CONFIG_EVA))
+		/* EVA has already been configured in mach-siflower/kernel-init.h */
+		pr_info("Enhanced Virtual Addressing (EVA) activated\n");
+
+	mips_pcibios_init();
+
+	/* Request I/O space for devices used on the sf16a18 board. */
+	for (i = 0; i < ARRAY_SIZE(standard_io_resources); i++)
+		request_resource(&ioport_resource, standard_io_resources+i);
+
+	/*
+	 * Enable DMA channel 4 (cascade channel) in the PIIX4 south bridge.
+	 */
+//	enable_dma(4);
+	plat_setup_iocoherency();
+
+	pci_clock_check();
+
+#ifdef CONFIG_BLK_DEV_FD
+	fd_activate();
+#endif
+
+#if defined(CONFIG_VT) && defined(CONFIG_VGA_CONSOLE)
+	screen_info_setup();
+#endif
+
+	board_be_init = sf16a18_be_init;
+	board_be_handler = sf16a18_be_handler;
+}
Index: linux-3.18.29/arch/mips/siflower/sf16a18-int.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/sf16a18-int.c	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,509 @@
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/hardirq.h>
+#include <linux/preempt.h>
+#include <linux/irqdomain.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <asm/mips-cm.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/traps.h>
+
+#include <asm/irq.h>
+#include <asm/setup.h>
+
+#include <asm/gic.h>
+
+#ifdef CONFIG_SOC_SF16A18
+#include <sf16a18int.h>
+#include <sf16a18.h>
+#endif
+
+static struct irq_chip *irq_gic;
+
+#ifdef CONFIG_MIPS_GIC_IPI
+static unsigned int ipi_map[NR_CPUS];
+DECLARE_BITMAP(ipi_ints, GIC_NUM_INTRS);
+#endif
+
+#define IPI_MAP_ENTRY 16
+#define X GIC_UNUSED
+#define HW_PIN(x) (x)
+#define GIC_CPU_NMI GIC_MAP_TO_NMI_MSK
+
+//static struct gic_intr_map gic_intr_map[GIC_NUM_INTRS];
+
+static struct gic_intr_map gic_intr_map[GIC_NUM_INTRS] = {
+	{ X, X,        X,       X,      0 },
+	{ X, X,        X,       X,      0 },
+	{ X, X,        X,       X,      0 },
+	{ X, X,        X,       X,      0 },
+	{ X, X,        X,       X,      0 },
+	{ X, X,        X,       X,      0 },
+	{ 0, GIC_CPU_NMI,  GIC_POL_POS, GIC_TRIG_LEVEL, GIC_FLAG_TRANSPARENT },
+	{ 0, GIC_CPU_NMI,  GIC_POL_POS, GIC_TRIG_LEVEL, GIC_FLAG_TRANSPARENT },
+
+	{ 0, HW_PIN(1), GIC_POL_POS, GIC_TRIG_EDGE, 0 },
+	{ 1, HW_PIN(1), GIC_POL_POS, GIC_TRIG_EDGE, 0 },
+	{ 2, HW_PIN(1), GIC_POL_POS, GIC_TRIG_EDGE, 0 },
+	{ 3, HW_PIN(1), GIC_POL_POS, GIC_TRIG_EDGE, 0 },
+
+	{ 0, HW_PIN(2), GIC_POL_POS, GIC_TRIG_EDGE, 0 },
+	{ 1, HW_PIN(2), GIC_POL_POS, GIC_TRIG_EDGE, 0 },
+	{ 2, HW_PIN(2), GIC_POL_POS, GIC_TRIG_EDGE, 0 },
+	{ 3, HW_PIN(2), GIC_POL_POS, GIC_TRIG_EDGE, 0 },
+
+};
+
+#undef X
+
+
+void sf16a18_be_init(void)
+{
+    /* Could change CM error mask register. */
+}
+
+
+static char *tr[8] = {
+    "mem",	"gcr",	"gic",	"mmio",
+    "0x04", "0x05", "0x06", "0x07"
+};
+
+static char *mcmd[32] = {
+    [0x00] = "0x00",
+    [0x01] = "Legacy Write",
+    [0x02] = "Legacy Read",
+    [0x03] = "0x03",
+    [0x04] = "0x04",
+    [0x05] = "0x05",
+    [0x06] = "0x06",
+    [0x07] = "0x07",
+    [0x08] = "Coherent Read Own",
+    [0x09] = "Coherent Read Share",
+    [0x0a] = "Coherent Read Discard",
+    [0x0b] = "Coherent Ready Share Always",
+    [0x0c] = "Coherent Upgrade",
+    [0x0d] = "Coherent Writeback",
+    [0x0e] = "0x0e",
+    [0x0f] = "0x0f",
+    [0x10] = "Coherent Copyback",
+    [0x11] = "Coherent Copyback Invalidate",
+    [0x12] = "Coherent Invalidate",
+    [0x13] = "Coherent Write Invalidate",
+    [0x14] = "Coherent Completion Sync",
+    [0x15] = "0x15",
+    [0x16] = "0x16",
+    [0x17] = "0x17",
+    [0x18] = "0x18",
+    [0x19] = "0x19",
+    [0x1a] = "0x1a",
+    [0x1b] = "0x1b",
+    [0x1c] = "0x1c",
+    [0x1d] = "0x1d",
+    [0x1e] = "0x1e",
+    [0x1f] = "0x1f"
+};
+
+static char *core[8] = {
+    "Invalid/OK",	"Invalid/Data",
+    "Shared/OK",	"Shared/Data",
+    "Modified/OK",	"Modified/Data",
+    "Exclusive/OK", "Exclusive/Data"
+};
+
+static char *causes[32] = {
+    "None", "GC_WR_ERR", "GC_RD_ERR", "COH_WR_ERR",
+    "COH_RD_ERR", "MMIO_WR_ERR", "MMIO_RD_ERR", "0x07",
+    "0x08", "0x09", "0x0a", "0x0b",
+    "0x0c", "0x0d", "0x0e", "0x0f",
+    "0x10", "0x11", "0x12", "0x13",
+    "0x14", "0x15", "0x16", "INTVN_WR_ERR",
+    "INTVN_RD_ERR", "0x19", "0x1a", "0x1b",
+    "0x1c", "0x1d", "0x1e", "0x1f"
+};
+
+int sf16a18_be_handler(struct pt_regs *regs, int is_fixup)
+{
+    /* This duplicates the handling in do_be which seems wrong */
+    int retval = is_fixup ? MIPS_BE_FIXUP : MIPS_BE_FATAL;
+
+    if (mips_cm_present()) {
+        unsigned long cm_error = read_gcr_error_cause();
+        unsigned long cm_addr = read_gcr_error_addr();
+        unsigned long cm_other = read_gcr_error_mult();
+        unsigned long cause, ocause;
+        char buf[256];
+
+        cause = cm_error & CM_GCR_ERROR_CAUSE_ERRTYPE_MSK;
+        if (cause != 0) {
+            cause >>= CM_GCR_ERROR_CAUSE_ERRTYPE_SHF;
+            if (cause < 16) {
+                unsigned long cca_bits = (cm_error >> 15) & 7;
+                unsigned long tr_bits = (cm_error >> 12) & 7;
+                unsigned long cmd_bits = (cm_error >> 7) & 0x1f;
+                unsigned long stag_bits = (cm_error >> 3) & 15;
+                unsigned long sport_bits = (cm_error >> 0) & 7;
+
+                snprintf(buf, sizeof(buf),
+                        "CCA=%lu TR=%s MCmd=%s STag=%lu "
+                        "SPort=%lu\n",
+                        cca_bits, tr[tr_bits], mcmd[cmd_bits],
+                        stag_bits, sport_bits);
+            } else {
+                /* glob state & sresp together */
+                unsigned long c3_bits = (cm_error >> 18) & 7;
+                unsigned long c2_bits = (cm_error >> 15) & 7;
+                unsigned long c1_bits = (cm_error >> 12) & 7;
+                unsigned long c0_bits = (cm_error >> 9) & 7;
+                unsigned long sc_bit = (cm_error >> 8) & 1;
+                unsigned long cmd_bits = (cm_error >> 3) & 0x1f;
+                unsigned long sport_bits = (cm_error >> 0) & 7;
+                snprintf(buf, sizeof(buf),
+                        "C3=%s C2=%s C1=%s C0=%s SC=%s "
+                        "MCmd=%s SPort=%lu\n",
+                        core[c3_bits], core[c2_bits],
+                        core[c1_bits], core[c0_bits],
+                        sc_bit ? "True" : "False",
+                        mcmd[cmd_bits], sport_bits);
+            }
+
+            ocause = (cm_other & CM_GCR_ERROR_MULT_ERR2ND_MSK) >>
+                CM_GCR_ERROR_MULT_ERR2ND_SHF;
+
+            pr_err("CM_ERROR=%08lx %s <%s>\n", cm_error,
+                    causes[cause], buf);
+            pr_err("CM_ADDR =%08lx\n", cm_addr);
+            pr_err("CM_OTHER=%08lx %s\n", cm_other, causes[ocause]);
+
+            /* reprime cause register */
+            write_gcr_error_cause(0);
+        }
+    }
+
+    return retval;
+}
+
+
+#if defined(CONFIG_MIPS_MT_SMP)
+static int gic_resched_int_base = 12;
+static int gic_call_int_base = 8;
+
+#define GIC_RESCHED_INT(cpu) (gic_resched_int_base+(cpu))
+#define GIC_CALL_INT(cpu) (gic_call_int_base+(cpu))
+
+static irqreturn_t ipi_resched_interrupt(int irq, void *dev_id)
+{
+#ifdef CONFIG_MIPS_VPE_APSP_API_CMP
+	if (aprp_hook)
+		aprp_hook();
+#endif
+
+	scheduler_ipi();
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ipi_call_interrupt(int irq, void *dev_id)
+{
+	smp_call_function_interrupt();
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction irq_resched = {
+        .handler        = ipi_resched_interrupt,
+        .flags          = IRQF_PERCPU,
+        .name           = "ipi resched"
+};
+
+static struct irqaction irq_call = {
+        .handler        = ipi_call_interrupt,
+        .flags          = IRQF_PERCPU,
+        .name           = "ipi call"
+};
+
+#endif
+
+#ifdef CONFIG_MIPS_GIC_IPI
+static void __init fill_ipi_map1(int baseintr, int cpu, int cpupin)
+{
+	int intr = baseintr + cpu;
+	ipi_map[cpu] |= (1 << (cpupin + 2));
+	bitmap_set(ipi_ints, intr, 1);
+}
+
+static void __init fill_ipi_map(void)
+{
+	int cpu;
+
+	for (cpu = 0; cpu < nr_cpu_ids; cpu++) {
+		fill_ipi_map1(gic_resched_int_base, cpu, GIC_CPU_INT1);
+		fill_ipi_map1(gic_call_int_base, cpu, GIC_CPU_INT2);
+	}
+}
+#endif
+
+static void __init gic_fill_map(void)
+{
+	int i;
+#ifdef CONFIG_MIPS_MT_SMP
+	int normal_start = GIC_RESCHED_INT(nr_cpu_ids);
+#else
+	int normal_start = nr_cpu_ids;
+#endif
+	for (i = normal_start; i < ARRAY_SIZE(gic_intr_map); i++) {
+		gic_intr_map[i].cpunum = 0;
+		gic_intr_map[i].pin = GIC_CPU_INT0;
+		gic_intr_map[i].polarity = GIC_POL_POS;
+		gic_intr_map[i].trigtype = GIC_TRIG_LEVEL;
+		gic_intr_map[i].flags = 0;
+	}
+#if defined(CONFIG_MIPS_GIC_IPI)
+	fill_ipi_map();
+#endif		
+}
+
+void
+gic_irq_ack(struct irq_data *d)
+{
+	int irq = (d->irq - gic_irq_base);
+
+	GIC_CLR_INTR_MASK(irq);
+
+	if (gic_irq_flags[irq] & GIC_TRIG_EDGE)
+		GICWRITE(GIC_REG(SHARED, GIC_SH_WEDGE), irq);
+}
+
+void
+gic_finish_irq(struct irq_data *d)
+{
+	GIC_SET_INTR_MASK(d->irq - gic_irq_base);
+}
+
+int siflower_irq_set_type(struct irq_data *data, unsigned int flow_type)
+{
+	unsigned int irq_nr = data->irq - MIPS_GIC_IRQ_BASE;
+	int trigger = GIC_TRIG_LEVEL;
+	int polarity = GIC_POL_POS;
+	if (flow_type & IRQF_TRIGGER_PROBE)
+		return 0;
+	if(irq_nr > 0 && irq_nr < GIC_NUM_INTRS){
+		switch (flow_type & IRQF_TRIGGER_MASK){
+			case IRQF_TRIGGER_RISING:
+				{
+					trigger = GIC_TRIG_EDGE;
+					polarity = GIC_POL_POS;
+					break;
+				}
+			case IRQF_TRIGGER_FALLING:
+				{
+					trigger = GIC_TRIG_EDGE;
+					polarity = GIC_POL_NEG;
+					break;
+				}
+			case IRQF_TRIGGER_HIGH:
+				{
+					trigger = GIC_TRIG_LEVEL;
+					polarity = GIC_POL_POS;
+					break;
+				}
+			case IRQF_TRIGGER_LOW:
+				{
+					trigger = GIC_TRIG_LEVEL;
+					polarity = GIC_POL_NEG;
+					break;
+				}
+			default:
+				return -EINVAL;
+		}
+		GIC_SET_POLARITY(irq_nr, polarity);
+		GIC_SET_TRIGGER(irq_nr, trigger);
+		return 0;
+	}else{
+		return -EINVAL;
+	}
+}
+
+void __init gic_platform_init(int irqs, struct irq_chip *irq_controller)
+{
+	irq_gic = irq_controller;
+	//set irq_set_type func
+	irq_controller->irq_set_type = siflower_irq_set_type;
+}
+
+static int sf_gic_get_int(void)
+{
+	DECLARE_BITMAP(interrupts, GIC_NUM_INTRS);
+
+	bitmap_fill(interrupts, GIC_NUM_INTRS);
+	gic_get_int_mask(interrupts, interrupts);
+
+#ifdef CONFIG_CORE1_MEM_RES
+	//irq 48
+	if(interrupts[1] & 0x10000)
+		interrupts[1] = interrupts[1] & (~0x10000);
+	//irq 64
+	if(interrupts[2] & 0x1)
+		interrupts[2] = interrupts[2] & (~0x1);
+#endif
+
+	return find_first_bit(interrupts, GIC_NUM_INTRS);
+}
+static void gic_irqdispatch(void)
+{
+	unsigned int irq = sf_gic_get_int();
+
+	if (likely(irq < GIC_NUM_INTRS))
+		do_IRQ(MIPS_GIC_IRQ_BASE + irq);
+	else {
+		pr_debug("Spurious GIC Interrupt!\n");
+		spurious_interrupt();
+	}
+
+}
+
+#if defined(CONFIG_MIPS_MT_SMP)
+unsigned int
+plat_ipi_call_int_xlate(unsigned int cpu)
+{
+	return GIC_CALL_INT(cpu);
+}
+
+unsigned int
+plat_ipi_resched_int_xlate(unsigned int cpu)
+{
+	return GIC_RESCHED_INT(cpu);
+}
+#endif
+
+static void sf16a18_ipi_irqdispatch(void)
+{
+#ifdef CONFIG_MIPS_GIC_IPI
+	unsigned long irq;
+	DECLARE_BITMAP(pending, GIC_NUM_INTRS);
+
+	gic_get_int_mask(pending, ipi_ints);
+
+	irq = find_first_bit(pending, GIC_NUM_INTRS);
+
+	while (irq < GIC_NUM_INTRS) {
+		do_IRQ(MIPS_GIC_IRQ_BASE + irq);
+
+		irq = find_next_bit(pending, GIC_NUM_INTRS, irq + 1);
+	}
+#endif
+	if (gic_compare_int())
+		do_IRQ(MIPS_GIC_IRQ_BASE);
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int pending = read_c0_status() & read_c0_cause() & ST0_IM;
+
+	if (unlikely(!pending)) {
+		pr_err("Spurious CP0 Interrupt!\n");
+		spurious_interrupt();
+	} else {
+		if (pending & CAUSEF_IP7) {
+			do_IRQ(cp0_compare_irq);
+		} else {
+			if (pending & (CAUSEF_IP4 | CAUSEF_IP3)) {
+				sf16a18_ipi_irqdispatch(); //IPI
+			} else {
+				if(pending & CAUSEF_IP2) {
+					gic_irqdispatch();
+				}
+				else {
+					if(pending & (CAUSEF_IP5 | CAUSEF_IP6))
+						printk("Warning! Unexpected interrupt!\n");
+					else
+						do_IRQ((pending>>8)+MIPS_GIC_IRQ_BASE);
+				}
+			}
+		}
+	}
+}
+
+static int gic_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)
+{
+	irq_set_chip_and_handler(irq, irq_gic,
+#if defined(CONFIG_MIPS_MT_SMP)
+		(hw < GIC_RESCHED_INT(nr_cpu_ids)) ?
+			handle_percpu_irq :
+#endif
+			handle_level_irq);
+
+	return 0;
+}
+
+static const struct irq_domain_ops irq_domain_ops = {
+	.xlate = irq_domain_xlate_onecell,
+	.map = gic_map,
+};
+
+static int __init of_gic_init(struct device_node *node,
+				struct device_node *parent)
+{
+	struct irq_domain *domain;
+	struct resource gic = { 0 };
+	unsigned int gic_rev;
+
+#if defined(CONFIG_MIPS_MT_SMP)
+	int i;
+#endif
+
+	if (of_address_to_resource(node, 0, &gic))
+		panic("Failed to get gic memory range");
+
+	if (request_mem_region(gic.start, resource_size(&gic),
+				gic.name) < 0)
+		panic("Failed to request gic memory");
+
+	gic_fill_map();
+
+	if (mips_cm_present()) {
+		write_gcr_gic_base(GIC_BASE_ADDR | CM_GCR_GIC_BASE_GICEN_MSK);
+		gic_present = 1;
+	}
+
+	if(gic_present){
+		gic_init(gic.start, resource_size(&gic), gic_intr_map,
+				ARRAY_SIZE(gic_intr_map), MIPS_GIC_IRQ_BASE);
+
+		GICREAD(GIC_REG(SHARED, GIC_SH_REVISIONID), gic_rev);
+		pr_info("gic: revision %d.%d\n", (gic_rev >> 8) & 0xff, gic_rev & 0xff);
+
+		domain = irq_domain_add_legacy(node, GIC_NUM_INTRS, MIPS_GIC_IRQ_BASE,
+				0, &irq_domain_ops, NULL);
+		if (!domain)
+			panic("Failed to add irqdomain");
+
+#if defined(CONFIG_MIPS_MT_SMP)
+		for (i = 0; i < nr_cpu_ids; i++) {
+			setup_irq(MIPS_GIC_IRQ_BASE + GIC_RESCHED_INT(i), &irq_resched);
+			setup_irq(MIPS_GIC_IRQ_BASE + GIC_CALL_INT(i), &irq_call);
+		}
+#endif
+		change_c0_status(ST0_IM, STATUSF_IP7 | STATUSF_IP4 | STATUSF_IP3 |
+				STATUSF_IP2);
+	}
+	return 0;
+}
+
+static struct of_device_id __initdata of_irq_ids[] = {
+	{ .compatible = "mti,cpu-interrupt-controller", .data = mips_cpu_intc_init },
+	{ .compatible = "siflower,sfax8-gic", .data = of_gic_init },
+	{},
+};
+
+void __init
+arch_init_irq(void)
+{
+	of_irq_init(of_irq_ids);
+}
Index: linux-3.18.29/arch/mips/siflower/sf16a18-memory.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/sf16a18-memory.c	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,264 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * PROM library functions for acquiring/using memory descriptors given to
+ * us from the YAMON.
+ *
+ * Copyright (C) 1999,2000,2012  MIPS Technologies, Inc.
+ * All rights reserved.
+ * Authors: Carsten Langgaard <carstenl@mips.com>
+ *          Steven J. Hill <sjhill@mips.com>
+ */
+#include <linux/init.h>
+#include <linux/bootmem.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/maar.h>
+#include <asm/sections.h>
+#include <asm/fw/fw.h>
+
+static fw_memblock_t mdesc[FW_MAX_MEMBLOCKS];
+
+static char __initdata DEFAULT_BOOT_ARG[COMMAND_LINE_SIZE] = "mem=256M";
+
+/* determined physical memory size, not overridden by command line args	 */
+unsigned long physical_memsize = 0L;
+
+#ifdef CONFIG_CORE1_MEM_RES
+unsigned long sf_mem_size;
+EXPORT_SYMBOL(sf_mem_size);
+static int ultostr(unsigned long val, int *n, char *p)
+{
+	int i;
+
+	for(i = 0; i < 8; i++) {
+		if(val != 0) {
+			p[7 - i] = val%10 + 48;
+			val = val/10;
+		} else {
+			break;
+		}
+	}
+	*n = i;
+
+	strncpy(p, p + 8 - *n, *n);
+	return 0;
+}
+static int reset_memsize(char *cmdline, int val)
+{
+	char *ptr, p[8] = {0};
+	unsigned long memsize = 0;
+	unsigned long oldmemsize = 0;
+	int n,len,n1;
+	static char tmpline[COMMAND_LINE_SIZE] __initdata;
+
+	ptr = strstr(cmdline, "mem=");
+	if (ptr && (ptr != cmdline) && (*(ptr - 1) != ' ')) {
+		ptr = strstr(ptr, " mem=");
+		ptr += 1;
+	}
+	if(ptr)
+		memsize = memparse(ptr + 4, NULL);
+
+	memsize >>= 20;
+	oldmemsize = memsize;
+	memsize -= val;
+	sf_mem_size = memsize << 20;
+
+	ultostr(memsize, &n, p);
+	//replace mem size
+	strcpy(tmpline, cmdline);
+	memset(cmdline,0,strlen(cmdline));
+	len = (ptr + 4) - cmdline;
+	memcpy(cmdline,tmpline,len);
+	strncpy(cmdline + len, p, n);
+	ultostr(oldmemsize, &n1, p);
+	strncpy(cmdline + len + n, tmpline + len + n1, strlen(tmpline) - (len + n1));
+
+	return 0;
+}
+#endif
+
+fw_memblock_t * __init fw_getmdesc(int eva)
+{
+	char *memsize_str, *ememsize_str = NULL, *ptr;
+	unsigned long memsize = 0, ememsize = 0;
+	static char cmdline[COMMAND_LINE_SIZE] __initdata;
+	int tmp;
+
+	/* otherwise look in the environment */
+
+	memsize_str = fw_getenv("memsize");
+	if (memsize_str) {
+		tmp = kstrtoul(memsize_str, 0, &memsize);
+		if (tmp)
+			pr_warn("Failed to read the 'memsize' env variable.\n");
+	}
+	if (eva) {
+	/* Look for ememsize for EVA */
+		ememsize_str = fw_getenv("ememsize");
+		if (ememsize_str) {
+			tmp = kstrtoul(ememsize_str, 0, &ememsize);
+			if (tmp)
+				pr_warn("Failed to read the 'ememsize' env variable.\n");
+		}
+	}
+	if (!memsize && !ememsize) {
+		pr_warn("memsize not set in YAMON, set to default (256MB)\n");
+		physical_memsize = 0x10000000;
+	} else {
+		if (memsize > (256 << 20)) { /* memsize should be capped to 256M */
+			pr_warn("Unsupported memsize value (0x%lx) detected! "
+				"Using 0x10000000 (256M) instead\n",
+				memsize);
+			memsize = 256 << 20;
+		}
+		/* If ememsize is set, then set physical_memsize to that */
+		physical_memsize = ememsize ? : memsize;
+	}
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+	/* SOC-it swaps, or perhaps doesn't swap, when DMA'ing the last
+	   word of physical memory */
+	physical_memsize -= PAGE_SIZE;
+#endif
+
+#ifdef CONFIG_CORE1_MEM_RES
+	//set boot arg to default value for fpga env build
+	if(!arcs_cmdline[0])
+		strlcpy(arcs_cmdline, DEFAULT_BOOT_ARG, COMMAND_LINE_SIZE);
+	/* Modified by nevermore. Reserve some memeory for core1 firmware. */
+	reset_memsize(arcs_cmdline, CONFIG_FIRMWARE_SIZE);
+#endif
+
+	/* Check the command line for a memsize directive that overrides
+	   the physical/default amount */
+	strcpy(cmdline, arcs_cmdline);
+	ptr = strstr(cmdline, "memsize=");
+	if (ptr && (ptr != cmdline) && (*(ptr - 1) != ' '))
+		ptr = strstr(ptr, " memsize=");
+	/* And now look for ememsize */
+	if (eva) {
+		ptr = strstr(cmdline, "ememsize=");
+		if (ptr && (ptr != cmdline) && (*(ptr - 1) != ' '))
+			ptr = strstr(ptr, " ememsize=");
+	}
+
+	if (ptr)
+		memsize = memparse(ptr + 8 + (eva ? 1 : 0), &ptr);
+	else
+		memsize = physical_memsize;
+
+	/* Last 64K for HIGHMEM arithmetics */
+	if (memsize > 0x7fff0000)
+		memsize = 0x7fff0000;
+
+	memset(mdesc, 0, sizeof(mdesc));
+
+	mdesc[0].type = fw_dontuse;
+	mdesc[0].base = PHYS_OFFSET;
+	mdesc[0].size = 0x00001000;
+
+	mdesc[1].type = fw_code;
+	mdesc[1].base = mdesc[0].base + 0x00001000UL;
+	mdesc[1].size = 0x000ef000;
+
+	/*
+	 * The area 0x000f0000-0x000fffff is allocated for BIOS memory by the
+	 * south bridge and PCI access always forwarded to the ISA Bus and
+	 * BIOSCS# is always generated.
+	 * This mean that this area can't be used as DMA memory for PCI
+	 * devices.
+	 */
+	mdesc[2].type = fw_dontuse;
+	mdesc[2].base = mdesc[0].base + 0x000f0000UL;
+	mdesc[2].size = 0x00010000;
+
+	mdesc[3].type = fw_free;
+	mdesc[3].base = mdesc[0].base + 0x00100000UL;
+	mdesc[3].size = memsize - CPHYSADDR(mdesc[3].base);
+
+	return &mdesc[0];
+}
+
+static void free_init_pages_eva_sf16a18(void *begin, void *end)
+{
+	free_init_pages("unused kernel", __pa_symbol((unsigned long *)begin),
+			__pa_symbol((unsigned long *)end));
+}
+
+static int __init fw_memtype_classify(unsigned int type)
+{
+	switch (type) {
+	case fw_free:
+		return BOOT_MEM_RAM;
+	case fw_code:
+		return BOOT_MEM_ROM_DATA;
+	default:
+		return BOOT_MEM_RESERVED;
+	}
+}
+
+void __init fw_meminit(void)
+{
+	fw_memblock_t *p;
+
+	p = fw_getmdesc(config_enabled(CONFIG_EVA));
+	free_init_pages_eva = (config_enabled(CONFIG_EVA) ?
+			       free_init_pages_eva_sf16a18 : NULL);
+
+	while (p->size) {
+		long type;
+		unsigned long base, size;
+
+		type = fw_memtype_classify(p->type);
+		base = p->base;
+		size = p->size;
+
+		add_memory_region(base, size, type);
+		p++;
+	}
+}
+
+void __init prom_free_prom_memory(void)
+{
+	unsigned long addr;
+	int i;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		if (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)
+			continue;
+
+		addr = boot_mem_map.map[i].addr;
+		free_init_pages("YAMON memory",
+				addr, addr + boot_mem_map.map[i].size);
+	}
+}
+
+unsigned platform_maar_init(unsigned num_pairs)
+{
+	phys_addr_t mem_end = (physical_memsize & ~0xffffull) - 1;
+	struct maar_config cfg[] = {
+		/* DRAM preceding I/O */
+		{ 0x00000000, 0x0fffffff, MIPS_MAAR_S },
+
+		/* DRAM following I/O */
+		{ 0x20000000, mem_end, MIPS_MAAR_S },
+
+		/* DRAM alias in upper half of physical */
+		{ 0x80000000, 0x80000000 + mem_end, MIPS_MAAR_S },
+	};
+	unsigned i, num_cfg = ARRAY_SIZE(cfg);
+
+	/* If DRAM fits before I/O, drop the region following it */
+	if (physical_memsize <= 0x10000000) {
+		num_cfg--;
+		for (i = 1; i < num_cfg; i++)
+			cfg[i] = cfg[i + 1];
+	}
+
+	return maar_config(cfg, num_cfg, num_pairs);
+}
Index: linux-3.18.29/arch/mips/siflower/sf16a28-clk.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/sf16a28-clk.c	2017-11-21 20:13:12.458710527 +0800
@@ -0,0 +1,773 @@
+/*
+ * SF16A18 clocks.
+ *
+ * Exposes all configurable internal clock sources to the clk framework.
+ *
+ * We have:
+ *  - Root source, usually 12MHz supplied by an external crystal
+ *  - 4 PLLs which generate multiples of root rate [CPU, DDR, CMN, SPC]
+ *
+ * Dividers:
+ *  - 22 clock dividers with:
+ *   * selectable source [one of the PLLs],
+ *   * output divided between [1 .. 256]
+ *   * can be enabled individually.
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/clk-private.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+
+static DEFINE_SPINLOCK(cm_cfg_lock);
+
+#if 0
+typedef enum cm_pll_t{
+	CPU_PLL,
+	DDR_PLL,
+	CMN_PLL,
+	SPC_PLL,
+}sf16a28_pll;
+#endif
+
+typedef enum cm_cfg_t{
+	BUS1_CFG,
+	BUS2_CFG,
+	BUS3_CFG,
+	CPU_CFG,
+	PBUS_CFG,
+	MEMPHY_CFG,
+	AUDIO_CFG,
+	UART_CFG,
+	SPDIF_CFG,
+	SDIO_CFG,
+	EMMC_CFG,
+	ETH_REF_CFG,
+	ETH_BYP_REF_CFG,
+	ETH_TSU_CFG,
+	WLAN24_CFG,
+	WLAN5_CFG,
+	USBPHY_CFG,
+	TCLK_CFG,
+	NPU_PE_CFG,
+	GDU0_CFG,
+	GDU0_EITF_CFG,
+	TVIF0_CFG
+}sf16a28_cfg;
+
+#if 0
+/*
+ *	CM_PLL_CLK init.
+ */
+static struct of_device_id sfa18_cpu_pll_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-cpupll-clk",
+	},
+	{}
+};
+static struct of_device_id sfa18_ddr_pll_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-ddrpll-clk",
+	},
+	{}
+};
+static struct of_device_id sfa18_cmn_pll_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-cmnpll-clk",
+	},
+	{}
+};
+static struct of_device_id sfa18_spc_pll_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-spcpll-clk",
+	},
+	{}
+};
+
+static void sf16a28_pll_setup(struct device_node *np,int pll_type)
+{
+	const struct of_device_id *match;
+	struct clk *clk;
+	const char *parent_name;
+	const char *clk_name;
+
+	if(!np)
+	{
+		pr_err("%s +%d %s: Device node not available for pll %d.\n",__FILE__,__LINE__,__func__,pll_type);
+		return;
+	}
+
+	switch(pll_type){
+		case CPU_PLL:
+			match = of_match_node(sfa18_cpu_pll_of_match, np);
+			break;
+		case DDR_PLL:
+			match = of_match_node(sfa18_ddr_pll_of_match, np);
+			break;
+		case CMN_PLL:
+			match = of_match_node(sfa18_cmn_pll_of_match, np);
+			break;
+		case SPC_PLL:
+			match = of_match_node(sfa18_spc_pll_of_match, np);
+			break;
+		default:
+			pr_err("%s +%d %s: No such pll_type: %d.\n",__FILE__,__LINE__,__func__,pll_type);
+			return;
+	}
+
+	if (!match) {
+		pr_err("%s +%d %s: No matching data.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	if (of_property_read_string(np, "clock-output-names", &clk_name))
+	{
+		pr_err("%s +%d %s: No matching name.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+	if (*clk_name == '\0')
+	{
+		pr_err("%s +%d %s: Clock name is empty.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	parent_name = of_clk_get_parent_name(np,0);
+
+	if(!parent_name)
+	{
+		pr_err("%s +%d %s: Can't get parent name.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	switch(pll_type){
+		case CPU_PLL:
+			clk = clk_register_fixed_factor(NULL, clk_name,parent_name, CLK_IGNORE_UNUSED, 56, 1);
+			break;
+		case DDR_PLL:
+			clk = clk_register_fixed_factor(NULL, clk_name,parent_name, CLK_IGNORE_UNUSED, 133, 1);
+			break;
+		case CMN_PLL:
+			clk = clk_register_fixed_factor(NULL, clk_name,parent_name, 0, 99, 1);
+			break;
+		case SPC_PLL:
+			clk = clk_register_fixed_factor(NULL, clk_name,parent_name, 0, 125, 1);
+			break;
+		default:
+			pr_err("%s +%d %s: No such pll_type: %d.\n",__FILE__,__LINE__,__func__,pll_type);
+			return;
+	}
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(np, of_clk_src_simple_get, clk);
+	else
+		pr_err("%s +%d %s: Clk register failed for %s.\n",__FILE__,__LINE__,__func__,clk_name);
+
+	//	printk("%s +%d %s: SF16A18 %s CLOCK INIT DONE!\n",__FILE__,__LINE__,__func__,clk_name);
+	return;
+}
+
+static void __init sf16a28_cpu_pll_setup(struct device_node *np)
+{
+	sf16a28_pll_setup(np,CPU_PLL);
+	return;
+}
+
+static void __init sf16a28_ddr_pll_setup(struct device_node *np)
+{
+	sf16a28_pll_setup(np,DDR_PLL);
+	return;
+}
+
+static void __init sf16a28_cmn_pll_setup(struct device_node *np)
+{
+	sf16a28_pll_setup(np,CMN_PLL);
+	return;
+}
+
+static void __init sf16a28_spc_pll_setup(struct device_node *np)
+{
+	sf16a28_pll_setup(np,SPC_PLL);
+	return;
+}
+CLK_OF_DECLARE(sf16a28_cpu_pll,"siflower,sf16a28-cpupll-clk",sf16a28_cpu_pll_setup);
+CLK_OF_DECLARE(sf16a28_ddr_pll,"siflower,sf16a28-ddrpll-clk",sf16a28_ddr_pll_setup);
+CLK_OF_DECLARE(sf16a28_cmn_pll,"siflower,sf16a28-cmnpll-clk",sf16a28_cmn_pll_setup);
+CLK_OF_DECLARE(sf16a28_spc_pll,"siflower,sf16a28-spcpll-clk",sf16a28_spc_pll_setup);
+#endif
+
+
+/*
+ *	CM_CFG_CLK init.
+ */
+static const char ** __init clk_mux_get_parents(struct device_node *np,
+		int *num_parents)
+{
+	const char **parents;
+	int nparents, i;
+
+	nparents = of_count_phandle_with_args(np, "clocks", "#clock-cells");
+	if (WARN_ON(nparents <= 0))
+		return ERR_PTR(-EINVAL);
+
+	parents = kzalloc(nparents * sizeof(const char *), GFP_KERNEL);
+	if (!parents)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < nparents; i++)
+		parents[i] = of_clk_get_parent_name(np, i);
+
+	*num_parents = nparents;
+	return parents;
+}
+typedef struct sf_clk_data {
+	spinlock_t *lock;
+	unsigned long clk_flags;
+}sf_clk_data_t;
+
+static sf_clk_data_t sf16a28_clk_data = {
+	.lock = &cm_cfg_lock,
+	.clk_flags = CLK_SET_PARENT_GATE,
+};
+
+static struct of_device_id sfa18_bus1_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-bus1-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_bus2_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-bus2-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_bus3_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-bus3-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_cpu_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-cpu-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_pbus_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-pbus-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_memphy_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-memphy-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_audio_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-audio-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_uart_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-uart-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_spdif_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-spdif-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_sdio_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-sdhc-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_emmc_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-emmc-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_eth_ref_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-eth-ref-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_eth_byp_ref_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-eth-byp-ref-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_eth_tsu_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-eth-tsu-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_wlan24_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-wlan24-mac-wt-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_wlan5_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-wlan5-mac-wt-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_usbphy_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-usbphy-ref-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_tclk_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-tclk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_npupe_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-npupe-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_gdu0_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-gdu0-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_gdu0_eitf_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-gdu0-eitf-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_tvif0_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a28-tvif0-clk",
+		.data = &sf16a28_clk_data,
+	},
+	{}
+};
+
+static void sf16a28_cfg_setup(struct device_node *np,int cfg_type)
+{
+	int num_parents;
+	const struct of_device_id *match;
+	struct clk *clk;
+	const char **parents;
+	struct clk_gate *gate;
+	struct clk_divider *div;
+	struct clk_mux *mux;
+	void __iomem *reg = NULL;
+	const char *clk_name;
+	struct clk_onecell_data *clk_data;
+	sf_clk_data_t *data;
+
+	if(!np)
+	{
+		pr_err("%s +%d %s: Device node not available for pll %d.\n",__FILE__,__LINE__,__func__,cfg_type);
+		return;
+	}
+
+	switch(cfg_type){
+		case BUS1_CFG:
+			match = of_match_node(sfa18_bus1_cfg_of_match, np);
+			break;
+		case BUS2_CFG:
+			match = of_match_node(sfa18_bus2_cfg_of_match, np);
+			break;
+		case BUS3_CFG:
+			match = of_match_node(sfa18_bus3_cfg_of_match, np);
+			break;
+		case CPU_CFG:
+			match = of_match_node(sfa18_cpu_cfg_of_match, np);
+			break;
+		case PBUS_CFG:
+			match = of_match_node(sfa18_pbus_cfg_of_match, np);
+			break;
+		case MEMPHY_CFG:
+			match = of_match_node(sfa18_memphy_cfg_of_match, np);
+			break;
+		case AUDIO_CFG:
+			match = of_match_node(sfa18_audio_cfg_of_match, np);
+			break;
+		case UART_CFG:
+			match = of_match_node(sfa18_uart_cfg_of_match, np);
+			break;
+		case SPDIF_CFG:
+			match = of_match_node(sfa18_spdif_cfg_of_match, np);
+			break;
+		case SDIO_CFG:
+			match = of_match_node(sfa18_sdio_cfg_of_match, np);
+			break;
+		case EMMC_CFG:
+			match = of_match_node(sfa18_emmc_cfg_of_match, np);
+			break;
+		case ETH_REF_CFG:
+			match = of_match_node(sfa18_eth_ref_cfg_of_match, np);
+			break;
+		case ETH_BYP_REF_CFG:
+			match = of_match_node(sfa18_eth_byp_ref_cfg_of_match, np);
+			break;
+		case ETH_TSU_CFG:
+			match = of_match_node(sfa18_eth_tsu_cfg_of_match, np);
+			break;
+		case WLAN24_CFG:
+			match = of_match_node(sfa18_wlan24_cfg_of_match, np);
+			break;
+		case WLAN5_CFG:
+			match = of_match_node(sfa18_wlan5_cfg_of_match, np);
+			break;
+		case USBPHY_CFG:
+			match = of_match_node(sfa18_usbphy_cfg_of_match, np);
+			break;
+		case TCLK_CFG:
+			match = of_match_node(sfa18_tclk_cfg_of_match, np);
+			break;
+		case NPU_PE_CFG:
+			match = of_match_node(sfa18_npupe_cfg_of_match, np);
+			break;
+		case GDU0_CFG:
+			match = of_match_node(sfa18_gdu0_cfg_of_match, np);
+			break;
+		case GDU0_EITF_CFG:
+			match = of_match_node(sfa18_gdu0_eitf_cfg_of_match, np);
+			break;
+		case TVIF0_CFG:
+			match = of_match_node(sfa18_tvif0_cfg_of_match, np);
+			break;
+		default:
+			pr_err("%s +%d %s: No such cfg_type: %d.\n",__FILE__,__LINE__,__func__,cfg_type);
+			return;
+	}
+
+	if (!match) {
+		pr_err("%s +%d %s: No matching data.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	data = (sf_clk_data_t *)match->data;
+
+	reg = of_iomap(np, 0);
+	if (!reg)
+	{
+		pr_err("%s +%d %s: Can't get clk base address.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	if (of_property_read_string(np, "clock-output-names", &clk_name))
+	{
+		pr_err("%s +%d %s: No matching name.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+	if (*clk_name == '\0')
+	{
+		pr_err("%s +%d %s: Clock name is empty.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	parents = clk_mux_get_parents(np, &num_parents);
+
+	if(!parents)
+	{
+		pr_err("%s +%d %s: Can't get parent names.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	clk_data = kzalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+	if (!clk_data)
+	{
+		pr_err("%s +%d %s: Can not alloc clk data.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	clk_data->clk_num = 1;
+	clk_data->clks = kzalloc(clk_data->clk_num * sizeof(struct clk *),
+			GFP_KERNEL);
+
+	if (!clk_data->clks)
+	{
+		pr_err("%s +%d %s: Can not alloc clk.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+
+	gate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);
+	if (!gate) {
+		pr_err("%s +%d %s: Out of memory for gate clk.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	div = kzalloc(sizeof(struct clk_divider), GFP_KERNEL);
+	if (!div) {
+		pr_err("%s +%d %s: Out of memory for div clk.\n",__FILE__,__LINE__,__func__);
+		kfree(gate);
+		return;
+	}
+
+	mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
+	if (!mux)
+	{
+		pr_err("%s +%d %s: Out of memory for mux clk.\n",__FILE__,__LINE__,__func__);
+		kfree(gate);
+		kfree(div);
+		return;
+	}
+
+	gate->reg = reg + 0xc;
+	gate->bit_idx = 0;
+	gate->flags = 0;
+	gate->lock = data->lock;
+
+	div->reg = reg + 0x4;
+	div->shift = 0;
+	div->width = 8;
+	div->lock = data->lock;
+	div->flags = CLK_DIVIDER_ROUND_CLOSEST | CLK_DIVIDER_ALLOW_ZERO;
+
+	mux->reg = reg;
+	mux->shift = 0;
+	mux->mask = 0x7;
+	mux->lock = data->lock;
+	mux->flags = 0;
+
+	switch(cfg_type){
+		case BUS1_CFG:
+		case BUS2_CFG:
+		case BUS3_CFG:
+		case CPU_CFG:
+		case PBUS_CFG:
+		case MEMPHY_CFG:
+		case AUDIO_CFG:
+		case USBPHY_CFG:
+		case WLAN24_CFG:
+		case WLAN5_CFG:
+			clk = clk_register_composite(NULL,clk_name,parents,num_parents,
+					&mux->hw,&clk_mux_ops,
+					&div->hw,&clk_divider_ops,
+					&gate->hw,&clk_gate_ops,
+					data->clk_flags | CLK_IGNORE_UNUSED);
+			break;
+		case UART_CFG:
+		case SPDIF_CFG:
+		case SDIO_CFG:
+		case EMMC_CFG:
+		case ETH_REF_CFG:
+		case ETH_BYP_REF_CFG:
+		case ETH_TSU_CFG:
+			//case WLAN24_CFG:
+			//case WLAN5_CFG:
+		case TCLK_CFG:
+		case NPU_PE_CFG:
+		case GDU0_CFG:
+		case GDU0_EITF_CFG:
+		case TVIF0_CFG:
+			clk = clk_register_composite(NULL,clk_name,parents,num_parents,
+					&mux->hw,&clk_mux_ops,
+					&div->hw,&clk_divider_ops,
+					&gate->hw,&clk_gate_ops,
+					data->clk_flags);
+			break;
+		default:
+			pr_err("%s +%d %s: No such cfg_type: %d.\n",__FILE__,__LINE__,__func__,cfg_type);
+			return;
+	}
+
+	if (!IS_ERR(clk))
+	{
+		clk_data->clks[0] = clk;
+		kfree(parents);
+		of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+		//		printk("%s +%d %s: SF16A18 %s CLOCK INIT DONE!\n",__FILE__,__LINE__,__func__,clk_name);
+	}
+	else
+	{
+		pr_err("%s +%d %s: Clk register failed for %s.\n",__FILE__,__LINE__,__func__,clk_name);
+		kfree(gate);
+		kfree(div);
+		kfree(mux);
+		if (clk_data)
+			kfree(clk_data->clks);
+		kfree(clk_data);
+		kfree(parents);
+	}
+
+	return;
+}
+
+static void __init sf16a28_bus1_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,BUS1_CFG);
+	return;
+}
+static void __init sf16a28_bus2_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,BUS2_CFG);
+	return;
+}
+static void __init sf16a28_bus3_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,BUS3_CFG);
+	return;
+}
+static void __init sf16a28_cpu_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,CPU_CFG);
+	return;
+}
+static void __init sf16a28_pbus_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,PBUS_CFG);
+	return;
+}
+static void __init sf16a28_memphy_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,MEMPHY_CFG);
+	return;
+}
+static void __init sf16a28_audio_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,AUDIO_CFG);
+	return;
+}
+static void __init sf16a28_uart_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,UART_CFG);
+	return;
+}
+static void __init sf16a28_spdif_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,SPDIF_CFG);
+	return;
+}
+static void __init sf16a28_sdio_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,SDIO_CFG);
+	return;
+}
+static void __init sf16a28_emmc_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,EMMC_CFG);
+	return;
+}
+static void __init sf16a28_eth_ref_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,ETH_REF_CFG);
+	return;
+}
+static void __init sf16a28_eth_byp_ref_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,ETH_BYP_REF_CFG);
+	return;
+}
+static void __init sf16a28_eth_tsu_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,ETH_TSU_CFG);
+	return;
+}
+static void __init sf16a28_wlan24_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,WLAN24_CFG);
+	return;
+}
+static void __init sf16a28_wlan5_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,WLAN5_CFG);
+	return;
+}
+static void __init sf16a28_usbphy_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,USBPHY_CFG);
+	return;
+}
+static void __init sf16a28_tclk_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,TCLK_CFG);
+	return;
+}
+static void __init sf16a28_npu_pe_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,NPU_PE_CFG);
+	return;
+}
+static void __init sf16a28_gdu0_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,GDU0_CFG);
+	return;
+}
+static void __init sf16a28_gdu0_eitf_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,GDU0_EITF_CFG);
+	return;
+}
+static void __init sf16a28_tvif0_cfg_setup(struct device_node *np)
+{
+	sf16a28_cfg_setup(np,TVIF0_CFG);
+	return;
+}
+CLK_OF_DECLARE(sf16a28_bus1_cfg,"siflower,sf16a28-bus1-clk",sf16a28_bus1_cfg_setup);
+CLK_OF_DECLARE(sf16a28_bus2_cfg,"siflower,sf16a28-bus2-clk",sf16a28_bus2_cfg_setup);
+CLK_OF_DECLARE(sf16a28_bus3_cfg,"siflower,sf16a28-bus3-clk",sf16a28_bus3_cfg_setup);
+CLK_OF_DECLARE(sf16a28_cpu_cfg,"siflower,sf16a28-cpu-clk",sf16a28_cpu_cfg_setup);
+CLK_OF_DECLARE(sf16a28_pbus_cfg,"siflower,sf16a28-pbus-clk",sf16a28_pbus_cfg_setup);
+CLK_OF_DECLARE(sf16a28_memphy_cfg,"siflower,sf16a28-memphy-clk",sf16a28_memphy_cfg_setup);
+CLK_OF_DECLARE(sf16a28_audio_cfg,"siflower,sf16a28-audio-clk",sf16a28_audio_cfg_setup);
+CLK_OF_DECLARE(sf16a28_uart_cfg,"siflower,sf16a28-uart-clk",sf16a28_uart_cfg_setup);
+CLK_OF_DECLARE(sf16a28_spdif_cfg,"siflower,sf16a28-spdif-clk",sf16a28_spdif_cfg_setup);
+CLK_OF_DECLARE(sf16a28_sdio_cfg,"siflower,sf16a28-sdhc-clk",sf16a28_sdio_cfg_setup);
+CLK_OF_DECLARE(sf16a28_emmc_cfg,"siflower,sf16a8-emmc-clk",sf16a28_emmc_cfg_setup);
+CLK_OF_DECLARE(sf16a28_eth_ref_cfg,"siflower,sf16a28-eth-ref-clk",sf16a28_eth_ref_cfg_setup);
+CLK_OF_DECLARE(sf16a28_eth_byp_ref_cfg,"siflower,sf16a28-eth-byp-ref-clk",sf16a28_eth_byp_ref_cfg_setup);
+CLK_OF_DECLARE(sf16a28_eth_tsu_cfg,"siflower,sf16a28-eth-tsu-clk",sf16a28_eth_tsu_cfg_setup);
+CLK_OF_DECLARE(sf16a28_wlan24_cfg,"siflower,sf16a28-wlan24-mac-wt-clk",sf16a28_wlan24_cfg_setup);
+CLK_OF_DECLARE(sf16a28_wlan5_cfg,"siflower,sf16a28-wlan5-mac-wt-clk",sf16a28_wlan5_cfg_setup);
+CLK_OF_DECLARE(sf16a28_usbphy_cfg,"siflower,sf16a28-usbphy-ref-clk",sf16a28_usbphy_cfg_setup);
+CLK_OF_DECLARE(sf16a28_tclk_cfg,"siflower,sf16a28-tclk",sf16a28_tclk_cfg_setup);
+CLK_OF_DECLARE(sf16a28_npu_pe_cfg,"siflower,sf16a28-npupe-clk",sf16a28_npu_pe_cfg_setup);
+CLK_OF_DECLARE(sf16a28_gdu0_cfg,"siflower,sf16a28-gdu0-clk",sf16a28_gdu0_cfg_setup);
+CLK_OF_DECLARE(sf16a28_gdu0_eitf_cfg,"siflower,sf16a28-gdu0-eitf-clk",sf16a28_gdu0_eitf_cfg_setup);
+CLK_OF_DECLARE(sf16a28_tvif0_cfg,"siflower,sf16a28-tvif0-clk",sf16a28_tvif0_cfg_setup);
+
Index: linux-3.18.29/arch/mips/siflower/time.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/time.c	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,149 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Setting up the clock on the MIPS boards.
+ */
+#include <linux/types.h>
+#include <linux/i8253.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/timex.h>
+#include <linux/mc146818rtc.h>
+
+#include <asm/cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/mipsmtregs.h>
+#include <asm/hardirq.h>
+#include <asm/irq.h>
+#include <asm/div64.h>
+#include <asm/setup.h>
+#include <asm/time.h>
+#include <asm/mc146818-time.h>
+#include <asm/msc01_ic.h>
+#include <asm/gic.h>
+
+#include <generic.h>
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/clocksource.h>
+
+#include <linux/clk-private.h>
+
+#ifdef CONFIG_SOC_SF16A18
+#include <sf16a18int.h>
+#endif
+
+
+static int mips_cpu_timer_irq;
+static int mips_cpu_perf_irq;
+extern int cp0_perfcount_irq;
+
+static void mips_timer_dispatch(void)
+{
+	do_IRQ(mips_cpu_timer_irq);
+}
+
+static void mips_perf_dispatch(void)
+{
+	do_IRQ(mips_cpu_perf_irq);
+}
+
+static unsigned int freqround(unsigned int freq, unsigned int amount)
+{
+	freq += amount;
+	freq -= freq % (amount*2);
+	return freq;
+}
+
+static void __init plat_perf_setup(void)
+{
+#ifdef MSC01E_INT_BASE
+	if (cpu_has_veic) {
+		set_vi_handler(MSC01E_INT_PERFCTR, mips_perf_dispatch);
+		mips_cpu_perf_irq = MSC01E_INT_BASE + MSC01E_INT_PERFCTR;
+	} else
+#endif
+	if (cp0_perfcount_irq >= 0) {
+		if (cpu_has_vint)
+			set_vi_handler(cp0_perfcount_irq, mips_perf_dispatch);
+		mips_cpu_perf_irq = MIPS_CPU_IRQ_BASE + cp0_perfcount_irq;
+#ifdef CONFIG_SMP
+		irq_set_handler(mips_cpu_perf_irq, handle_percpu_irq);
+#endif
+	}
+}
+
+unsigned int get_c0_compare_int(void)
+{
+#ifdef MSC01E_INT_BASE
+	if (cpu_has_veic) {
+		set_vi_handler(MSC01E_INT_CPUCTR, mips_timer_dispatch);
+		mips_cpu_timer_irq = MSC01E_INT_BASE + MSC01E_INT_CPUCTR;
+	} else
+#endif
+	{
+		if (cpu_has_vint)
+			set_vi_handler(cp0_compare_irq, mips_timer_dispatch);
+		mips_cpu_timer_irq = MIPS_CPU_IRQ_BASE + cp0_compare_irq;
+	}
+
+	return mips_cpu_timer_irq;
+}
+
+void __init plat_time_init(void)
+{
+	unsigned int freq;
+	struct device_node *gic_node = NULL;
+	struct clk *gic_clk;
+
+	of_clk_init(NULL);
+	gic_node = of_find_compatible_node(NULL, NULL, "siflower,sfax8-gic");
+
+	if(gic_node) {
+		gic_clk = of_clk_get(gic_node,0);
+		if(IS_ERR(gic_clk)) {
+			printk("Can't get GIC clock!\n");
+			return;
+		} else {
+			gic_frequency = gic_clk->rate;
+			printk("get gic frequency from dts=%d\n", gic_frequency);
+		}
+		of_node_put(gic_node);
+	} else {
+		printk("error-can not get gic node\n");
+	}
+
+	//now we don't use cpu timer,so it is no sense here
+	mips_hpt_frequency = gic_frequency/2;
+
+#ifdef CONFIG_IRQ_GIC
+	if (gic_present) {
+		freq = freqround(gic_frequency, 5000);
+		printk("GIC frequency %d.%02d MHz\n", freq/1000000,
+		       (freq%1000000)*100/1000000);
+#ifdef CONFIG_CSRC_GIC
+		gic_clocksource_init(gic_frequency);
+#endif
+	}
+#endif
+	clocksource_of_init();
+	plat_perf_setup();
+}
Index: linux-3.18.29/drivers/char/hw_random/sfax8-rng.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/char/hw_random/sfax8-rng.c	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,146 @@
+/*
+ * sfax8-rng.c - Random Number Generator driver for the sfax8 socs
+ *
+ * Copyright (C) 2017 Siflower Communication Technology Co.
+ * Chang Li <chang.li@siflower.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/hw_random.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+#define SFAX8_RNG_CLK_EN			0x17CC
+#define SFAX8_RNG_SOFT_CLK_EN		0x4C04
+#define SFAX8_RNG_CONTROL_OFFSET		0x0
+#define SFAX8_RNG_OUT1_OFFSET		0x8
+#define SFAX8_SEED_SETUP			BIT(1)
+#define SFAX8_RNG_START			BIT(0)
+#define SFAX8_AUTOSUSPEND_DELAY	100
+
+struct sfax8_rng {
+	struct device *dev;
+	struct hwrng rng;
+	struct regmap *map;
+	void __iomem *mem;
+	struct clk *clk;
+};
+
+static u32 sfax8_rng_readl(struct sfax8_rng *rng, u32 offset)
+{
+	return	__raw_readl(rng->mem + offset);
+}
+
+static void sfax8_rng_writel(struct sfax8_rng *rng, u32 val, u32 offset)
+{
+	__raw_writel(val, rng->mem + offset);
+}
+
+static int sfax8_init(struct hwrng *rng)
+{
+	struct sfax8_rng *sfax8_rng = container_of(rng,
+						struct sfax8_rng, rng);
+	sfax8_rng_writel(sfax8_rng, SFAX8_SEED_SETUP,
+				SFAX8_RNG_CONTROL_OFFSET);	
+	return 0;
+
+}
+
+static int sfax8_read(struct hwrng *rng, void *buf,
+					size_t max, bool wait)
+{
+	struct sfax8_rng *sfax8_rng = container_of(rng,
+						struct sfax8_rng, rng);
+	u32 *data = buf;
+
+
+	sfax8_rng_writel(sfax8_rng, SFAX8_RNG_START, SFAX8_RNG_CONTROL_OFFSET);
+	*data = sfax8_rng_readl(sfax8_rng, SFAX8_RNG_OUT1_OFFSET);
+
+	return 4;
+}
+
+static int sfax8_rng_probe(struct platform_device *pdev)
+{
+	struct sfax8_rng *sfax8_rng;
+	struct resource *res;
+	struct device_node *np, *node;
+	np = pdev->dev.of_node;
+
+	sfax8_rng = devm_kzalloc(&pdev->dev, sizeof(struct sfax8_rng),
+					GFP_KERNEL);
+	if (!sfax8_rng)
+		return -ENOMEM;
+
+	sfax8_rng->dev = &pdev->dev;
+	sfax8_rng->rng.name = "sfax8";
+	sfax8_rng->rng.init =	sfax8_init;
+	sfax8_rng->rng.read = sfax8_read;
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sfax8_rng->mem = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(sfax8_rng->mem))
+		return PTR_ERR(sfax8_rng->mem);
+
+	node = of_parse_phandle(np, "rnggrf", 0);
+	if(!node){
+		dev_err(&pdev->dev, "Couldn't find node.\n");
+		return -ENOENT;
+	}
+	sfax8_rng->map = syscon_node_to_regmap(node);
+	regmap_write(sfax8_rng->map, SFAX8_RNG_CLK_EN, 0x1);
+	regmap_write(sfax8_rng->map, SFAX8_RNG_SOFT_CLK_EN, 0xFF);
+	platform_set_drvdata(pdev, sfax8_rng);
+		
+	return hwrng_register(&sfax8_rng->rng);
+}
+
+static int sfax8_rng_remove(struct platform_device *pdev)
+{
+	struct sfax8_rng *sfax8_rng = platform_get_drvdata(pdev);
+
+	hwrng_unregister(&sfax8_rng->rng);
+	return 0;
+}
+
+static const struct of_device_id sfax8_rng_of_match[] = {
+	{ .compatible = "siflower,sfax8-rng", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, msm_rng_of_match);
+
+static struct platform_driver sfax8_rng_driver = {
+	.driver		= {
+		.name	= "sfax8-rng",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(sfax8_rng_of_match),
+	},
+	.probe		= sfax8_rng_probe,
+	.remove		= sfax8_rng_remove,
+};
+
+module_platform_driver(sfax8_rng_driver);
+
+MODULE_DESCRIPTION("SFAX8 H/W Random Number Generator driver");
+MODULE_AUTHOR("CHANG LI <chang.li@siflower.com.cn>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/clocksource/sfax8_timer.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/clocksource/sfax8_timer.c	2017-11-21 09:22:50.285560000 +0800
@@ -0,0 +1,555 @@
+/*
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/sfax8_timer.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/clk.h>
+#include <linux/sched_clock.h>
+#include <linux/cpu.h>
+#include <sf16a18.h>
+
+#ifdef CONFIG_SF16A18_MPW0
+#define CONFIG_CLKSRC_SFAX8_TIMER
+#endif
+
+#define SF_TIMER_MIN_PERIOD			4
+#define APBT_MIN_DELTA_USEC			200
+
+#define SF_TIMER_LOAD_COUNT		0x00
+#define SF_TIMER_CURRENT_VALUE		0x04
+#define SF_TIMER_CONTROL			0x08
+#define SF_TIMER_EOI				0x0c
+#define SF_TIMER_INT_STATUS		0x10
+
+#if 0
+#define APBTMRS_INT_STATUS		0xa0
+#define APBTMRS_EOI			0xa4
+#define APBTMRS_RAW_INT_STATUS		0xa8
+#define APBTMRS_COMP_VERSION		0xac
+#endif
+
+#define SF_TIMER_CONTROL_ENABLE		(1 << 0)
+/* 1: periodic, 0:free running. */
+#define SF_TIMER_CONTROL_MODE_PERIODIC	(1 << 1)
+#define SF_TIMER_CONTROL_INT		(1 << 2)
+
+DEFINE_PER_CPU(struct sfax8_clock_event_device, sf_clockevent);
+struct device_node *sf_timer;
+
+static inline struct sfax8_clock_event_device *
+ced_to_sfax8_ced(struct clock_event_device *evt)
+{
+	return container_of(evt, struct sfax8_clock_event_device, ced);
+}
+
+static unsigned long apbt_readl(struct sfax8_timer *timer, unsigned long offs)
+{
+	return readl(timer->base + offs);
+}
+
+static void apbt_writel(struct sfax8_timer *timer, unsigned long val,
+		 unsigned long offs)
+{
+	writel(val, timer->base + offs);
+}
+
+static void apbt_disable_int(struct sfax8_timer *timer)
+{
+	unsigned long ctrl = apbt_readl(timer, SF_TIMER_CONTROL);
+
+	ctrl |= SF_TIMER_CONTROL_INT;
+	apbt_writel(timer, ctrl, SF_TIMER_CONTROL);
+}
+
+/**
+ * sfax8_clockevent_pause() - stop the clock_event_device from running
+ *
+ * @sf_ced:	The APB clock to stop generating events.
+ */
+void sfax8_clockevent_pause(struct sfax8_clock_event_device *sf_ced)
+{
+	disable_irq(sf_ced->timer.irq);
+	apbt_disable_int(&sf_ced->timer);
+}
+
+static void apbt_eoi(struct sfax8_timer *timer)
+{
+	apbt_readl(timer, SF_TIMER_EOI);
+}
+
+static irqreturn_t sfax8_clockevent_irq(int irq, void *data)
+{
+	struct clock_event_device *evt = data;
+	struct sfax8_clock_event_device *sf_ced = ced_to_sfax8_ced(evt);
+
+	if (!evt->event_handler) {
+		pr_info("Spurious APBT timer interrupt %d", irq);
+		return IRQ_NONE;
+	}
+
+	if (sf_ced->eoi)
+		sf_ced->eoi(&sf_ced->timer);
+
+	evt->event_handler(evt);
+	return IRQ_HANDLED;
+}
+
+static void apbt_enable_int(struct sfax8_timer *timer)
+{
+	unsigned long ctrl = apbt_readl(timer, SF_TIMER_CONTROL);
+	/* clear pending intr */
+	apbt_readl(timer, SF_TIMER_EOI);
+	ctrl &= ~SF_TIMER_CONTROL_INT;
+	apbt_writel(timer, ctrl, SF_TIMER_CONTROL);
+}
+
+static void apbt_set_mode(enum clock_event_mode mode,
+			  struct clock_event_device *evt)
+{
+	unsigned long ctrl;
+	unsigned long period;
+	struct sfax8_clock_event_device *sf_ced = ced_to_sfax8_ced(evt);
+
+	pr_debug("%s CPU %d mode=%d\n", __func__, first_cpu(*evt->cpumask),
+		 mode);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		period = DIV_ROUND_UP(sf_ced->timer.freq, HZ);
+		ctrl = apbt_readl(&sf_ced->timer, SF_TIMER_CONTROL);
+		ctrl |= SF_TIMER_CONTROL_MODE_PERIODIC;
+		apbt_writel(&sf_ced->timer, ctrl, SF_TIMER_CONTROL);
+		/*
+		 *  have to disable timer before load counter,
+		 * may cause sync problem.
+		 */
+		ctrl &= ~SF_TIMER_CONTROL_ENABLE;
+		apbt_writel(&sf_ced->timer, ctrl, SF_TIMER_CONTROL);
+		udelay(1);
+		pr_debug("Setting clock period %lu for HZ %d\n", period, HZ);
+		apbt_writel(&sf_ced->timer, period, SF_TIMER_LOAD_COUNT);
+		ctrl |= SF_TIMER_CONTROL_ENABLE;
+		apbt_writel(&sf_ced->timer, ctrl, SF_TIMER_CONTROL);
+		break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		ctrl = apbt_readl(&sf_ced->timer, SF_TIMER_CONTROL);
+		/*
+		 * set free running mode, this mode will let timer reload max
+		 * timeout which will give time (3min on 25MHz clock) to rearm
+		 * the next event, therefore emulate the one-shot mode.
+		 */
+		ctrl &= ~SF_TIMER_CONTROL_ENABLE;
+		ctrl &= ~SF_TIMER_CONTROL_MODE_PERIODIC;
+
+		apbt_writel(&sf_ced->timer, ctrl, SF_TIMER_CONTROL);
+		/* write again to set free running mode */
+		apbt_writel(&sf_ced->timer, ctrl, SF_TIMER_CONTROL);
+
+		/*
+		 * load counter with all 1s before starting free
+		 * running mode.
+		 */
+		apbt_writel(&sf_ced->timer, ~0, SF_TIMER_LOAD_COUNT);
+		ctrl &= ~SF_TIMER_CONTROL_INT;
+		ctrl |= SF_TIMER_CONTROL_ENABLE;
+		apbt_writel(&sf_ced->timer, ctrl, SF_TIMER_CONTROL);
+		break;
+
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		ctrl = apbt_readl(&sf_ced->timer, SF_TIMER_CONTROL);
+		ctrl &= ~SF_TIMER_CONTROL_ENABLE;
+		apbt_writel(&sf_ced->timer, ctrl, SF_TIMER_CONTROL);
+		break;
+
+	case CLOCK_EVT_MODE_RESUME:
+		apbt_enable_int(&sf_ced->timer);
+		break;
+	}
+}
+
+static int apbt_next_event(unsigned long delta,
+			   struct clock_event_device *evt)
+{
+	unsigned long ctrl;
+	struct sfax8_clock_event_device *sf_ced = ced_to_sfax8_ced(evt);
+
+	/* Disable timer */
+	ctrl = apbt_readl(&sf_ced->timer, SF_TIMER_CONTROL);
+	ctrl &= ~SF_TIMER_CONTROL_ENABLE;
+	apbt_writel(&sf_ced->timer, ctrl, SF_TIMER_CONTROL);
+	/* write new count */
+	apbt_writel(&sf_ced->timer, delta, SF_TIMER_LOAD_COUNT);
+	ctrl |= SF_TIMER_CONTROL_ENABLE;
+	apbt_writel(&sf_ced->timer, ctrl, SF_TIMER_CONTROL);
+
+	return 0;
+}
+
+/**
+ * sfax8_clockevent_init() - use an APB timer as a clock_event_device
+ *
+ * @cpu:	The CPU the events will be targeted at.
+ * @name:	The name used for the timer and the IRQ for it.
+ * @rating:	The rating to give the timer.
+ * @base:	I/O base for the timer registers.
+ * @irq:	The interrupt number to use for the timer.
+ * @freq:	The frequency that the timer counts at.
+ *
+ * This creates a clock_event_device for using with the generic clock layer
+ * but does not start and register it.  This should be done with
+ * sfax8_clockevent_register() as the next step.  If this is the first time
+ * it has been called for a timer then the IRQ will be requested, if not it
+ * just be enabled to allow CPU hotplug to avoid repeatedly requesting and
+ * releasing the IRQ.
+ */
+void sfax8_clockevent_init(int cpu, const char *name, unsigned rating,
+		       void __iomem *base, int irq, unsigned long freq)
+{
+	int err;
+	struct sfax8_clock_event_device *sf_ced =
+						&per_cpu(sf_clockevent, cpu);
+
+	if (!sf_ced)
+		return;
+	sf_ced->timer.base = base;
+	sf_ced->timer.irq = irq;
+	sf_ced->timer.freq = freq;
+
+	clockevents_calc_mult_shift(&sf_ced->ced, freq, SF_TIMER_MIN_PERIOD);
+	sf_ced->ced.max_delta_ns = clockevent_delta2ns(0x7fffffff,
+						       &sf_ced->ced);
+	sf_ced->ced.min_delta_ns = clockevent_delta2ns(800, &sf_ced->ced);
+	sf_ced->ced.cpumask = cpumask_of(cpu);
+	sf_ced->ced.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;
+	sf_ced->ced.set_mode = apbt_set_mode;
+	sf_ced->ced.set_next_event = apbt_next_event;
+	sf_ced->ced.irq = sf_ced->timer.irq;
+	sf_ced->ced.rating = rating;
+	sf_ced->ced.name = name;
+
+	sf_ced->irqaction.name		= sf_ced->ced.name;
+	sf_ced->irqaction.handler	= sfax8_clockevent_irq;
+	sf_ced->irqaction.dev_id	= &sf_ced->ced;
+	sf_ced->irqaction.irq		= irq;
+	sf_ced->irqaction.flags		= IRQF_NOBALANCING | IRQF_TIMER;
+
+	sf_ced->eoi = apbt_eoi;
+	err = setup_irq(irq, &sf_ced->irqaction);
+	if (err) {
+		pr_err("failed to request timer irq\n");
+		kfree(sf_ced);
+		return;
+	}
+
+	sfax8_clockevent_register(sf_ced);
+
+	return;
+}
+
+/**
+ * sfax8_clockevent_resume() - resume a clock that has been paused.
+ *
+ * @sf_ced:	The APB clock to resume.
+ */
+void sfax8_clockevent_resume(struct sfax8_clock_event_device *sf_ced)
+{
+	enable_irq(sf_ced->timer.irq);
+}
+
+/**
+ * sfax8_clockevent_stop() - stop the clock_event_device and release the IRQ.
+ *
+ * @sf_ced:	The APB clock to stop generating the events.
+ */
+void sfax8_clockevent_stop(struct sfax8_clock_event_device *sf_ced)
+{
+	free_irq(sf_ced->timer.irq, &sf_ced->ced);
+}
+
+/**
+ * sfax8_clockevent_register() - register the clock with the generic layer
+ *
+ * @sf_ced:	The APB clock to register as a clock_event_device.
+ */
+void sfax8_clockevent_register(struct sfax8_clock_event_device *sf_ced)
+{
+	apbt_writel(&sf_ced->timer, 0, SF_TIMER_CONTROL);
+	clockevents_register_device(&sf_ced->ced);
+	apbt_enable_int(&sf_ced->timer);
+}
+
+static void __init timer_get_base_and_rate(struct device_node *np,
+				    void __iomem **base, u32 *rate)
+{
+	struct clk *timer_clk;
+	struct clk *pclk;
+	unsigned int cpu = smp_processor_id();
+
+	*base = of_iomap(np, cpu);
+
+	if (!*base)
+		panic("Unable to map regs for %s", np->name);
+
+	/*
+	 * Not all implementations use a periphal clock, so don't panic
+	 * if it's not present
+	 */
+	pclk = of_clk_get_by_name(np, "pclk");
+	if (!IS_ERR(pclk))
+		if (clk_prepare_enable(pclk))
+			pr_warn("pclk for %s is present, but could not be activated\n",
+				np->name);
+
+	timer_clk = of_clk_get_by_name(np, "timer");
+	if (IS_ERR(timer_clk))
+		goto try_clock_freq;
+
+	if (!clk_prepare_enable(timer_clk)) {
+		*rate = clk_get_rate(timer_clk);
+		return;
+	}
+
+try_clock_freq:
+	if (of_property_read_u32(np, "clock-freq", rate) &&
+	    of_property_read_u32(np, "clock-frequency", rate))
+		panic("No clock nor clock-frequency property for %s", np->name);
+}
+
+#ifdef CONFIG_CLKSRC_SFAX8_TIMER
+static inline struct sfax8_clocksource *
+clocksource_to_sfax8_clocksource(struct clocksource *cs)
+{
+	return container_of(cs, struct sfax8_clocksource, cs);
+}
+
+/**
+ * sfax8_clocksource_start() - start the clocksource counting.
+ *
+ * @sf_cs:	The clocksource to start.
+ *
+ * This is used to start the clocksource before registration and can be used
+ * to enable calibration of timers.
+ */
+void sfax8_clocksource_start(struct sfax8_clocksource *sf_cs)
+{
+	/*
+	 * start count down from 0xffff_ffff. this is done by toggling the
+	 * enable bit then load initial load count to ~0.
+	 */
+	unsigned long ctrl = apbt_readl(&sf_cs->timer, SF_TIMER_CONTROL);
+
+	ctrl &= ~SF_TIMER_CONTROL_ENABLE;
+	apbt_writel(&sf_cs->timer, ctrl, SF_TIMER_CONTROL);
+	apbt_writel(&sf_cs->timer, ~0, SF_TIMER_LOAD_COUNT);
+	/* enable, mask interrupt */
+	ctrl &= ~SF_TIMER_CONTROL_MODE_PERIODIC;
+	ctrl |= (SF_TIMER_CONTROL_ENABLE | SF_TIMER_CONTROL_INT);
+	apbt_writel(&sf_cs->timer, ctrl, SF_TIMER_CONTROL);
+	/* read it once to get cached counter value initialized */
+	sfax8_clocksource_read(sf_cs);
+}
+
+static cycle_t __apbt_read_clocksource(struct clocksource *cs)
+{
+	unsigned long current_count;
+	struct sfax8_clocksource *sf_cs =
+		clocksource_to_sfax8_clocksource(cs);
+
+	current_count = apbt_readl(&sf_cs->timer, SF_TIMER_CURRENT_VALUE);
+
+	return (cycle_t)~current_count;
+}
+
+static void apbt_restart_clocksource(struct clocksource *cs)
+{
+	struct sfax8_clocksource *sf_cs =
+		clocksource_to_sfax8_clocksource(cs);
+
+	sfax8_clocksource_start(sf_cs);
+}
+
+/**
+ * sfax8_clocksource_init() - use an APB timer as a clocksource.
+ *
+ * @rating:	The rating to give the clocksource.
+ * @name:	The name for the clocksource.
+ * @base:	The I/O base for the timer registers.
+ * @freq:	The frequency that the timer counts at.
+ *
+ * This creates a clocksource using an APB timer but does not yet register it
+ * with the clocksource system.  This should be done with
+ * sfax8_clocksource_register() as the next step.
+ */
+struct sfax8_clocksource *
+sfax8_clocksource_init(unsigned rating, const char *name, void __iomem *base,
+			unsigned long freq)
+{
+	struct sfax8_clocksource *sf_cs = kzalloc(sizeof(*sf_cs), GFP_KERNEL);
+
+	if (!sf_cs)
+		return NULL;
+
+	sf_cs->timer.base = base;
+	sf_cs->timer.freq = freq;
+	sf_cs->cs.name = name;
+	sf_cs->cs.rating = rating;
+	sf_cs->cs.read = __apbt_read_clocksource;
+	sf_cs->cs.mask = CLOCKSOURCE_MASK(32);
+	sf_cs->cs.flags = CLOCK_SOURCE_IS_CONTINUOUS;
+	sf_cs->cs.resume = apbt_restart_clocksource;
+
+	return sf_cs;
+}
+
+/**
+ * sfax8_clocksource_register() - register the APB clocksource.
+ *
+ * @sf_cs:	The clocksource to register.
+ */
+void sfax8_clocksource_register(struct sfax8_clocksource *sf_cs)
+{
+	clocksource_register_hz(&sf_cs->cs, sf_cs->timer.freq);
+}
+
+/**
+ * sfax8_clocksource_read() - read the current value of a clocksource.
+ *
+ * @sf_cs:	The clocksource to read.
+ */
+cycle_t sfax8_clocksource_read(struct sfax8_clocksource *sf_cs)
+{
+	return (cycle_t)~apbt_readl(&sf_cs->timer, SF_TIMER_CURRENT_VALUE);
+}
+
+static void __iomem *sched_io_base;
+static u32 sched_rate;
+
+// static u64 notrace read_sched_clock(void)
+// {
+// 	return ~__raw_readl(sched_io_base);
+// }
+
+static const struct of_device_id sptimer_ids[] __initconst = {
+	{ .compatible = "siflower,sfax8-rtc" },
+	{ /* Sentinel */ },
+};
+
+#if 0
+static void __init init_sched_clock(void)
+{
+	extern void sched_clock_register(u64 (*read)(void), int bits, unsigned long rate);
+	struct device_node *sched_timer;
+
+	sched_timer = of_find_matching_node(NULL, sptimer_ids);
+	if (sched_timer) {
+		timer_get_base_and_rate(sched_timer, &sched_io_base,
+					&sched_rate);
+		of_node_put(sched_timer);
+	}
+
+	sched_clock_register(read_sched_clock, 32, sched_rate);
+}
+#endif
+
+static void __init add_clocksource(struct device_node *source_timer)
+{
+	void __iomem *iobase;
+	struct sfax8_clocksource *cs;
+	u32 rate;
+
+	timer_get_base_and_rate(source_timer, &iobase, &rate);
+#ifdef CONFIG_SF16A18_MPW0
+	//FIXME: switch clocksource to timer 2.
+	iobase = of_iomap(source_timer, 2);
+
+	cs = sfax8_clocksource_init(400, source_timer->name, iobase, rate);
+#else
+	cs = sfax8_clocksource_init(200, source_timer->name, iobase, rate);
+#endif
+	if (!cs)
+		panic("Unable to initialise clocksource device");
+
+	sfax8_clocksource_start(cs);
+	sfax8_clocksource_register(cs);
+
+	/*
+	 * Fallback to use the clocksource as sched_clock if no separate
+	 * timer is found. sched_io_base then points to the current_value
+	 * register of the clocksource timer.
+	 */
+	sched_io_base = iobase + 0x04;
+	sched_rate = rate;
+}
+#endif /* CONFIG_CLKSRC_SFAX8_TIMER */
+
+static void add_clockevent(void)
+{
+	void __iomem *iobase;
+	unsigned int cpu = smp_processor_id();
+	u32 irq, rate;
+
+	irq = irq_of_parse_and_map(sf_timer, cpu);
+	if (irq == 0)
+		panic("No IRQ for clock event timer\n");
+
+	timer_get_base_and_rate(sf_timer, &iobase, &rate);
+
+	sfax8_clockevent_init(cpu, sf_timer->name, 350, iobase, irq,
+			rate);
+
+	if(irq_force_affinity(irq, cpumask_of(cpu)) != 0)
+		panic("Failed to set timer clockevent irq affinity!\n");
+}
+
+static int sf_timer_notify(struct notifier_block *self, unsigned long action,
+				void *hcpu)
+{
+	switch (action & ~CPU_TASKS_FROZEN) {
+	case CPU_STARTING:
+		add_clockevent();
+		break;
+	case CPU_DYING:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block sf_timer_nb = {
+	.notifier_call = sf_timer_notify,
+};
+
+static void __init sfax8_timer_init(struct device_node *timer)
+{
+	int err;
+
+	if(release_reset(SF_TIMER_SOFT_RESET))
+		return;
+
+	sf_timer = timer;
+
+#ifdef CONFIG_CLKSRC_SFAX8_TIMER
+	add_clocksource(sf_timer);
+#endif
+	err = register_cpu_notifier(&sf_timer_nb);
+	if(err)
+		panic("Unable to initialise clockevent device");
+	add_clockevent();
+
+	return;
+}
+CLOCKSOURCE_OF_DECLARE(sfax8_timer, "siflower,sfax8-timer", sfax8_timer_init);
Index: linux-3.18.29/drivers/dma/sfax8_dma.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/dma/sfax8_dma.c	2017-11-15 17:26:54.345090000 +0800
@@ -0,0 +1,2960 @@
+/*
+ * Copyright (c) 2012 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Copyright (C) 2010 Samsung Electronics Co. Ltd.
+ *	Jaswinder Singh <jassi.brar@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/pl330.h>
+#include <linux/scatterlist.h>
+#include <linux/of.h>
+#include <linux/of_dma.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <sf16a18.h>
+
+#include "dmaengine.h"
+#define PL330_MAX_CHAN		8
+#define PL330_MAX_IRQS		32
+#define PL330_MAX_PERI		32
+#define SFDMA_NR_IRQS		13
+
+enum pl330_cachectrl {
+	CCTRL0,		/* Noncacheable and nonbufferable */
+	CCTRL1,		/* Bufferable only */
+	CCTRL2,		/* Cacheable, but do not allocate */
+	CCTRL3,		/* Cacheable and bufferable, but do not allocate */
+	INVALID1,	/* AWCACHE = 0x1000 */
+	INVALID2,
+	CCTRL6,		/* Cacheable write-through, allocate on writes only */
+	CCTRL7,		/* Cacheable write-back, allocate on writes only */
+};
+
+enum pl330_byteswap {
+	SWAP_NO,
+	SWAP_2,
+	SWAP_4,
+	SWAP_8,
+	SWAP_16,
+};
+
+/* Register and Bit field Definitions */
+#define DS			0x0
+#define DS_ST_STOP		0x0
+#define DS_ST_EXEC		0x1
+#define DS_ST_CMISS		0x2
+#define DS_ST_UPDTPC		0x3
+#define DS_ST_WFE		0x4
+#define DS_ST_ATBRR		0x5
+#define DS_ST_QBUSY		0x6
+#define DS_ST_WFP		0x7
+#define DS_ST_KILL		0x8
+#define DS_ST_CMPLT		0x9
+#define DS_ST_FLTCMP		0xe
+#define DS_ST_FAULT		0xf
+
+#define DPC			0x4
+#define INTEN			0x20
+#define ES			0x24
+#define INTSTATUS		0x28
+#define INTCLR			0x2c
+#define FSM			0x30
+#define FSC			0x34
+#define FTM			0x38
+
+#define _FTC			0x40
+#define FTC(n)			(_FTC + (n)*0x4)
+
+#define _CS			0x100
+#define CS(n)			(_CS + (n)*0x8)
+#define CS_CNS			(1 << 21)
+
+#define _CPC			0x104
+#define CPC(n)			(_CPC + (n)*0x8)
+
+#define _SA			0x400
+#define SA(n)			(_SA + (n)*0x20)
+
+#define _DA			0x404
+#define DA(n)			(_DA + (n)*0x20)
+
+#define _CC			0x408
+#define CC(n)			(_CC + (n)*0x20)
+
+#define CC_SRCINC		(1 << 0)
+#define CC_DSTINC		(1 << 14)
+#define CC_SRCPRI		(1 << 8)
+#define CC_DSTPRI		(1 << 22)
+#define CC_SRCNS		(1 << 9)
+#define CC_DSTNS		(1 << 23)
+#define CC_SRCIA		(1 << 10)
+#define CC_DSTIA		(1 << 24)
+#define CC_SRCBRSTLEN_SHFT	4
+#define CC_DSTBRSTLEN_SHFT	18
+#define CC_SRCBRSTSIZE_SHFT	1
+#define CC_DSTBRSTSIZE_SHFT	15
+#define CC_SRCCCTRL_SHFT	11
+#define CC_SRCCCTRL_MASK	0x7
+#define CC_DSTCCTRL_SHFT	25
+#define CC_DRCCCTRL_MASK	0x7
+#define CC_SWAP_SHFT		28
+
+#define _LC0			0x40c
+#define LC0(n)			(_LC0 + (n)*0x20)
+
+#define _LC1			0x410
+#define LC1(n)			(_LC1 + (n)*0x20)
+
+#define DBGSTATUS		0xd00
+#define DBG_BUSY		(1 << 0)
+
+#define DBGCMD			0xd04
+#define DBGINST0		0xd08
+#define DBGINST1		0xd0c
+
+#define CR0			0xe00
+#define CR1			0xe04
+#define CR2			0xe08
+#define CR3			0xe0c
+#define CR4			0xe10
+#define CRD			0xe14
+
+#define PERIPH_ID		0xfe0
+#define PERIPH_REV_SHIFT	20
+#define PERIPH_REV_MASK		0xf
+#define PERIPH_REV_R0P0		0
+#define PERIPH_REV_R1P0		1
+#define PERIPH_REV_R1P1		2
+
+#define CR0_PERIPH_REQ_SET	(1 << 0)
+#define CR0_BOOT_EN_SET		(1 << 1)
+#define CR0_BOOT_MAN_NS		(1 << 2)
+#define CR0_NUM_CHANS_SHIFT	4
+#define CR0_NUM_CHANS_MASK	0x7
+#define CR0_NUM_PERIPH_SHIFT	12
+#define CR0_NUM_PERIPH_MASK	0x1f
+#define CR0_NUM_EVENTS_SHIFT	17
+#define CR0_NUM_EVENTS_MASK	0x1f
+
+#define CR1_ICACHE_LEN_SHIFT	0
+#define CR1_ICACHE_LEN_MASK	0x7
+#define CR1_NUM_ICACHELINES_SHIFT	4
+#define CR1_NUM_ICACHELINES_MASK	0xf
+
+#define CRD_DATA_WIDTH_SHIFT	0
+#define CRD_DATA_WIDTH_MASK	0x7
+#define CRD_WR_CAP_SHIFT	4
+#define CRD_WR_CAP_MASK		0x7
+#define CRD_WR_Q_DEP_SHIFT	8
+#define CRD_WR_Q_DEP_MASK	0xf
+#define CRD_RD_CAP_SHIFT	12
+#define CRD_RD_CAP_MASK		0x7
+#define CRD_RD_Q_DEP_SHIFT	16
+#define CRD_RD_Q_DEP_MASK	0xf
+#define CRD_DATA_BUFF_SHIFT	20
+#define CRD_DATA_BUFF_MASK	0x3ff
+
+#define PART			0x330
+#define DESIGNER		0x41
+#define REVISION		0x0
+#define INTEG_CFG		0x0
+#define PERIPH_ID_VAL		((PART << 0) | (DESIGNER << 12))
+
+#define PL330_STATE_STOPPED		(1 << 0)
+#define PL330_STATE_EXECUTING		(1 << 1)
+#define PL330_STATE_WFE			(1 << 2)
+#define PL330_STATE_FAULTING		(1 << 3)
+#define PL330_STATE_COMPLETING		(1 << 4)
+#define PL330_STATE_WFP			(1 << 5)
+#define PL330_STATE_KILLING		(1 << 6)
+#define PL330_STATE_FAULT_COMPLETING	(1 << 7)
+#define PL330_STATE_CACHEMISS		(1 << 8)
+#define PL330_STATE_UPDTPC		(1 << 9)
+#define PL330_STATE_ATBARRIER		(1 << 10)
+#define PL330_STATE_QUEUEBUSY		(1 << 11)
+#define PL330_STATE_INVALID		(1 << 15)
+
+#define PL330_STABLE_STATES (PL330_STATE_STOPPED | PL330_STATE_EXECUTING \
+				| PL330_STATE_WFE | PL330_STATE_FAULTING)
+
+#define CMD_DMAADDH		0x54
+#define CMD_DMAEND		0x00
+#define CMD_DMAFLUSHP		0x35
+#define CMD_DMAGO		0xa0
+#define CMD_DMALD		0x04
+#define CMD_DMALDP		0x25
+#define CMD_DMALP		0x20
+#define CMD_DMALPEND		0x28
+#define CMD_DMAKILL		0x01
+#define CMD_DMAMOV		0xbc
+#define CMD_DMANOP		0x18
+#define CMD_DMARMB		0x12
+#define CMD_DMASEV		0x34
+#define CMD_DMAST		0x08
+#define CMD_DMASTP		0x29
+#define CMD_DMASTZ		0x0c
+#define CMD_DMAWFE		0x36
+#define CMD_DMAWFP		0x30
+#define CMD_DMAWMB		0x13
+
+#define SZ_DMAADDH		3
+#define SZ_DMAEND		1
+#define SZ_DMAFLUSHP		2
+#define SZ_DMALD		1
+#define SZ_DMALDP		2
+#define SZ_DMALP		2
+#define SZ_DMALPEND		2
+#define SZ_DMAKILL		1
+#define SZ_DMAMOV		6
+#define SZ_DMANOP		1
+#define SZ_DMARMB		1
+#define SZ_DMASEV		2
+#define SZ_DMAST		1
+#define SZ_DMASTP		2
+#define SZ_DMASTZ		1
+#define SZ_DMAWFE		2
+#define SZ_DMAWFP		2
+#define SZ_DMAWMB		1
+#define SZ_DMAGO		6
+
+#define BRST_LEN(ccr)		((((ccr) >> CC_SRCBRSTLEN_SHFT) & 0xf) + 1)
+#define BRST_SIZE(ccr)		(1 << (((ccr) >> CC_SRCBRSTSIZE_SHFT) & 0x7))
+
+#define BYTE_TO_BURST(b, ccr)	((b) / BRST_SIZE(ccr) / BRST_LEN(ccr))
+#define BURST_TO_BYTE(c, ccr)	((c) * BRST_SIZE(ccr) * BRST_LEN(ccr))
+
+/*
+ * With 256 bytes, we can do more than 2.5MB and 5MB xfers per req
+ * at 1byte/burst for P<->M and M<->M respectively.
+ * For typical scenario, at 1word/burst, 10MB and 20MB xfers per req
+ * should be enough for P<->M and M<->M respectively.
+ */
+#define MCODE_BUFF_PER_REQ	256
+
+/* Use this _only_ to wait on transient states */
+#define UNTIL(t, s)	while (!(_state(t) & (s))) cpu_relax();
+
+#ifdef PL330_DEBUG_MCGEN
+static unsigned cmd_line;
+#define PL330_DBGCMD_DUMP(off, x...)	do { \
+						printk("%x:", cmd_line); \
+						printk(x); \
+						cmd_line += off; \
+					} while (0)
+#define PL330_DBGMC_START(addr)		(cmd_line = addr)
+#else
+#define PL330_DBGCMD_DUMP(off, x...)	do {} while (0)
+#define PL330_DBGMC_START(addr)		do {} while (0)
+#endif
+
+/* The number of default descriptors */
+
+#define NR_DEFAULT_DESC	16
+
+/* Populated by the PL330 core driver for DMA API driver's info */
+struct pl330_config {
+	u32	periph_id;
+#define DMAC_MODE_NS	(1 << 0)
+	unsigned int	mode;
+	unsigned int	data_bus_width:10; /* In number of bits */
+	unsigned int	data_buf_dep:11;
+	unsigned int	num_chan:4;
+	unsigned int	num_peri:6;
+	u32		peri_ns;
+	unsigned int	num_events:6;
+	u32		irq_ns;
+};
+
+/**
+ * Request Configuration.
+ * The PL330 core does not modify this and uses the last
+ * working configuration if the request doesn't provide any.
+ *
+ * The Client may want to provide this info only for the
+ * first request and a request with new settings.
+ */
+struct pl330_reqcfg {
+	/* Address Incrementing */
+	unsigned dst_inc:1;
+	unsigned src_inc:1;
+
+	/*
+	 * For now, the SRC & DST protection levels
+	 * and burst size/length are assumed same.
+	 */
+	bool nonsecure;
+	bool privileged;
+	bool insnaccess;
+	unsigned brst_len:5;
+	unsigned brst_size:3; /* in power of 2 */
+
+	enum pl330_cachectrl dcctl;
+	enum pl330_cachectrl scctl;
+	enum pl330_byteswap swap;
+	struct pl330_config *pcfg;
+};
+
+/*
+ * One cycle of DMAC operation.
+ * There may be more than one xfer in a request.
+ */
+struct pl330_xfer {
+	u32 src_addr;
+	u32 dst_addr;
+	/* Size to xfer */
+	u32 bytes;
+};
+
+/* The xfer callbacks are made with one of these arguments. */
+enum pl330_op_err {
+	/* The all xfers in the request were success. */
+	PL330_ERR_NONE,
+	/* If req aborted due to global error. */
+	PL330_ERR_ABORT,
+	/* If req failed due to problem with Channel. */
+	PL330_ERR_FAIL,
+};
+
+enum dmamov_dst {
+	SAR = 0,
+	CCR,
+	DAR,
+};
+
+enum pl330_dst {
+	SRC = 0,
+	DST,
+};
+
+enum pl330_cond {
+	SINGLE,
+	BURST,
+	ALWAYS,
+};
+
+struct dma_pl330_desc;
+
+struct _pl330_req {
+	u32 mc_bus;
+	void *mc_cpu;
+	struct dma_pl330_desc *desc;
+};
+
+/* ToBeDone for tasklet */
+struct _pl330_tbd {
+	bool reset_dmac;
+	bool reset_mngr;
+	u8 reset_chan;
+};
+
+/* A DMAC Thread */
+struct pl330_thread {
+	u8 id;
+	int ev;
+	/* If the channel is not yet acquired by any client */
+	bool free;
+	/* Parent DMAC */
+	struct pl330_dmac *dmac;
+	/* Only two at a time */
+	struct _pl330_req req[2];
+	/* Index of the last enqueued request */
+	unsigned lstenq;
+	/* Index of the last submitted request or -1 if the DMA is stopped */
+	int req_running;
+};
+
+enum pl330_dmac_state {
+	UNINIT,
+	INIT,
+	DYING,
+};
+
+enum desc_status {
+	/* In the DMAC pool */
+	FREE,
+	/*
+	 * Allocated to some channel during prep_xxx
+	 * Also may be sitting on the work_list.
+	 */
+	PREP,
+	/*
+	 * Sitting on the work_list and already submitted
+	 * to the PL330 core. Not more than two descriptors
+	 * of a channel can be BUSY at any time.
+	 */
+	BUSY,
+	/*
+	 * Sitting on the channel work_list but xfer done
+	 * by PL330 core
+	 */
+	DONE,
+};
+
+struct dma_pl330_chan {
+	/* Schedule desc completion */
+	struct tasklet_struct task;
+
+	/* DMA-Engine Channel */
+	struct dma_chan chan;
+
+	/* List of submitted descriptors */
+	struct list_head submitted_list;
+	/* List of issued descriptors */
+	struct list_head work_list;
+	/* List of completed descriptors */
+	struct list_head completed_list;
+
+	/* Pointer to the DMAC that manages this channel,
+	 * NULL if the channel is available to be acquired.
+	 * As the parent, this DMAC also provides descriptors
+	 * to the channel.
+	 */
+	struct pl330_dmac *dmac;
+
+	/* To protect channel manipulation */
+	spinlock_t lock;
+
+	/*
+	 * Hardware channel thread of PL330 DMAC. NULL if the channel is
+	 * available.
+	 */
+	struct pl330_thread *thread;
+
+	/* For D-to-M and M-to-D channels */
+	int burst_sz; /* the peripheral fifo width */
+	int burst_len; /* the number of burst */
+	dma_addr_t fifo_addr;
+
+	/* for cyclic capability */
+	bool cyclic;
+};
+
+struct pl330_dmac {
+	/* DMA-Engine Device */
+	struct dma_device ddma;
+
+	/* Holds info about sg limitations */
+	struct device_dma_parameters dma_parms;
+
+	/* Pool of descriptors available for the DMAC's channels */
+	struct list_head desc_pool;
+	/* To protect desc_pool manipulation */
+	spinlock_t pool_lock;
+
+	/* Size of MicroCode buffers for each channel. */
+	unsigned mcbufsz;
+	/* ioremap'ed address of PL330 registers. */
+	void __iomem	*base;
+	/* Populated by the PL330 core driver during pl330_add */
+	struct pl330_config	pcfg;
+
+	spinlock_t		lock;
+	/* Maximum possible events/irqs */
+	int			events[32];
+	/* BUS address of MicroCode buffer */
+	dma_addr_t		mcode_bus;
+	/* CPU address of MicroCode buffer */
+	void			*mcode_cpu;
+	/* List of all Channel threads */
+	struct pl330_thread	*channels;
+	/* Pointer to the MANAGER thread */
+	struct pl330_thread	*manager;
+	/* To handle bad news in interrupt */
+	struct tasklet_struct	tasks;
+	struct _pl330_tbd	dmac_tbd;
+	/* State of DMAC operation */
+	enum pl330_dmac_state	state;
+	/* Holds list of reqs with due callbacks */
+	struct list_head        req_done;
+
+	/* Peripheral channels connected to this DMAC */
+	unsigned int num_peripherals;
+	struct dma_pl330_chan *peripherals; /* keep at end */
+};
+
+struct dma_pl330_desc {
+	/* To attach to a queue as child */
+	struct list_head node;
+
+	/* Descriptor for the DMA Engine API */
+	struct dma_async_tx_descriptor txd;
+
+	/* Xfer for PL330 core */
+	struct pl330_xfer px;
+
+	struct pl330_reqcfg rqcfg;
+
+	enum desc_status status;
+
+	int bytes_requested;
+	bool last;
+
+	/* The channel which currently holds this desc */
+	struct dma_pl330_chan *pchan;
+
+	enum dma_transfer_direction rqtype;
+	/* Index of peripheral for the xfer. */
+	unsigned peri:5;
+	/* Hook to attach to DMAC's list of reqs with due callback */
+	struct list_head rqd;
+};
+
+struct _xfer_spec {
+	u32 ccr;
+	struct dma_pl330_desc *desc;
+};
+
+static inline bool _queue_empty(struct pl330_thread *thrd)
+{
+	return thrd->req[0].desc == NULL && thrd->req[1].desc == NULL;
+}
+
+static inline bool _queue_full(struct pl330_thread *thrd)
+{
+	return thrd->req[0].desc != NULL && thrd->req[1].desc != NULL;
+}
+
+static inline bool is_manager(struct pl330_thread *thrd)
+{
+	return thrd->dmac->manager == thrd;
+}
+
+/* If manager of the thread is in Non-Secure mode */
+static inline bool _manager_ns(struct pl330_thread *thrd)
+{
+	return (thrd->dmac->pcfg.mode & DMAC_MODE_NS) ? true : false;
+}
+
+static inline u32 get_revision(u32 periph_id)
+{
+	return (periph_id >> PERIPH_REV_SHIFT) & PERIPH_REV_MASK;
+}
+
+static inline u32 _emit_ADDH(unsigned dry_run, u8 buf[],
+		enum pl330_dst da, u16 val)
+{
+	if (dry_run)
+		return SZ_DMAADDH;
+
+	buf[0] = CMD_DMAADDH;
+	buf[0] |= (da << 1);
+	*((u16 *)&buf[1]) = val;
+
+	PL330_DBGCMD_DUMP(SZ_DMAADDH, "\tDMAADDH %s %u\n",
+		da == 1 ? "DA" : "SA", val);
+
+	return SZ_DMAADDH;
+}
+
+static inline u32 _emit_END(unsigned dry_run, u8 buf[])
+{
+	if (dry_run)
+		return SZ_DMAEND;
+
+	buf[0] = CMD_DMAEND;
+
+	PL330_DBGCMD_DUMP(SZ_DMAEND, "\tDMAEND\n");
+
+	return SZ_DMAEND;
+}
+
+static inline u32 _emit_FLUSHP(unsigned dry_run, u8 buf[], u8 peri)
+{
+	if (dry_run)
+		return SZ_DMAFLUSHP;
+
+	buf[0] = CMD_DMAFLUSHP;
+
+	peri &= 0x1f;
+	peri <<= 3;
+	buf[1] = peri;
+
+	PL330_DBGCMD_DUMP(SZ_DMAFLUSHP, "\tDMAFLUSHP %u\n", peri >> 3);
+
+	return SZ_DMAFLUSHP;
+}
+
+static inline u32 _emit_LD(unsigned dry_run, u8 buf[],	enum pl330_cond cond)
+{
+	if (dry_run)
+		return SZ_DMALD;
+
+	buf[0] = CMD_DMALD;
+
+	if (cond == SINGLE)
+		buf[0] |= (0 << 1) | (1 << 0);
+	else if (cond == BURST)
+		buf[0] |= (1 << 1) | (1 << 0);
+
+	PL330_DBGCMD_DUMP(SZ_DMALD, "\tDMALD%c\n",
+		cond == SINGLE ? 'S' : (cond == BURST ? 'B' : 'A'));
+
+	return SZ_DMALD;
+}
+
+static inline u32 _emit_LDP(unsigned dry_run, u8 buf[],
+		enum pl330_cond cond, u8 peri)
+{
+	if (dry_run)
+		return SZ_DMALDP;
+
+	buf[0] = CMD_DMALDP;
+
+	if (cond == BURST)
+		buf[0] |= (1 << 1);
+
+	peri &= 0x1f;
+	peri <<= 3;
+	buf[1] = peri;
+
+	PL330_DBGCMD_DUMP(SZ_DMALDP, "\tDMALDP%c %u\n",
+		cond == SINGLE ? 'S' : 'B', peri >> 3);
+
+	return SZ_DMALDP;
+}
+
+static inline u32 _emit_LP(unsigned dry_run, u8 buf[],
+		unsigned loop, u8 cnt)
+{
+	if (dry_run)
+		return SZ_DMALP;
+
+	buf[0] = CMD_DMALP;
+
+	if (loop)
+		buf[0] |= (1 << 1);
+
+	cnt--; /* DMAC increments by 1 internally */
+	buf[1] = cnt;
+
+	PL330_DBGCMD_DUMP(SZ_DMALP, "\tDMALP_%c %u\n", loop ? '1' : '0', cnt);
+
+	return SZ_DMALP;
+}
+
+struct _arg_LPEND {
+	enum pl330_cond cond;
+	bool forever;
+	unsigned loop;
+	u8 bjump;
+};
+
+static inline u32 _emit_LPEND(unsigned dry_run, u8 buf[],
+		const struct _arg_LPEND *arg)
+{
+	enum pl330_cond cond = arg->cond;
+	bool forever = arg->forever;
+	unsigned loop = arg->loop;
+	u8 bjump = arg->bjump;
+
+	if (dry_run)
+		return SZ_DMALPEND;
+
+	buf[0] = CMD_DMALPEND;
+
+	if (loop)
+		buf[0] |= (1 << 2);
+
+	if (!forever)
+		buf[0] |= (1 << 4);
+
+	if (cond == SINGLE)
+		buf[0] |= (0 << 1) | (1 << 0);
+	else if (cond == BURST)
+		buf[0] |= (1 << 1) | (1 << 0);
+
+	buf[1] = bjump;
+
+	PL330_DBGCMD_DUMP(SZ_DMALPEND, "\tDMALP%s%c_%c bjmpto_%x\n",
+			forever ? "FE" : "END",
+			cond == SINGLE ? 'S' : (cond == BURST ? 'B' : 'A'),
+			loop ? '1' : '0',
+			bjump);
+
+	return SZ_DMALPEND;
+}
+
+static inline u32 _emit_KILL(unsigned dry_run, u8 buf[])
+{
+	if (dry_run)
+		return SZ_DMAKILL;
+
+	buf[0] = CMD_DMAKILL;
+
+	return SZ_DMAKILL;
+}
+
+static inline u32 _emit_MOV(unsigned dry_run, u8 buf[],
+		enum dmamov_dst dst, u32 val)
+{
+	if (dry_run)
+		return SZ_DMAMOV;
+
+	buf[0] = CMD_DMAMOV;
+	buf[1] = dst;
+	*((u32 *)&buf[2]) = val;
+
+	PL330_DBGCMD_DUMP(SZ_DMAMOV, "\tDMAMOV %s 0x%x\n",
+		dst == SAR ? "SAR" : (dst == DAR ? "DAR" : "CCR"), val);
+
+	return SZ_DMAMOV;
+}
+
+static inline u32 _emit_NOP(unsigned dry_run, u8 buf[])
+{
+	if (dry_run)
+		return SZ_DMANOP;
+
+	buf[0] = CMD_DMANOP;
+
+	PL330_DBGCMD_DUMP(SZ_DMANOP, "\tDMANOP\n");
+
+	return SZ_DMANOP;
+}
+
+static inline u32 _emit_RMB(unsigned dry_run, u8 buf[])
+{
+	if (dry_run)
+		return SZ_DMARMB;
+
+	buf[0] = CMD_DMARMB;
+
+	PL330_DBGCMD_DUMP(SZ_DMARMB, "\tDMARMB\n");
+
+	return SZ_DMARMB;
+}
+
+static inline u32 _emit_SEV(unsigned dry_run, u8 buf[], u8 ev)
+{
+	if (dry_run)
+		return SZ_DMASEV;
+
+	buf[0] = CMD_DMASEV;
+
+	ev &= 0x1f;
+	ev <<= 3;
+	buf[1] = ev;
+
+	PL330_DBGCMD_DUMP(SZ_DMASEV, "\tDMASEV %u\n", ev >> 3);
+
+	return SZ_DMASEV;
+}
+
+static inline u32 _emit_ST(unsigned dry_run, u8 buf[], enum pl330_cond cond)
+{
+	if (dry_run)
+		return SZ_DMAST;
+
+	buf[0] = CMD_DMAST;
+
+	if (cond == SINGLE)
+		buf[0] |= (0 << 1) | (1 << 0);
+	else if (cond == BURST)
+		buf[0] |= (1 << 1) | (1 << 0);
+
+	PL330_DBGCMD_DUMP(SZ_DMAST, "\tDMAST%c\n",
+		cond == SINGLE ? 'S' : (cond == BURST ? 'B' : 'A'));
+
+	return SZ_DMAST;
+}
+
+static inline u32 _emit_STP(unsigned dry_run, u8 buf[],
+		enum pl330_cond cond, u8 peri)
+{
+	if (dry_run)
+		return SZ_DMASTP;
+
+	buf[0] = CMD_DMASTP;
+
+	if (cond == BURST)
+		buf[0] |= (1 << 1);
+
+	peri &= 0x1f;
+	peri <<= 3;
+	buf[1] = peri;
+
+	PL330_DBGCMD_DUMP(SZ_DMASTP, "\tDMASTP%c %u\n",
+		cond == SINGLE ? 'S' : 'B', peri >> 3);
+
+	return SZ_DMASTP;
+}
+
+static inline u32 _emit_STZ(unsigned dry_run, u8 buf[])
+{
+	if (dry_run)
+		return SZ_DMASTZ;
+
+	buf[0] = CMD_DMASTZ;
+
+	PL330_DBGCMD_DUMP(SZ_DMASTZ, "\tDMASTZ\n");
+
+	return SZ_DMASTZ;
+}
+
+static inline u32 _emit_WFE(unsigned dry_run, u8 buf[], u8 ev,
+		unsigned invalidate)
+{
+	if (dry_run)
+		return SZ_DMAWFE;
+
+	buf[0] = CMD_DMAWFE;
+
+	ev &= 0x1f;
+	ev <<= 3;
+	buf[1] = ev;
+
+	if (invalidate)
+		buf[1] |= (1 << 1);
+
+	PL330_DBGCMD_DUMP(SZ_DMAWFE, "\tDMAWFE %u%s\n",
+		ev >> 3, invalidate ? ", I" : "");
+
+	return SZ_DMAWFE;
+}
+
+static inline u32 _emit_WFP(unsigned dry_run, u8 buf[],
+		enum pl330_cond cond, u8 peri)
+{
+	if (dry_run)
+		return SZ_DMAWFP;
+
+	buf[0] = CMD_DMAWFP;
+
+	if (cond == SINGLE)
+		buf[0] |= (0 << 1) | (0 << 0);
+	else if (cond == BURST)
+		buf[0] |= (1 << 1) | (0 << 0);
+	else
+		buf[0] |= (0 << 1) | (1 << 0);
+
+	peri &= 0x1f;
+	peri <<= 3;
+	buf[1] = peri;
+
+	PL330_DBGCMD_DUMP(SZ_DMAWFP, "\tDMAWFP%c %u\n",
+		cond == SINGLE ? 'S' : (cond == BURST ? 'B' : 'P'), peri >> 3);
+
+	return SZ_DMAWFP;
+}
+
+static inline u32 _emit_WMB(unsigned dry_run, u8 buf[])
+{
+	if (dry_run)
+		return SZ_DMAWMB;
+
+	buf[0] = CMD_DMAWMB;
+
+	PL330_DBGCMD_DUMP(SZ_DMAWMB, "\tDMAWMB\n");
+
+	return SZ_DMAWMB;
+}
+
+struct _arg_GO {
+	u8 chan;
+	u32 addr;
+	unsigned ns;
+};
+
+static inline u32 _emit_GO(unsigned dry_run, u8 buf[],
+		const struct _arg_GO *arg)
+{
+	u8 chan = arg->chan;
+	u32 addr = arg->addr;
+	unsigned ns = arg->ns;
+
+	if (dry_run)
+		return SZ_DMAGO;
+
+	buf[0] = CMD_DMAGO;
+	buf[0] |= (ns << 1);
+
+	buf[1] = chan & 0x7;
+
+	*((u32 *)&buf[2]) = addr;
+
+	return SZ_DMAGO;
+}
+
+#define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)
+
+/* Returns Time-Out */
+static bool _until_dmac_idle(struct pl330_thread *thrd)
+{
+	void __iomem *regs = thrd->dmac->base;
+	unsigned long loops = msecs_to_loops(5);
+
+	do {
+		/* Until Manager is Idle */
+		if (!(readl(regs + DBGSTATUS) & DBG_BUSY))
+			break;
+
+		cpu_relax();
+	} while (--loops);
+
+	if (!loops)
+		return true;
+
+	return false;
+}
+
+static inline void _execute_DBGINSN(struct pl330_thread *thrd,
+		u8 insn[], bool as_manager)
+{
+	void __iomem *regs = thrd->dmac->base;
+	u32 val;
+
+	val = (insn[0] << 16) | (insn[1] << 24);
+	if (!as_manager) {
+		val |= (1 << 0);
+		val |= (thrd->id << 8); /* Channel Number */
+	}
+	writel(val, regs + DBGINST0);
+
+	val = *((u32 *)&insn[2]);
+	writel(val, regs + DBGINST1);
+
+	/* If timed out due to halted state-machine */
+	if (_until_dmac_idle(thrd)) {
+		dev_err(thrd->dmac->ddma.dev, "DMAC halted!\n");
+		return;
+	}
+
+	/* Get going */
+	writel(0, regs + DBGCMD);
+}
+
+static inline u32 _state(struct pl330_thread *thrd)
+{
+	void __iomem *regs = thrd->dmac->base;
+	u32 val;
+
+	if (is_manager(thrd))
+		val = readl(regs + DS) & 0xf;
+	else
+		val = readl(regs + CS(thrd->id)) & 0xf;
+
+	switch (val) {
+	case DS_ST_STOP:
+		return PL330_STATE_STOPPED;
+	case DS_ST_EXEC:
+		return PL330_STATE_EXECUTING;
+	case DS_ST_CMISS:
+		return PL330_STATE_CACHEMISS;
+	case DS_ST_UPDTPC:
+		return PL330_STATE_UPDTPC;
+	case DS_ST_WFE:
+		return PL330_STATE_WFE;
+	case DS_ST_FAULT:
+		return PL330_STATE_FAULTING;
+	case DS_ST_ATBRR:
+		if (is_manager(thrd))
+			return PL330_STATE_INVALID;
+		else
+			return PL330_STATE_ATBARRIER;
+	case DS_ST_QBUSY:
+		if (is_manager(thrd))
+			return PL330_STATE_INVALID;
+		else
+			return PL330_STATE_QUEUEBUSY;
+	case DS_ST_WFP:
+		if (is_manager(thrd))
+			return PL330_STATE_INVALID;
+		else
+			return PL330_STATE_WFP;
+	case DS_ST_KILL:
+		if (is_manager(thrd))
+			return PL330_STATE_INVALID;
+		else
+			return PL330_STATE_KILLING;
+	case DS_ST_CMPLT:
+		if (is_manager(thrd))
+			return PL330_STATE_INVALID;
+		else
+			return PL330_STATE_COMPLETING;
+	case DS_ST_FLTCMP:
+		if (is_manager(thrd))
+			return PL330_STATE_INVALID;
+		else
+			return PL330_STATE_FAULT_COMPLETING;
+	default:
+		return PL330_STATE_INVALID;
+	}
+}
+
+static void _stop(struct pl330_thread *thrd)
+{
+	void __iomem *regs = thrd->dmac->base;
+	u8 insn[6] = {0, 0, 0, 0, 0, 0};
+
+	if (_state(thrd) == PL330_STATE_FAULT_COMPLETING)
+		UNTIL(thrd, PL330_STATE_FAULTING | PL330_STATE_KILLING);
+
+	/* Return if nothing needs to be done */
+	if (_state(thrd) == PL330_STATE_COMPLETING
+		  || _state(thrd) == PL330_STATE_KILLING
+		  || _state(thrd) == PL330_STATE_STOPPED)
+		return;
+
+	_emit_KILL(0, insn);
+
+	/* Stop generating interrupts for SEV */
+	writel(readl(regs + INTEN) & ~(1 << thrd->ev), regs + INTEN);
+
+	_execute_DBGINSN(thrd, insn, is_manager(thrd));
+}
+
+/* Start doing req 'idx' of thread 'thrd' */
+static bool _trigger(struct pl330_thread *thrd)
+{
+	void __iomem *regs = thrd->dmac->base;
+	struct _pl330_req *req;
+	struct dma_pl330_desc *desc;
+	struct _arg_GO go;
+	unsigned ns;
+	u8 insn[6] = {0, 0, 0, 0, 0, 0};
+	int idx;
+
+	/* Return if already ACTIVE */
+	if (_state(thrd) != PL330_STATE_STOPPED)
+		return true;
+
+	idx = 1 - thrd->lstenq;
+	if (thrd->req[idx].desc != NULL) {
+		req = &thrd->req[idx];
+	} else {
+		idx = thrd->lstenq;
+		if (thrd->req[idx].desc != NULL)
+			req = &thrd->req[idx];
+		else
+			req = NULL;
+	}
+
+	/* Return if no request */
+	if (!req)
+		return true;
+
+	/* Return if req is running */
+	if (idx == thrd->req_running)
+		return true;
+
+	desc = req->desc;
+
+	ns = desc->rqcfg.nonsecure ? 1 : 0;
+
+	/* See 'Abort Sources' point-4 at Page 2-25 */
+	if (_manager_ns(thrd) && !ns)
+		dev_info(thrd->dmac->ddma.dev, "%s:%d Recipe for ABORT!\n",
+			__func__, __LINE__);
+
+	go.chan = thrd->id;
+	go.addr = req->mc_bus;
+	go.ns = ns;
+	_emit_GO(0, insn, &go);
+
+	/* Set to generate interrupts for SEV */
+	writel(readl(regs + INTEN) | (1 << thrd->ev), regs + INTEN);
+
+	/* Only manager can execute GO */
+	_execute_DBGINSN(thrd, insn, true);
+
+	thrd->req_running = idx;
+
+	return true;
+}
+
+static bool _start(struct pl330_thread *thrd)
+{
+	switch (_state(thrd)) {
+	case PL330_STATE_FAULT_COMPLETING:
+		UNTIL(thrd, PL330_STATE_FAULTING | PL330_STATE_KILLING);
+
+		if (_state(thrd) == PL330_STATE_KILLING)
+			UNTIL(thrd, PL330_STATE_STOPPED)
+
+	case PL330_STATE_FAULTING:
+		_stop(thrd);
+
+	case PL330_STATE_KILLING:
+	case PL330_STATE_COMPLETING:
+		UNTIL(thrd, PL330_STATE_STOPPED)
+
+	case PL330_STATE_STOPPED:
+		return _trigger(thrd);
+
+	case PL330_STATE_WFP:
+	case PL330_STATE_QUEUEBUSY:
+	case PL330_STATE_ATBARRIER:
+	case PL330_STATE_UPDTPC:
+	case PL330_STATE_CACHEMISS:
+	case PL330_STATE_EXECUTING:
+		return true;
+
+	case PL330_STATE_WFE: /* For RESUME, nothing yet */
+	default:
+		return false;
+	}
+}
+
+static inline int _ldst_memtomem(unsigned dry_run, u8 buf[],
+		const struct _xfer_spec *pxs, int cyc)
+{
+	int off = 0;
+	struct pl330_config *pcfg = pxs->desc->rqcfg.pcfg;
+
+	/* check lock-up free version */
+	if (get_revision(pcfg->periph_id) >= PERIPH_REV_R1P0) {
+		while (cyc--) {
+			off += _emit_LD(dry_run, &buf[off], ALWAYS);
+			off += _emit_ST(dry_run, &buf[off], ALWAYS);
+		}
+	} else {
+		while (cyc--) {
+			off += _emit_LD(dry_run, &buf[off], ALWAYS);
+			off += _emit_RMB(dry_run, &buf[off]);
+			off += _emit_ST(dry_run, &buf[off], ALWAYS);
+			off += _emit_WMB(dry_run, &buf[off]);
+		}
+	}
+
+	return off;
+}
+
+static inline int _ldst_devtomem(unsigned dry_run, u8 buf[],
+		const struct _xfer_spec *pxs, int cyc)
+{
+	int off = 0;
+
+	while (cyc--) {
+		off += _emit_WFP(dry_run, &buf[off], SINGLE, pxs->desc->peri);
+		off += _emit_LDP(dry_run, &buf[off], SINGLE, pxs->desc->peri);
+		off += _emit_ST(dry_run, &buf[off], ALWAYS);
+		off += _emit_FLUSHP(dry_run, &buf[off], pxs->desc->peri);
+	}
+
+	return off;
+}
+
+static inline int _ldst_memtodev(unsigned dry_run, u8 buf[],
+		const struct _xfer_spec *pxs, int cyc)
+{
+	int off = 0;
+
+	while (cyc--) {
+		off += _emit_WFP(dry_run, &buf[off], SINGLE, pxs->desc->peri);
+		off += _emit_LD(dry_run, &buf[off], ALWAYS);
+		off += _emit_STP(dry_run, &buf[off], SINGLE, pxs->desc->peri);
+		off += _emit_FLUSHP(dry_run, &buf[off], pxs->desc->peri);
+	}
+
+	return off;
+}
+
+static int _bursts(unsigned dry_run, u8 buf[],
+		const struct _xfer_spec *pxs, int cyc)
+{
+	int off = 0;
+
+	switch (pxs->desc->rqtype) {
+	case DMA_MEM_TO_DEV:
+		off += _ldst_memtodev(dry_run, &buf[off], pxs, cyc);
+		break;
+	case DMA_DEV_TO_MEM:
+		off += _ldst_devtomem(dry_run, &buf[off], pxs, cyc);
+		break;
+	case DMA_MEM_TO_MEM:
+		off += _ldst_memtomem(dry_run, &buf[off], pxs, cyc);
+		break;
+	default:
+		off += 0x40000000; /* Scare off the Client */
+		break;
+	}
+
+	return off;
+}
+
+/* Returns bytes consumed and updates bursts */
+static inline int _loop(unsigned dry_run, u8 buf[],
+		unsigned long *bursts, const struct _xfer_spec *pxs)
+{
+	int cyc, cycmax, szlp, szlpend, szbrst, off;
+	unsigned lcnt0, lcnt1, ljmp0, ljmp1;
+	struct _arg_LPEND lpend;
+
+	if (*bursts == 1)
+		return _bursts(dry_run, buf, pxs, 1);
+
+	/* Max iterations possible in DMALP is 256 */
+	if (*bursts >= 256*256) {
+		lcnt1 = 256;
+		lcnt0 = 256;
+		cyc = *bursts / lcnt1 / lcnt0;
+	} else if (*bursts > 256) {
+		lcnt1 = 256;
+		lcnt0 = *bursts / lcnt1;
+		cyc = 1;
+	} else {
+		lcnt1 = *bursts;
+		lcnt0 = 0;
+		cyc = 1;
+	}
+
+	szlp = _emit_LP(1, buf, 0, 0);
+	szbrst = _bursts(1, buf, pxs, 1);
+
+	lpend.cond = ALWAYS;
+	lpend.forever = false;
+	lpend.loop = 0;
+	lpend.bjump = 0;
+	szlpend = _emit_LPEND(1, buf, &lpend);
+
+	if (lcnt0) {
+		szlp *= 2;
+		szlpend *= 2;
+	}
+
+	/*
+	 * Max bursts that we can unroll due to limit on the
+	 * size of backward jump that can be encoded in DMALPEND
+	 * which is 8-bits and hence 255
+	 */
+	cycmax = (255 - (szlp + szlpend)) / szbrst;
+
+	cyc = (cycmax < cyc) ? cycmax : cyc;
+
+	off = 0;
+
+	if (lcnt0) {
+		off += _emit_LP(dry_run, &buf[off], 0, lcnt0);
+		ljmp0 = off;
+	}
+
+	off += _emit_LP(dry_run, &buf[off], 1, lcnt1);
+	ljmp1 = off;
+
+	off += _bursts(dry_run, &buf[off], pxs, cyc);
+
+	lpend.cond = ALWAYS;
+	lpend.forever = false;
+	lpend.loop = 1;
+	lpend.bjump = off - ljmp1;
+	off += _emit_LPEND(dry_run, &buf[off], &lpend);
+
+	if (lcnt0) {
+		lpend.cond = ALWAYS;
+		lpend.forever = false;
+		lpend.loop = 0;
+		lpend.bjump = off - ljmp0;
+		off += _emit_LPEND(dry_run, &buf[off], &lpend);
+	}
+
+	*bursts = lcnt1 * cyc;
+	if (lcnt0)
+		*bursts *= lcnt0;
+
+	return off;
+}
+
+static inline int _setup_loops(unsigned dry_run, u8 buf[],
+		const struct _xfer_spec *pxs)
+{
+	struct pl330_xfer *x = &pxs->desc->px;
+	u32 ccr = pxs->ccr;
+	unsigned long c, bursts = BYTE_TO_BURST(x->bytes, ccr);
+	int off = 0;
+
+	while (bursts) {
+		c = bursts;
+		off += _loop(dry_run, &buf[off], &c, pxs);
+		bursts -= c;
+	}
+
+	return off;
+}
+
+static inline int _setup_xfer(unsigned dry_run, u8 buf[],
+		const struct _xfer_spec *pxs)
+{
+	struct pl330_xfer *x = &pxs->desc->px;
+	int off = 0;
+
+	/* DMAMOV SAR, x->src_addr */
+	off += _emit_MOV(dry_run, &buf[off], SAR, x->src_addr);
+	/* DMAMOV DAR, x->dst_addr */
+	off += _emit_MOV(dry_run, &buf[off], DAR, x->dst_addr);
+
+	/* Setup Loop(s) */
+	off += _setup_loops(dry_run, &buf[off], pxs);
+
+	return off;
+}
+
+/*
+ * A req is a sequence of one or more xfer units.
+ * Returns the number of bytes taken to setup the MC for the req.
+ */
+static int _setup_req(unsigned dry_run, struct pl330_thread *thrd,
+		unsigned index, struct _xfer_spec *pxs)
+{
+	struct _pl330_req *req = &thrd->req[index];
+	struct pl330_xfer *x;
+	u8 *buf = req->mc_cpu;
+	int off = 0;
+
+	PL330_DBGMC_START(req->mc_bus);
+
+	/* DMAMOV CCR, ccr */
+	off += _emit_MOV(dry_run, &buf[off], CCR, pxs->ccr);
+
+	x = &pxs->desc->px;
+	/* Error if xfer length is not aligned at burst size */
+	if (x->bytes % (BRST_SIZE(pxs->ccr) * BRST_LEN(pxs->ccr)))
+		return -EINVAL;
+
+	off += _setup_xfer(dry_run, &buf[off], pxs);
+
+	/* DMASEV peripheral/event */
+	off += _emit_SEV(dry_run, &buf[off], thrd->ev);
+	/* DMAEND */
+	off += _emit_END(dry_run, &buf[off]);
+
+	return off;
+}
+
+static inline u32 _prepare_ccr(const struct pl330_reqcfg *rqc)
+{
+	u32 ccr = 0;
+
+	if (rqc->src_inc)
+		ccr |= CC_SRCINC;
+
+	if (rqc->dst_inc)
+		ccr |= CC_DSTINC;
+
+	/* We set same protection levels for Src and DST for now */
+	if (rqc->privileged)
+		ccr |= CC_SRCPRI | CC_DSTPRI;
+	if (rqc->nonsecure)
+		ccr |= CC_SRCNS | CC_DSTNS;
+	if (rqc->insnaccess)
+		ccr |= CC_SRCIA | CC_DSTIA;
+
+	ccr |= (((rqc->brst_len - 1) & 0xf) << CC_SRCBRSTLEN_SHFT);
+	ccr |= (((rqc->brst_len - 1) & 0xf) << CC_DSTBRSTLEN_SHFT);
+
+	ccr |= (rqc->brst_size << CC_SRCBRSTSIZE_SHFT);
+	ccr |= (rqc->brst_size << CC_DSTBRSTSIZE_SHFT);
+
+	ccr |= (rqc->scctl << CC_SRCCCTRL_SHFT);
+	ccr |= (rqc->dcctl << CC_DSTCCTRL_SHFT);
+
+	ccr |= (rqc->swap << CC_SWAP_SHFT);
+
+	return ccr;
+}
+
+/*
+ * Submit a list of xfers after which the client wants notification.
+ * Client is not notified after each xfer unit, just once after all
+ * xfer units are done or some error occurs.
+ */
+static int pl330_submit_req(struct pl330_thread *thrd,
+	struct dma_pl330_desc *desc)
+{
+	struct pl330_dmac *pl330 = thrd->dmac;
+	struct _xfer_spec xs;
+	unsigned long flags;
+	unsigned idx;
+	u32 ccr;
+	int ret = 0;
+
+	if (pl330->state == DYING
+		|| pl330->dmac_tbd.reset_chan & (1 << thrd->id)) {
+		dev_info(thrd->dmac->ddma.dev, "%s:%d\n",
+			__func__, __LINE__);
+		return -EAGAIN;
+	}
+
+	/* If request for non-existing peripheral */
+	if (desc->rqtype != DMA_MEM_TO_MEM &&
+	    desc->peri >= pl330->pcfg.num_peri) {
+		dev_info(thrd->dmac->ddma.dev,
+				"%s:%d Invalid peripheral(%u)!\n",
+				__func__, __LINE__, desc->peri);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&pl330->lock, flags);
+
+	if (_queue_full(thrd)) {
+		ret = -EAGAIN;
+		goto xfer_exit;
+	}
+
+	/* Prefer Secure Channel */
+	if (!_manager_ns(thrd))
+		desc->rqcfg.nonsecure = 0;
+	else
+		desc->rqcfg.nonsecure = 1;
+
+	ccr = _prepare_ccr(&desc->rqcfg);
+
+	idx = thrd->req[0].desc == NULL ? 0 : 1;
+
+	xs.ccr = ccr;
+	xs.desc = desc;
+
+	/* First dry run to check if req is acceptable */
+	ret = _setup_req(1, thrd, idx, &xs);
+	if (ret < 0)
+		goto xfer_exit;
+
+	if (ret > pl330->mcbufsz / 2) {
+		dev_info(pl330->ddma.dev, "%s:%d Trying increasing mcbufsz\n",
+				__func__, __LINE__);
+		ret = -ENOMEM;
+		goto xfer_exit;
+	}
+
+	/* Hook the request */
+	thrd->lstenq = idx;
+	thrd->req[idx].desc = desc;
+	_setup_req(0, thrd, idx, &xs);
+
+	ret = 0;
+
+xfer_exit:
+	spin_unlock_irqrestore(&pl330->lock, flags);
+
+	return ret;
+}
+
+static void dma_pl330_rqcb(struct dma_pl330_desc *desc, enum pl330_op_err err)
+{
+	struct dma_pl330_chan *pch;
+	unsigned long flags;
+
+	if (!desc)
+		return;
+
+	pch = desc->pchan;
+
+	/* If desc aborted */
+	if (!pch)
+		return;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	desc->status = DONE;
+
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+	tasklet_schedule(&pch->task);
+}
+
+static void pl330_dotask(unsigned long data)
+{
+	struct pl330_dmac *pl330 = (struct pl330_dmac *) data;
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&pl330->lock, flags);
+
+	/* The DMAC itself gone nuts */
+	if (pl330->dmac_tbd.reset_dmac) {
+		pl330->state = DYING;
+		/* Reset the manager too */
+		pl330->dmac_tbd.reset_mngr = true;
+		/* Clear the reset flag */
+		pl330->dmac_tbd.reset_dmac = false;
+	}
+
+	if (pl330->dmac_tbd.reset_mngr) {
+		_stop(pl330->manager);
+		/* Reset all channels */
+		pl330->dmac_tbd.reset_chan = (1 << pl330->pcfg.num_chan) - 1;
+		/* Clear the reset flag */
+		pl330->dmac_tbd.reset_mngr = false;
+	}
+
+	for (i = 0; i < pl330->pcfg.num_chan; i++) {
+
+		if (pl330->dmac_tbd.reset_chan & (1 << i)) {
+			struct pl330_thread *thrd = &pl330->channels[i];
+			void __iomem *regs = pl330->base;
+			enum pl330_op_err err;
+
+			_stop(thrd);
+
+			if (readl(regs + FSC) & (1 << thrd->id))
+				err = PL330_ERR_FAIL;
+			else
+				err = PL330_ERR_ABORT;
+
+			spin_unlock_irqrestore(&pl330->lock, flags);
+			dma_pl330_rqcb(thrd->req[1 - thrd->lstenq].desc, err);
+			dma_pl330_rqcb(thrd->req[thrd->lstenq].desc, err);
+			spin_lock_irqsave(&pl330->lock, flags);
+
+			thrd->req[0].desc = NULL;
+			thrd->req[1].desc = NULL;
+			thrd->req_running = -1;
+
+			/* Clear the reset flag */
+			pl330->dmac_tbd.reset_chan &= ~(1 << i);
+		}
+	}
+
+	spin_unlock_irqrestore(&pl330->lock, flags);
+
+	return;
+}
+
+/* Returns 1 if state was updated, 0 otherwise */
+static int pl330_update(struct pl330_dmac *pl330)
+{
+	struct dma_pl330_desc *descdone, *tmp;
+	unsigned long flags;
+	void __iomem *regs;
+	u32 val;
+	int id, ev, ret = 0;
+
+	regs = pl330->base;
+
+	spin_lock_irqsave(&pl330->lock, flags);
+
+	val = readl(regs + FSM) & 0x1;
+	if (val)
+		pl330->dmac_tbd.reset_mngr = true;
+	else
+		pl330->dmac_tbd.reset_mngr = false;
+
+	val = readl(regs + FSC) & ((1 << pl330->pcfg.num_chan) - 1);
+	pl330->dmac_tbd.reset_chan |= val;
+	if (val) {
+		int i = 0;
+		while (i < pl330->pcfg.num_chan) {
+			if (val & (1 << i)) {
+				dev_info(pl330->ddma.dev,
+					"Reset Channel-%d\t CS-%x FTC-%x\n",
+						i, readl(regs + CS(i)),
+						readl(regs + FTC(i)));
+				_stop(&pl330->channels[i]);
+			}
+			i++;
+		}
+	}
+
+	/* Check which event happened i.e, thread notified */
+	val = readl(regs + ES);
+	if (pl330->pcfg.num_events < 32
+			&& val & ~((1 << pl330->pcfg.num_events) - 1)) {
+		pl330->dmac_tbd.reset_dmac = true;
+		dev_err(pl330->ddma.dev, "%s:%d Unexpected!\n", __func__,
+			__LINE__);
+		ret = 1;
+		goto updt_exit;
+	}
+
+	for (ev = 0; ev < pl330->pcfg.num_events; ev++) {
+		if (val & (1 << ev)) { /* Event occurred */
+			struct pl330_thread *thrd;
+			u32 inten = readl(regs + INTEN);
+			int active;
+
+			/* Clear the event */
+			if (inten & (1 << ev))
+				writel(1 << ev, regs + INTCLR);
+
+			ret = 1;
+
+			id = pl330->events[ev];
+
+			thrd = &pl330->channels[id];
+
+			active = thrd->req_running;
+			if (active == -1) /* Aborted */
+				continue;
+
+			/* Detach the req */
+			descdone = thrd->req[active].desc;
+			thrd->req[active].desc = NULL;
+
+			thrd->req_running = -1;
+
+			/* Get going again ASAP */
+			_start(thrd);
+
+			/* For now, just make a list of callbacks to be done */
+			list_add_tail(&descdone->rqd, &pl330->req_done);
+		}
+	}
+
+	/* Now that we are in no hurry, do the callbacks */
+	list_for_each_entry_safe(descdone, tmp, &pl330->req_done, rqd) {
+		list_del(&descdone->rqd);
+		spin_unlock_irqrestore(&pl330->lock, flags);
+		dma_pl330_rqcb(descdone, PL330_ERR_NONE);
+		spin_lock_irqsave(&pl330->lock, flags);
+	}
+
+updt_exit:
+	spin_unlock_irqrestore(&pl330->lock, flags);
+
+	if (pl330->dmac_tbd.reset_dmac
+			|| pl330->dmac_tbd.reset_mngr
+			|| pl330->dmac_tbd.reset_chan) {
+		ret = 1;
+		tasklet_schedule(&pl330->tasks);
+	}
+
+	return ret;
+}
+
+/* Reserve an event */
+static inline int _alloc_event(struct pl330_thread *thrd)
+{
+	struct pl330_dmac *pl330 = thrd->dmac;
+	int ev;
+
+	for (ev = 0; ev < pl330->pcfg.num_events; ev++)
+		if (pl330->events[ev] == -1) {
+			pl330->events[ev] = thrd->id;
+			return ev;
+		}
+
+	return -1;
+}
+
+static bool _chan_ns(const struct pl330_dmac *pl330, int i)
+{
+	return pl330->pcfg.irq_ns & (1 << i);
+}
+
+/* Upon success, returns IdentityToken for the
+ * allocated channel, NULL otherwise.
+ */
+static struct pl330_thread *pl330_request_channel(struct pl330_dmac *pl330)
+{
+	struct pl330_thread *thrd = NULL;
+	unsigned long flags;
+	int chans, i;
+
+	if (pl330->state == DYING)
+		return NULL;
+
+	chans = pl330->pcfg.num_chan;
+
+	spin_lock_irqsave(&pl330->lock, flags);
+
+	for (i = 0; i < chans; i++) {
+		thrd = &pl330->channels[i];
+		if ((thrd->free) && (!_manager_ns(thrd) ||
+					_chan_ns(pl330, i))) {
+			thrd->ev = _alloc_event(thrd);
+			if (thrd->ev >= 0) {
+				thrd->free = false;
+				thrd->lstenq = 1;
+				thrd->req[0].desc = NULL;
+				thrd->req[1].desc = NULL;
+				thrd->req_running = -1;
+				break;
+			}
+		}
+		thrd = NULL;
+	}
+
+	spin_unlock_irqrestore(&pl330->lock, flags);
+
+	return thrd;
+}
+
+/* Release an event */
+static inline void _free_event(struct pl330_thread *thrd, int ev)
+{
+	struct pl330_dmac *pl330 = thrd->dmac;
+
+	/* If the event is valid and was held by the thread */
+	if (ev >= 0 && ev < pl330->pcfg.num_events
+			&& pl330->events[ev] == thrd->id)
+		pl330->events[ev] = -1;
+}
+
+static void pl330_release_channel(struct pl330_thread *thrd)
+{
+	struct pl330_dmac *pl330;
+	unsigned long flags;
+
+	if (!thrd || thrd->free)
+		return;
+
+	_stop(thrd);
+
+	dma_pl330_rqcb(thrd->req[1 - thrd->lstenq].desc, PL330_ERR_ABORT);
+	dma_pl330_rqcb(thrd->req[thrd->lstenq].desc, PL330_ERR_ABORT);
+
+	pl330 = thrd->dmac;
+
+	spin_lock_irqsave(&pl330->lock, flags);
+	_free_event(thrd, thrd->ev);
+	thrd->free = true;
+	spin_unlock_irqrestore(&pl330->lock, flags);
+}
+
+/* Initialize the structure for PL330 configuration, that can be used
+ * by the client driver the make best use of the DMAC
+ */
+static void read_dmac_config(struct pl330_dmac *pl330)
+{
+	void __iomem *regs = pl330->base;
+	u32 val;
+
+	val = readl(regs + CRD) >> CRD_DATA_WIDTH_SHIFT;
+	val &= CRD_DATA_WIDTH_MASK;
+	pl330->pcfg.data_bus_width = 8 * (1 << val);
+
+	val = readl(regs + CRD) >> CRD_DATA_BUFF_SHIFT;
+	val &= CRD_DATA_BUFF_MASK;
+	pl330->pcfg.data_buf_dep = val + 1;
+
+	val = readl(regs + CR0) >> CR0_NUM_CHANS_SHIFT;
+	val &= CR0_NUM_CHANS_MASK;
+	val += 1;
+	pl330->pcfg.num_chan = val;
+
+	val = readl(regs + CR0);
+	if (val & CR0_PERIPH_REQ_SET) {
+		val = (val >> CR0_NUM_PERIPH_SHIFT) & CR0_NUM_PERIPH_MASK;
+		val += 1;
+		pl330->pcfg.num_peri = val;
+		pl330->pcfg.peri_ns = readl(regs + CR4);
+	} else {
+		pl330->pcfg.num_peri = 0;
+	}
+
+	val = readl(regs + CR0);
+	if (val & CR0_BOOT_MAN_NS)
+		pl330->pcfg.mode |= DMAC_MODE_NS;
+	else
+		pl330->pcfg.mode &= ~DMAC_MODE_NS;
+
+	val = readl(regs + CR0) >> CR0_NUM_EVENTS_SHIFT;
+	val &= CR0_NUM_EVENTS_MASK;
+	val += 1;
+	pl330->pcfg.num_events = val;
+
+	pl330->pcfg.irq_ns = readl(regs + CR3);
+}
+
+static inline void _reset_thread(struct pl330_thread *thrd)
+{
+	struct pl330_dmac *pl330 = thrd->dmac;
+
+	thrd->req[0].mc_cpu = pl330->mcode_cpu
+				+ (thrd->id * pl330->mcbufsz);
+	thrd->req[0].mc_bus = pl330->mcode_bus
+				+ (thrd->id * pl330->mcbufsz);
+	thrd->req[0].desc = NULL;
+
+	thrd->req[1].mc_cpu = thrd->req[0].mc_cpu
+				+ pl330->mcbufsz / 2;
+	thrd->req[1].mc_bus = thrd->req[0].mc_bus
+				+ pl330->mcbufsz / 2;
+	thrd->req[1].desc = NULL;
+
+	thrd->req_running = -1;
+}
+
+static int dmac_alloc_threads(struct pl330_dmac *pl330)
+{
+	int chans = pl330->pcfg.num_chan;
+	struct pl330_thread *thrd;
+	int i;
+
+	/* Allocate 1 Manager and 'chans' Channel threads */
+	pl330->channels = kzalloc((1 + chans) * sizeof(*thrd),
+					GFP_KERNEL);
+	if (!pl330->channels)
+		return -ENOMEM;
+
+	/* Init Channel threads */
+	for (i = 0; i < chans; i++) {
+		thrd = &pl330->channels[i];
+		thrd->id = i;
+		thrd->dmac = pl330;
+		_reset_thread(thrd);
+		thrd->free = true;
+	}
+
+	/* MANAGER is indexed at the end */
+	thrd = &pl330->channels[chans];
+	thrd->id = chans;
+	thrd->dmac = pl330;
+	thrd->free = false;
+	pl330->manager = thrd;
+
+	return 0;
+}
+
+static int dmac_alloc_resources(struct pl330_dmac *pl330)
+{
+	int chans = pl330->pcfg.num_chan;
+	int ret;
+
+	/*
+	 * Alloc MicroCode buffer for 'chans' Channel threads.
+	 * A channel's buffer offset is (Channel_Id * MCODE_BUFF_PERCHAN)
+	 */
+	pl330->mcode_cpu = dma_alloc_coherent(pl330->ddma.dev,
+				chans * pl330->mcbufsz,
+				&pl330->mcode_bus, GFP_KERNEL);
+	if (!pl330->mcode_cpu) {
+		dev_err(pl330->ddma.dev, "%s:%d Can't allocate memory!\n",
+			__func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	ret = dmac_alloc_threads(pl330);
+	if (ret) {
+		dev_err(pl330->ddma.dev, "%s:%d Can't to create channels for DMAC!\n",
+			__func__, __LINE__);
+		dma_free_coherent(pl330->ddma.dev,
+				chans * pl330->mcbufsz,
+				pl330->mcode_cpu, pl330->mcode_bus);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int pl330_add(struct pl330_dmac *pl330)
+{
+	void __iomem *regs;
+	int i, ret;
+
+	regs = pl330->base;
+
+#if 0
+	/* Check if we can handle this DMAC */
+	if ((pl330->pcfg.periph_id & 0xfffff) != PERIPH_ID_VAL) {
+		dev_err(pl330->ddma.dev, "PERIPH_ID 0x%x !\n",
+			pl330->pcfg.periph_id);
+		return -EINVAL;
+	}
+#endif
+
+	/* Read the configuration of the DMAC */
+	read_dmac_config(pl330);
+
+	if (pl330->pcfg.num_events == 0) {
+		dev_err(pl330->ddma.dev, "%s:%d Can't work without events!\n",
+			__func__, __LINE__);
+		return -EINVAL;
+	}
+
+	spin_lock_init(&pl330->lock);
+
+	INIT_LIST_HEAD(&pl330->req_done);
+
+	/* Use default MC buffer size if not provided */
+	if (!pl330->mcbufsz)
+		pl330->mcbufsz = MCODE_BUFF_PER_REQ * 2;
+
+	/* Mark all events as free */
+	for (i = 0; i < pl330->pcfg.num_events; i++)
+		pl330->events[i] = -1;
+
+	/* Allocate resources needed by the DMAC */
+	ret = dmac_alloc_resources(pl330);
+	if (ret) {
+		dev_err(pl330->ddma.dev, "Unable to create channels for DMAC\n");
+		return ret;
+	}
+
+	tasklet_init(&pl330->tasks, pl330_dotask, (unsigned long) pl330);
+
+	pl330->state = INIT;
+
+	return 0;
+}
+
+static int dmac_free_threads(struct pl330_dmac *pl330)
+{
+	struct pl330_thread *thrd;
+	int i;
+
+	/* Release Channel threads */
+	for (i = 0; i < pl330->pcfg.num_chan; i++) {
+		thrd = &pl330->channels[i];
+		pl330_release_channel(thrd);
+	}
+
+	/* Free memory */
+	kfree(pl330->channels);
+
+	return 0;
+}
+
+static void pl330_del(struct pl330_dmac *pl330)
+{
+	pl330->state = UNINIT;
+
+	tasklet_kill(&pl330->tasks);
+
+	/* Free DMAC resources */
+	dmac_free_threads(pl330);
+
+	dma_free_coherent(pl330->ddma.dev,
+		pl330->pcfg.num_chan * pl330->mcbufsz, pl330->mcode_cpu,
+		pl330->mcode_bus);
+}
+
+/* forward declaration */
+static struct platform_driver pl330_driver;
+
+static inline struct dma_pl330_chan *
+to_pchan(struct dma_chan *ch)
+{
+	if (!ch)
+		return NULL;
+
+	return container_of(ch, struct dma_pl330_chan, chan);
+}
+
+static inline struct dma_pl330_desc *
+to_desc(struct dma_async_tx_descriptor *tx)
+{
+	return container_of(tx, struct dma_pl330_desc, txd);
+}
+
+static inline void fill_queue(struct dma_pl330_chan *pch)
+{
+	struct dma_pl330_desc *desc;
+	int ret;
+
+	list_for_each_entry(desc, &pch->work_list, node) {
+
+		/* If already submitted */
+		if (desc->status == BUSY)
+			continue;
+
+		ret = pl330_submit_req(pch->thread, desc);
+		if (!ret) {
+			desc->status = BUSY;
+		} else if (ret == -EAGAIN) {
+			/* QFull or DMAC Dying */
+			break;
+		} else {
+			/* Unacceptable request */
+			desc->status = DONE;
+			dev_err(pch->dmac->ddma.dev, "%s:%d Bad Desc(%d)\n",
+					__func__, __LINE__, desc->txd.cookie);
+			tasklet_schedule(&pch->task);
+		}
+	}
+}
+
+static void pl330_tasklet(unsigned long data)
+{
+	struct dma_pl330_chan *pch = (struct dma_pl330_chan *)data;
+	struct dma_pl330_desc *desc, *_dt;
+	unsigned long flags;
+	bool power_down = false;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	/* Pick up ripe tomatoes */
+	list_for_each_entry_safe(desc, _dt, &pch->work_list, node)
+		if (desc->status == DONE) {
+			if (!pch->cyclic)
+				dma_cookie_complete(&desc->txd);
+			list_move_tail(&desc->node, &pch->completed_list);
+		}
+
+	/* Try to submit a req imm. next to the last completed cookie */
+	fill_queue(pch);
+
+	if (list_empty(&pch->work_list)) {
+		spin_lock(&pch->thread->dmac->lock);
+		_stop(pch->thread);
+		spin_unlock(&pch->thread->dmac->lock);
+		power_down = true;
+	} else {
+		/* Make sure the PL330 Channel thread is active */
+		spin_lock(&pch->thread->dmac->lock);
+		_start(pch->thread);
+		spin_unlock(&pch->thread->dmac->lock);
+	}
+
+	while (!list_empty(&pch->completed_list)) {
+		dma_async_tx_callback callback;
+		void *callback_param;
+
+		desc = list_first_entry(&pch->completed_list,
+					struct dma_pl330_desc, node);
+
+		callback = desc->txd.callback;
+		callback_param = desc->txd.callback_param;
+
+		if (pch->cyclic) {
+			desc->status = PREP;
+			list_move_tail(&desc->node, &pch->work_list);
+			if (power_down) {
+				spin_lock(&pch->thread->dmac->lock);
+				_start(pch->thread);
+				spin_unlock(&pch->thread->dmac->lock);
+				power_down = false;
+			}
+		} else {
+			desc->status = FREE;
+			list_move_tail(&desc->node, &pch->dmac->desc_pool);
+		}
+
+		dma_descriptor_unmap(&desc->txd);
+
+		if (callback) {
+			spin_unlock_irqrestore(&pch->lock, flags);
+			callback(callback_param);
+			spin_lock_irqsave(&pch->lock, flags);
+		}
+	}
+	spin_unlock_irqrestore(&pch->lock, flags);
+}
+
+bool pl330_filter(struct dma_chan *chan, void *param)
+{
+	u8 *peri_id;
+
+	if (chan->device->dev->driver != &pl330_driver.driver)
+		return false;
+
+	peri_id = chan->private;
+	return *peri_id == (unsigned long)param;
+}
+EXPORT_SYMBOL(pl330_filter);
+
+static struct dma_chan *of_dma_pl330_xlate(struct of_phandle_args *dma_spec,
+						struct of_dma *ofdma)
+{
+	int count = dma_spec->args_count;
+	struct pl330_dmac *pl330 = ofdma->of_dma_data;
+	unsigned int chan_id;
+
+	if (!pl330)
+		return NULL;
+
+	if (count != 1)
+		return NULL;
+
+	chan_id = dma_spec->args[0];
+	if (chan_id >= pl330->num_peripherals)
+		return NULL;
+
+	return dma_get_slave_channel(&pl330->peripherals[chan_id].chan);
+}
+
+static int pl330_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	struct pl330_dmac *pl330 = pch->dmac;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	dma_cookie_init(chan);
+	pch->cyclic = false;
+
+	pch->thread = pl330_request_channel(pl330);
+	if (!pch->thread) {
+		spin_unlock_irqrestore(&pch->lock, flags);
+		return -ENOMEM;
+	}
+
+	tasklet_init(&pch->task, pl330_tasklet, (unsigned long) pch);
+
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+	return 1;
+}
+
+static int pl330_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd, unsigned long arg)
+{
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	struct dma_pl330_desc *desc;
+	unsigned long flags;
+	struct pl330_dmac *pl330 = pch->dmac;
+	struct dma_slave_config *slave_config;
+	LIST_HEAD(list);
+
+	switch (cmd) {
+	case DMA_TERMINATE_ALL:
+		spin_lock_irqsave(&pch->lock, flags);
+
+		spin_lock(&pl330->lock);
+		_stop(pch->thread);
+		spin_unlock(&pl330->lock);
+
+		pch->thread->req[0].desc = NULL;
+		pch->thread->req[1].desc = NULL;
+		pch->thread->req_running = -1;
+
+		/* Mark all desc done */
+		list_for_each_entry(desc, &pch->submitted_list, node) {
+			desc->status = FREE;
+			dma_cookie_complete(&desc->txd);
+		}
+
+		list_for_each_entry(desc, &pch->work_list , node) {
+			desc->status = FREE;
+			dma_cookie_complete(&desc->txd);
+		}
+
+		list_for_each_entry(desc, &pch->completed_list , node) {
+			desc->status = FREE;
+			dma_cookie_complete(&desc->txd);
+		}
+
+		list_splice_tail_init(&pch->submitted_list, &pl330->desc_pool);
+		list_splice_tail_init(&pch->work_list, &pl330->desc_pool);
+		list_splice_tail_init(&pch->completed_list, &pl330->desc_pool);
+		spin_unlock_irqrestore(&pch->lock, flags);
+		break;
+	case DMA_SLAVE_CONFIG:
+		slave_config = (struct dma_slave_config *)arg;
+
+		if (slave_config->direction == DMA_MEM_TO_DEV) {
+			if (slave_config->dst_addr)
+				pch->fifo_addr = slave_config->dst_addr;
+			if (slave_config->dst_addr_width)
+				pch->burst_sz = __ffs(slave_config->dst_addr_width);
+			if (slave_config->dst_maxburst)
+				pch->burst_len = slave_config->dst_maxburst;
+		} else if (slave_config->direction == DMA_DEV_TO_MEM) {
+			if (slave_config->src_addr)
+				pch->fifo_addr = slave_config->src_addr;
+			if (slave_config->src_addr_width)
+				pch->burst_sz = __ffs(slave_config->src_addr_width);
+			if (slave_config->src_maxburst)
+				pch->burst_len = slave_config->src_maxburst;
+		}
+		break;
+	default:
+		dev_err(pch->dmac->ddma.dev, "Not supported command.\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void pl330_free_chan_resources(struct dma_chan *chan)
+{
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	unsigned long flags;
+
+	tasklet_kill(&pch->task);
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	pl330_release_channel(pch->thread);
+	pch->thread = NULL;
+
+	if (pch->cyclic)
+		list_splice_tail_init(&pch->work_list, &pch->dmac->desc_pool);
+
+	spin_unlock_irqrestore(&pch->lock, flags);
+}
+
+static int pl330_get_current_xferred_count(struct dma_pl330_chan *pch,
+					   struct dma_pl330_desc *desc)
+{
+	struct pl330_thread *thrd = pch->thread;
+	void __iomem *regs = thrd->dmac->base;
+	u32 val, addr;
+
+	val = addr = 0;
+	if (desc->rqcfg.src_inc) {
+		val = readl(regs + SA(thrd->id));
+		addr = desc->px.src_addr;
+	} else {
+		val = readl(regs + DA(thrd->id));
+		addr = desc->px.dst_addr;
+	}
+
+	return val - addr;
+}
+
+static enum dma_status
+pl330_tx_status(struct dma_chan *chan, dma_cookie_t cookie,
+		 struct dma_tx_state *txstate)
+{
+	enum dma_status ret;
+	unsigned long flags;
+	struct dma_pl330_desc *desc, *running = NULL;
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	unsigned int transferred, residual = 0;
+
+	ret = dma_cookie_status(chan, cookie, txstate);
+
+	if (!txstate)
+		return ret;
+
+	if (ret == DMA_COMPLETE)
+		goto out;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	if (pch->thread->req_running != -1)
+		running = pch->thread->req[pch->thread->req_running].desc;
+
+	/* Check in pending list */
+	list_for_each_entry(desc, &pch->work_list, node) {
+		if (desc->status == DONE)
+			transferred = desc->bytes_requested;
+		else if (running && desc == running)
+			transferred =
+				pl330_get_current_xferred_count(pch, desc);
+		else
+			transferred = 0;
+		residual += desc->bytes_requested - transferred;
+		if (desc->txd.cookie == cookie) {
+			switch (desc->status) {
+			case DONE:
+				ret = DMA_COMPLETE;
+				break;
+			case PREP:
+			case BUSY:
+				ret = DMA_IN_PROGRESS;
+				break;
+			default:
+				WARN_ON(1);
+			}
+			break;
+		}
+		if (desc->last)
+			residual = 0;
+	}
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+out:
+	dma_set_residue(txstate, residual);
+
+	return ret;
+}
+
+static void pl330_issue_pending(struct dma_chan *chan)
+{
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	unsigned long flags;
+
+	spin_lock_irqsave(&pch->lock, flags);
+	list_splice_tail_init(&pch->submitted_list, &pch->work_list);
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+	pl330_tasklet((unsigned long)pch);
+}
+
+/*
+ * We returned the last one of the circular list of descriptor(s)
+ * from prep_xxx, so the argument to submit corresponds to the last
+ * descriptor of the list.
+ */
+static dma_cookie_t pl330_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct dma_pl330_desc *desc, *last = to_desc(tx);
+	struct dma_pl330_chan *pch = to_pchan(tx->chan);
+	dma_cookie_t cookie;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	/* Assign cookies to all nodes */
+	while (!list_empty(&last->node)) {
+		desc = list_entry(last->node.next, struct dma_pl330_desc, node);
+		if (pch->cyclic) {
+			desc->txd.callback = last->txd.callback;
+			desc->txd.callback_param = last->txd.callback_param;
+		}
+		desc->last = false;
+
+		dma_cookie_assign(&desc->txd);
+
+		list_move_tail(&desc->node, &pch->submitted_list);
+	}
+
+	last->last = true;
+	cookie = dma_cookie_assign(&last->txd);
+	list_add_tail(&last->node, &pch->submitted_list);
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+	return cookie;
+}
+
+static inline void _init_desc(struct dma_pl330_desc *desc)
+{
+	desc->rqcfg.swap = SWAP_NO;
+	desc->rqcfg.scctl = CCTRL0;
+	desc->rqcfg.dcctl = CCTRL0;
+	desc->txd.tx_submit = pl330_tx_submit;
+
+	INIT_LIST_HEAD(&desc->node);
+}
+
+/* Returns the number of descriptors added to the DMAC pool */
+static int add_desc(struct pl330_dmac *pl330, gfp_t flg, int count)
+{
+	struct dma_pl330_desc *desc;
+	unsigned long flags;
+	int i;
+
+	desc = kcalloc(count, sizeof(*desc), flg);
+	if (!desc)
+		return 0;
+
+	spin_lock_irqsave(&pl330->pool_lock, flags);
+
+	for (i = 0; i < count; i++) {
+		_init_desc(&desc[i]);
+		list_add_tail(&desc[i].node, &pl330->desc_pool);
+	}
+
+	spin_unlock_irqrestore(&pl330->pool_lock, flags);
+
+	return count;
+}
+
+static struct dma_pl330_desc *pluck_desc(struct pl330_dmac *pl330)
+{
+	struct dma_pl330_desc *desc = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pl330->pool_lock, flags);
+
+	if (!list_empty(&pl330->desc_pool)) {
+		desc = list_entry(pl330->desc_pool.next,
+				struct dma_pl330_desc, node);
+
+		list_del_init(&desc->node);
+
+		desc->status = PREP;
+		desc->txd.callback = NULL;
+	}
+
+	spin_unlock_irqrestore(&pl330->pool_lock, flags);
+
+	return desc;
+}
+
+static struct dma_pl330_desc *pl330_get_desc(struct dma_pl330_chan *pch)
+{
+	struct pl330_dmac *pl330 = pch->dmac;
+	u8 *peri_id = pch->chan.private;
+	struct dma_pl330_desc *desc;
+
+	/* Pluck one desc from the pool of DMAC */
+	desc = pluck_desc(pl330);
+
+	/* If the DMAC pool is empty, alloc new */
+	if (!desc) {
+		if (!add_desc(pl330, GFP_ATOMIC, 1))
+			return NULL;
+
+		/* Try again */
+		desc = pluck_desc(pl330);
+		if (!desc) {
+			dev_err(pch->dmac->ddma.dev,
+				"%s:%d ALERT!\n", __func__, __LINE__);
+			return NULL;
+		}
+	}
+
+	/* Initialize the descriptor */
+	desc->pchan = pch;
+	desc->txd.cookie = 0;
+	async_tx_ack(&desc->txd);
+
+	desc->peri = peri_id ? pch->chan.chan_id : 0;
+	desc->rqcfg.pcfg = &pch->dmac->pcfg;
+
+	dma_async_tx_descriptor_init(&desc->txd, &pch->chan);
+
+	return desc;
+}
+
+static inline void fill_px(struct pl330_xfer *px,
+		dma_addr_t dst, dma_addr_t src, size_t len)
+{
+	px->bytes = len;
+	px->dst_addr = dst;
+	px->src_addr = src;
+}
+
+static struct dma_pl330_desc *
+__pl330_prep_dma_memcpy(struct dma_pl330_chan *pch, dma_addr_t dst,
+		dma_addr_t src, size_t len)
+{
+	struct dma_pl330_desc *desc = pl330_get_desc(pch);
+
+	if (!desc) {
+		dev_err(pch->dmac->ddma.dev, "%s:%d Unable to fetch desc\n",
+			__func__, __LINE__);
+		return NULL;
+	}
+
+	/*
+	 * Ideally we should lookout for reqs bigger than
+	 * those that can be programmed with 256 bytes of
+	 * MC buffer, but considering a req size is seldom
+	 * going to be word-unaligned and more than 200MB,
+	 * we take it easy.
+	 * Also, should the limit is reached we'd rather
+	 * have the platform increase MC buffer size than
+	 * complicating this API driver.
+	 */
+	fill_px(&desc->px, dst, src, len);
+
+	return desc;
+}
+
+/* Call after fixing burst size */
+static inline int get_burst_len(struct dma_pl330_desc *desc, size_t len)
+{
+	struct dma_pl330_chan *pch = desc->pchan;
+	struct pl330_dmac *pl330 = pch->dmac;
+	int burst_len;
+
+	burst_len = pl330->pcfg.data_bus_width / 8;
+	burst_len *= pl330->pcfg.data_buf_dep / pl330->pcfg.num_chan;
+	burst_len >>= desc->rqcfg.brst_size;
+
+	/* src/dst_burst_len can't be more than 16 */
+	if (burst_len > 16)
+		burst_len = 16;
+
+	while (burst_len > 1) {
+		if (!(len % (burst_len << desc->rqcfg.brst_size)))
+			break;
+		burst_len--;
+	}
+
+	return burst_len;
+}
+
+static struct dma_async_tx_descriptor *pl330_prep_dma_cyclic(
+		struct dma_chan *chan, dma_addr_t dma_addr, size_t len,
+		size_t period_len, enum dma_transfer_direction direction,
+		unsigned long flags)
+{
+	struct dma_pl330_desc *desc = NULL, *first = NULL;
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	struct pl330_dmac *pl330 = pch->dmac;
+	unsigned int i;
+	dma_addr_t dst;
+	dma_addr_t src;
+
+	if (len % period_len != 0)
+		return NULL;
+
+	if (!is_slave_direction(direction)) {
+		dev_err(pch->dmac->ddma.dev, "%s:%d Invalid dma direction\n",
+		__func__, __LINE__);
+		return NULL;
+	}
+
+	for (i = 0; i < len / period_len; i++) {
+		desc = pl330_get_desc(pch);
+		if (!desc) {
+			dev_err(pch->dmac->ddma.dev, "%s:%d Unable to fetch desc\n",
+				__func__, __LINE__);
+
+			if (!first)
+				return NULL;
+
+			spin_lock_irqsave(&pl330->pool_lock, flags);
+
+			while (!list_empty(&first->node)) {
+				desc = list_entry(first->node.next,
+						struct dma_pl330_desc, node);
+				list_move_tail(&desc->node, &pl330->desc_pool);
+			}
+
+			list_move_tail(&first->node, &pl330->desc_pool);
+
+			spin_unlock_irqrestore(&pl330->pool_lock, flags);
+
+			return NULL;
+		}
+
+		switch (direction) {
+		case DMA_MEM_TO_DEV:
+			desc->rqcfg.src_inc = 1;
+			desc->rqcfg.dst_inc = 0;
+			src = dma_addr;
+			dst = pch->fifo_addr;
+			break;
+		case DMA_DEV_TO_MEM:
+			desc->rqcfg.src_inc = 0;
+			desc->rqcfg.dst_inc = 1;
+			src = pch->fifo_addr;
+			dst = dma_addr;
+			break;
+		default:
+			break;
+		}
+
+		desc->rqtype = direction;
+		desc->rqcfg.brst_size = pch->burst_sz;
+		desc->rqcfg.brst_len = 1;
+		desc->bytes_requested = period_len;
+		fill_px(&desc->px, dst, src, period_len);
+
+		if (!first)
+			first = desc;
+		else
+			list_add_tail(&desc->node, &first->node);
+
+		dma_addr += period_len;
+	}
+
+	if (!desc)
+		return NULL;
+
+	pch->cyclic = true;
+	desc->txd.flags = flags;
+
+	return &desc->txd;
+}
+
+static struct dma_async_tx_descriptor *
+pl330_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dst,
+		dma_addr_t src, size_t len, unsigned long flags)
+{
+	struct dma_pl330_desc *desc;
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	struct pl330_dmac *pl330;
+	int burst;
+
+	if (unlikely(!pch || !len))
+		return NULL;
+
+	pl330 = pch->dmac;
+
+	desc = __pl330_prep_dma_memcpy(pch, dst, src, len);
+	if (!desc)
+		return NULL;
+
+	desc->rqcfg.src_inc = 1;
+	desc->rqcfg.dst_inc = 1;
+	desc->rqtype = DMA_MEM_TO_MEM;
+
+	/* Select max possible burst size */
+	burst = pl330->pcfg.data_bus_width / 8;
+
+	/*
+	 * Make sure we use a burst size that aligns with all the memcpy
+	 * parameters because our DMA programming algorithm doesn't cope with
+	 * transfers which straddle an entry in the DMA device's MFIFO.
+	 */
+	while ((src | dst | len) & (burst - 1))
+		burst /= 2;
+
+	desc->rqcfg.brst_size = 0;
+	while (burst != (1 << desc->rqcfg.brst_size))
+		desc->rqcfg.brst_size++;
+
+	/*
+	 * If burst size is smaller than bus width then make sure we only
+	 * transfer one at a time to avoid a burst stradling an MFIFO entry.
+	 */
+	if (desc->rqcfg.brst_size * 8 < pl330->pcfg.data_bus_width)
+		desc->rqcfg.brst_len = 1;
+
+	desc->rqcfg.brst_len = get_burst_len(desc, len);
+	desc->bytes_requested = len;
+
+	desc->txd.flags = flags;
+
+	return &desc->txd;
+}
+
+static void __pl330_giveback_desc(struct pl330_dmac *pl330,
+				  struct dma_pl330_desc *first)
+{
+	unsigned long flags;
+	struct dma_pl330_desc *desc;
+
+	if (!first)
+		return;
+
+	spin_lock_irqsave(&pl330->pool_lock, flags);
+
+	while (!list_empty(&first->node)) {
+		desc = list_entry(first->node.next,
+				struct dma_pl330_desc, node);
+		list_move_tail(&desc->node, &pl330->desc_pool);
+	}
+
+	list_move_tail(&first->node, &pl330->desc_pool);
+
+	spin_unlock_irqrestore(&pl330->pool_lock, flags);
+}
+
+static struct dma_async_tx_descriptor *
+pl330_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_transfer_direction direction,
+		unsigned long flg, void *context)
+{
+	struct dma_pl330_desc *first, *desc = NULL;
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	struct scatterlist *sg;
+	int i;
+	dma_addr_t addr;
+
+	if (unlikely(!pch || !sgl || !sg_len))
+		return NULL;
+
+	addr = pch->fifo_addr;
+
+	first = NULL;
+
+	for_each_sg(sgl, sg, sg_len, i) {
+
+		desc = pl330_get_desc(pch);
+		if (!desc) {
+			struct pl330_dmac *pl330 = pch->dmac;
+
+			dev_err(pch->dmac->ddma.dev,
+				"%s:%d Unable to fetch desc\n",
+				__func__, __LINE__);
+			__pl330_giveback_desc(pl330, first);
+
+			return NULL;
+		}
+
+		if (!first)
+			first = desc;
+		else
+			list_add_tail(&desc->node, &first->node);
+
+		if (direction == DMA_MEM_TO_DEV) {
+			desc->rqcfg.src_inc = 1;
+			desc->rqcfg.dst_inc = 0;
+			fill_px(&desc->px,
+				addr, sg_dma_address(sg), sg_dma_len(sg));
+		} else {
+			desc->rqcfg.src_inc = 0;
+			desc->rqcfg.dst_inc = 1;
+			fill_px(&desc->px,
+				sg_dma_address(sg), addr, sg_dma_len(sg));
+		}
+
+		desc->rqcfg.brst_size = pch->burst_sz;
+		desc->rqcfg.brst_len = 1;
+		desc->rqtype = direction;
+		desc->bytes_requested = sg_dma_len(sg);
+	}
+
+	/* Return the last desc in the chain */
+	desc->txd.flags = flg;
+	return &desc->txd;
+}
+
+static irqreturn_t pl330_irq_handler(int irq, void *data)
+{
+	if (pl330_update(data))
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+#define PL330_DMA_BUSWIDTHS \
+	BIT(DMA_SLAVE_BUSWIDTH_UNDEFINED) | \
+	BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \
+	BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \
+	BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) | \
+	BIT(DMA_SLAVE_BUSWIDTH_8_BYTES)
+
+static int pl330_dma_device_slave_caps(struct dma_chan *dchan,
+	struct dma_slave_caps *caps)
+{
+	caps->src_addr_widths = PL330_DMA_BUSWIDTHS;
+	caps->dstn_addr_widths = PL330_DMA_BUSWIDTHS;
+	caps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+	caps->cmd_pause = false;
+	caps->cmd_terminate = true;
+	caps->residue_granularity = DMA_RESIDUE_GRANULARITY_DESCRIPTOR;
+
+	return 0;
+}
+
+static int
+pl330_probe(struct platform_device *adev)
+{
+	struct dma_pl330_platdata *pdat;
+	struct pl330_config *pcfg;
+	struct pl330_dmac *pl330;
+	struct dma_pl330_chan *pch, *_p;
+	struct dma_device *pd;
+	struct resource *res;
+	int i, ret, irq;
+	int num_chan;
+
+	pdat = dev_get_platdata(&adev->dev);
+
+	ret = dma_set_mask_and_coherent(&adev->dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
+	/* Allocate a new DMAC and its Channels */
+	pl330 = devm_kzalloc(&adev->dev, sizeof(*pl330), GFP_KERNEL);
+	if (!pl330) {
+		dev_err(&adev->dev, "unable to allocate mem\n");
+		return -ENOMEM;
+	}
+
+	pl330->mcbufsz = pdat ? pdat->mcbuf_sz : 0;
+
+	res = adev->resource;
+	pl330->base = devm_ioremap_resource(&adev->dev, res);
+	if (IS_ERR(pl330->base))
+		return PTR_ERR(pl330->base);
+
+	dev_set_drvdata(&adev->dev, pl330);
+
+	irq = platform_get_irq(adev,0);
+
+	if (irq) {
+		for (i = 0; i < SFDMA_NR_IRQS; i++) {
+			ret = devm_request_irq(&adev->dev, irq + i,
+					pl330_irq_handler, 0,
+					dev_name(&adev->dev), pl330);
+			if (ret)
+				return ret;
+		} 
+	}
+
+	pcfg = &pl330->pcfg;
+
+	//pcfg->periph_id = adev->id;
+	ret = pl330_add(pl330);
+	if (ret)
+		return ret;
+
+	INIT_LIST_HEAD(&pl330->desc_pool);
+	spin_lock_init(&pl330->pool_lock);
+
+	/* Create a descriptor pool of default size */
+	if (!add_desc(pl330, GFP_KERNEL, NR_DEFAULT_DESC))
+		dev_warn(&adev->dev, "unable to allocate desc\n");
+
+	pd = &pl330->ddma;
+	INIT_LIST_HEAD(&pd->channels);
+
+	/* Initialize channel parameters */
+	if (pdat)
+		num_chan = max_t(int, pdat->nr_valid_peri, pcfg->num_chan);
+	else
+		num_chan = max_t(int, pcfg->num_peri, pcfg->num_chan);
+
+	pl330->num_peripherals = num_chan;
+
+	pl330->peripherals = kzalloc(num_chan * sizeof(*pch), GFP_KERNEL);
+	if (!pl330->peripherals) {
+		ret = -ENOMEM;
+		dev_err(&adev->dev, "unable to allocate pl330->peripherals\n");
+		goto probe_err2;
+	}
+
+	for (i = 0; i < num_chan; i++) {
+		pch = &pl330->peripherals[i];
+		if (!adev->dev.of_node)
+			pch->chan.private = pdat ? &pdat->peri_id[i] : NULL;
+		else
+			pch->chan.private = adev->dev.of_node;
+
+		INIT_LIST_HEAD(&pch->submitted_list);
+		INIT_LIST_HEAD(&pch->work_list);
+		INIT_LIST_HEAD(&pch->completed_list);
+		spin_lock_init(&pch->lock);
+		pch->thread = NULL;
+		pch->chan.device = pd;
+		pch->dmac = pl330;
+
+		/* Add the channel to the DMAC list */
+		list_add_tail(&pch->chan.device_node, &pd->channels);
+	}
+
+	pd->dev = &adev->dev;
+	if (pdat) {
+		pd->cap_mask = pdat->cap_mask;
+	} else {
+		dma_cap_set(DMA_MEMCPY, pd->cap_mask);
+		if (pcfg->num_peri) {
+			dma_cap_set(DMA_SLAVE, pd->cap_mask);
+			dma_cap_set(DMA_CYCLIC, pd->cap_mask);
+			dma_cap_set(DMA_PRIVATE, pd->cap_mask);
+		}
+	}
+
+	pd->device_alloc_chan_resources = pl330_alloc_chan_resources;
+	pd->device_free_chan_resources = pl330_free_chan_resources;
+	pd->device_prep_dma_memcpy = pl330_prep_dma_memcpy;
+	pd->device_prep_dma_cyclic = pl330_prep_dma_cyclic;
+	pd->device_tx_status = pl330_tx_status;
+	pd->device_prep_slave_sg = pl330_prep_slave_sg;
+	pd->device_control = pl330_control;
+	pd->device_issue_pending = pl330_issue_pending;
+	pd->device_slave_caps = pl330_dma_device_slave_caps;
+
+	ret = dma_async_device_register(pd);
+	if (ret) {
+		dev_err(&adev->dev, "unable to register DMAC\n");
+		goto probe_err3;
+	}
+
+	if (adev->dev.of_node) {
+		ret = of_dma_controller_register(adev->dev.of_node,
+					 of_dma_pl330_xlate, pl330);
+		if (ret) {
+			dev_err(&adev->dev,
+			"unable to register DMA to the generic DT DMA helpers\n");
+		}
+	}
+
+	adev->dev.dma_parms = &pl330->dma_parms;
+
+	/*
+	 * This is the limit for transfers with a buswidth of 1, larger
+	 * buswidths will have larger limits.
+	 */
+	ret = dma_set_max_seg_size(&adev->dev, 1900800);
+	if (ret)
+		dev_err(&adev->dev, "unable to set the seg size\n");
+
+
+	dev_info(&adev->dev,
+		"Loaded driver for PL330 DMAC\n");
+	dev_info(&adev->dev,
+		"\tDBUFF-%ux%ubytes Num_Chans-%u Num_Peri-%u Num_Events-%u\n",
+		pcfg->data_buf_dep, pcfg->data_bus_width / 8, pcfg->num_chan,
+		pcfg->num_peri, pcfg->num_events);
+
+	return 0;
+probe_err3:
+	/* Idle the DMAC */
+	list_for_each_entry_safe(pch, _p, &pl330->ddma.channels,
+			chan.device_node) {
+
+		/* Remove the channel */
+		list_del(&pch->chan.device_node);
+
+		/* Flush the channel */
+		if (pch->thread) {
+			pl330_control(&pch->chan, DMA_TERMINATE_ALL, 0);
+			pl330_free_chan_resources(&pch->chan);
+		}
+	}
+probe_err2:
+	pl330_del(pl330);
+
+	return ret;
+}
+
+static int pl330_remove(struct platform_device *adev)
+{
+	struct pl330_dmac *pl330 = dev_get_drvdata(&adev->dev);
+	struct dma_pl330_chan *pch, *_p;
+
+	if (adev->dev.of_node)
+		of_dma_controller_free(adev->dev.of_node);
+
+	dma_async_device_unregister(&pl330->ddma);
+
+	/* Idle the DMAC */
+	list_for_each_entry_safe(pch, _p, &pl330->ddma.channels,
+			chan.device_node) {
+
+		/* Remove the channel */
+		list_del(&pch->chan.device_node);
+
+		/* Flush the channel */
+		if (pch->thread) {
+			pl330_control(&pch->chan, DMA_TERMINATE_ALL, 0);
+			pl330_free_chan_resources(&pch->chan);
+		}
+	}
+
+	pl330_del(pl330);
+
+	return 0;
+}
+
+#if 0
+static struct amba_id pl330_ids[] = {
+	{
+		.id	= 0x00041330,
+		.mask	= 0x000fffff,
+	},
+	{ 0, 0 },
+};
+
+MODULE_DEVICE_TABLE(amba, pl330_ids);
+#endif
+
+static const struct of_device_id gdma_of_match[] = {
+	{ .compatible = "siflower,sfax8-gdma", },
+	{},
+};
+
+static struct platform_driver pl330_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "dma-pl330",
+		.of_match_table = gdma_of_match,
+	},
+//	.id_table = pl330_ids,
+	.probe = pl330_probe,
+	.remove = pl330_remove,
+};
+
+//module_amba_driver(pl330_driver);
+
+static int __init pl330_init(void)
+{
+	printk(KERN_INFO "DMA: SFAX8 DMA driver\n");
+
+	if(release_reset(SF_GDMA_SOFT_RESET))
+		return -EFAULT;
+
+	return platform_driver_register(&pl330_driver);
+}
+
+static void __exit pl330_exit(void)
+{
+	platform_driver_unregister(&pl330_driver);
+	if(hold_reset(SF_GDMA_SOFT_RESET))
+		return ;
+}
+
+module_init(pl330_init);
+module_exit(pl330_exit);
+
+
+MODULE_AUTHOR("Jaswinder Singh <jassi.brar@samsung.com>");
+MODULE_DESCRIPTION("API Driver for PL330 DMAC");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/i2c/busses/i2c-sfax8-core.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/i2c/busses/i2c-sfax8-core.c	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,764 @@
+/*
+ * Siflower I2C adapter driver (master only).
+ *
+ * Based on the Synopsys DesignWare I2C adapter driver.
+ *
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#include <linux/export.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/pm_runtime.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include "i2c-sfax8-core.h"
+
+/*
+ * Registers offset
+ */
+#define SF_IC_CON		0x0
+#define SF_IC_TAR		0x4
+#define SF_IC_DATA_CMD		0x10
+#define SF_IC_SS_SCL_HCNT	0x14
+#define SF_IC_SS_SCL_LCNT	0x18
+#define SF_IC_FS_SCL_HCNT	0x1c
+#define SF_IC_FS_SCL_LCNT	0x20
+#define SF_IC_HS_SCL_HCNT	0x24
+#define SF_IC_HS_SCL_LCNT	0x28
+#define SF_IC_INTR_STAT		0x2c
+#define SF_IC_INTR_MASK		0x30
+#define SF_IC_RAW_INTR_STAT	0x34
+#define SF_IC_RX_TL		0x38
+#define SF_IC_TX_TL		0x3c
+#define SF_IC_CLR_INTR		0x40
+#define SF_IC_CLR_RX_UNDER	0x44
+#define SF_IC_CLR_RX_OVER	0x48
+#define SF_IC_CLR_TX_OVER	0x4c
+#define SF_IC_CLR_RD_REQ	0x50
+#define SF_IC_CLR_TX_ABRT	0x54
+#define SF_IC_CLR_RX_DONE	0x58
+#define SF_IC_CLR_ACTIVITY	0x5c
+#define SF_IC_CLR_STOP_DET	0x60
+#define SF_IC_CLR_START_DET	0x64
+#define SF_IC_CLR_GEN_CALL	0x68
+#define SF_IC_ENABLE		0x6c
+#define SF_IC_STATUS		0x70
+#define SF_IC_TXFLR		0x74
+#define SF_IC_RXFLR		0x78
+#define SF_IC_SDA_HOLD		0x7c
+#define SF_IC_TX_ABRT_SOURCE	0x80
+#define SF_IC_ENABLE_STATUS	0x9c
+#define SF_IC_CFG    0xa0
+/*
+#define SF_IC_COMP_PARAM_1	0xf4
+#define SF_IC_COMP_VERSION	0xf8
+#define SF_IC_SDA_HOLD_MIN_VERS	0x3131312A
+#define SF_IC_COMP_TYPE		0xfc
+#define SF_IC_COMP_TYPE_VALUE	0x44570140
+*/
+#define SF_IC_INTR_RX_UNDER	0x001
+#define SF_IC_INTR_RX_OVER	0x002
+#define SF_IC_INTR_RX_FULL	0x004
+#define SF_IC_INTR_TX_OVER	0x008
+#define SF_IC_INTR_TX_EMPTY	0x010
+#define SF_IC_INTR_RD_REQ	0x020
+#define SF_IC_INTR_TX_ABRT	0x040
+#define SF_IC_INTR_RX_DONE	0x080
+#define SF_IC_INTR_ACTIVITY	0x100
+#define SF_IC_INTR_STOP_DET	0x200
+#define SF_IC_INTR_START_DET	0x400
+#define SF_IC_INTR_GEN_CALL	0x800
+
+#define SF_IC_INTR_DEFAULT_MASK		(SF_IC_INTR_RX_FULL | \
+					 SF_IC_INTR_TX_EMPTY | \
+					 SF_IC_INTR_TX_ABRT | \
+					 SF_IC_INTR_STOP_DET)
+
+#define SF_IC_STATUS_ACTIVITY	0x1
+
+#define SF_IC_ERR_TX_ABRT	0x1
+
+#define SF_IC_TAR_10BITADDR_MASTER BIT(12)
+
+/*
+ * status codes
+ */
+#define STATUS_IDLE			0x0
+#define STATUS_WRITE_IN_PROGRESS	0x1
+#define STATUS_READ_IN_PROGRESS		0x2
+
+#define TIMEOUT			20 /* ms */
+
+/*
+ * hardware abort codes from the SF_IC_TX_ABRT_SOURCE register
+ *
+ * only expected abort codes are listed here
+ * refer to the datasheet for the full list
+ */
+#define ABRT_7B_ADDR_NOACK	0
+#define ABRT_10ADDR1_NOACK	1
+#define ABRT_10ADDR2_NOACK	2
+#define ABRT_TXDATA_NOACK	3
+#define ABRT_GCALL_NOACK	4
+#define ABRT_GCALL_READ		5
+#define ABRT_SBYTE_ACKDET	7
+#define ABRT_SBYTE_NORSTRT	9
+#define ABRT_10B_RD_NORSTRT	10
+#define ABRT_MASTER_DIS		11
+#define ARB_LOST		12
+
+#define SF_IC_TX_ABRT_7B_ADDR_NOACK	(1UL << ABRT_7B_ADDR_NOACK)
+#define SF_IC_TX_ABRT_10ADDR1_NOACK	(1UL << ABRT_10ADDR1_NOACK)
+#define SF_IC_TX_ABRT_10ADDR2_NOACK	(1UL << ABRT_10ADDR2_NOACK)
+#define SF_IC_TX_ABRT_TXDATA_NOACK	(1UL << ABRT_TXDATA_NOACK)
+#define SF_IC_TX_ABRT_GCALL_NOACK	(1UL << ABRT_GCALL_NOACK)
+#define SF_IC_TX_ABRT_GCALL_READ	(1UL << ABRT_GCALL_READ)
+#define SF_IC_TX_ABRT_SBYTE_ACKDET	(1UL << ABRT_SBYTE_ACKDET)
+#define SF_IC_TX_ABRT_SBYTE_NORSTRT	(1UL << ABRT_SBYTE_NORSTRT)
+#define SF_IC_TX_ABRT_10B_RD_NORSTRT	(1UL << ABRT_10B_RD_NORSTRT)
+#define SF_IC_TX_ABRT_MASTER_DIS	(1UL << ABRT_MASTER_DIS)
+#define SF_IC_TX_ARB_LOST		(1UL << ARB_LOST)
+
+#define SF_IC_TX_ABRT_NOACK		(SF_IC_TX_ABRT_7B_ADDR_NOACK | \
+					 SF_IC_TX_ABRT_10ADDR1_NOACK | \
+					 SF_IC_TX_ABRT_10ADDR2_NOACK | \
+					 SF_IC_TX_ABRT_TXDATA_NOACK | \
+					 SF_IC_TX_ABRT_GCALL_NOACK)
+
+static char *abort_sources[] = {
+	[ABRT_7B_ADDR_NOACK] =
+		"slave address not acknowledged (7bit mode)",
+	[ABRT_10ADDR1_NOACK] =
+		"first address byte not acknowledged (10bit mode)",
+	[ABRT_10ADDR2_NOACK] =
+		"second address byte not acknowledged (10bit mode)",
+	[ABRT_TXDATA_NOACK] =
+		"data not acknowledged",
+	[ABRT_GCALL_NOACK] =
+		"no acknowledgement for a general call",
+	[ABRT_GCALL_READ] =
+		"read after general call",
+	[ABRT_SBYTE_ACKDET] =
+		"start byte acknowledged",
+	[ABRT_SBYTE_NORSTRT] =
+		"trying to send start byte when restart is disabled",
+	[ABRT_10B_RD_NORSTRT] =
+		"trying to read when restart is disabled (10bit mode)",
+	[ABRT_MASTER_DIS] =
+		"trying to use disabled adapter",
+	[ARB_LOST] =
+		"lost arbitration",
+};
+
+u16 sf_readw(struct sf_i2c_dev *dev, int offset)
+{
+	return readw(dev->base + offset);
+}
+
+void sf_writew(struct sf_i2c_dev *dev, u16 b, int offset)
+{
+	writew(b, dev->base + offset);
+}
+
+static void __i2c_sf_enable(struct sf_i2c_dev *dev, bool enable)
+{
+	int timeout = 100;
+	do {
+		sf_writew(dev, enable, SF_IC_ENABLE);
+		if ((sf_readw(dev, SF_IC_ENABLE_STATUS) & 1) == enable)
+			return;
+		/*
+		 * Wait 10 times the signaling period of the highest I2C
+		 * transfer supported by the driver (for 400KHz this is
+		 * 25us) as described in the Siflower I2C databook.
+		 */
+		usleep_range(25, 250);
+	} while (timeout--);
+
+	dev_warn(dev->dev, "timeout in %sabling adapter\n",
+		 enable ? "en" : "dis");
+}
+
+/**
+ * i2c_sf_init() - initialize the siflower i2c master hardware
+ * @dev: device private data
+ *
+ * This functions configures and enables the I2C master.
+ * This function is called during I2C init function, and in case of timeout at
+ * run time.
+ */
+int i2c_sf_init(struct sf_i2c_dev *dev)
+{
+	u32 input_clock_khz;
+	u16 hcnt, lcnt;
+	//u32 sda_falling_time, scl_falling_time;
+
+	input_clock_khz = dev->get_clk_rate_khz(dev);
+	/* Disable the adapter */
+	__i2c_sf_enable(dev, false);
+	/* set standard and fast speed deviders for high/low periods */
+
+	/* Standard-mode */
+	hcnt =(u16) ((input_clock_khz / 100 / 2) + 1 ) - 8;
+	lcnt =(u16)(input_clock_khz / 100 / 2) + 1 ;
+	/* Allow platforms to specify the ideal HCNT and LCNT values */
+	if (dev->ss_hcnt && dev->ss_lcnt) {
+		hcnt = dev->ss_hcnt;
+		lcnt = dev->ss_lcnt;
+	}
+	sf_writew(dev, hcnt, SF_IC_SS_SCL_HCNT);
+	sf_writew(dev, lcnt, SF_IC_SS_SCL_LCNT);
+	dev_dbg(dev->dev, "Standard-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);
+
+	/* Fast-mode */
+	hcnt = (u16)((input_clock_khz / 400 / 2) + 1 ) - 8;
+	lcnt = (u16)(input_clock_khz / 400 / 2) + 1 ;
+
+	if (dev->fs_hcnt && dev->fs_lcnt) {
+		hcnt = dev->fs_hcnt;
+		lcnt = dev->fs_lcnt;
+	}
+	sf_writew(dev, hcnt, SF_IC_FS_SCL_HCNT);
+	sf_writew(dev, lcnt, SF_IC_FS_SCL_LCNT);
+	dev_dbg(dev->dev, "Fast-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);
+
+	/* High-mode */
+	hcnt = (u16)((input_clock_khz / 3400 / 2) + 1 ) - 8;
+	lcnt = (u16)(input_clock_khz / 3400 / 2) + 1 ;
+
+	if (dev->fs_hcnt && dev->fs_lcnt) {
+		hcnt = dev->fs_hcnt;
+		lcnt = dev->fs_lcnt;
+	}
+	sf_writew(dev, hcnt, SF_IC_HS_SCL_HCNT);
+	sf_writew(dev, lcnt, SF_IC_HS_SCL_LCNT);
+	dev_dbg(dev->dev, "Fast-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);
+
+	/* Configure Tx/Rx FIFO threshold levels */
+	sf_writew(dev, dev->tx_fifo_depth / 2, SF_IC_TX_TL);
+	sf_writew(dev, 0, SF_IC_RX_TL);
+	/* configure the i2c master */
+	sf_writew(dev, dev->master_cfg , SF_IC_CON);
+
+
+	/*ignore no ack in high speed*/
+	if((dev->master_cfg & SF_IC_CON_SPEED_HIGH) == SF_IC_CON_SPEED_HIGH)
+		sf_writew(dev, 0x100 | sf_readw(dev, SF_IC_CFG), SF_IC_CFG);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(i2c_sf_init);
+
+/*
+ * Waiting for bus not busy
+ */
+static int i2c_sf_wait_bus_not_busy(struct sf_i2c_dev *dev)
+{
+	int timeout = TIMEOUT;
+	while (sf_readw(dev, SF_IC_STATUS) & SF_IC_STATUS_ACTIVITY) {
+		if (timeout <= 0) {
+			dev_warn(dev->dev, "timeout waiting for bus ready\n");
+			return -ETIMEDOUT;
+		}
+		timeout--;
+		usleep_range(1000, 1100);
+	}
+	return 0;
+}
+
+static void i2c_sf_xfer_init(struct sf_i2c_dev *dev)
+{
+	struct i2c_msg *msgs = dev->msgs;
+	u32 ic_con, ic_tar = 0;
+
+	/* Disable the adapter */
+	__i2c_sf_enable(dev, false);
+
+	/* if the slave address is ten bit address, enable 10BITADDR */
+	ic_con = sf_readw(dev, SF_IC_CON);
+	if (msgs[dev->msg_write_idx].flags & I2C_M_TEN) {
+		ic_con |= SF_IC_CON_10BITADDR_MASTER;
+		/*
+		 * If I2C_DYNAMIC_TAR_UPDATE is set, the 10-bit addressing
+		 * mode has to be enabled via bit 12 of IC_TAR register.
+		 * We set it always as I2C_DYNAMIC_TAR_UPDATE can't be
+		 * detected from registers.
+		 */
+		ic_tar = SF_IC_TAR_10BITADDR_MASTER;
+	} else {
+		ic_con &= ~SF_IC_CON_10BITADDR_MASTER;
+	}
+
+	sf_writew(dev, ic_con, SF_IC_CON);
+
+	/*
+	 * Set the slave (target) address and enable 10-bit addressing mode
+	 * if applicable.
+	 */
+	sf_writew(dev, msgs[dev->msg_write_idx].addr | ic_tar, SF_IC_TAR);
+
+	/* enforce disabled interrupts (due to HW issues) */
+	i2c_sf_disable_int(dev);
+	/* Enable the adapter */
+	__i2c_sf_enable(dev, true);
+
+
+	/* Clear and enable interrupts */
+	i2c_sf_clear_int(dev);
+	sf_writew(dev, SF_IC_INTR_DEFAULT_MASK, SF_IC_INTR_MASK);
+}
+
+/*
+ * Initiate (and continue) low level master read/write transaction.
+ * This function is only called from i2c_sf_isr, and pumping i2c_msg
+ * messages into the tx buffer.  Even if the size of i2c_msg data is
+ * longer than the size of the tx buffer, it handles everything.
+ */
+static void
+i2c_sf_xfer_msg(struct sf_i2c_dev *dev)
+{
+	struct i2c_msg *msgs = dev->msgs;
+	u32 intr_mask;
+	u16 tx_limit, rx_limit;
+	u32 addr = msgs[dev->msg_write_idx].addr;
+	u32 buf_len = dev->tx_buf_len;
+	u8 *buf = dev->tx_buf;
+	bool need_restart = false;
+
+	intr_mask = SF_IC_INTR_DEFAULT_MASK;
+
+	for (; dev->msg_write_idx < dev->msgs_num; dev->msg_write_idx++) {
+		/*
+		 * if target address has changed, we need to
+		 * reprogram the target address in the i2c
+		 * adapter when we are done with this transfer
+		 */
+		if (msgs[dev->msg_write_idx].addr != addr) {
+			dev_err(dev->dev,
+				"%s: invalid target address\n", __func__);
+			dev->msg_err = -EINVAL;
+			break;
+		}
+
+		if (msgs[dev->msg_write_idx].len == 0) {
+			dev_err(dev->dev,
+				"%s: invalid message length\n", __func__);
+			dev->msg_err = -EINVAL;
+			break;
+		}
+
+		if (!(dev->status & STATUS_WRITE_IN_PROGRESS)) {
+			/* new i2c_msg */
+			buf = msgs[dev->msg_write_idx].buf;
+			buf_len = msgs[dev->msg_write_idx].len;
+
+			/* If both IC_EMPTYFIFO_HOLD_MASTER_EN and
+			 * IC_RESTART_EN are set, we must manually
+			 * set restart bit between messages.
+			 */
+			if ((dev->master_cfg & SF_IC_CON_RESTART_EN) &&
+					(dev->msg_write_idx > 0))
+				need_restart = true;
+		}
+
+		tx_limit = dev->tx_fifo_depth - sf_readw(dev, SF_IC_TXFLR);
+		rx_limit = dev->rx_fifo_depth - sf_readw(dev, SF_IC_RXFLR);
+		while (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {
+			u16 cmd = 0;
+
+			/*
+			 * If IC_EMPTYFIFO_HOLD_MASTER_EN is set we must
+			 * manually set the stop bit. However, it cannot be
+			 * detected from the registers so we set it always
+			 * when writing/reading the last byte.
+			 */
+			if (dev->msg_write_idx == dev->msgs_num - 1 &&
+			    buf_len == 1)
+				cmd |= BIT(9);
+
+			if (need_restart) {
+				cmd |= BIT(10);
+				need_restart = false;
+			}
+
+			if (msgs[dev->msg_write_idx].flags & I2C_M_RD) {
+
+				/* avoid rx buffer overrun */
+				if (rx_limit - dev->rx_outstanding <= 0)
+					break;
+
+				sf_writew(dev, cmd | 0x100, SF_IC_DATA_CMD);
+				rx_limit--;
+				dev->rx_outstanding++;
+			} else
+				sf_writew(dev, cmd | *buf++, SF_IC_DATA_CMD);
+			tx_limit--; buf_len--;
+		}
+		dev->tx_buf = buf;
+		dev->tx_buf_len = buf_len;
+
+		if (buf_len > 0) {
+			/* more bytes to be written */
+			dev->status |= STATUS_WRITE_IN_PROGRESS;
+			break;
+		} else
+			dev->status &= ~STATUS_WRITE_IN_PROGRESS;
+	}
+
+	/*
+	 * If i2c_msg index search is completed, we don't need TX_EMPTY
+	 * interrupt any more.
+	 */
+	if (dev->msg_write_idx == dev->msgs_num)
+		intr_mask &= ~SF_IC_INTR_TX_EMPTY;
+
+	if (dev->msg_err)
+		intr_mask = 0;
+	sf_writew(dev, intr_mask,  SF_IC_INTR_MASK);
+}
+
+static void
+i2c_sf_read(struct sf_i2c_dev *dev)
+{
+	struct i2c_msg *msgs = dev->msgs;
+	u16 rx_valid;
+
+	for (; dev->msg_read_idx < dev->msgs_num; dev->msg_read_idx++) {
+		u32 len;
+		u8 *buf;
+
+		if (!(msgs[dev->msg_read_idx].flags & I2C_M_RD))
+			continue;
+
+		if (!(dev->status & STATUS_READ_IN_PROGRESS)) {
+			len = msgs[dev->msg_read_idx].len;
+			buf = msgs[dev->msg_read_idx].buf;
+		} else {
+			len = dev->rx_buf_len;
+			buf = dev->rx_buf;
+		}
+
+		rx_valid = sf_readw(dev, SF_IC_RXFLR);
+
+		for (; len > 0 && rx_valid > 0; len--, rx_valid--) {
+			*buf++ = sf_readw(dev, SF_IC_DATA_CMD);
+			dev->rx_outstanding--;
+		}
+
+		if (len > 0) {
+			dev->status |= STATUS_READ_IN_PROGRESS;
+			dev->rx_buf_len = len;
+			dev->rx_buf = buf;
+			return;
+		} else
+			dev->status &= ~STATUS_READ_IN_PROGRESS;
+	}
+}
+
+static int i2c_sf_handle_tx_abort(struct sf_i2c_dev *dev)
+{
+	unsigned long abort_source = dev->abort_source;
+	int i;
+
+	if (abort_source & SF_IC_TX_ABRT_NOACK) {
+		for_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))
+			dev_dbg(dev->dev,
+				"%s: %s\n", __func__, abort_sources[i]);
+		return -EREMOTEIO;
+	}
+
+	for_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))
+		dev_err(dev->dev, "%s: %s\n", __func__, abort_sources[i]);
+
+	if (abort_source & SF_IC_TX_ARB_LOST)
+		return -EAGAIN;
+	else if (abort_source & SF_IC_TX_ABRT_GCALL_READ)
+		return -EINVAL; /* wrong msgs[] data */
+	else
+		return -EIO;
+}
+
+/*
+ * Prepare controller for a transaction and call i2c_sf_xfer_msg
+ */
+int
+i2c_sf_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
+{
+	struct sf_i2c_dev *dev = i2c_get_adapdata(adap);
+	int ret;
+	int time_out, speed, i, data_len;
+
+	dev_dbg(dev->dev, "%s: msgs: %d\n", __func__, num);
+
+	if(msgs == NULL){
+		dev_dbg(dev->dev, "%s: invalid msgs parameter!", __func__);
+		return -EINVAL;
+	}
+
+	if(num < 0){
+		dev_dbg(dev->dev, "%s: invalid num parameter!", __func__);
+		return -EINVAL;
+	}
+	/*if adapter timeout is defined ,using it ,else time_out increases with transmitted data dynamically*/
+	/*adapter timeout is initiaized as HZ*/
+	if(adap->timeout != HZ)
+		time_out = adap->timeout;
+	else{
+
+		if((dev->master_cfg & SF_IC_CON_SPEED_HIGH) == SF_IC_CON_SPEED_HIGH)
+			speed = 3400000;
+		else if((dev->master_cfg & SF_IC_CON_SPEED_FAST)== SF_IC_CON_SPEED_FAST)
+			speed = 400000;
+		else if((dev->master_cfg & SF_IC_CON_SPEED_STD) == SF_IC_CON_SPEED_STD)
+			speed = 100000;
+
+		else {
+			dev_dbg(dev->dev, "%s:unsupport transfer speed",__func__);
+			goto done;
+		}
+		data_len = 0;
+		for(i = 0; i < num; i++){
+			data_len += msgs[i].len;
+		}
+		time_out = HZ > (data_len * 20 * 100 / speed)?
+			HZ : (data_len * 20 * 100 / speed);
+	}
+
+	mutex_lock(&dev->lock);
+	pm_runtime_get_sync(dev->dev);
+
+	reinit_completion(&dev->cmd_complete);
+	dev->msgs = msgs;
+	dev->msgs_num = num;
+	dev->cmd_err = 0;
+	dev->msg_write_idx = 0;
+	dev->msg_read_idx = 0;
+	dev->msg_err = 0;
+	dev->status = STATUS_IDLE;
+	dev->abort_source = 0;
+	dev->rx_outstanding = 0;
+	ret = i2c_sf_wait_bus_not_busy(dev);
+	if (ret < 0)
+		goto done;
+
+
+	/* start the transfers */
+	i2c_sf_xfer_init(dev);
+
+	/* wait for tx to complete */
+	ret = wait_for_completion_timeout(&dev->cmd_complete, time_out);
+	if (ret == 0) {
+		dev_err(dev->dev, "controller timed out\n");
+		/* i2c_sf_init implicitly disables the adapter */
+		i2c_sf_init(dev);
+		ret = -ETIMEDOUT;
+		goto done;
+		}
+
+	/*
+	 * We must disable the adapter before unlocking the &dev->lock mutex
+	 * below. Otherwise the hardware might continue generating interrupts
+	 * which in turn causes a race condition with the following transfer.
+	 * Needs some more investigation if the additional interrupts are
+	 * a hardware bug or this driver doesn't handle them correctly yet.
+	 */
+	__i2c_sf_enable(dev, false);
+
+	if (dev->msg_err) {
+		ret = dev->msg_err;
+		goto done;
+	}
+
+	/* no error */
+	if (likely(!dev->cmd_err)) {
+		ret = num;
+		goto done;
+	}
+
+	/* We have an error */
+	if (dev->cmd_err == SF_IC_ERR_TX_ABRT) {
+		ret = i2c_sf_handle_tx_abort(dev);
+		goto done;
+	}
+	ret = -EIO;
+
+done:
+	pm_runtime_mark_last_busy(dev->dev);
+	pm_runtime_put_autosuspend(dev->dev);
+	mutex_unlock(&dev->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i2c_sf_xfer);
+
+u32 i2c_sf_func(struct i2c_adapter *adap)
+{
+	struct sf_i2c_dev *dev = i2c_get_adapdata(adap);
+	return dev->functionality;
+}
+EXPORT_SYMBOL_GPL(i2c_sf_func);
+
+static u32 i2c_sf_read_clear_intrbits(struct sf_i2c_dev *dev)
+{
+	u16 stat;
+
+	/*
+	 * The IC_INTR_STAT register just indicates "enabled" interrupts.
+	 * Ths unmasked raw version of interrupt status bits are available
+	 * in the IC_RAW_INTR_STAT register.
+	 *
+	 * That is,
+	 *   stat = sf_readw(IC_INTR_STAT);
+	 * equals to,
+	 *   stat = sf_readw(IC_RAW_INTR_STAT) & sf_readl(IC_INTR_MASK);
+	 *
+	 * The raw version might be useful for debugging purposes.
+	 */
+	stat = sf_readw(dev, SF_IC_INTR_STAT);
+
+	/*
+	 * Do not use the IC_CLR_INTR register to clear interrupts, or
+	 * you'll miss some interrupts, triggered during the period from
+	 * sf_readw(IC_INTR_STAT) to sf_readl(IC_CLR_INTR).
+	 *
+	 * Instead, use the separately-prepared IC_CLR_* registers.
+	 */
+	if (stat & SF_IC_INTR_RX_UNDER)
+		sf_readw(dev, SF_IC_CLR_RX_UNDER);
+	if (stat & SF_IC_INTR_RX_OVER)
+		sf_readw(dev, SF_IC_CLR_RX_OVER);
+	if (stat & SF_IC_INTR_TX_OVER)
+		sf_readw(dev, SF_IC_CLR_TX_OVER);
+	if (stat & SF_IC_INTR_RD_REQ)
+		sf_readw(dev, SF_IC_CLR_RD_REQ);
+	if (stat & SF_IC_INTR_TX_ABRT) {
+		/*
+		 * The IC_TX_ABRT_SOURCE register is cleared whenever
+		 * the IC_CLR_TX_ABRT is read.  Preserve it beforehand.
+		 */
+		dev->abort_source = sf_readw(dev, SF_IC_TX_ABRT_SOURCE);
+		sf_readw(dev, SF_IC_CLR_TX_ABRT);
+	}
+	if (stat & SF_IC_INTR_RX_DONE)
+		sf_readw(dev, SF_IC_CLR_RX_DONE);
+	if (stat & SF_IC_INTR_ACTIVITY)
+		sf_readw(dev, SF_IC_CLR_ACTIVITY);
+	if (stat & SF_IC_INTR_STOP_DET)
+		sf_readw(dev, SF_IC_CLR_STOP_DET);
+	if (stat & SF_IC_INTR_START_DET)
+		sf_readw(dev, SF_IC_CLR_START_DET);
+	if (stat & SF_IC_INTR_GEN_CALL)
+		sf_readw(dev, SF_IC_CLR_GEN_CALL);
+
+	return stat;
+}
+
+/*
+ * Interrupt service routine. This gets called whenever an I2C interrupt
+ * occurs.
+ */
+irqreturn_t i2c_sf_isr(int this_irq, void *dev_id)
+{
+	struct sf_i2c_dev *dev = dev_id;
+	u32 stat, enabled;
+	enabled = sf_readw(dev, SF_IC_ENABLE);
+	stat = sf_readw(dev, SF_IC_RAW_INTR_STAT);
+	dev_dbg(dev->dev, "%s:  %s enabled= 0x%x stat=0x%x\n", __func__,
+		dev->adapter.name, enabled, stat);
+	if (!enabled || !(stat & ~SF_IC_INTR_ACTIVITY))
+		return IRQ_NONE;
+
+	stat = i2c_sf_read_clear_intrbits(dev);
+
+	if (stat & SF_IC_INTR_TX_ABRT) {
+		dev->cmd_err |= SF_IC_ERR_TX_ABRT;
+		dev->status = STATUS_IDLE;
+
+		/*
+		 * Anytime TX_ABRT is set, the contents of the tx/rx
+		 * buffers are flushed.  Make sure to skip them.
+		 */
+		sf_writew(dev, 0, SF_IC_INTR_MASK);
+		goto tx_aborted;
+	}
+
+	if (stat & SF_IC_INTR_RX_FULL)
+		i2c_sf_read(dev);
+
+	if (stat & SF_IC_INTR_TX_EMPTY)
+		i2c_sf_xfer_msg(dev);
+
+	/*
+	 * No need to modify or disable the interrupt mask here.
+	 * i2c_sf_xfer_msg() will take care of it according to
+	 * the current transmit status.
+	 */
+
+tx_aborted:
+	if ((stat & (SF_IC_INTR_TX_ABRT | SF_IC_INTR_STOP_DET)) || dev->msg_err)
+		complete(&dev->cmd_complete);
+
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL_GPL(i2c_sf_isr);
+
+void i2c_sf_enable(struct sf_i2c_dev *dev)
+{
+       /* Enable the adapter */
+	__i2c_sf_enable(dev, true);
+}
+EXPORT_SYMBOL_GPL(i2c_sf_enable);
+
+u16 i2c_sf_is_enabled(struct sf_i2c_dev *dev)
+{
+	return sf_readw(dev, SF_IC_ENABLE);
+}
+EXPORT_SYMBOL_GPL(i2c_sf_is_enabled);
+
+void i2c_sf_disable(struct sf_i2c_dev *dev)
+{
+	/* Disable controller */
+	__i2c_sf_enable(dev, false);
+
+	/* Disable all interupts */
+	sf_writew(dev, 0, SF_IC_INTR_MASK);
+	sf_readw(dev, SF_IC_CLR_INTR);
+}
+EXPORT_SYMBOL_GPL(i2c_sf_disable);
+
+void i2c_sf_clear_int(struct sf_i2c_dev *dev)
+{
+	sf_readw(dev, SF_IC_CLR_INTR);
+}
+EXPORT_SYMBOL_GPL(i2c_sf_clear_int);
+
+void i2c_sf_disable_int(struct sf_i2c_dev *dev)
+{
+	sf_writew(dev, 0, SF_IC_INTR_MASK);
+}
+EXPORT_SYMBOL_GPL(i2c_sf_disable_int);
+/*
+u32 i2c_sf_read_comp_param(struct sf_i2c_dev *dev)
+{
+	return sf_readw(dev, SF_IC_COMP_PARAM_1);
+}
+EXPORT_SYMBOL_GPL(i2c_sf_read_comp_param);
+*/
+MODULE_DESCRIPTION("Siflower I2C bus adapter core");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/i2c/busses/i2c-sfax8-core.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/i2c/busses/i2c-sfax8-core.h	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,126 @@
+/*
+ * Synopsys DesignWare I2C adapter driver (master only).
+ *
+ * Based on the TI DAVINCI I2C adapter driver.
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ * Copyright (C) 2007 MontaVista Software Inc.
+ * Copyright (C) 2009 Provigent Ltd.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * ----------------------------------------------------------------------------
+ *
+ */
+
+#define SF_IC_CON_MASTER		0x1
+#define SF_IC_CON_SPEED_STD		0x2
+#define SF_IC_CON_SPEED_FAST		0x4
+#define SF_IC_CON_SPEED_HIGH		0x6
+#define SF_IC_CON_10BITADDR_MASTER	0x10
+#define SF_IC_CON_RESTART_EN		0x20
+#define SF_IC_CON_SLAVE_DISABLE		0x40
+
+
+/**
+ * struct sf_i2c_dev - private i2c-designware data
+ * @dev: driver model device node
+ * @base: IO registers pointer
+ * @cmd_complete: tx completion indicator
+ * @lock: protect this struct and IO registers
+ * @clk: input reference clock
+ * @cmd_err: run time hasfare error code
+ * @msgs: points to an array of messages currently being transfered
+ * @msgs_num: the number of elements in msgs
+ * @msg_write_idx: the element index of the current tx message in the msgs
+ *	array
+ * @tx_buf_len: the length of the current tx buffer
+ * @tx_buf: the current tx buffer
+ * @msg_read_idx: the element index of the current rx message in the msgs
+ *	array
+ * @rx_buf_len: the length of the current rx buffer
+ * @rx_buf: the current rx buffer
+ * @msg_err: error status of the current transfer
+ * @status: i2c master status, one of STATUS_*
+ * @abort_source: copy of the TX_ABRT_SOURCE register
+ * @irq: interrupt number for the i2c master
+ * @adapter: i2c subsystem adapter node
+ * @tx_fifo_depth: depth of the hardware tx fifo
+ * @rx_fifo_depth: depth of the hardware rx fifo
+ * @rx_outstanding: current master-rx elements in tx fifo
+ * @ss_hcnt: standard speed HCNT value
+ * @ss_lcnt: standard speed LCNT value
+ * @fs_hcnt: fast speed HCNT value
+ * @fs_lcnt: fast speed LCNT value
+ *
+ * HCNT and LCNT parameters can be used if the platform knows more accurate
+ * values than the one computed based only on the input clock frequency.
+ * Leave them to be %0 if not used.
+ */
+struct sf_i2c_dev {
+	struct device		*dev;
+	void __iomem		*base;
+	struct completion	cmd_complete;
+	struct mutex		lock;
+	struct clk		*clk;
+	u32			(*get_clk_rate_khz) (struct sf_i2c_dev *dev);
+	struct sf_pci_controller *controller;
+	int			cmd_err;
+	struct i2c_msg		*msgs;
+	int			msgs_num;
+	int			msg_write_idx;
+	u32			tx_buf_len;
+	u8			*tx_buf;
+	int			msg_read_idx;
+	u32			rx_buf_len;
+	u8			*rx_buf;
+	int			msg_err;
+	unsigned int		status;
+	u32			abort_source;
+	int			irq;
+//	u32			accessor_flags;
+	struct i2c_adapter	adapter;
+	u32			functionality;
+	u16			master_cfg;
+	u16		tx_fifo_depth;
+	u16		rx_fifo_depth;
+	int			rx_outstanding;
+/*	u32			sda_hold_time;
+	u32			sda_falling_time;
+	u32			scl_falling_time;
+*/
+	u16			ss_hcnt;
+	u16			ss_lcnt;
+	u16			fs_hcnt;
+	u16			fs_lcnt;
+};
+
+#define ACCESS_SWAP		0x00000001
+#define ACCESS_16BIT		0x00000002
+
+struct sf_i2c_platform_data {
+	unsigned int i2c_scl_freq;
+};
+
+extern u32 sf_readl(struct sf_i2c_dev *dev, int offset);
+extern void sf_writel(struct sf_i2c_dev *dev, u32 b, int offset);
+extern int i2c_sf_init(struct sf_i2c_dev *dev);
+extern int i2c_sf_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
+		int num);
+extern u32 i2c_sf_func(struct i2c_adapter *adap);
+extern irqreturn_t i2c_sf_isr(int this_irq, void *dev_id);
+extern void i2c_sf_enable(struct sf_i2c_dev *dev);
+extern u16 i2c_sf_is_enabled(struct sf_i2c_dev *dev);
+extern void i2c_sf_disable(struct sf_i2c_dev *dev);
+extern void i2c_sf_clear_int(struct sf_i2c_dev *dev);
+extern void i2c_sf_disable_int(struct sf_i2c_dev *dev);
+extern u32 i2c_sf_read_comp_param(struct sf_i2c_dev *dev);
Index: linux-3.18.29/drivers/i2c/busses/i2c-sfax8-platdrv.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/i2c/busses/i2c-sfax8-platdrv.c	2017-11-15 17:26:54.357090000 +0800
@@ -0,0 +1,497 @@
+/*
+ * Siflower I2C adapter driver (master only).
+ *
+ * Based on the TI DAVINCI I2C adapter driver.
+ *
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/dmi.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/acpi.h>
+#include <sf16a18.h>
+#include "i2c-sfax8-core.h"
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/string.h>
+#include <linux/debugfs.h>
+
+static int sfax8_i2c_debug_show(struct seq_file *m, void *v)
+{
+	seq_printf(m,"i2c debug interface\n");
+	return 0;
+}
+
+static int sfax8_i2c_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sfax8_i2c_debug_show, NULL);
+}
+
+static ssize_t sfax8_i2c_debug_read(struct file *file, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	int ret = 0;
+	char *buff = kmalloc(sizeof(char) * count, GFP_KERNEL);
+	if(!buff)
+		return -ENOMEM;
+
+	if(*ppos > 0)
+		return 0;
+
+	ret = snprintf(buff, count, "Usage: echo i2c_ctl_num r(read)|w(write) addr reg_addr [value(if write)] > i2c_debug\n");
+	if(copy_to_user(buf, buff, ret))
+		ret = -EFAULT;
+
+	*ppos += ret;
+	kfree(buff);
+	return ret;
+}
+
+static ssize_t sfax8_i2c_debug_write(struct file *file, const char __user *user_buf,
+				size_t ncount, loff_t *ppos)
+{
+		char *buf, *tmp;
+		unsigned char s_ctl[8], s_rw[8],s_addr[8], s_reg[8], s_value[8];
+		unsigned char ctl, rw, addr, reg, value;
+		size_t buf_size;
+		char sp = ' ';
+		int ret, count = 0;
+		struct i2c_adapter *adapter;
+		struct i2c_msg *msgs;
+
+		buf_size = 128 <= ncount ? 128: ncount;
+		buf = (char *)kmalloc(buf_size * sizeof(char), GFP_KERNEL);
+		tmp = (char *)kmalloc(buf_size * sizeof(char), GFP_KERNEL);
+		if(copy_from_user(buf, user_buf, buf_size))
+			return -EFAULT;
+
+		strcpy(tmp, buf);
+		while(strchr(tmp, sp)){
+			count++;
+			strcpy(tmp, strchr(tmp, sp) + 1);
+		}
+		if(count < 3){
+			return -EINVAL;
+		}
+		strcpy(s_ctl, strsep((char **)&buf, &sp));
+
+
+		ctl = (unsigned char)simple_strtoull(s_ctl, NULL, 0);
+
+
+		if(ctl > 4)
+			return -EINVAL;
+
+		strcpy(s_rw, strsep((char **)&buf, &sp));
+
+
+		rw = -1;
+		if((!strcmp(s_rw, "r")) || (!strcmp(s_rw, "read")) )
+			rw = 1;
+		if((!strcmp(s_rw, "w")) || (!strcmp(s_rw, "write")) )
+			rw = 0;
+		if(!(rw + 1))
+			return -EINVAL;
+
+		//get addr
+		strcpy(s_addr, strsep((char **)&buf, &sp));
+		addr = (unsigned char)simple_strtoull(s_addr, NULL, 0);
+
+		//get reg
+		strcpy(s_reg, strsep((char **)&buf, &sp));
+		reg = (unsigned char)simple_strtoull(s_reg, NULL, 0);
+
+
+		adapter = i2c_get_adapter(ctl);
+		if(!adapter){
+			pr_debug("Can't get i2c adapter!\n");
+			return -EBADF;
+		}
+		msgs = (struct i2c_msg *)kmalloc((1 + rw) * sizeof(struct i2c_msg), GFP_KERNEL);
+
+		if(!rw){
+			//get value
+			strcpy(s_value, strsep(&buf, &sp));
+			value = (unsigned char)simple_strtoull(s_value, NULL, 0);
+			msgs[0].buf = (unsigned char *)kmalloc(sizeof(char) * 2, GFP_KERNEL);
+			msgs[0].buf[0] = reg;
+			msgs[0].buf[1] = value;
+			msgs[0].len = 2;
+			msgs[0].addr = addr;
+			msgs[0].flags = 0;
+		}else {
+			msgs[0].addr = msgs[1].addr = addr;
+			msgs[0].len = msgs[1].len = 1;
+			msgs[0].flags = 0;
+			msgs[0].buf = &reg;
+			msgs[1].flags = 1;
+			msgs[1].buf = (unsigned char *)kmalloc(sizeof(char), GFP_KERNEL);
+		}
+
+		ret = i2c_transfer(adapter, msgs, 1 + rw);
+
+		if(!rw)
+			kfree(msgs[0].buf);
+		else{
+			if(ret > 0)
+				printk("read value:0x%x\n", msgs[1].buf[0]);
+			kfree(msgs[1].buf);
+		}
+		kfree(msgs);
+
+		if(ret < 0){
+			printk("Transmit error\n");
+		}
+
+		return ncount;
+}
+
+static struct file_operations i2c_ops = {
+	.owner = THIS_MODULE,
+	.open  = sfax8_i2c_debug_open,
+	.read  = sfax8_i2c_debug_read,
+	.write  = sfax8_i2c_debug_write,
+	.llseek  = default_llseek,
+};
+#endif
+static struct i2c_algorithm i2c_sf_algo = {
+	.master_xfer	= i2c_sf_xfer,
+	.functionality	= i2c_sf_func,
+};
+static u32 i2c_sf_get_clk_rate_khz(struct sf_i2c_dev *dev)
+{
+	return clk_get_rate(dev->clk)/1000;
+}
+
+#ifdef CONFIG_ACPI
+/*
+ * The HCNT/LCNT information coming from ACPI should be the most accurate
+ * for given platform. However, some systems get it wrong. On such systems
+ * we get better results by calculating those based on the input clock.
+ */
+static const struct dmi_system_id sf_i2c_no_acpi_params[] = {
+	{
+		.ident = "Dell Inspiron 7348",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 7348"),
+		},
+	},
+	{ }
+};
+
+static void sf_i2c_acpi_params(struct platform_device *pdev, char method[],
+			       u16 *hcnt, u16 *lcnt, u32 *sda_hold)
+{
+	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
+	union acpi_object *obj;
+
+	if (dmi_check_system(sf_i2c_no_acpi_params))
+		return;
+
+	if (ACPI_FAILURE(acpi_evaluate_object(handle, method, NULL, &buf)))
+		return;
+
+	obj = (union acpi_object *)buf.pointer;
+	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 3) {
+		const union acpi_object *objs = obj->package.elements;
+
+		*hcnt = (u16)objs[0].integer.value;
+		*lcnt = (u16)objs[1].integer.value;
+		if (sda_hold)
+			*sda_hold = (u32)objs[2].integer.value;
+	}
+
+	kfree(buf.pointer);
+}
+
+static int sf_i2c_acpi_configure(struct platform_device *pdev)
+{
+	struct sf_i2c_dev *dev = platform_get_drvdata(pdev);
+	const struct acpi_device_id *id;
+
+	dev->adapter.nr = -1;
+	dev->tx_fifo_depth = 32;
+	dev->rx_fifo_depth = 32;
+
+	/*
+	 * Try to get SDA hold time and *CNT values from an ACPI method if
+	 * it exists for both supported speed modes.
+	 */
+	sf_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt, NULL);
+	sf_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
+			   &dev->sda_hold_time);
+
+	/*
+	 * Provide a way for Designware I2C host controllers that are not
+	 * based on Intel LPSS to specify their input clock frequency via
+	 * id->driver_data.
+	 */
+	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
+	if (id && id->driver_data)
+		clk_register_fixed_rate(&pdev->dev, dev_name(&pdev->dev), NULL,
+					CLK_IS_ROOT, id->driver_data);
+
+	return 0;
+}
+
+static void sf_i2c_acpi_unconfigure(struct platform_device *pdev)
+{
+	struct sf_i2c_dev *dev = platform_get_drvdata(pdev);
+	const struct acpi_device_id *id;
+
+	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
+	if (id && id->driver_data)
+		clk_unregister(dev->clk);
+}
+
+static const struct acpi_device_id sf_i2c_acpi_match[] = {
+	{ "INT33C2", 0 },
+	{ "INT33C3", 0 },
+	{ "INT3432", 0 },
+	{ "INT3433", 0 },
+	{ "80860F41", 0 },
+	{ "808622C1", 0 },
+	{ "AMD0010", 133 * 1000 * 1000 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, sf_i2c_acpi_match);
+#else
+static inline int sf_i2c_acpi_configure(struct platform_device *pdev)
+{
+	return -ENODEV;
+}
+static inline void sf_i2c_acpi_unconfigure(struct platform_device *pdev) { }
+#endif
+
+static int sf_i2c_probe(struct platform_device *pdev)
+{
+	struct sf_i2c_dev *dev;
+	struct i2c_adapter *adap;
+	struct resource *mem;
+	struct sf_i2c_platform_data *pdata;
+	int irq, r;
+	u32 clk_freq = 0;
+
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "no irq resource?\n");
+		return irq; /* -ENXIO */
+	}
+	dev = devm_kzalloc(&pdev->dev, sizeof(struct sf_i2c_dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(dev->base))
+		return PTR_ERR(dev->base);
+
+	init_completion(&dev->cmd_complete);
+	mutex_init(&dev->lock);
+	dev->dev = &pdev->dev;
+	dev->irq = irq;
+	platform_set_drvdata(pdev, dev);
+
+	/* fast mode by default because of legacy reasons */
+	clk_freq = 400000;
+
+	if (ACPI_COMPANION(&pdev->dev)) {
+		sf_i2c_acpi_configure(pdev);
+	} else if (pdev->dev.of_node) {
+		of_property_read_u32(pdev->dev.of_node, "clock-frequency",
+				     &clk_freq);
+
+		/* Only standard mode at 100kHz and fast mode at 400kHz
+		 * are supported.
+		 */
+		if (clk_freq != 100000 && clk_freq != 400000 && clk_freq != 3400000) {
+			dev_err(&pdev->dev, "Only 100kHz, 400khz and 3.4 mhz supported");
+			return -EINVAL;
+		}
+	} else {
+		pdata = dev_get_platdata(&pdev->dev);
+		if (pdata)
+			clk_freq = pdata->i2c_scl_freq;
+	}
+
+	dev->functionality =
+		I2C_FUNC_I2C |
+		I2C_FUNC_10BIT_ADDR |
+		I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+	if (clk_freq == 100000)
+		dev->master_cfg =  SF_IC_CON_MASTER | SF_IC_CON_SLAVE_DISABLE |
+			SF_IC_CON_RESTART_EN | SF_IC_CON_SPEED_STD;
+	else if(clk_freq == 400000)
+		dev->master_cfg =  SF_IC_CON_MASTER | SF_IC_CON_SLAVE_DISABLE |
+			SF_IC_CON_RESTART_EN | SF_IC_CON_SPEED_FAST;
+	else if(clk_freq == 3400000)
+		dev->master_cfg =  SF_IC_CON_MASTER | SF_IC_CON_SLAVE_DISABLE |
+			SF_IC_CON_RESTART_EN | SF_IC_CON_SPEED_HIGH;
+
+	printk("i2c clk freq is %d\n", clk_freq);
+	dev->clk = devm_clk_get(&pdev->dev, NULL);
+	dev->get_clk_rate_khz = i2c_sf_get_clk_rate_khz;
+	if (IS_ERR(dev->clk))
+		return PTR_ERR(dev->clk);
+	clk_prepare_enable(dev->clk);
+	if (!dev->tx_fifo_depth) {
+		dev->tx_fifo_depth = 16;
+		dev->rx_fifo_depth = 16;
+		dev->adapter.nr = pdev->id;
+	}
+	r = i2c_sf_init(dev);
+	if (r)
+		return r;
+
+	i2c_sf_disable_int(dev);
+	r = devm_request_irq(&pdev->dev, dev->irq, i2c_sf_isr, IRQF_SHARED,
+			pdev->name, dev);
+	if (r) {
+		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
+		return r;
+	}
+	adap = &dev->adapter;
+	i2c_set_adapdata(adap, dev);
+	adap->owner = THIS_MODULE;
+	adap->class = I2C_CLASS_DEPRECATED;
+	strlcpy(adap->name, "sfax8-i2c-adapter",
+			sizeof(adap->name));
+	adap->algo = &i2c_sf_algo;
+	adap->dev.parent = &pdev->dev;
+	adap->dev.of_node = pdev->dev.of_node;
+	r = i2c_add_numbered_adapter(adap);
+	if (r) {
+		dev_err(&pdev->dev, "failure adding adapter\n");
+		return r;
+	}
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	#ifdef CONFIG_DEBUG_FS
+	debugfs_create_file("i2c_debug", 0777, NULL, NULL, &i2c_ops);
+	#endif
+
+	return 0;
+}
+
+static int sf_i2c_remove(struct platform_device *pdev)
+{
+	struct sf_i2c_dev *dev = platform_get_drvdata(pdev);
+
+	pm_runtime_get_sync(&pdev->dev);
+
+	i2c_del_adapter(&dev->adapter);
+
+	i2c_sf_disable(dev);
+
+	pm_runtime_put(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	if (ACPI_COMPANION(&pdev->dev))
+		sf_i2c_acpi_unconfigure(pdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id sf_i2c_of_match[] = {
+	{ .compatible = "siflower,sfax8-i2c", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sf_i2c_of_match);
+#endif
+
+#ifdef CONFIG_PM
+static int sf_i2c_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sf_i2c_dev *i_dev = platform_get_drvdata(pdev);
+
+	i2c_sf_disable(i_dev);
+	clk_disable_unprepare(i_dev->clk);
+
+	return 0;
+}
+
+static int sf_i2c_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sf_i2c_dev *i_dev = platform_get_drvdata(pdev);
+
+	clk_prepare_enable(i_dev->clk);
+	i2c_sf_init(i_dev);
+
+	return 0;
+}
+#endif
+
+static UNIVERSAL_DEV_PM_OPS(sf_i2c_dev_pm_ops, sf_i2c_suspend,
+			    sf_i2c_resume, NULL);
+
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:i2c_siflower");
+
+static struct platform_driver sf_i2c_driver = {
+	.probe = sf_i2c_probe,
+	.remove = sf_i2c_remove,
+	.driver		= {
+		.name	= "i2c_siflower",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(sf_i2c_of_match),
+		/*.acpi_match_table = ACPI_PTR(sf_i2c_acpi_match),*/
+		.pm	= &sf_i2c_dev_pm_ops,
+	},
+};
+
+static int __init sf_i2c_init_driver(void)
+{
+	if(release_reset(SF_IIC_SOFT_RESET))
+		return -EFAULT;
+	return platform_driver_register(&sf_i2c_driver);
+}
+subsys_initcall(sf_i2c_init_driver);
+
+static void __exit sf_i2c_exit_driver(void)
+{
+	platform_driver_unregister(&sf_i2c_driver);
+	if(hold_reset(SF_IIC_SOFT_RESET))
+		return ;
+}
+module_exit(sf_i2c_exit_driver);
+
+MODULE_DESCRIPTION("Siflower SFAX8 I2C bus adapter");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/input/misc/sfax8-miscdev.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/input/misc/sfax8-miscdev.c	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,167 @@
+/*
+ *	A18 not use IR device on IP6103, and this driver is not full testing,
+ *	add this driver just for future to use.
+ *
+ */
+ 
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/sfax8.h>
+
+
+#ifdef CONFIG_SF_IRC_MODE9012
+#define MODE		0x0
+#elif defined(CONFIG_SF_IRC_MODE8NEC)
+#define MODE		0x1
+#elif defined(CONFIG_SF_IRC_MODERC5)
+#define MODE		0x2
+#else
+#define MODE		0x3
+#endif
+
+#define IRC_IRQ_ENABLE_MASK				(0x1 << 2)
+#define IRC_ENABLE_MASK					(0x1 << 3)
+#define IRQ_EN							(0x1 << 2)
+#define IRC_EN							(0x1 << 3)
+#define IRC_MODE_MASK					0x3
+#define IRC_IRQ_PENDING_MASK			(0x1 << 2)
+#define CLEAR_IRQ_PENDING				(0x1 << 2)
+#define MFP_INT_MASK					0x3
+#define MFP_INT_FUNC					0x1
+
+
+struct sfax8_misc {
+	struct input_dev *idev;
+	struct sfax8 *info;
+	struct regmap *regmap;
+	struct device *dev;
+};
+
+static irqreturn_t sfax8_misc_irq_handler(int irq, void *_sfax8_misc)
+{
+	struct sfax8_misc *sfmisc = _sfax8_misc;
+	u32 value = 0;
+	int ret;
+#if defined(CONFIG_SF_IRC_MODE9012) || defined(CONFIG_SF_IRC_8NEC)
+	u32	lvalue;
+	regmap_read(sfmisc->regmap, SFAX8_IRC_IKDC0_REG, &lvalue);
+	regmap_read(sfmisc->regmap, SFAX8_IRC_IKDC1_REG, &value);
+	value = (value << 8) | lvalue;
+#else
+	regmap_read(sfmisc->regmap, SFAX8_IRC_IKDC0_REG, &value);
+#endif
+	input_event(sfmisc->idev, EV_MSC, MSC_SCAN, value);
+	input_sync(sfmisc->idev);
+
+	ret = regmap_write(sfmisc->regmap, SFAX8_IRC_CONF1_REG, CLEAR_IRQ_PENDING);
+	if (ret){
+		dev_dbg(sfmisc->dev, "Clear IRC irq error\n");
+	}
+
+	/*GPIO clear irq status*/
+	ret = sf_pad_irq_clear(60);
+	if (ret)
+		dev_dbg("Clear GPIO irq status fail\n");
+
+	return IRQ_HANDLED;
+
+}
+
+static int sfax8_misc_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	struct input_dev *input_dev;
+	struct sfax8_misc *sfmisc;
+	int ret;
+	int irq;
+
+	dev_dbg(&pdev->dev, "IR mode is %d", MODE);
+
+	input_dev = devm_input_allocate_device(&pdev->dev);
+	if (!input_dev){
+		dev_err(&pdev->dev, "Input allocate device error %d\n", input_dev);
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	sfmisc = devm_kzalloc(&pdev->dev, sizeof(struct sfax8_misc), GFP_KERNEL);
+	if (!sfmisc){
+		dev_err(&pdev->dev, "Alloc sfmisc error\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	input_dev->name = "sfax8";
+	input_dev->phys = "sfax8/input0";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &pdev->dev;
+	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
+
+	sfmisc->idev = input_dev;
+	sfmisc->dev = &pdev->dev;
+	sfmisc->info = dev_get_drvdata(pdev->dev.parent);
+	sfmisc->regmap = sfmisc->info->regmap;
+
+	dev_set_drvdata(&pdev->dev, sfmisc);
+	ret = input_register_device(input_dev);
+	if(ret){
+		dev_err(&pdev->dev, "Register input device sfax8 error %d\n", ret);
+		goto err;
+	}
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "miscdev");
+	pdev->dev.of_node = np;
+
+	irq = platform_get_irq(pdev, 0);
+	if (ret){
+		dev_err(&pdev->dev, "Get irq num error %d\n", irq);
+		goto err;
+	}
+	
+	/*set gpio irq, just for now*/
+	ret = sf_pad_irq_config(60, 0x1,0xff);
+	if (ret){
+		dev_err(&pdev->dev, "Set gpio irq error\n");
+		goto err;
+	}
+
+	ret = regmap_update_bits(sfmisc->regmap, SFAX8_IRC_CONF0_REG, IRC_MODE_MASK
+			| IRC_IRQ_ENABLE_MASK | IRC_ENABLE_MASK, MODE | IRQ_EN | IRC_EN);
+	ret = regmap_update_bits(sfmisc->regmap, SFAX8_MFP_IRQ_REG, MFP_INT_MASK, MFP_INT_FUNC);
+	if (ret)
+		dev_dbg(&pdev->dev, "Set IR mode fail, error %d\n", ret);
+
+	ret =devm_request_irq(&pdev->dev, irq, sfax8_misc_irq_handler, IRQF_SHARED, pdev->name, sfmisc);
+	if (ret){
+		dev_err(&pdev->dev, "Request irq error %d\n", ret);
+		goto err;
+	}
+
+	dev_dbg(&pdev->dev, "Sf16ax8 misc device probe done\n");
+
+err:
+	return ret;	
+
+}
+
+
+
+static struct platform_driver sfax8_misc_driver = {
+		.driver			= {
+				.name	= "sfax8-misc",
+				.owner	= THIS_MODULE,
+		},
+		.probe			= sfax8_misc_probe,
+};
+
+module_platform_driver(sfax8_misc_driver);
+
+MODULE_AUTHOR("Allen Guo <xijun.guo@siflower.com.cn>");
+MODULE_DESCRIPTION("SIFLOWER SFAX8 Input Misc Device driver");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/mfd/sfax8.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/mfd/sfax8.c	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,371 @@
+/*
+ * Core driver for ams SF16ax8 PMICs
+ *
+ * Copyright (C) 2013 AMS AG
+ * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.
+ * Copyright (C) 2016 SIFLOWER
+ *
+ * Author: Xijun Guo  <xijun.guo@siflower.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/sfax8.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+static const struct resource sfax8_rtc_resource[] = {
+	{
+		.name = "sfax8-rtc-alarm",
+		.start = SF16ax8_IRQ_RTC_ALARM,
+		.end = SF16ax8_IRQ_RTC_ALARM,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static const struct mfd_cell sfax8_devs[] = {
+	{
+		.name = "sfax8-regulator",
+	},
+	{
+		.name = "power-management",
+	},
+	{
+		.name = "sfax8-misc",
+	},
+	{
+		.name = "reset-button"
+	},
+	{
+		.name = "sfax8-rtc",
+		.num_resources = ARRAY_SIZE(sfax8_rtc_resource),
+		.resources = sfax8_rtc_resource,
+	},
+	{
+		.name = "sfax8-clk-32k"
+	},
+};
+
+
+/*static int sfax8_check_device_id(struct sfax8 *as3722)
+{
+	u32 val;
+	int ret;
+
+	ret = sfax8_read(sfax8, SF16ax8_ASIC_ID1_REG, &val);
+	if (ret < 0) {
+		dev_err(sfax8->dev, "ASIC_ID1 read failed: %d\n", ret);
+		return ret;
+	}
+
+	if (val != SF16ax8_DEVICE_ID) {
+		dev_err(sfax8->dev, "Device is not SF16ax8, ID is 0x%x\n", val);
+		return -ENODEV;
+	}
+
+	ret = sfax8_read(sfax8, SF16ax8_ASIC_ID2_REG, &val);
+	if (ret < 0) {
+		dev_err(sfax8->dev, "ASIC_ID2 read failed: %d\n", ret);
+		return ret;
+	}
+
+	dev_info(sfax8->dev, "SF16ax8 with revision 0x%x found\n", val);
+	return 0;
+}
+
+
+static int sfax8_configure_pullups(struct sfax8 *as3722)
+{
+	int ret;
+	u32 val = 0;
+
+	if (sfax8->en_intern_int_pullup)
+		val |= SF16ax8_INT_PULL_UP;
+	if (sfax8->en_intern_i2c_pullup)
+		val |= SF16ax8_I2C_PULL_UP;
+
+	ret = sfax8_update_bits(sfax8, SF16ax8_IOVOLTAGE_REG,
+			SF16ax8_INT_PULL_UP | AS3722_I2C_PULL_UP, val);
+	if (ret < 0)
+		dev_err(sfax8->dev, "IOVOLTAGE_REG update failed: %d\n", ret);
+	return ret;
+}
+*/
+static const struct regmap_range sfax8_readable_ranges[] = {
+	regmap_reg_range(SFAX8_WAKE0_REG, SFAX8_PWR1_REG),
+	regmap_reg_range(SFAX8_PWR2_REG, SFAX8_PWR2_REG),
+	regmap_reg_range(SFAX8_IRC_CONF0_REG, SFAX8_PWR_OFF_FLAG_REG),
+	regmap_reg_range(SFAX8_DCDC_CTL_REG, SFAX8_DCDC0_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC1_CTL0_REG, SFAX8_DCDC1_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC2_CTL0_REG, SFAX8_DCDC2_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC3_CTL0_REG, SFAX8_DCDC3_CTL1_REG),
+	regmap_reg_range(SFAX8_SW_LDO_CTL0_REG, SFAX8_LDO0_REG),
+	regmap_reg_range(SFAX8_LDO1_REG, SFAX8_LDO1_REG),
+	regmap_reg_range(SFAX8_LDO2_REG, SFAX8_LDO2_REG),
+	regmap_reg_range(SFAX8_LDO4_REG, SFAX8_LDO4_REG),
+	regmap_reg_range(SFAX8_LDO5_REG, SFAX8_LDO5_REG),
+	regmap_reg_range(SFAX8_LDO6_REG, SFAX8_LDO6_REG),
+	regmap_reg_range(SFAX8_SVCC_REG, SFAX8_SVCC_REG),
+	regmap_reg_range(SFAX8_INT0_REG, SFAX8_INT3_REG),
+	regmap_reg_range(SFAX8_MFP_LDO65_REG, SFAX8_MFP_GPIO74_PUPD_REG),
+	regmap_reg_range(SFAX8_ALARM_SEC_REG, SFAX8_WATCH_YEAR_REG),
+};
+
+static const struct regmap_access_table sfax8_readable_table = {
+	.yes_ranges = sfax8_readable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sfax8_readable_ranges),
+};
+
+static const struct regmap_range sfax8_writable_ranges[] = {
+	regmap_reg_range(SFAX8_WAKE0_REG, SFAX8_STATUE0_REG),
+	regmap_reg_range(SFAX8_PWR0_REG, SFAX8_PWR1_REG),
+	regmap_reg_range(SFAX8_PWR2_REG, SFAX8_PWR2_REG),
+	regmap_reg_range(SFAX8_IRC_CONF0_REG, SFAX8_IRC_IWKDC_REG),
+	regmap_reg_range(SFAX8_PWR_OFF_FLAG_REG, SFAX8_PWR_OFF_FLAG_REG),
+	regmap_reg_range(SFAX8_DCDC_CTL_REG, SFAX8_DCDC0_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC1_CTL0_REG, SFAX8_DCDC1_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC2_CTL0_REG, SFAX8_DCDC2_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC3_CTL0_REG, SFAX8_DCDC3_CTL1_REG),
+	regmap_reg_range(SFAX8_SW_LDO_CTL0_REG, SFAX8_LDO0_REG),
+	regmap_reg_range(SFAX8_LDO1_REG, SFAX8_LDO1_REG),
+	regmap_reg_range(SFAX8_LDO2_REG, SFAX8_LDO2_REG),
+	regmap_reg_range(SFAX8_LDO4_REG, SFAX8_LDO4_REG),
+	regmap_reg_range(SFAX8_LDO5_REG, SFAX8_LDO5_REG),
+	regmap_reg_range(SFAX8_LDO6_REG, SFAX8_LDO6_REG),
+	regmap_reg_range(SFAX8_SVCC_REG, SFAX8_SVCC_REG),
+	regmap_reg_range(SFAX8_INT0_REG, SFAX8_INT3_REG),
+	regmap_reg_range(SFAX8_MFP_LDO65_REG, SFAX8_MFP_GPIO74_PUPD_REG),
+	regmap_reg_range(SFAX8_ALARM_SEC_REG, SFAX8_WATCH_YEAR_REG),
+};
+
+static const struct regmap_access_table sfax8_writable_table = {
+	.yes_ranges = sfax8_writable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sfax8_writable_ranges),
+};
+
+static const struct regmap_range sfax8_cacheable_ranges[] = {
+	regmap_reg_range(SFAX8_WAKE1_REG, SFAX8_SLEEP_REG),
+	regmap_reg_range(SFAX8_PWR0_REG, SFAX8_PWR2_REG),
+	regmap_reg_range(SFAX8_DCDC_CTL_REG, SFAX8_INT1_REG),
+	regmap_reg_range(SFAX8_MFP_LDO65_REG, SFAX8_MFP_GPIO74_PUPD_REG),
+};
+
+static const struct regmap_access_table sfax8_volatile_table = {
+	.no_ranges = sfax8_cacheable_ranges,
+	.n_no_ranges = ARRAY_SIZE(sfax8_cacheable_ranges),
+};
+
+#else
+
+static const struct mfd_cell sfax8_devs[] = {
+	{
+		.name = "sfax8-regulator",
+	},
+	{
+		.name = "power-management",
+	},
+	{
+		.name = "sfax8-clk-32k"
+	},
+};
+
+
+
+static const struct regmap_range sfax8_readable_ranges[] = {
+	regmap_reg_range(SFAX8_LSIVER, SFAX8_LDO5_SLOT),
+	regmap_reg_range(SFAX8_DC1CTL, SFAX8_DC4DAC),
+	regmap_reg_range(SFAX8_DC1DAC_SLP, SFAX8_DC4DAC_SLP),
+	regmap_reg_range(SFAX8_DCIREN, SFAX8_LDODIS),
+	regmap_reg_range(SFAX8_LDO1DAC, SFAX8_LDO5DAC),
+	regmap_reg_range(SFAX8_LDORTCDAC, SFAX8_LDO5DAC_SLP),
+	regmap_reg_range(SFAX8_IOSEL, SFAX8_GPLED_FUNC),
+	regmap_reg_range(SFAX8_INTPOL, SFAX8_INTMON),
+	regmap_reg_range(SFAX8_PREVINDAC, SFAX8_OVTEMP),
+};
+static const struct regmap_access_table sfax8_readable_table = {
+	.yes_ranges = sfax8_readable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sfax8_readable_ranges),
+};
+
+static const struct regmap_range sfax8_writable_ranges[] = {
+	regmap_reg_range(SFAX8_LSIVER, SFAX8_LDO5_SLOT),
+	regmap_reg_range(SFAX8_DC1CTL, SFAX8_DC4DAC),
+	regmap_reg_range(SFAX8_DC1DAC_SLP, SFAX8_DC4DAC_SLP),
+	regmap_reg_range(SFAX8_DCIREN, SFAX8_LDODIS),
+	regmap_reg_range(SFAX8_LDO1DAC, SFAX8_LDO5DAC),
+	regmap_reg_range(SFAX8_LDORTCDAC, SFAX8_LDO5DAC_SLP),
+	regmap_reg_range(SFAX8_IOSEL, SFAX8_GPLED_FUNC),
+	regmap_reg_range(SFAX8_INTPOL, SFAX8_INTMON),
+	regmap_reg_range(SFAX8_PREVINDAC, SFAX8_OVTEMP),
+};
+static const struct regmap_access_table sfax8_writable_table = {
+	.yes_ranges = sfax8_writable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sfax8_writable_ranges),
+};
+
+static const struct regmap_range sfax8_cacheable_ranges[] = {
+	regmap_reg_range(SFAX8_LDO1DAC_SLP, SFAX8_LDO5DAC_SLP),
+	regmap_reg_range(SFAX8_DC1DAC_SLP, SFAX8_DC4DAC_SLP),
+
+};
+static const struct regmap_access_table sfax8_volatile_table = {
+	.no_ranges = sfax8_cacheable_ranges,
+	.n_no_ranges = ARRAY_SIZE(sfax8_cacheable_ranges),
+};
+#endif
+static const struct regmap_config sfax8_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = SFAX8_MAX_REGISTER,
+	.cache_type = REGCACHE_RBTREE,
+	.rd_table = &sfax8_readable_table,
+	.wr_table = &sfax8_writable_table,
+	.volatile_table = &sfax8_volatile_table,
+};
+
+static int sfax8_i2c_of_probe(struct i2c_client *i2c,
+			struct sfax8 *sfax8)
+{
+	struct device_node *np = i2c->dev.of_node;
+	//struct irq_data *irq_data;
+
+	if (!np) {
+		dev_err(&i2c->dev, "Device Tree not found\n");
+		return -EINVAL;
+	}
+
+/*	irq_data = irq_get_irq_data(i2c->irq);
+	if (!irq_data) {
+		dev_err(&i2c->dev, "Invalid IRQ: %d\n", i2c->irq);
+		return -EINVAL;
+	}
+
+	sfax8->en_intern_int_pullup = of_property_read_bool(np,
+					"ams,enable-internal-int-pullup");
+	sfax8->en_intern_i2c_pullup = of_property_read_bool(np,
+					"ams,enable-internal-i2c-pullup");
+	sfax8->irq_flags = irqd_get_trigger_type(irq_data);
+	dev_dbg(&i2c->dev, "IRQ flags are 0x%08lx\n", sfax8->irq_flags);*/
+	return 0;
+}
+
+static int sfax8_i2c_probe(struct i2c_client *i2c,
+			const struct i2c_device_id *id)
+{
+	struct sfax8 *sfax8;
+	//unsigned long irq_flags;
+	int ret;
+
+	sfax8 = devm_kzalloc(&i2c->dev, sizeof(struct sfax8), GFP_KERNEL);
+	if (!sfax8)
+		return -ENOMEM;
+
+	sfax8->dev = &i2c->dev;
+	sfax8->chip_irq = i2c->irq;
+	i2c_set_clientdata(i2c, sfax8);
+
+	ret = sfax8_i2c_of_probe(i2c, sfax8);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(sfax8->dev, "start regmap init\n");
+
+	sfax8->regmap = devm_regmap_init_i2c(i2c, &sfax8_regmap_config);
+	if (IS_ERR(sfax8->regmap)) {
+		ret = PTR_ERR(sfax8->regmap);
+		dev_err(&i2c->dev, "regmap init failed: %d\n", ret);
+		return ret;
+	}
+/*
+	ret = sfax8_check_device_id(sfax8);
+	if (ret < 0)
+		return ret;
+
+	irq_flags = sfax8->irq_flags | IRQF_ONESHOT;
+	ret = regmap_add_irq_chip(sfax8->regmap, sfax8->chip_irq,
+			irq_flags, -1, &sfax8_irq_chip,
+			&sfax8->irq_data);
+	if (ret < 0) {
+		dev_err(sfax8->dev, "Failed to add regmap irq: %d\n", ret);
+		return ret;
+	}
+
+	ret = sfax8_configure_pullups(sfax8);
+	if (ret < 0)
+		goto scrub;
+*/
+	dev_dbg(sfax8->dev, "start add devices\n");
+	ret = mfd_add_devices(&i2c->dev, -1, sfax8_devs,
+			ARRAY_SIZE(sfax8_devs), NULL, 0,NULL);
+//			regmap_irq_get_domain(sfax8->irq_data));
+	if (ret) {
+		dev_err(sfax8->dev, "Failed to add MFD devices: %d\n", ret);
+		goto scrub;
+	}
+
+	dev_dbg(sfax8->dev, "SF16ax8 core driver initialized successfully\n");
+	return 0;
+
+scrub:
+//	regmap_del_irq_chip(sfax8->chip_irq, sfax8->irq_data);
+	return ret;
+}
+
+static int sfax8_i2c_remove(struct i2c_client *i2c)
+{
+	struct sfax8 *sfax8 = i2c_get_clientdata(i2c);
+
+	mfd_remove_devices(sfax8->dev);
+//	regmap_del_irq_chip(sfax8->chip_irq, sfax8->irq_data);
+	return 0;
+}
+
+static const struct of_device_id sfax8_of_match[] = {
+	{ .compatible = "siflower, sfax8-pmu", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sfax8_of_match);
+
+static const struct i2c_device_id sfax8_i2c_id[] = {
+	{ "sfax8", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, sfax8_i2c_id);
+
+static struct i2c_driver sfax8_i2c_driver = {
+	.driver = {
+		.name = "sfax8-pmu",
+		.owner = THIS_MODULE,
+		.of_match_table = sfax8_of_match,
+	},
+	.probe = sfax8_i2c_probe,
+	.remove = sfax8_i2c_remove,
+	.id_table = sfax8_i2c_id,
+};
+
+module_i2c_driver(sfax8_i2c_driver);
+
+MODULE_DESCRIPTION("I2C support for SF16ax8 PMU");
+MODULE_AUTHOR("Xijun Guo <xijun.guo@siflower.com.cn>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/phy/phy-sfax8-usb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/phy/phy-sfax8-usb.c	2017-11-15 17:26:54.373090000 +0800
@@ -0,0 +1,145 @@
+/*
+ * SIFLOWER sfax8 USB PHY driver
+ *
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <sf16a18.h>
+
+#ifdef CONFIG_SF16A18_MPW0
+#define USB_SLEEPM0		0xC844
+#define USB_DEBUG_EN_OFFSET	0xC88C
+#else
+#define USB_SLEEPM0		0xC044
+#define USB_DEBUG_EN_OFFSET	0xC08C
+#endif
+
+struct sfax8_usb_phy {
+	struct device *dev;
+	struct clk *phy_clk;
+};
+
+static int sfax8_usb_phy_power_on(struct phy *phy)
+{
+	struct device_node *node;
+	struct regmap *regmap_base;
+	struct sfax8_usb_phy *p_phy = phy_get_drvdata(phy);
+	int ret;
+
+	printk("%s:\n", __func__);
+
+	node = of_parse_phandle(phy->dev.of_node, "usbgrf", 0);
+	regmap_base = syscon_node_to_regmap(node);
+
+	if(regmap_base) {
+		regmap_write(regmap_base, USB_DEBUG_EN_OFFSET, 1);
+		regmap_write(regmap_base, USB_SLEEPM0, 1);
+	} else {
+		dev_err(p_phy->dev, "Failed to get grf regmap base\n");
+		return -EINVAL;
+	}
+
+	ret = clk_prepare_enable(p_phy->phy_clk);
+	if (ret < 0)
+		dev_err(p_phy->dev, "Failed to enable PHY clock: %d\n", ret);
+
+	return ret;
+
+}
+
+static int sfax8_usb_phy_power_off(struct phy *phy)
+{
+	struct sfax8_usb_phy *p_phy = phy_get_drvdata(phy);
+
+	clk_disable_unprepare(p_phy->phy_clk);
+
+	return 0;
+}
+
+static const struct phy_ops sfax8_usb_phy_ops = {
+	.power_on = sfax8_usb_phy_power_on,
+	.power_off = sfax8_usb_phy_power_off,
+	.owner = THIS_MODULE,
+};
+
+static int sfax8_usb_phy_probe(struct platform_device *pdev)
+{
+	struct sfax8_usb_phy *p_phy;
+	struct phy_provider *provider;
+	struct phy *phy;
+
+	if(release_reset(SF_USB_SOFT_RESET))
+		return -EFAULT;
+
+	p_phy = devm_kzalloc(&pdev->dev, sizeof(*p_phy), GFP_KERNEL);
+	if (!p_phy)
+		return -ENOMEM;
+	p_phy->dev = &pdev->dev;
+	platform_set_drvdata(pdev, p_phy);
+
+	p_phy->phy_clk = devm_clk_get(p_phy->dev, NULL);
+	if (IS_ERR(p_phy->phy_clk)) {
+		dev_err(p_phy->dev, "Failed to get usb_phy clock: %ld\n",
+			PTR_ERR(p_phy->phy_clk));
+		return PTR_ERR(p_phy->phy_clk);
+	}
+
+	phy = devm_phy_create(p_phy->dev, NULL, &sfax8_usb_phy_ops, NULL);
+	if (IS_ERR(phy)) {
+		dev_err(p_phy->dev, "Failed to create PHY: %ld\n",
+			PTR_ERR(phy));
+		return PTR_ERR(phy);
+	}
+	phy_set_drvdata(phy, p_phy);
+
+	provider = devm_of_phy_provider_register(p_phy->dev,
+						 of_phy_simple_xlate);
+	if (IS_ERR(provider)) {
+		dev_err(p_phy->dev, "Failed to register PHY provider: %ld\n",
+			PTR_ERR(provider));
+		return PTR_ERR(provider);
+	}
+
+	return 0;
+}
+
+static int sfax8_usb_phy_remove(struct platform_device *pdev)
+{
+	if(hold_reset(SF_USB_SOFT_RESET))
+		return -EFAULT;
+	return 0;
+}
+
+static const struct of_device_id sfax8_usb_phy_of_match[] = {
+	{ .compatible = "siflower,sfax8-usb-phy", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sfax8_usb_phy_of_match);
+
+static struct platform_driver sfax8_usb_phy_driver = {
+	.probe		= sfax8_usb_phy_probe,
+	.remove 	= sfax8_usb_phy_remove,
+	.driver		= {
+		.name	= "sfax8-usb-phy",
+		.of_match_table = sfax8_usb_phy_of_match,
+	},
+};
+module_platform_driver(sfax8_usb_phy_driver);
+
+MODULE_AUTHOR("Nevermore");
+MODULE_DESCRIPTION("SIFLOWER sfax8 USB2.0 PHY driver");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/regulator/sfax8-regulator.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/regulator/sfax8-regulator.c	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,616 @@
+/*
+ * Voltage regulator support for AMS SFAX8 PMIC
+ *
+ * Copyright (C) 2013 ams
+ *
+ * Author: Florian Lobmaier <florian.lobmaier@ams.com>
+ * Author: Laxman Dewangan <ldewangan@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/sfax8.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/slab.h>
+
+//#define ENABLE_DCDC1
+
+/* Regulator IDs */
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+enum sfax8_regulators_id {
+	SFAX8_REGULATOR_DCDC0,
+#ifdef ENABLE_DCDC1
+	SFAX8_REGULATOR_DCDC1,
+#endif
+	SFAX8_REGULATOR_DCDC2,
+	SFAX8_REGULATOR_DCDC3,
+	SFAX8_REGULATOR_LDO0,
+	SFAX8_REGULATOR_LDO1,
+	SFAX8_REGULATOR_LDO2,
+	SFAX8_REGULATOR_LDO4,
+	SFAX8_REGULATOR_LDO5,
+	SFAX8_REGULATOR_LDO6,
+/*	SFAX8_REGULATOR_SVCC,*/
+	SFAX8_REGULATOR_ID_MAX,
+};
+#else
+enum sfax8_regulators_id {
+	SFAX8_REGULATOR_DCDC1,
+	SFAX8_REGULATOR_DCDC2,
+	SFAX8_REGULATOR_DCDC3,
+	SFAX8_REGULATOR_DCDC4,
+	SFAX8_REGULATOR_LDO1,
+	SFAX8_REGULATOR_LDO2,
+	SFAX8_REGULATOR_LDO3,
+	SFAX8_REGULATOR_LDO4,
+	SFAX8_REGULATOR_LDO5,
+	SFAX8_REGULATOR_ID_MAX,
+};
+
+#endif
+
+struct sfax8_register_mapping {
+	u8 regulator_id;
+	const char *name;
+	const char *sname;
+	u8 vsel_reg;
+	u8 vsel_mask;
+	int n_voltages;
+	u32 enable_reg;
+	u8 enable_mask;
+	u32 control_reg;
+	u8 mode_mask;
+	u32 sleep_ctrl_reg;
+	u8 sleep_ctrl_mask;
+	int sf_pmu_current;
+};
+
+struct sfax8_regulator_config_data {
+	struct regulator_init_data *reg_init;
+	bool enable_tracking;
+	int ext_control;
+};
+
+struct sfax8_regulators {
+	struct device *dev;
+	struct sfax8 *sfax8;
+	struct regulator_dev *rdevs[SFAX8_REGULATOR_ID_MAX];
+	struct regulator_desc desc[SFAX8_REGULATOR_ID_MAX];
+	struct sfax8_regulator_config_data
+			reg_config_data[SFAX8_REGULATOR_ID_MAX];
+};
+
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+static const struct sfax8_register_mapping sfax8_reg_lookup[] = {
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC0,
+		.name = "sfax8-dcdc0",
+		.vsel_reg = SFAX8_DCDC0_CTL0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_DCDC_CTL_REG,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.sleep_ctrl_reg = SFAX8_PWR0_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+#ifdef ENABLE_DCDC1
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC1,
+		.name = "sfax8-dcdc1",
+		.vsel_reg = SFAX8_DCDC1_CTL0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_DCDC_CTL_REG,
+		.enable_mask = ONE_BIT_SHIFT(1),
+		.sleep_ctrl_reg = SFAX8_PWR0_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(1),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+#endif
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC2,
+		.name = "sfax8-dcdc2",
+		.vsel_reg = SFAX8_DCDC2_CTL0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_DCDC_CTL_REG,
+		.enable_mask = ONE_BIT_SHIFT(2),
+		.sleep_ctrl_reg = SFAX8_PWR0_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(2),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC3,
+		.name = "sfax8-dcdc3",
+		.vsel_reg = SFAX8_DCDC3_CTL0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_DCDC_CTL_REG,
+		.enable_mask = ONE_BIT_SHIFT(3),
+		.sleep_ctrl_reg = SFAX8_PWR0_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(3),
+		.n_voltages = SFAX8_DCDC3_VOLTAGES,
+		.sf_pmu_current = 2000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO0,
+		.name = "sfax8-ldo0",
+		.vsel_reg = SFAX8_LDO0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 400000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO1,
+		.name = "sfax8-ldo1",
+		.vsel_reg = SFAX8_LDO1_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(1),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(1),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 400000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO2,
+		.name = "sfax8-ldo2",
+		.vsel_reg = SFAX8_LDO2_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(2),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(2),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 400000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO4,
+		.name = "sfax8-ldo4",
+		.vsel_reg = SFAX8_LDO4_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(4),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(4),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO5,
+		.name = "sfax8-ldo5",
+		.vsel_reg = SFAX8_LDO5_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(5),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(5),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO6,
+		.name = "sfax8-ldo6",
+		.vsel_reg = SFAX8_LDO6_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(6),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(6),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+	/*
+	{
+		.regulator_id = SFAX8_REGULATOR_SVCC,
+		.name = "sfax8-svcc",
+		.vsel_reg = SFAX8_SVCC_REG,
+		.vsel_mask = SFAX8_VREG_MASK_2_0,
+		.n_voltages = SFAX8_SVCC_VOLTAGES,
+		.sf_pmu_current = 50000,
+	},*/
+};
+#else
+static const struct sfax8_register_mapping sfax8_reg_lookup[] = {
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC1,
+		.name = "sfax8-dcdc1",
+		.vsel_reg = SFAX8_DC1DAC,
+		.vsel_mask = SFAX8_VREG_MASK_7_0,
+		.enable_reg = SFAX8_DC1CTL,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC2,
+		.name = "sfax8-dcdc2",
+		.vsel_reg = SFAX8_DC2DAC,
+		.vsel_mask = SFAX8_VREG_MASK_7_0,
+		.enable_reg = SFAX8_DC2CTL,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC3,
+		.name = "sfax8-dcdc3",
+		.vsel_reg = SFAX8_DC3DAC,
+		.vsel_mask = SFAX8_VREG_MASK_7_0,
+		.enable_reg = SFAX8_DC3CTL,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 2000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC4,
+		.name = "sfax8-dcdc4",
+		.vsel_reg = SFAX8_DC4DAC,
+		.vsel_mask = SFAX8_VREG_MASK_7_0,
+		.enable_reg = SFAX8_DC4CTL,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC3_VOLTAGES,
+		.sf_pmu_current = 2000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO1,
+		.name = "sfax8-ldo1",
+		.vsel_reg = SFAX8_LDO1DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 300000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO2,
+		.name = "sfax8-ldo2",
+		.vsel_reg = SFAX8_LDO2DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(1),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 300000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO3,
+		.name = "sfax8-ldo3",
+		.vsel_reg = SFAX8_LDO3DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(2),
+		.n_voltages = SFAX8_LDO3_VOLTAGES,
+		.sf_pmu_current = 300000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO4,
+		.name = "sfax8-ldo4",
+		.vsel_reg = SFAX8_LDO4DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(3),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO5,
+		.name = "sfax8-ldo5",
+		.vsel_reg = SFAX8_LDO5DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(4),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+};
+#endif
+static int sfax8_pmu_get_current_limit(struct regulator_dev *rdev)
+{
+	int id = rdev_get_id(rdev);
+	return sfax8_reg_lookup[id].sf_pmu_current;
+}
+
+static int sfax8_pmu_set_current_limit(struct regulator_dev *rdev,
+		int min_uA, int max_uA)
+{
+	struct sfax8_regulators *sfax8_regs = rdev_get_drvdata(rdev);
+	dev_err(sfax8_regs->dev,"Current is fixed\n");
+	return 0;
+}
+
+/*static int sfax8_regulator_enable_disable(struct regulator_dev *rdev)
+{
+	struct sfax8_regulators *sfax8_regs = rdev_get_drvdata(rdev);
+	dev_dbg(sfax8_regs->dev,"svcc can not support enable or disable\n");
+	return 0;
+}*/
+
+static struct regulator_ops sfax8_ops = {
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+	.map_voltage = regulator_map_voltage_linear,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_current_limit = sfax8_pmu_get_current_limit,
+	.set_current_limit = sfax8_pmu_set_current_limit,
+};
+
+/*static struct regulator_ops sfax8_svcc_ops = {
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = sfax8_regulator_enable_disable,
+	.disable = sfax8_regulator_enable_disable,
+	.list_voltage = regulator_list_voltage_linear,
+	.map_voltage = regulator_map_voltage_linear,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_current_limit = sfax8_pmu_get_current_limit,
+	.set_current_limit = sfax8_pmu_set_current_limit,
+};*/
+
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+static struct of_regulator_match sfax8_regulator_matches[] = {
+	{ .name = "dcdc0", },
+#ifdef ENABLE_DCDC1
+	{ .name = "dcdc1", },
+#endif
+	{ .name = "dcdc2", },
+	{ .name = "dcdc3", },
+	{ .name = "ldo0", },
+	{ .name = "ldo1", },
+	{ .name = "ldo2", },
+	{ .name = "ldo4", },
+	{ .name = "ldo5", },
+	{ .name = "ldo6", },
+/*	{ .name = "svcc", },*/
+};
+#else
+static struct of_regulator_match sfax8_regulator_matches[] = {
+	{ .name = "dcdc1", },
+	{ .name = "dcdc2", },
+	{ .name = "dcdc3", },
+	{ .name = "dcdc4", },
+	{ .name = "ldo1", },
+	{ .name = "ldo2", },
+	{ .name = "ldo3", },
+	{ .name = "ldo4", },
+	{ .name = "ldo5", },
+};
+#endif
+static int sfax8_get_regulator_dt_data(struct platform_device *pdev,
+		struct sfax8_regulators *sfax8_regs)
+{
+	struct device_node *np;
+	struct sfax8_regulator_config_data *reg_config;
+	int id;
+	int ret;
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "regulators");
+	if (!np) {
+		dev_err(&pdev->dev, "Device is not having regulators node\n");
+		return -ENODEV;
+	}
+	pdev->dev.of_node = np;
+
+	ret = of_regulator_match(&pdev->dev, np, sfax8_regulator_matches,
+			ARRAY_SIZE(sfax8_regulator_matches));
+	of_node_put(np);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Parsing of regulator node failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	for (id = 0; id < ARRAY_SIZE(sfax8_regulator_matches); ++id) {
+		reg_config = &sfax8_regs->reg_config_data[id];
+		reg_config->reg_init = sfax8_regulator_matches[id].init_data;
+	}
+	return 0;
+}
+
+static int sfax8_regulator_probe(struct platform_device *pdev)
+{
+	struct sfax8 *sfax8 = dev_get_drvdata(pdev->dev.parent);
+	struct sfax8_regulators *sfax8_regs;
+	struct sfax8_regulator_config_data *reg_config;
+	struct regulator_dev *rdev;
+	struct regulator_config config = { };
+	struct regulator_ops *ops;
+	int id;
+	int ret;
+
+	dev_dbg(&pdev->dev, "start probe sfax8 regulator\n");
+
+	sfax8_regs = devm_kzalloc(&pdev->dev, sizeof(*sfax8_regs),
+				GFP_KERNEL);
+	if (!sfax8_regs)
+		return -ENOMEM;
+
+	sfax8_regs->dev = &pdev->dev;
+	sfax8_regs->sfax8 = sfax8;
+	platform_set_drvdata(pdev, sfax8_regs);
+
+	ret = sfax8_get_regulator_dt_data(pdev, sfax8_regs);
+	if (ret < 0)
+		return ret;
+
+	config.dev = &pdev->dev;
+	config.driver_data = sfax8_regs;
+	config.regmap = sfax8->regmap;
+
+	for (id = 0; id < SFAX8_REGULATOR_ID_MAX; id++) {
+		reg_config = &sfax8_regs->reg_config_data[id];
+
+		sfax8_regs->desc[id].name = sfax8_reg_lookup[id].name;
+		sfax8_regs->desc[id].supply_name = sfax8_reg_lookup[id].sname;
+		sfax8_regs->desc[id].id = sfax8_reg_lookup[id].regulator_id;
+		sfax8_regs->desc[id].n_voltages =
+					sfax8_reg_lookup[id].n_voltages;
+		sfax8_regs->desc[id].type = REGULATOR_VOLTAGE;
+		sfax8_regs->desc[id].owner = THIS_MODULE;
+		sfax8_regs->desc[id].vsel_reg = sfax8_reg_lookup[id].vsel_reg;
+		sfax8_regs->desc[id].vsel_mask =
+					sfax8_reg_lookup[id].vsel_mask;
+/*		if (id != SFAX8_REGULATOR_SVCC){
+			sfax8_regs->desc[id].enable_reg =
+					sfax8_reg_lookup[id].enable_reg;
+			sfax8_regs->desc[id].enable_mask =
+					sfax8_reg_lookup[id].enable_mask;
+			ops = &sfax8_ops;
+		}else{
+			ops = &sfax8_svcc_ops;
+		}*/
+		sfax8_regs->desc[id].enable_reg =
+				sfax8_reg_lookup[id].enable_reg;
+		sfax8_regs->desc[id].enable_mask =
+				sfax8_reg_lookup[id].enable_mask;
+		ops = &sfax8_ops;
+		switch (id) {
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+		case SFAX8_REGULATOR_DCDC0:
+#ifdef ENABLE_DCDC1
+		case SFAX8_REGULATOR_DCDC1:
+#endif
+		case SFAX8_REGULATOR_DCDC2:
+			sfax8_regs->desc[id].min_uV = 600000;
+			sfax8_regs->desc[id].uV_step = 12500;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+		case SFAX8_REGULATOR_DCDC3:
+			sfax8_regs->desc[id].min_uV = 2200000;
+			sfax8_regs->desc[id].uV_step = 12500;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+		case SFAX8_REGULATOR_LDO0:
+		case SFAX8_REGULATOR_LDO1:
+		case SFAX8_REGULATOR_LDO2:
+		case SFAX8_REGULATOR_LDO4:
+		case SFAX8_REGULATOR_LDO5:
+		case SFAX8_REGULATOR_LDO6:
+			sfax8_regs->desc[id].min_uV = 700000;
+			sfax8_regs->desc[id].uV_step = 25000;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+/*		case SFAX8_REGULATOR_SVCC:
+			sfax8_regs->desc[id].min_uV = 2600000;
+			sfax8_regs->desc[id].uV_step = 100000;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;*/
+#else
+
+		case SFAX8_REGULATOR_DCDC1:
+		case SFAX8_REGULATOR_DCDC2:
+		case SFAX8_REGULATOR_DCDC3:
+		case SFAX8_REGULATOR_DCDC4:
+			sfax8_regs->desc[id].min_uV = 600000;
+			sfax8_regs->desc[id].uV_step = 12500;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+		case SFAX8_REGULATOR_LDO1:
+		case SFAX8_REGULATOR_LDO2:
+		case SFAX8_REGULATOR_LDO4:
+		case SFAX8_REGULATOR_LDO5:
+			sfax8_regs->desc[id].min_uV = 900000;
+			sfax8_regs->desc[id].uV_step = 50000;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+		case SFAX8_REGULATOR_LDO3:
+			sfax8_regs->desc[id].min_uV = 600000;
+			sfax8_regs->desc[id].uV_step = 50000;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+#endif
+		default:
+			break;
+		}
+
+		sfax8_regs->desc[id].ops = ops;
+		config.init_data = reg_config->reg_init;
+		config.of_node = sfax8_regulator_matches[id].of_node;
+
+		dev_dbg(&pdev->dev, "register regulator num %d\n", id);
+
+		rdev = devm_regulator_register(&pdev->dev,
+					&sfax8_regs->desc[id], &config);
+		if (IS_ERR(rdev)) {
+			ret = PTR_ERR(rdev);
+			dev_err(&pdev->dev, "regulator %d register failed %d\n",
+				id, ret);
+			return ret;
+		}
+
+		sfax8_regs->rdevs[id] = rdev;
+		ret = regulator_enable_regmap(rdev);
+		if (ret < 0) {
+			dev_err(&pdev->dev,
+				"Regulator %d enable failed: %d\n",
+				id, ret);
+			return ret;
+		}
+/*
+			ret = sfax8_extreg_init(sfax8_regs, id,
+					reg_config->ext_control);
+			if (ret < 0) {
+				dev_err(&pdev->dev,
+					"SFAX8 ext control failed: %d", ret);
+				return ret;
+			}
+		}*/
+	}
+	return 0;
+}
+
+static const struct of_device_id of_sfax8_regulator_match[] = {
+	{ .compatible = "siflower, sfax8-regulator", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_sfax8_regulator_match);
+
+static struct platform_driver sfax8_regulator_driver = {
+	.driver = {
+		.name = "sfax8-regulator",
+		.owner = THIS_MODULE,
+		.of_match_table = of_sfax8_regulator_match,
+	},
+	.probe = sfax8_regulator_probe,
+};
+
+module_platform_driver(sfax8_regulator_driver);
+
+MODULE_ALIAS("platform:sfax8-regulator");
+MODULE_DESCRIPTION("SFAX8 regulator driver");
+MODULE_AUTHOR("Xijun Guo <xijun.guo@siflower.com.cn>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/rtc/rtc-sfax8.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/rtc/rtc-sfax8.c	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,202 @@
+/*
+ * An rtc/i2c driver for the EM Microelectronic SFAX8
+ * Copyright 2011 CompuLab, Ltd.
+ *
+ * Author: Mike Rapoport <mike@compulab.co.il>
+ *
+ * Based on rtc-ds1672.c by Alessandro Zummo <a.zummo@towertech.it>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/i2c.h>
+#include <linux/rtc.h>
+#include <linux/module.h>
+#include <linux/mfd/sfax8.h>
+#include <linux/platform_device.h>
+/* Registers */
+#if 0
+#define SFAX8_REG_ON_OFF_CTRL	0x00
+#define SFAX8_REG_IRQ_CTRL	0x01
+#define SFAX8_REG_IRQ_FLAGS	0x02
+#define SFAX8_REG_STATUS		0x03
+#endif
+#define NUM_TIME_REGS           (6)
+struct sfax8_rtc{
+	struct sfax8 *sfax8;
+	struct rtc_device *rtc;
+    int irq;	
+};
+
+static int sfax8_read_time(struct device *dev, struct rtc_time *tm)
+{
+
+	struct sfax8_rtc *sfax8_rtc = dev_get_drvdata(dev);
+	struct sfax8 *sfax8 = sfax8_rtc->sfax8;
+	u8 buf[NUM_TIME_REGS];
+	int ret;
+	ret = regmap_bulk_read(sfax8->regmap, SFAX8_WATCH_SEC_REG, buf, NUM_TIME_REGS);
+    if(ret) {
+		dev_err(dev, "Failed to bulk read rtc_data: %d\n",ret);
+		return ret;
+	}	
+	tm->tm_sec  = buf[0];
+	tm->tm_min  = buf[1];
+	tm->tm_hour = buf[2];
+	tm->tm_mday = buf[3];
+	tm->tm_wday = (buf[4] & 0x70)>> 4;
+	tm->tm_mon  = (buf[4] & 0xf);
+	tm->tm_year = (buf[5] & 0x7f) + 100;
+	return ret;
+}
+
+static int sfax8_set_time(struct device *dev, struct rtc_time *tm)
+{
+
+	struct sfax8_rtc *sfax8_rtc = dev_get_drvdata(dev);
+	struct sfax8 *sfax8 = sfax8_rtc->sfax8;
+	u8 buf[NUM_TIME_REGS];
+	int ret;
+	buf[0] = (unsigned char)tm->tm_sec;
+	buf[1] = (unsigned char)(u8)tm->tm_min;
+	buf[2] = (unsigned char)tm->tm_hour;
+	buf[3] = (unsigned char)tm->tm_mday;
+	buf[4] = (unsigned char)((tm->tm_wday << 4) | tm->tm_mon);
+	buf[5] = (unsigned char)(tm->tm_year % 100) & 0x7f;
+	dev_dbg(dev, "set RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
+		1900 + tm->tm_year, tm->tm_mon + 1, tm->tm_mday,
+		tm->tm_wday, tm->tm_hour , tm->tm_min, tm->tm_sec);
+	ret = regmap_bulk_write(sfax8->regmap, SFAX8_WATCH_SEC_REG, buf, NUM_TIME_REGS);	
+	if(ret) {
+		dev_err(dev, "Failed to bull write rtc_data: %d\n",ret);
+		return ret;
+	}
+	return 0;
+
+}
+
+static int sfax8_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct sfax8_rtc *sfax8_rtc = dev_get_drvdata(dev);
+	struct sfax8 *sfax8 = sfax8_rtc->sfax8;
+	u8 buf[NUM_TIME_REGS];
+	int ret;
+	ret = regmap_bulk_read(sfax8->regmap, SFAX8_WATCH_SEC_REG, buf, NUM_TIME_REGS);
+    if(ret) {
+		dev_err(dev, "Failed to bulk read rtc_data: %d\n",ret);
+		return ret;
+	}	
+	alrm->time.tm_sec  = buf[0];
+	alrm->time.tm_min  = buf[1];
+	alrm->time.tm_hour = buf[2];
+	alrm->time.tm_mday = buf[3];
+	alrm->time.tm_wday = (buf[4] & 0x70)>> 4;
+	alrm->time.tm_mon  = (buf[4] & 0xf);
+	alrm->time.tm_year = (buf[5] & 0x7f) + 100;
+	return ret;
+}
+
+static int sfax8_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct sfax8_rtc *sfax8_rtc = dev_get_drvdata(dev);
+	struct sfax8 *sfax8 = sfax8_rtc->sfax8;
+	u8 buf[NUM_TIME_REGS];
+	int ret;
+	buf[0] = (unsigned char)alrm->time.tm_sec;
+	buf[1] = (unsigned char)alrm->time.tm_min;
+	buf[2] = (unsigned char)alrm->time.tm_hour;
+	buf[3] = (unsigned char)alrm->time.tm_mday;
+	buf[4] = (unsigned char)((alrm->time.tm_wday << 4) | alrm->time.tm_mon);
+	buf[5] = (unsigned char)(alrm->time.tm_year % 100) & 0x7f;
+	dev_dbg(dev, "set RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
+		1900 + alrm->time.tm_year, alrm->time.tm_mon + 1, alrm->time.tm_mday,
+		alrm->time.tm_wday, alrm->time.tm_hour , alrm->time.tm_min, alrm->time.tm_sec);
+	ret = regmap_bulk_write(sfax8->regmap, SFAX8_WATCH_SEC_REG, buf, NUM_TIME_REGS);	
+	if(ret) {
+		dev_err(dev, "Failed to bull write rtc_data: %d\n",ret);
+		return ret;
+	}
+	return 0;
+
+
+
+}
+
+
+static const struct rtc_class_ops sfax8_rtc_ops = {
+	.read_time = sfax8_read_time,
+	.set_time = sfax8_set_time,
+	.read_alarm = sfax8_read_alarm,
+	.set_alarm = sfax8_set_alarm,
+};
+
+static int sfax8_probe(struct platform_device *pdev)
+{
+	struct sfax8 *sfax8 = dev_get_drvdata(
+			pdev->dev.parent);
+	struct sfax8_rtc *sfax8_rtc;
+	struct rtc_time tm;
+	int ret;
+	sfax8_rtc = devm_kzalloc(&pdev->dev, sizeof(*sfax8_rtc),GFP_KERNEL);
+	if(sfax8_rtc == NULL)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, sfax8_rtc);
+	sfax8_rtc->sfax8 = sfax8;
+#if 0
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	rtc = devm_rtc_device_register(&client->dev, sfax8_driver.driver.name,
+				  &sfax8_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc))
+		return PTR_ERR(rtc);
+
+	i2c_set_clientdata(client, rtc);
+#endif
+	ret = sfax8_read_time(&pdev->dev, &tm);
+	if(ret) {
+		dev_err(&pdev->dev,"Failed to read RTC time\n");
+		return ret;
+	}
+	ret = rtc_valid_tm(&tm);
+	if(ret)
+		dev_warn(&pdev->dev, "invalid date/time\n");
+	device_init_wakeup(&pdev->dev, 1);
+	sfax8_rtc->rtc = devm_rtc_device_register(&pdev->dev, "sfax8-rtc", &sfax8_rtc_ops, THIS_MODULE);
+	if(IS_ERR(sfax8_rtc->rtc)){
+		ret = PTR_ERR(sfax8_rtc->rtc);
+		return ret;
+	}
+
+#if 0
+	sfax8_rtc->irq = platform_get_irq(pdev,0);
+	if(sfax8_rtc->irq < 0) {
+		if(sfax8_rtc->irq != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Wake up is not possible as irq = %d \n", sfax8_rtc->irq);
+		return sfax8_rtc->irq;
+	}
+	
+	ret = devm_request_threaded_irq(&pdev->dev, sfax8_rtc->irq, NULL, sfax8_alarm_irq, 0 "RTC alarm", sfax8_rtc);
+	if(ret){
+		dev_err(&pdev->dev, "Failed to request alarm IRQ %d:%d\n", sfax8_rtc->irq, ret);
+	
+	}
+    return ret
+#endif
+	return 0;
+}
+
+static struct platform_driver sfax8_rtc_driver = {
+	.driver = {
+		   .name = "sfax8-rtc",
+	},
+	.probe = &sfax8_probe,
+};
+
+module_platform_driver(sfax8_rtc_driver);
+
+MODULE_DESCRIPTION("SIFLOWER SFAX8 RTC driver");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/include/linux/mfd/sfax8.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/linux/mfd/sfax8.h	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,282 @@
+/*
+ * sfax8 definitions
+ *
+ * Copyright (C) 2013 ams
+ * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.
+ *
+ * Author: Florian Lobmaier <florian.lobmaier@ams.com>
+ * Author: Laxman Dewangan <ldewangan@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/regmap.h>
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+/* SFAX8 registers */
+#define SFAX8_WAKE0_REG				0x00
+#define SFAX8_WAKE1_REG				0x01
+#define SFAX8_SLEEP_REG				0x02
+#define SFAX8_PROTECT_REG				0x03
+#define SFAX8_STATUE0_REG				0x04
+#define SFAX8_STATUE1_REG				0x05
+#define SFAX8_STATUE2_REG				0x06
+#define SFAX8_PWR0_REG				0x07
+#define SFAX8_PWR1_REG				0x08
+#define SFAX8_PWR2_REG				0x11
+#define SFAX8_IRC_CONF0_REG			0x13
+#define SFAX8_IRC_CONF1_REG			0x14
+#define SFAX8_IRC_ICCC_REG			0x15
+#define SFAX8_IRC_IWKDC_REG			0x16
+#define SFAX8_IRC_IKDC0_REG			0x17
+#define SFAX8_IRC_IKDC1_REG			0x18
+#define SFAX8_IRC_IRCC0_REG			0x19
+#define SFAX8_IRC_IRCC1_REG			0x1a
+#define SFAX8_PWR_OFF_FLAG_REG		0x1b
+#define SFAX8_DCDC_CTL_REG			0x20
+#define SFAX8_DCDC0_CTL0_REG			0x21
+#define SFAX8_DCDC0_CTL1_REG			0x22
+#define SFAX8_DCDC1_CTL0_REG				0x28
+#define SFAX8_DCDC1_CTL1_REG				0x29
+#define SFAX8_DCDC2_CTL0_REG				0x2F
+#define SFAX8_DCDC2_CTL1_REG				0x30
+#define SFAX8_DCDC3_CTL0_REG				0x36
+#define SFAX8_DCDC3_CTL1_REG				0x37
+#define SFAX8_SW_LDO_CTL0_REG				0x40
+#define SFAX8_SW_LDO_CTL1_REG				0x41
+#define SFAX8_LDO0_REG					0x42
+#define SFAX8_LDO1_REG					0x44
+#define SFAX8_LDO2_REG					0x46
+#define SFAX8_LDO4_REG					0x4A
+#define SFAX8_LDO5_REG					0x4C
+#define SFAX8_LDO6_REG					0x4E
+#define SFAX8_SVCC_REG					0x51
+#define SFAX8_INT0_REG					0x60
+#define SFAX8_INT1_REG					0x61
+#define SFAX8_INT2_REG					0x62
+#define SFAX8_INT3_REG					0x63
+#define SFAX8_RST_CTRL_REG	0x70
+#define SFAX8_ALARM_SEC_REG	0x71
+#define SFAX8_ALARM_MIN_REG	0x72
+#define SFAX8_ALARM_HOUR_REG	0x73
+#define SFAX8_ALARM_DAY_REG	0x74
+#define SFAX8_ALARM_MON_REG	0x75
+#define SFAX8_ALARM_YEAR_REG	0x76
+
+#define SFAX8_WATCH_SEC_REG	0x77
+#define SFAX8_WATCH_MIN_REG	0x78
+#define SFAX8_WATCH_HOUR_REG	0x79
+#define SFAX8_WATCH_DAY_REG	0x7A
+#define SFAX8_WATCH_MON_REG	0x7B
+#define SFAX8_WATCH_YEAR_REG	0x7C
+
+#define SFAX8_MFP_LDO65_REG				0x80
+#define SFAX8_MFP_LDO4_REG				0x81
+#define SFAX8_MFP_GPIO2_REG				0x82
+#define SFAX8_MFP_GPIO10_REG				0x83
+#define SFAX8_MFP_GPIO_PUPD_REG			0x84
+#define SFAX8_MFP_IRQ_REG					0x85
+#define SFAX8_MFP_RESET_EN_REG			0x86
+#define SFAX8_MFP_GPIO74_PUPD_REG			0x87
+#define SFAX8_MAX_REGISTER				0x90
+
+#define ONE_BIT_SHIFT(n)					(0x1 << n)
+#define TWO_BITS_SHIFT(n)					(0x3 << n)
+#define SFAX8_IRC_MODE_MASK				0x3
+#define SFAX8_VREG_MASK_2_0				0x07
+#define SFAX8_VREG_MASK_6_0				0x7f
+#define SFAX8_VREG_MASK_6_1				0x7e
+#define SFAX8_DCDC_VOLTAGES				0x7f
+#define SFAX8_DCDC3_VOLTAGES				0x68
+#define SFAX8_LDO_VOLTAGES				0x6c
+#define SFAX8_SVCC_VOLTAGES				0x7
+#define SF16ax8_IRQ_RTC_ALARM               5
+
+#else
+
+#define SFAX8_LSIVER    0x00
+#define SFAX8_OTPVER    0x01
+#define SFAX8_IODAC     0x02
+#define SFAX8_VINDAC    0x03
+#define SFAX8_OUT32KEN  0x05
+#define SFAX8_CPUCNT    0x06
+#define SFAX8_PSWR      0x07
+#define SFAX8_PONHIS    0x09
+#define SFAX8_POFFHIS   0x0A
+#define SFAX8_WATCHDOG  0x0B
+#define SFAX8_WATCHDOGCNT       0x0C
+#define SFAX8_PWRFUNC   0x0D
+#define SFAX8_SLPCNT    0x0E
+#define SFAX8_REPCNT    0x0F
+#define SFAX8_PWRONTIMSET       0x10
+#define SFAX8_NOETIMSET 0x11
+#define SFAX8_PWRIREN   0x12
+#define SFAX8_PWRIRQ    0x13
+#define SFAX8_PWRMON    0x14
+#define SFAX8_PWRIRSEL  0x15
+
+#define SFAX8_DC1_SLOT  0x16
+#define SFAX8_DC2_SLOT  0x17
+#define SFAX8_DC3_SLOT  0x18
+#define SFAX8_DC4_SLOT  0x19
+
+#define SFAX8_LDO1_SLOT  0x1B
+#define SFAX8_LD02_SLOT  0x1C
+#define SFAX8_LDO3_SLOT  0x1D
+#define SFAX8_LDO4_SLOT  0x1E
+#define SFAX8_LDO5_SLOT  0x1F
+
+#define SFAX8_DC1CTL    0x2C
+#define SFAX8_DC1CTL2   0x2D
+#define SFAX8_DC2CTL    0x2E
+#define SFAX8_DC2CTL2   0x2F
+#define SFAX8_DC3CTL    0x30
+#define SFAX8_DC3CTL2   0x31
+#define SFAX8_DC4CTL    0x32
+#define SFAX8_DC4CTL2   0x33
+#define SFAX8_DC1DAC    0x36
+#define SFAX8_DC2DAC    0x37
+#define SFAX8_DC3DAC    0x38
+#define SFAX8_DC4DAC    0x39
+#define SFAX8_DC1DAC_SLP        0x3B
+#define SFAX8_DC2DAC_SLP        0x3C
+#define SFAX8_DC3DAC_SLP        0x3D
+#define SFAX8_DC4DAC_SLP        0x3E
+#define SFAX8_DCIREN    0x40
+#define SFAX8_DCIRQ     0x41
+#define SFAX8_DCIRMON   0x42
+#define SFAX8_LDOEN1    0x44
+#define SFAX8_LDOEN2    0x45
+#define SFAX8_LDODIS    0x46
+#define SFAX8_LDO1DAC   0x4C
+#define SFAX8_LDO2DAC   0x4D
+#define SFAX8_LDO3DAC   0x4E
+#define SFAX8_LDO4DAC   0x4F
+#define SFAX8_LDO5DAC   0x50
+#define SFAX8_LDORTCDAC 0x56
+#define SFAX8_LDORTC2DAC        0x57
+#define SFAX8_LDO1DAC_SLP       0x58
+#define SFAX8_LDO2DAC_SLP       0x59
+#define SFAX8_LDO3DAC_SLP       0x5A
+#define SFAX8_LDO4DAC_SLP       0x5B
+#define SFAX8_LDO5DAC_SLP       0x5C
+#define SFAX8_IOSEL     0x90
+#define SFAX8_IOOUT     0x91
+#define SFAX8_GPEDGE1   0x92
+#define SFAX8_EN_GPIR   0x94
+#define SFAX8_IR_GPR    0x95
+#define SFAX8_IR_GPF    0x96
+#define SFAX8_MON_IOIN  0x97
+#define SFAX8_GPLED_FUNC        0x98
+#define SFAX8_INTPOL    0x9C
+#define SFAX8_INTEN     0x9D
+#define SFAX8_INTMON    0x9E
+#define SFAX8_PREVINDAC 0xB0
+#define SFAX8_OVTEMP    0xBC
+#define SFAX8_MAX_REGISTER		0xBC
+#define ONE_BIT_SHIFT(n)					(0x1 << n)
+#define TWO_BITS_SHIFT(n)					(0x3 << n)
+#define SFAX8_IRC_MODE_MASK				0x3
+#define SFAX8_VREG_MASK_2_0				0x07
+#define SFAX8_VREG_MASK_6_1				0x7e
+#define SFAX8_VREG_MASK_7_0				0xff
+#define SFAX8_DCDC_VOLTAGES				0xe9
+#define SFAX8_DCDC3_VOLTAGES				0x68
+#define SFAX8_LDO_VOLTAGES				0x69
+#define SFAX8_LDO3_VOLTAGES				0x75
+#define SFAX8_SVCC_VOLTAGES				0x7
+#define SF16ax8_IRQ_RTC_ALARM               5
+
+#endif
+/* Interrupt IDs */
+/*enum sfax8_irq {
+	SFAX8_IRQ_LID,
+	SFAX8_IRQ_ACOK,
+	SFAX8_IRQ_ENABLE1,
+	SFAX8_IRQ_OCCUR_ALARM_SD0,
+	SFAX8_IRQ_ONKEY_LONG_PRESS,
+	SFAX8_IRQ_ONKEY,
+	SFAX8_IRQ_OVTMP,
+	SFAX8_IRQ_LOWBAT,
+	SFAX8_IRQ_SD0_LV,
+	SFAX8_IRQ_SD1_LV,
+	SFAX8_IRQ_SD2_LV,
+	SFAX8_IRQ_PWM1_OV_PROT,
+	SFAX8_IRQ_PWM2_OV_PROT,
+	SFAX8_IRQ_ENABLE2,
+	SFAX8_IRQ_SD6_LV,
+	SFAX8_IRQ_RTC_REP,
+	SFAX8_IRQ_RTC_ALARM,
+	SFAX8_IRQ_GPIO1,
+	SFAX8_IRQ_GPIO2,
+	SFAX8_IRQ_GPIO3,
+	SFAX8_IRQ_GPIO4,
+	SFAX8_IRQ_GPIO5,
+	SFAX8_IRQ_WATCHDOG,
+	SFAX8_IRQ_ENABLE3,
+	SFAX8_IRQ_TEMP_SD0_SHUTDOWN,
+	SFAX8_IRQ_TEMP_SD1_SHUTDOWN,
+	SFAX8_IRQ_TEMP_SD2_SHUTDOWN,
+	SFAX8_IRQ_TEMP_SD0_ALARM,
+	SFAX8_IRQ_TEMP_SD1_ALARM,
+	SFAX8_IRQ_TEMP_SD6_ALARM,
+	SFAX8_IRQ_OCCUR_ALARM_SD6,
+	SFAX8_IRQ_ADC,
+	SFAX8_IRQ_MAX,
+};
+*/
+struct sfax8 {
+	struct device *dev;
+	struct regmap *regmap;
+	int chip_irq;
+	unsigned long irq_flags;
+	bool en_intern_int_pullup;
+	bool en_intern_i2c_pullup;
+	struct regmap_irq_chip_data *irq_data;
+};
+
+static inline int sfax8_read(struct sfax8 *sfax8, u32 reg, u32 *dest)
+{
+	return regmap_read(sfax8->regmap, reg, dest);
+}
+
+static inline int sfax8_write(struct sfax8 *sfax8, u32 reg, u32 value)
+{
+	return regmap_write(sfax8->regmap, reg, value);
+}
+
+static inline int sfax8_block_read(struct sfax8 *sfax8, u32 reg,
+		int count, u8 *buf)
+{
+	return regmap_bulk_read(sfax8->regmap, reg, buf, count);
+}
+
+static inline int sfax8_block_write(struct sfax8 *sfax8, u32 reg,
+		int count, u8 *data)
+{
+	return regmap_bulk_write(sfax8->regmap, reg, data, count);
+}
+
+static inline int sfax8_update_bits(struct sfax8 *sfax8, u32 reg,
+		u32 mask, u8 val)
+{
+	return regmap_update_bits(sfax8->regmap, reg, mask, val);
+}
+/*
+static inline int sfax8_irq_get_virq(struct sfax8 *sfax8, int irq)
+{
+	return regmap_irq_get_virq(sfax8->irq_data, irq);
+}
+*/
Index: linux-3.18.29/include/linux/sfax8_timer.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/linux/sfax8_timer.h	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,54 @@
+/*
+ * (C) Copyright 2009 Intel Corporation
+ * Author: Jacob Pan (jacob.jun.pan@intel.com)
+ *
+ * Shared with ARM platforms, Jamie Iles, Picochip 2011
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Support for the Synopsys DesignWare APB Timers.
+ */
+#ifndef __SFAX8_TIMER_H__
+#define __SFAX8_TIMER_H__
+
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <linux/interrupt.h>
+
+#define APBTMRS_REG_SIZE       0x14
+
+struct sfax8_timer {
+	void __iomem				*base;
+	unsigned long				freq;
+	int					irq;
+};
+
+struct sfax8_clock_event_device {
+	struct clock_event_device		ced;
+	struct sfax8_timer			timer;
+	struct irqaction			irqaction;
+	void					(*eoi)(struct sfax8_timer *);
+};
+
+struct sfax8_clocksource {
+	struct sfax8_timer			timer;
+	struct clocksource			cs;
+};
+
+void sfax8_clockevent_register(struct sfax8_clock_event_device *sf_ced);
+void sfax8_clockevent_pause(struct sfax8_clock_event_device *sf_ced);
+void sfax8_clockevent_resume(struct sfax8_clock_event_device *sf_ced);
+void sfax8_clockevent_stop(struct sfax8_clock_event_device *sf_ced);
+
+void sfax8_clockevent_init(int cpu, const char *name, unsigned rating,
+		       void __iomem *base, int irq, unsigned long freq);
+struct sfax8_clocksource *
+sfax8_clocksource_init(unsigned rating, const char *name, void __iomem *base,
+			unsigned long freq);
+void sfax8_clocksource_register(struct sfax8_clocksource *sf_cs);
+void sfax8_clocksource_start(struct sfax8_clocksource *sf_cs);
+cycle_t sfax8_clocksource_read(struct sfax8_clocksource *sf_cs);
+
+#endif /* __SFAX8_TIMER_H__ */
Index: linux-3.18.29/include/sound/sfax8_i2s.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/sound/sfax8_i2s.h	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,72 @@
+/*
+ * Copyright (ST) 2012 Rajeev Kumar (rajeev-dlh.kumar@st.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef __SOUND_SFAX8_I2S_H
+#define __SOUND_SFAX8_I2S_H
+
+#include <linux/dmaengine.h>
+#include <linux/types.h>
+
+/*
+ * struct i2s_clk_config_data - represent i2s clk configuration data
+ * @chan_nr: number of channel
+ * @data_width: number of bits per sample (8/16/24/32 bit)
+ * @sample_rate: sampling frequency (8Khz, 16Khz, 32Khz, 44Khz, 48Khz)
+ */
+struct i2s_clk_config_data {
+	int chan_nr;
+	u32 data_width;
+	u32 sample_rate;
+};
+
+struct i2s_platform_data {
+	#define SF_I2S_PLAY	(1 << 0)
+	#define SF_I2S_RECORD	(1 << 1)
+	#define SF_I2S_MASTER   (1 << 2)
+	#define SF_I2S_SLAVE    (1 << 3)
+	unsigned int cap;
+	int channel;
+	u32 snd_fmts;
+	u32 snd_rates;
+
+	void *play_dma_data;
+	void *capture_dma_data;
+	bool (*filter)(struct dma_chan *chan, void *slave);
+	int (*i2s_clk_cfg)(struct i2s_clk_config_data *config, unsigned long rate);
+};
+
+struct i2s_dma_data {
+	void *data;
+	dma_addr_t addr;
+	u32 max_burst;
+	enum dma_slave_buswidth addr_width;
+	bool (*filter)(struct dma_chan *chan, void *slave);
+};
+
+/* I2S DMA registers */
+#define I2S_RXDMA		0x01C0
+#define I2S_TXDMA		0x01C8
+
+#define TWO_CHANNEL_SUPPORT	2	/* up to 2.0 */
+#define FOUR_CHANNEL_SUPPORT	4	/* up to 3.1 */
+#define SIX_CHANNEL_SUPPORT	6	/* up to 5.1 */
+#define EIGHT_CHANNEL_SUPPORT	8	/* up to 7.1 */
+#define I2S_MASTER_MODE		((1 << 2) | (1 << 1 ))
+#define I2S_CDCLK_DIV		(8)
+#endif /*  __SOUND_SFAX8_I2S_H */
Index: linux-3.18.29/sound/soc/siflower/sfax8-machine.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/siflower/sfax8-machine.c	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,195 @@
+/*
+ *
+ * Copyright (C) 2016 Siflower Solutions
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <linux/gpio.h>
+#include <linux/module.h>
+
+static int sfax8_hw_params(struct snd_pcm_substream *substream,
+			 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct device *dev = rtd->card->dev;
+	int err;
+	u32 param_rate, sysclk;
+	u32 codec_fmt, cpu_fmt;
+	param_rate = params_rate(params);
+
+	sysclk = param_rate * 256;
+
+	codec_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_GATED;
+	cpu_fmt =SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_GATED;
+
+	err = snd_soc_dai_set_fmt(codec_dai, codec_fmt);
+	if (err < 0){
+		dev_err(dev,"%s: ERROR: snd_soc_dai_set_fmt set codec dai error %d!\n", __func__, err);
+	}
+
+	err = snd_soc_dai_set_fmt(cpu_dai, cpu_fmt);
+	if (err < 0){
+		dev_err(dev,"%s: ERROR: snd_soc_dai_set_fmt set cpu dai error %d!\n", __func__, err);
+	}
+
+	/* Set the codec system clock for DAC and ADC */
+	err =
+	    snd_soc_dai_set_sysclk(codec_dai, 0, sysclk, SND_SOC_CLOCK_IN);
+
+	if (err < 0) {
+		printk(KERN_ERR "can't set codec system clock\n");
+		return err;
+	}
+
+	return err;
+}
+
+static struct snd_soc_ops sfax8_ops = {
+	.hw_params = sfax8_hw_params,
+};
+
+/* Digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link sfax8_dai[] = {
+
+#ifdef CONFIG_SND_SOC_ES8388S
+	{
+	.name = "SFA18-audio0",
+	.stream_name = "ES8388-pcm0",
+	.cpu_dai_name = "18400000.pcm",
+	.codec_dai_name = "es8388s-hifi",
+	.platform_name = "18400000.pcm",
+	.codec_name = "es8388s-codec.1-0011",
+	.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF |
+		   SND_SOC_DAIFMT_CBS_CFS,
+	.ops = &sfax8_ops,
+	},
+/*	{
+	.name = "SFA18-audio1",
+	.stream_name = "ES8388-pcm1",
+	.cpu_dai_name = "18401000.pcm",
+	.codec_dai_name = "es8388s-hifi",
+	.platform_name = "18401000.pcm",
+	.codec_name = "es8388s-codec.1-0011",
+	.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF |
+		   SND_SOC_DAIFMT_CBS_CFS,
+	.ops = &sfax8_ops,
+	},
+*/
+	{
+	.name = "SFA18-audio2",
+	.stream_name = "ES8388-i2s0",
+	.cpu_dai_name = "18000000.i2s",
+	.codec_dai_name = "es8388s-hifi",
+	.platform_name = "18000000.i2s",
+	.codec_name = "es8388s-codec.1-0011",
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		   SND_SOC_DAIFMT_CBS_CFS ,
+	.ops = &sfax8_ops,
+	},
+#endif
+#ifdef CONFIG_SND_SOC_ES8316
+	{
+	.name = "SFA18-audio0",
+	.stream_name = "ES8316-pcm0",
+	.cpu_dai_name = "18400000.pcm",
+	.codec_dai_name = "ES8316 HiFi",
+	.platform_name = "18400000.pcm",
+	.codec_name = "es8316.1-0011",
+	.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF |
+		   SND_SOC_DAIFMT_CBS_CFS,
+	.ops = &sfax8_ops,
+	},
+/*	{
+	.name = "SFA18-audio1",
+	.stream_name = "ES8316-pcm1",
+	.cpu_dai_name = "18401000.pcm",
+	.codec_dai_name = "ES8316 HIFI",
+	.platform_name = "18401000.pcm",
+	.codec_name = "es8316.1-0011",
+	.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF |
+		   SND_SOC_DAIFMT_CBS_CFS,
+	.ops = &sfax8_ops,
+	},
+*/
+	{
+	.name = "SFA18-audio2",
+	.stream_name = "ES8316-i2s0",
+	.cpu_dai_name = "18000000.i2s",
+	.codec_dai_name = "ES8316 HiFi",
+	.platform_name = "18000000.i2s",
+	.codec_name = "es8316.1-0011",
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		   SND_SOC_DAIFMT_CBS_CFS ,
+	.ops = &sfax8_ops,
+	},
+#endif
+
+};
+
+/* Audio machine driver */
+static struct snd_soc_card snd_soc_card_sfax8 = {
+	.name = "SFAX8",
+	.owner = THIS_MODULE,
+	.dai_link = sfax8_dai,
+	.num_links = ARRAY_SIZE(sfax8_dai),
+};
+
+static struct platform_device *sfax8_snd_device;
+
+static int __init sfax8_soc_init(void)
+{
+	int err;
+
+	sfax8_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!sfax8_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(sfax8_snd_device, &snd_soc_card_sfax8);
+	err = platform_device_add(sfax8_snd_device);
+	if (err)
+		goto err1;
+
+	return 0;
+
+err1:
+	platform_device_put(sfax8_snd_device);
+
+	return err;
+
+}
+
+static void __exit sfax8_soc_exit(void)
+{
+	platform_device_unregister(sfax8_snd_device);
+}
+
+module_init(sfax8_soc_init);
+module_exit(sfax8_soc_exit);
+
+MODULE_AUTHOR("Xijun Guo <xijun.guo@siflower.com.cn>");
+MODULE_DESCRIPTION("ALSA SoC SFA18");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/sound/soc/siflower/sfax8-pcm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/siflower/sfax8-pcm.c	2017-11-15 17:26:54.373090000 +0800
@@ -0,0 +1,674 @@
+/* 
+ *
+ * ALSA SoC Audio Layer - SF PCM-Controller driver
+ *
+ * Copyright (c) 2016 Siflower Co. Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/dmaengine.h>
+#include <linux/of.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sf16a18.h>
+
+/*Register Offsets */
+#define SF_PCM_CTL		0x00
+#define SF_PCM_MC		0x04
+#define SF_PCM_CLKCTL		0x08
+#define SF_PCM_CDCLKCFG		0x0C
+#define SF_PCM_SCLKCFG		0x10
+#define SF_PCM_TXFIFO		0x14
+#define SF_PCM_RXFIFO		0x18
+#define SF_PCM_IRQCTL		0x1C
+#define SF_PCM_IRQSTAT		0x20
+#define SF_PCM_FIFOSTAT		0x24
+#define SF_PCM_CLRINT		0x28
+
+/* Constant*/
+#define SF_PCM_CLKSRC_PCLK     0
+#define SF_PCM_CLKSRC_MUX      1
+#define SF_PCM_SCLK_PER_FS     0
+#define SF_PCM_TX_FIFO_DEPTH	0x10
+#define SF_PCM_RX_FIFO_DEPTH	0x10
+//#define SF_PCM_CDCLK_DIV		8
+#define SF_PCM_WORDLENGTH_8		(0x11 << 16)
+#define SF_PCM_WORDLENGTH_16	(0x0 << 16)
+#define SF_PCM_WORDLENGTH_32	(0x10 << 16)
+#define SF_PCM_WORDLENGTH_MASK	(0x1f << 16)
+#define SF_PCM_MSYNC_RATIO		256
+
+/* PCM_CTL Bit-Fields */
+#define SF_PCM_CTL_MODE         (0x1 << 27)
+#define SF_PCM_CTL_SINEDGE      (0x1 << 26)
+#define SF_PCM_CTL_CHNUM_SHIFT  23
+#define SF_PCM_CTL_CHNUM_MASK	0x7
+#define SF_PCM_CTL_FMT_SHIFT    21
+#define SF_PCM_CTL_WL_SHIFT     16
+#define SF_PCM_CTL_TXDIPSTICK_MASK	0x3f
+#define SF_PCM_CTL_TXDIPSTICK_SHIFT	10
+#define SF_PCM_CTL_RXDIPSTICK_MASK	0x3f
+#define SF_PCM_CTL_RXDIPSTICK_SHIFT	4
+#define SF_PCM_CTL_TXDMA_EN		(0x1 << 3)
+#define SF_PCM_CTL_RXDMA_EN		(0x1 << 2)
+#define SF_PCM_CTL_TXMSB_AFTER_FSYNC	(0x1 << 1)
+#define SF_PCM_CTL_RXMSB_AFTER_FSYNC	(0x1 << 0)
+
+/*PCM MC Bit-Fields*/
+#define SF_PCM_CTL_TXFIFO_EN		(0x1 << 5)
+#define SF_PCM_CTL_RXFIFO_EN		(0x1 << 4)
+#define SF_PCM_CTL_RX_EN				(0x1 << 3)
+#define SF_PCM_CTL_TX_EN				(0x1 << 2)
+#define SF_PCM_CTL_ENABLE		(0x1 << 0)
+
+/* PCM_CLKCTL Bit-Fields */
+#define SF_PCM_CLKCTL_SYNCDIV_MASK		0x1ff
+#define SF_PCM_CLKCTL_SYNCDIV_SHIFT		8
+#define SF_PCM_CLKCTL_SCLK_INV			(0x1 << 5)
+#define SF_PCM_CLKCTL_SERCLKSEL_PCLK	(0x1 << 4)
+#define SF_PCM_CLKCTL_SYNCCLK_EN		(0x1 << 3)
+#define SF_PCM_CLKCTL_SCLK_EN			(0x1 << 2)
+#define SF_PCM_CLKCTL_CDCLK_EN			(0x1 << 1)
+#define SF_PCM_CLKCTL_SERCLK_EN			(0x1 << 0)
+/* PCM_IRQCTL Bit-Fields 
+#define SF_PCM_IRQCTL_IRQEN		(0x1 << 14)
+#define SF_PCM_IRQCTL_WRDEN		(0x1 << 12)
+#define SF_PCM_IRQCTL_TXEMPTYEN	(0x1 << 11)
+#define SF_PCM_IRQCTL_TXALMSTEMPTYEN	(0x1 << 10)
+#define SF_PCM_IRQCTL_TXFULLEN		(0x1 << 9)
+#define SF_PCM_IRQCTL_TXALMSTFULLEN	(0x1 << 8)
+#define SF_PCM_IRQCTL_TXSTARVEN	(0x1 << 7)
+#define SF_PCM_IRQCTL_TXERROVRFLEN	(0x1 << 6)
+#define SF_PCM_IRQCTL_RXEMPTEN		(0x1 << 5)
+#define SF_PCM_IRQCTL_RXALMSTEMPTEN	(0x1 << 4)
+#define SF_PCM_IRQCTL_RXFULLEN		(0x1 << 3)
+#define SF_PCM_IRQCTL_RXALMSTFULLEN	(0x1 << 2)
+#define SF_PCM_IRQCTL_RXSTARVEN	(0x1 << 1)
+#define SF_PCM_IRQCTL_RXERROVRFLEN	(0x1 << 0)
+*/
+/* PCM_IRQSTAT Bit-Fields 
+#define SF_PCM_IRQSTAT_IRQPND		(0x1 << 13)
+#define SF_PCM_IRQSTAT_WRD_XFER	(0x1 << 12)
+#define SF_PCM_IRQSTAT_TXEMPTY		(0x1 << 11)
+#define SF_PCM_IRQSTAT_TXALMSTEMPTY	(0x1 << 10)
+#define SF_PCM_IRQSTAT_TXFULL		(0x1 << 9)
+#define SF_PCM_IRQSTAT_TXALMSTFULL	(0x1 << 8)
+#define SF_PCM_IRQSTAT_TXSTARV		(0x1 << 7)
+#define SF_PCM_IRQSTAT_TXERROVRFL	(0x1 << 6)
+#define SF_PCM_IRQSTAT_RXEMPT		(0x1 << 5)
+#define SF_PCM_IRQSTAT_RXALMSTEMPT	(0x1 << 4)
+#define SF_PCM_IRQSTAT_RXFULL		(0x1 << 3)
+#define SF_PCM_IRQSTAT_RXALMSTFULL	(0x1 << 2)
+#define SF_PCM_IRQSTAT_RXSTARV		(0x1 << 1)
+#define SF_PCM_IRQSTAT_RXERROVRFL	(0x1 << 0)
+*/
+/* PCM_FIFOSTAT Bit-Fields
+#define SF_PCM_FIFOSTAT_TXCNT_MSK		(0x3f << 14)
+#define SF_PCM_FIFOSTAT_TXFIFOEMPTY		(0x1 << 13)
+#define SF_PCM_FIFOSTAT_TXFIFOALMSTEMPTY	(0x1 << 12)
+#define SF_PCM_FIFOSTAT_TXFIFOFULL		(0x1 << 11)
+#define SF_PCM_FIFOSTAT_TXFIFOALMSTFULL	(0x1 << 10)
+#define SF_PCM_FIFOSTAT_RXCNT_MSK		(0x3f << 4)
+#define SF_PCM_FIFOSTAT_RXFIFOEMPTY		(0x1 << 3)
+#define SF_PCM_FIFOSTAT_RXFIFOALMSTEMPTY	(0x1 << 2)
+#define SF_PCM_FIFOSTAT_RXFIFOFULL		(0x1 << 1)
+#define SF_PCM_FIFOSTAT_RXFIFOALMSTFULL	(0x1 << 0)
+*/
+/**
+ * struct sf_pcm_info - SF PCM Controller information
+ * @dev: The parent device passed to use from the probe.
+ * @regs: The pointer to the device register block.
+ */
+struct sf_pcm_info {
+	spinlock_t lock;
+	struct device	*dev;
+	struct snd_dmaengine_dai_dma_data	dma_data[2];
+	void __iomem	*regs;
+
+	unsigned int sclk_per_fs;
+
+	/* Whether to keep PCMSCLK enabled even when idle(no active xfer) */
+	unsigned int idleclk;
+
+	struct clk	*pclk;
+	struct clk	*audio_clk;
+
+};
+
+static struct sf_pcm_info sf_pcm[2];
+
+static void sf_pcm_snd_txctrl(struct sf_pcm_info *pcm, int on)
+{
+	void __iomem *regs = pcm->regs;
+	u32 ctl, mcctl, clkctl;
+
+	clkctl = readl(regs + SF_PCM_CLKCTL);
+	ctl = readl(regs + SF_PCM_CTL);
+	mcctl = readl(regs + SF_PCM_MC);
+	ctl &= ~(SF_PCM_CTL_TXDIPSTICK_MASK
+			 << SF_PCM_CTL_TXDIPSTICK_SHIFT);
+
+	if (on) {
+		ctl |= SF_PCM_CTL_TXDMA_EN;
+		mcctl |= SF_PCM_CTL_TXFIFO_EN;
+		mcctl |= SF_PCM_CTL_ENABLE;
+		mcctl |= SF_PCM_CTL_TX_EN;
+		ctl |= (SF_PCM_TX_FIFO_DEPTH<<SF_PCM_CTL_TXDIPSTICK_SHIFT);
+		clkctl |= SF_PCM_CLKCTL_SERCLK_EN;
+		clkctl |= SF_PCM_CLKCTL_SCLK_EN;
+		clkctl |= SF_PCM_CLKCTL_SYNCCLK_EN;
+	} else {
+		ctl &= ~SF_PCM_CTL_TXDMA_EN;
+		mcctl &= ~SF_PCM_CTL_TXFIFO_EN;
+		mcctl &= ~SF_PCM_CTL_TX_EN;
+		if (!(mcctl & SF_PCM_CTL_RXFIFO_EN)) {
+			mcctl &= ~SF_PCM_CTL_ENABLE;
+			if (!pcm->idleclk)
+				clkctl |= SF_PCM_CLKCTL_SERCLK_EN;
+		}
+	}
+
+	writel(mcctl, regs + SF_PCM_MC);
+	mb();
+	writel(clkctl, regs + SF_PCM_CLKCTL);
+	writel(ctl, regs + SF_PCM_CTL);
+}
+
+static void sf_pcm_snd_rxctrl(struct sf_pcm_info *pcm, int on)
+{
+	void __iomem *regs = pcm->regs;
+	u32 mcctl, ctl, clkctl;
+
+	ctl = readl(regs + SF_PCM_CTL);
+	mcctl = readl(regs + SF_PCM_MC);
+	clkctl = readl(regs + SF_PCM_CLKCTL);
+	ctl &= ~(SF_PCM_CTL_RXDIPSTICK_MASK
+			 << SF_PCM_CTL_RXDIPSTICK_SHIFT);
+
+	if (on) {
+		ctl |= SF_PCM_CTL_RXDMA_EN;
+		mcctl |= SF_PCM_CTL_RXFIFO_EN;
+		mcctl |= SF_PCM_CTL_ENABLE;
+		mcctl |= SF_PCM_CTL_RX_EN;
+		ctl |= (SF_PCM_RX_FIFO_DEPTH<<SF_PCM_CTL_RXDIPSTICK_SHIFT);
+		clkctl |= SF_PCM_CLKCTL_SERCLK_EN;
+		clkctl |= SF_PCM_CLKCTL_SCLK_EN;
+		clkctl |= SF_PCM_CLKCTL_SYNCCLK_EN;
+	} else {
+		ctl &= ~SF_PCM_CTL_RXDMA_EN;
+		mcctl &= ~SF_PCM_CTL_RXFIFO_EN;
+		mcctl &= ~SF_PCM_CTL_RX_EN;
+		if (!(mcctl & SF_PCM_CTL_TXFIFO_EN)) {
+			mcctl &= ~SF_PCM_CTL_ENABLE;
+			if (!pcm->idleclk)
+				clkctl |= SF_PCM_CLKCTL_SERCLK_EN;
+		}
+	}
+
+	writel(clkctl, regs + SF_PCM_CLKCTL);
+	writel(mcctl, regs + SF_PCM_MC);
+	writel(ctl, regs + SF_PCM_CTL);
+}
+
+static int sf_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sf_pcm_info *pcm = snd_soc_dai_get_drvdata(rtd->cpu_dai);
+	unsigned long flags;
+
+	dev_dbg(pcm->dev, "Entered %s\n", __func__);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		spin_lock_irqsave(&pcm->lock, flags);
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			sf_pcm_snd_rxctrl(pcm, 1);
+		else
+			sf_pcm_snd_txctrl(pcm, 1);
+
+		spin_unlock_irqrestore(&pcm->lock, flags);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		spin_lock_irqsave(&pcm->lock, flags);
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			sf_pcm_snd_rxctrl(pcm, 0);
+		else
+			sf_pcm_snd_txctrl(pcm, 0);
+
+		spin_unlock_irqrestore(&pcm->lock, flags);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sf_pcm_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *socdai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sf_pcm_info *pcm = snd_soc_dai_get_drvdata(rtd->cpu_dai);
+	void __iomem *regs = pcm->regs;
+	struct clk *clk;
+	int sclk_div, sync_div;
+	unsigned long flags;
+	u32 clkctl, pcmctl, word_length, param_word, param_channel, param_rate, clk_freq, cdclk_div;
+
+	dev_dbg(pcm->dev, "Entered %s\n", __func__);
+	param_word = params_width(params);
+	param_channel = params_channels(params);
+	param_rate = params_rate(params);
+	dev_dbg(pcm->dev, "word is %d,channel is %d, rate is %d\n", param_word, param_channel, param_rate);
+
+	/* Get hold of the PCMSOURCE_CLK */
+	clkctl = readl(regs + SF_PCM_CLKCTL);
+	if (clkctl & SF_PCM_CLKCTL_SERCLKSEL_PCLK)
+		clk = pcm->pclk;
+	else
+		clk = pcm->audio_clk;
+
+	clk_freq = clk_get_rate(clk);
+
+	spin_lock_irqsave(&pcm->lock, flags);
+	pcmctl = readl(regs + SF_PCM_CTL);
+
+	/* Strictly check for sample size */
+	switch (param_word) {
+	case 8:
+		word_length = SF_PCM_WORDLENGTH_8;
+		break;
+	case 16:
+		word_length = SF_PCM_WORDLENGTH_16;
+		break;
+	case 32:
+		word_length = SF_PCM_WORDLENGTH_32;
+		break;
+	default:
+		return -EINVAL;
+	}
+	pcmctl &= ~SF_PCM_WORDLENGTH_MASK;
+	pcmctl |= word_length;
+
+	pcmctl &= ~(SF_PCM_CTL_CHNUM_MASK << SF_PCM_CTL_CHNUM_SHIFT);
+	if (param_channel < 1 || param_channel > 8) {
+		return -EINVAL;
+	}else{
+		pcmctl |= (param_channel - 1) << SF_PCM_CTL_CHNUM_SHIFT;
+	}
+
+	writel(pcmctl, regs + SF_PCM_CTL);
+	
+	/*set codec mclk source freq*/
+	cdclk_div = clk_freq / ( param_rate * SF_PCM_MSYNC_RATIO) - 1;
+	writel(cdclk_div, regs + SF_PCM_CDCLKCFG);
+
+	clkctl |= SF_PCM_CLKCTL_CDCLK_EN;
+	/* Set the SCLK divider */
+	sclk_div = clk_freq / (param_word * param_channel + 8) /
+					param_rate - 1;
+	writel(sclk_div, regs + SF_PCM_SCLKCFG);
+	/* Set the SYNC divider */
+	sync_div = clk_freq / (sclk_div + 1) / param_rate - 1;
+	clkctl &= ~(SF_PCM_CLKCTL_SYNCDIV_MASK
+				<< SF_PCM_CLKCTL_SYNCDIV_SHIFT);
+	clkctl |= ((sync_div & SF_PCM_CLKCTL_SYNCDIV_MASK)
+				<< SF_PCM_CLKCTL_SYNCDIV_SHIFT);
+
+	writel(clkctl, regs + SF_PCM_CLKCTL);
+
+	spin_unlock_irqrestore(&pcm->lock, flags);
+
+	dev_dbg(pcm->dev, "PCMSOURCE_CLK-%d SCLK_DIV=%d SYNC_DIV=%d PCMCTL=%d\n",
+				clk_freq, sclk_div, sync_div, pcmctl);
+
+	return 0;
+}
+
+static int sf_pcm_set_fmt(struct snd_soc_dai *cpu_dai,
+			       unsigned int fmt)
+{
+	struct sf_pcm_info *pcm = snd_soc_dai_get_drvdata(cpu_dai);
+	void __iomem *regs = pcm->regs;
+	unsigned long flags;
+	int ret = 0;
+	u32 ctl;
+
+	dev_dbg(pcm->dev, "Entered %s\n", __func__);
+
+	spin_lock_irqsave(&pcm->lock, flags);
+
+	ctl = readl(regs + SF_PCM_CTL);
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_NF:
+	case SND_SOC_DAIFMT_IB_IF:
+		ctl |= SF_PCM_CLKCTL_SCLK_INV;
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+	case SND_SOC_DAIFMT_NB_IF:
+		ctl &= ~SF_PCM_CLKCTL_SCLK_INV;
+		break;
+	default:
+		dev_err(pcm->dev, "Unsupported clock inversion!\n");
+		ret = -EINVAL;
+		goto exit;
+	}
+	dev_dbg(pcm->dev, "clock inv is %4x\n", fmt & SND_SOC_DAIFMT_INV_MASK);
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* Nothing to do, Master by default */
+		break;
+	default:
+		dev_err(pcm->dev, "Unsupported master/slave format!\n");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CONT:
+		pcm->idleclk = 1;
+		break;
+	case SND_SOC_DAIFMT_GATED:
+		pcm->idleclk = 0;
+		break;
+	default:
+		dev_err(pcm->dev, "Invalid Clock gating request!\n");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_A:
+		ctl |= SF_PCM_CTL_TXMSB_AFTER_FSYNC;
+		ctl |= SF_PCM_CTL_RXMSB_AFTER_FSYNC;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		ctl &= ~SF_PCM_CTL_TXMSB_AFTER_FSYNC;
+		ctl &= ~SF_PCM_CTL_RXMSB_AFTER_FSYNC;
+		break;
+	default:
+		dev_err(pcm->dev, "Unsupported data format!\n");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	writel(ctl, regs + SF_PCM_CTL);
+
+exit:
+	spin_unlock_irqrestore(&pcm->lock, flags);
+
+	return ret;
+}
+
+/*static int sf_pcm_set_clkdiv(struct snd_soc_dai *cpu_dai,
+						int div_id, int div)
+{
+	struct sf_pcm_info *pcm = snd_soc_dai_get_drvdata(cpu_dai);
+
+	switch (div_id) {
+	case SF_PCM_SCLK_PER_FS:
+		pcm->sclk_per_fs = div;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}*/
+
+static int sf_pcm_set_sysclk(struct snd_soc_dai *cpu_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct sf_pcm_info *pcm = snd_soc_dai_get_drvdata(cpu_dai);
+	void __iomem *regs = pcm->regs;
+	u32 clkctl = readl(regs + SF_PCM_CLKCTL);
+
+	switch (clk_id) {
+	case SF_PCM_CLKSRC_PCLK:
+		clkctl |= SF_PCM_CLKCTL_SERCLKSEL_PCLK;
+		break;
+
+	case SF_PCM_CLKSRC_MUX:
+		clkctl &= ~SF_PCM_CLKCTL_SERCLKSEL_PCLK;
+
+	/*	if (clk_get_rate(pcm->audio_clk) != freq)
+			clk_set_rate(pcm->audio_clk, freq);
+*/
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	writel(clkctl, regs + SF_PCM_CLKCTL);
+	dev_dbg(pcm->dev, "freq is  %d, clk_id is %d!\n", freq, clk_id);
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sf_pcm_dai_ops = {
+	.set_sysclk	= sf_pcm_set_sysclk,
+	.trigger	= sf_pcm_trigger,
+	.hw_params	= sf_pcm_hw_params,
+	.set_fmt	= sf_pcm_set_fmt,
+};
+
+static int sf_pcm_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sf_pcm_info *pcm = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai,
+							&pcm->dma_data[SNDRV_PCM_STREAM_PLAYBACK],
+							&pcm->dma_data[SNDRV_PCM_STREAM_CAPTURE]);
+
+	return 0;
+}
+
+#define SF_PCM_RATES  (SNDRV_PCM_RATE_8000_96000)
+
+#define SF_PCM_DAI_DECLARE			\
+	.symmetric_rates = 1,					\
+	.probe = sf_pcm_dai_probe,				\
+	.ops = &sf_pcm_dai_ops,				\
+	.playback = {						\
+		.channels_min	= 1,				\
+		.channels_max	= 8,				\
+		.rates		= SF_PCM_RATES,		\
+		.formats	= SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8,	\
+	},							\
+	.capture = {						\
+		.channels_min	= 1,				\
+		.channels_max	= 8,				\
+		.rates		= SF_PCM_RATES,		\
+		.formats	= SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8,	\
+	}
+
+static struct snd_soc_dai_driver sf_pcm_dai[] = {
+	[0] = {
+		.name	= "sf-pcm.0",
+		SF_PCM_DAI_DECLARE,
+	},
+	[1] = {
+		.name	= "sf-pcm.1",
+		SF_PCM_DAI_DECLARE,
+	},
+};
+
+static const struct snd_soc_component_driver sf_pcm_component = {
+	.name		= "sf-pcm",
+};
+
+static int sf_pcm_dev_probe(struct platform_device *pdev)
+{
+	struct sf_pcm_info *pcm;
+	struct resource *mem_res;
+	int ret, id;
+
+	if(release_reset(SF_PCM_SOFT_RESET))
+		return -EFAULT;
+
+	dev_dbg(&pdev->dev, "PCM start!\n");
+
+	if ( of_property_read_u32(pdev->dev.of_node, "id", &id) ){
+		dev_err(&pdev->dev, "PCM get id error!\n");
+		return -EINVAL;
+	}else{
+		pdev->id = id;
+	}
+	/* Check for valid device index */
+	if (pdev->id >= ARRAY_SIZE(sf_pcm)) {
+		dev_err(&pdev->dev, "id %d out of range\n", pdev->id);
+		return -EINVAL;
+	}
+
+	pcm = &sf_pcm[pdev->id];
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "Unable to get register resource\n");
+		return -ENXIO;
+	}
+
+	pcm->dev = &pdev->dev;
+
+	spin_lock_init(&pcm->lock);
+
+	/* Default is 128fs */
+	pcm->sclk_per_fs = 128;
+
+	pcm->audio_clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(pcm->audio_clk)) {
+		dev_err(&pdev->dev, "failed to get pcm-audio_clk\n");
+		ret = PTR_ERR(pcm->audio_clk);
+		goto err1;
+	}
+	ret = clk_prepare_enable(pcm->audio_clk);
+	if (ret){
+		dev_err(&pdev->dev, "failed to start audio clk\n");
+		goto err1;
+	}
+	/* record our pcm structure for later use in the callbacks */
+	dev_set_drvdata(&pdev->dev, pcm);
+
+	if (!request_mem_region(mem_res->start,
+				resource_size(mem_res), "sfax8-pcm")) {
+		dev_err(&pdev->dev, "Unable to request register region\n");
+		ret = -EBUSY;
+		goto err2;
+	}
+
+	pcm->regs = ioremap(mem_res->start, 0x100);
+	if (pcm->regs == NULL) {
+		dev_err(&pdev->dev, "cannot ioremap registers\n");
+		ret = -ENXIO;
+		goto err3;
+	}
+
+/*	pcm->pclk = devm_clk_get(&pdev->dev, "pcm-pclk");
+	if (IS_ERR(pcm->pclk)) {
+		dev_err(&pdev->dev, "failed to get pcm-pclk\n");
+		ret = -ENOENT;
+		goto err4;
+	}
+	clk_prepare_enable(pcm->pclk);
+*/
+
+	pcm->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr = (dma_addr_t)mem_res->start
+							+ SF_PCM_RXFIFO;
+	pcm->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr = (dma_addr_t)mem_res->start
+							+ SF_PCM_TXFIFO;
+	
+	pcm->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr_width = 
+							DMA_SLAVE_BUSWIDTH_UNDEFINED;
+	pcm->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr_width =
+							DMA_SLAVE_BUSWIDTH_UNDEFINED;
+
+	pcm->dma_data[SNDRV_PCM_STREAM_CAPTURE].maxburst = 16;
+	pcm->dma_data[SNDRV_PCM_STREAM_PLAYBACK].maxburst = 16;
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sf_pcm_component,
+					 &sf_pcm_dai[pdev->id], 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "failed to get register DAI: %d\n", ret);
+		goto err4;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get register DMA: %d\n", ret);
+		goto err4;
+	}
+
+	return 0;
+
+/*err5:
+	clk_disable_unprepare(pcm->pclk);*/
+err4:
+	iounmap(pcm->regs);
+err3:
+	release_mem_region(mem_res->start, resource_size(mem_res));
+err2:
+	clk_disable_unprepare(pcm->audio_clk);
+err1:
+	return ret;
+}
+
+static int sf_pcm_dev_remove(struct platform_device *pdev)
+{
+	struct sf_pcm_info *pcm = &sf_pcm[pdev->id];
+	struct resource *mem_res;
+
+	iounmap(pcm->regs);
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem_res->start, resource_size(mem_res));
+
+	clk_disable_unprepare(pcm->audio_clk);
+/*	clk_disable_unprepare(pcm->pclk);*/
+
+	if(hold_reset(SF_PCM_SOFT_RESET))
+		return -EFAULT;
+	return 0;
+}
+
+static const struct of_device_id sfax8_pcm_of_match[] = {
+	{ .compatible = "siflower,sfax8-pcm",},
+	{},
+};
+
+static struct platform_driver sf_pcm_driver = {
+	.probe  = sf_pcm_dev_probe,
+	.remove = sf_pcm_dev_remove,
+	.driver = {
+		.name = "sfax8-pcm",
+		.owner = THIS_MODULE,
+		.of_match_table = sfax8_pcm_of_match,
+	},
+};
+
+module_platform_driver(sf_pcm_driver);
+
+/* Module information */
+MODULE_AUTHOR("Xijun Guo, <xijun.guo@siflower.com>");
+MODULE_DESCRIPTION("SF PCM Controller Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:SF-pcm");
Index: linux-3.18.29/sound/soc/siflower/sfax8_i2s.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/sound/soc/siflower/sfax8_i2s.c	2017-11-15 17:26:54.373090000 +0800
@@ -0,0 +1,700 @@
+/*
+ * ALSA SoC Synopsys I2S Audio Layer
+ *
+ * sound/soc/sf/sfax8_i2s.c
+ *
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <sound/sfax8_i2s.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+//Module reset
+#include <sf16a18.h>
+
+
+/* common register for all channel */
+#define IER		0x000
+#define IRER		0x004
+#define ITER		0x008
+#define CER		0x00C
+#define CCR		0x010
+#define RXFFR		0x014
+#define TXFFR		0x018
+
+/* I2STxRxRegisters for all channels */
+#define LRBR_LTHR(x)	(0x40 * x + 0x020)
+#define RRBR_RTHR(x)	(0x40 * x + 0x024)
+#define RER(x)		(0x40 * x + 0x028)
+#define TER(x)		(0x40 * x + 0x02C)
+#define RCR(x)		(0x40 * x + 0x030)
+#define TCR(x)		(0x40 * x + 0x034)
+#define ISR(x)		(0x40 * x + 0x038)
+#define IMR(x)		(0x40 * x + 0x03C)
+#define ROR(x)		(0x40 * x + 0x040)
+#define TOR(x)		(0x40 * x + 0x044)
+#define RFCR(x)		(0x40 * x + 0x048)
+#define TFCR(x)		(0x40 * x + 0x04C)
+#define RFF(x)		(0x40 * x + 0x050)
+#define TFF(x)		(0x40 * x + 0x054)
+
+/* I2SCOMPRegisters */
+#define I2S_COMP_PARAM_2	0x01F0
+#define I2S_COMP_PARAM_1	0x01F4
+#define I2S_COMP_VERSION	0x01F8
+#define I2S_COMP_TYPE		0x01FC
+
+/*
+* IMCR	IIS Mode register
+* ICDR	IIS CDCLK Divisor register 
+* ISDR	IIS SCLK  Divisor register
+*/
+#define IMCR				0x3000
+#define ICDR				0x3004
+#define ISDR				0x3008
+
+/*
+ * Component parameter register fields - define the I2S block's
+ * configuration.
+ */
+#define	COMP1_TX_WORDSIZE_3(r)	(((r) & GENMASK(27, 25)) >> 25)
+#define	COMP1_TX_WORDSIZE_2(r)	(((r) & GENMASK(24, 22)) >> 22)
+#define	COMP1_TX_WORDSIZE_1(r)	(((r) & GENMASK(21, 19)) >> 19)
+#define	COMP1_TX_WORDSIZE_0(r)	(((r) & GENMASK(18, 16)) >> 16)
+#define	COMP1_TX_CHANNELS(r)	(((r) & GENMASK(10, 9)) >> 9)
+#define	COMP1_RX_CHANNELS(r)	(((r) & GENMASK(8, 7)) >> 7)
+#define	COMP1_RX_ENABLED(r)	(((r) & BIT(6)) >> 6)
+#define	COMP1_TX_ENABLED(r)	(((r) & BIT(5)) >> 5)
+#define	COMP1_MODE_EN(r)	(((r) & BIT(4)) >> 4)
+#define	COMP1_FIFO_DEPTH_GLOBAL(r)	(((r) & GENMASK(3, 2)) >> 2)
+#define	COMP1_APB_DATA_WIDTH(r)	(((r) & GENMASK(1, 0)) >> 0)
+
+#define	COMP2_RX_WORDSIZE_3(r)	(((r) & GENMASK(12, 10)) >> 10)
+#define	COMP2_RX_WORDSIZE_2(r)	(((r) & GENMASK(9, 7)) >> 7)
+#define	COMP2_RX_WORDSIZE_1(r)	(((r) & GENMASK(5, 3)) >> 3)
+#define	COMP2_RX_WORDSIZE_0(r)	(((r) & GENMASK(2, 0)) >> 0)
+
+/* Number of entries in WORDSIZE and DATA_WIDTH parameter registers */
+#define	COMP_MAX_WORDSIZE	(1 << 3)
+#define	COMP_MAX_DATA_WIDTH	(1 << 2 )
+
+#define I2S_MAX_CHANNEL_NUM		2
+#define I2S_MIN_CHANNEL_NUM		2
+
+union sf_i2s_snd_dma_data {
+	struct i2s_dma_data pd;
+	struct snd_dmaengine_dai_dma_data dt;
+};
+
+struct sf_i2s_dev {
+	void __iomem *i2s_base;
+	struct clk *clk;
+	int active;
+	unsigned int capability;
+	struct device *dev;
+
+	/* data related to DMA transfers b/w i2s and DMAC */
+	union sf_i2s_snd_dma_data play_dma_data;
+	union sf_i2s_snd_dma_data capture_dma_data;
+	struct i2s_clk_config_data config;
+	int (*i2s_clk_cfg)(struct i2s_clk_config_data *config, unsigned long rate);
+};
+static int sf_i2s_clk_cfg(struct i2s_clk_config_data *config, unsigned long rate);
+static inline void i2s_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 i2s_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static inline void i2s_disable_channels(struct sf_i2s_dev *dev, u32 stream)
+{
+	u32 i = 0;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++)
+			i2s_write_reg(dev->i2s_base, TER(i), 0);
+	} else {
+		for (i = 0; i < 4; i++)
+			i2s_write_reg(dev->i2s_base, RER(i), 0);
+	}
+}
+
+static inline void i2s_clear_irqs(struct sf_i2s_dev *dev, u32 stream)
+{
+	u32 i = 0;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++)
+			i2s_read_reg(dev->i2s_base, TOR(i));
+	} else {
+		for (i = 0; i < 4; i++)
+			i2s_read_reg(dev->i2s_base, ROR(i));
+	}
+}
+
+static void i2s_start(struct sf_i2s_dev *dev,
+		      struct snd_pcm_substream *substream)
+{
+	u32 i, irq;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq & ~0x30);
+		}
+		i2s_write_reg(dev->i2s_base, ITER, 1);
+	} else {
+		for (i = 0; i < 4; i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq & ~0x03);
+		}
+		i2s_write_reg(dev->i2s_base, IRER, 1);
+	}
+
+	i2s_write_reg(dev->i2s_base, CER, 1);
+	i2s_write_reg(dev->i2s_base, IER, 1);
+}
+
+static void i2s_stop(struct sf_i2s_dev *dev,
+		struct snd_pcm_substream *substream)
+{
+	u32 i = 0, irq;
+
+	i2s_clear_irqs(dev, substream->stream);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		i2s_write_reg(dev->i2s_base, ITER, 0);
+
+		for (i = 0; i < 4; i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq | 0x30);
+		}
+	} else {
+		i2s_write_reg(dev->i2s_base, IRER, 0);
+
+		for (i = 0; i < 4; i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq | 0x03);
+		}
+	}
+
+	if (!dev->active) {
+		i2s_write_reg(dev->i2s_base, CER, 0);
+		i2s_write_reg(dev->i2s_base, IER, 0);
+	}
+}
+
+static int sf_i2s_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct sf_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	union sf_i2s_snd_dma_data *dma_data = NULL;
+
+
+	if (!(dev->capability & SF_I2S_RECORD) &&
+			(substream->stream == SNDRV_PCM_STREAM_CAPTURE))
+		return -EINVAL;
+
+	if (!(dev->capability & SF_I2S_PLAY) &&
+			(substream->stream == SNDRV_PCM_STREAM_PLAYBACK))
+		return -EINVAL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &dev->play_dma_data;
+	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		dma_data = &dev->capture_dma_data;
+
+	snd_soc_dai_set_dma_data(cpu_dai, substream, (void *)dma_data);
+
+	return 0;
+}
+
+static int sf_i2s_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sf_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	struct i2s_clk_config_data *config = &dev->config;
+	u32 ccr, xfer_resolution, ch_reg, irq;
+	int ret;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		config->data_width = 16;
+		ccr = 0x00;
+		xfer_resolution = 0x02;
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		config->data_width = 24;
+		ccr = 0x08;
+		xfer_resolution = 0x04;
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		config->data_width = 32;
+		ccr = 0x10;
+		xfer_resolution = 0x05;
+		break;
+
+	default:
+		dev_err(dev->dev, "sfax8-i2s: unsuppted PCM fmt");
+		return -EINVAL;
+	}
+
+	config->chan_nr = params_channels(params);
+	printk("Playback Stream channels:%d, dat_width is %d\n", config->chan_nr,
+		config->data_width);
+	switch (config->chan_nr) {
+	case EIGHT_CHANNEL_SUPPORT:
+	case SIX_CHANNEL_SUPPORT:
+	case FOUR_CHANNEL_SUPPORT:
+	case TWO_CHANNEL_SUPPORT:
+		break;
+	default:
+		dev_err(dev->dev, "channel not supported\n");
+		return -EINVAL;
+	}
+
+	i2s_disable_channels(dev, substream->stream);
+
+	for (ch_reg = 0; ch_reg < (config->chan_nr / 2); ch_reg++) {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			i2s_write_reg(dev->i2s_base, TCR(ch_reg),
+				      xfer_resolution);
+			i2s_write_reg(dev->i2s_base, TFCR(ch_reg), 0x08);
+			irq = i2s_read_reg(dev->i2s_base, IMR(ch_reg));
+			i2s_write_reg(dev->i2s_base, IMR(ch_reg), irq & ~0x30);
+			i2s_write_reg(dev->i2s_base, TER(ch_reg), 1);
+		} else {
+			i2s_write_reg(dev->i2s_base, RCR(ch_reg),
+				      xfer_resolution);
+			i2s_write_reg(dev->i2s_base, RFCR(ch_reg), 0x07);
+			irq = i2s_read_reg(dev->i2s_base, IMR(ch_reg));
+			i2s_write_reg(dev->i2s_base, IMR(ch_reg), irq & ~0x03);
+			i2s_write_reg(dev->i2s_base, RER(ch_reg), 1);
+		}
+	}
+
+	i2s_write_reg(dev->i2s_base, CCR, ccr);
+
+	config->sample_rate = params_rate(params);
+	dev->i2s_clk_cfg = &sf_i2s_clk_cfg;
+	if (dev->capability & SF_I2S_MASTER) {
+		if (dev->i2s_clk_cfg) {
+			ret = dev->i2s_clk_cfg(config, clk_get_rate(dev->clk));
+			if (ret < 0) {
+				dev_err(dev->dev, "runtime audio clk config fail\n");
+				return ret;
+			} else {
+				i2s_write_reg(dev->i2s_base, ISDR, ret);
+			}
+		} else {
+			u32 bitclk = config->sample_rate *
+					config->data_width * 2;
+
+			printk("dev_i2s_clk_clk is null \n");
+			ret = clk_set_rate(dev->clk, bitclk);
+			if (ret) {
+				dev_err(dev->dev, "Can't set I2S clock rate: %d\n",
+					ret);
+				return ret;
+			}
+		}
+	}
+	return 0;
+}
+static int sf_i2s_clk_cfg(struct i2s_clk_config_data *config, unsigned long rate)
+{
+	unsigned int div = 0;
+	div = rate / (config->sample_rate * 2 * config->data_width);
+	if(div > 1)
+		return div - 1;
+	else
+		return 0;
+}
+
+
+static void sf_i2s_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	snd_soc_dai_set_dma_data(dai, substream, NULL);
+}
+
+static int sf_i2s_prepare(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	struct sf_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, TXFFR, 1);
+	else
+		i2s_write_reg(dev->i2s_base, RXFFR, 1);
+
+	return 0;
+}
+
+static int sf_i2s_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct sf_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dev->active++;
+		i2s_start(dev, substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev->active--;
+		i2s_stop(dev, substream);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sf_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct sf_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		if (dev->capability & SF_I2S_SLAVE)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		if (dev->capability & SF_I2S_MASTER)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+	case SND_SOC_DAIFMT_CBS_CFM:
+		ret = -EINVAL;
+		break;
+	default:
+		dev_dbg(dev->dev, "sf : Invalid master/slave format\n");
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static struct snd_soc_dai_ops sf_i2s_dai_ops = {
+	.startup	= sf_i2s_startup,
+	.shutdown	= sf_i2s_shutdown,
+	.hw_params	= sf_i2s_hw_params,
+	.prepare	= sf_i2s_prepare,
+	.trigger	= sf_i2s_trigger,
+	.set_fmt	= sf_i2s_set_fmt,
+};
+
+static const struct snd_soc_component_driver sf_i2s_component = {
+	.name		= "sf-i2s",
+};
+
+#ifdef CONFIG_PM
+
+static int sf_i2s_suspend(struct snd_soc_dai *dai)
+{
+	struct sf_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	if (dev->capability & SF_I2S_MASTER)
+		clk_disable(dev->clk);
+	return 0;
+}
+
+static int sf_i2s_resume(struct snd_soc_dai *dai)
+{
+	struct sf_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	if (dev->capability & SF_I2S_MASTER)
+		clk_enable(dev->clk);
+	return 0;
+}
+
+#else
+#define sf_i2s_suspend	NULL
+#define sf_i2s_resume	NULL
+#endif
+
+/*
+ * The following tables allow a direct lookup of various parameters
+ * defined in the I2S block's configuration in terms of sound system
+ * parameters.  Each table is sized to the number of entries possible
+ * according to the number of configuration bits describing an I2S
+ * block parameter.
+ */
+
+/* Maximum bit resolution of a channel - not uniformly spaced */
+static const u32 fifo_width[COMP_MAX_WORDSIZE] = {
+	12, 16, 20, 24, 32, 0, 0, 0
+};
+
+/* Width of (DMA) bus */
+static const u32 bus_widths[COMP_MAX_DATA_WIDTH] = {
+	DMA_SLAVE_BUSWIDTH_1_BYTE,
+	DMA_SLAVE_BUSWIDTH_2_BYTES,
+	DMA_SLAVE_BUSWIDTH_3_BYTES,
+	DMA_SLAVE_BUSWIDTH_UNDEFINED,
+};
+/* PCM format to support channel resolution */
+static const u32 formats[COMP_MAX_WORDSIZE] = {
+	SNDRV_PCM_FMTBIT_S16_LE,
+	SNDRV_PCM_FMTBIT_S16_LE,
+	SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S32_LE,
+	0,
+	0,
+	0
+};
+
+static int sf_configure_dai(struct sf_i2s_dev *dev,
+				   struct snd_soc_dai_driver *sf_i2s_dai,
+				   unsigned int rates)
+{
+	dev_dbg(dev->dev, "sfax8: playback supported\n");
+	sf_i2s_dai->playback.channels_min = I2S_MIN_CHANNEL_NUM;
+	sf_i2s_dai->playback.channels_max = I2S_MAX_CHANNEL_NUM;
+	sf_i2s_dai->playback.formats = formats[0];
+	sf_i2s_dai->playback.rates = rates;
+
+	printk("paly rate is %d \n",rates);
+	dev_dbg(dev->dev, "sfax8: record supported\n");
+	sf_i2s_dai->capture.channels_min = I2S_MIN_CHANNEL_NUM;
+	sf_i2s_dai->capture.channels_max = I2S_MIN_CHANNEL_NUM;
+	sf_i2s_dai->capture.formats = formats[0];
+	sf_i2s_dai->capture.rates = rates;
+
+	dev_dbg(dev->dev, "sfax8: i2s master mode supported\n");
+	dev->capability |= SF_I2S_MASTER;
+	return 0;
+}
+
+static int sf_configure_dai_by_pd(struct sf_i2s_dev *dev,
+				   struct snd_soc_dai_driver *sf_i2s_dai,
+				   struct resource *res,
+				   const struct i2s_platform_data *pdata)
+{
+	/*
+	 * try to get bus width via I2S_COMP_PARAM_1 register,but 
+	 * this register don't exist in our soc.
+	 */
+	u32 comp1 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_1);
+	
+	u32 idx = COMP1_APB_DATA_WIDTH(comp1);
+	int ret;
+
+	if (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))
+		return -EINVAL;
+
+	ret = sf_configure_dai(dev, sf_i2s_dai, pdata->snd_rates);
+	if (ret < 0)
+		return ret;
+
+	/* Set DMA slaves info */
+	dev->play_dma_data.pd.data = pdata->play_dma_data;
+	dev->capture_dma_data.pd.data = pdata->capture_dma_data;
+	dev->play_dma_data.pd.addr = res->start + I2S_TXDMA;
+	dev->capture_dma_data.pd.addr = res->start + I2S_RXDMA;
+	dev->play_dma_data.pd.max_burst = 16;
+	dev->capture_dma_data.pd.max_burst = 16;
+/*
+	dev->play_dma_data.pd.addr_width = bus_widths[idx];
+	dev->capture_dma_data.pd.addr_width = bus_widths[idx];
+*/
+	dev->play_dma_data.pd.filter = pdata->filter;
+	dev->capture_dma_data.pd.filter = pdata->filter;
+
+	return 0;
+}
+
+static int sf_configure_dai_by_dt(struct sf_i2s_dev *dev,
+				   struct snd_soc_dai_driver *sf_i2s_dai,
+				   struct resource *res)
+{
+	int ret, fifo_depth;
+	ret = sf_configure_dai(dev, sf_i2s_dai, SNDRV_PCM_RATE_8000_192000);
+	if (ret < 0) {
+		return ret;
+	}
+	fifo_depth = 16;
+	dev->capability |= SF_I2S_PLAY;
+	dev->play_dma_data.dt.addr = res->start + I2S_TXDMA;
+/*
+  	dev->play_dma_data.dt.addr_width = bus_widths[4];
+*/
+	dev->play_dma_data.dt.chan_name = "tx";
+	dev->play_dma_data.dt.fifo_size = fifo_depth *
+		(fifo_width[4]) >> 8;
+	dev->play_dma_data.dt.maxburst = 8;
+
+
+	dev->capability |= SF_I2S_RECORD;
+	dev->capture_dma_data.dt.addr = res->start + I2S_RXDMA;
+/*
+	dev->capture_dma_data.dt.addr_width = bus_widths[4];
+*/
+	dev->capture_dma_data.dt.chan_name = "rx";
+	dev->capture_dma_data.dt.fifo_size = fifo_depth *
+		(fifo_width[4] >> 8);
+	dev->capture_dma_data.dt.maxburst = 8;
+	return 0;
+
+}
+// static struct sf_i2s_dev sf_i2s[2];
+
+
+static int sf_i2s_probe(struct platform_device *pdev)
+{
+	const struct i2s_platform_data *pdata = pdev->dev.platform_data;
+	struct sf_i2s_dev *dev;
+	struct resource *res;
+	int ret;
+	struct snd_soc_dai_driver *sf_i2s_dai;
+
+	if(release_reset(SF_IIS_SOFT_RESET))
+		return -EFAULT;
+
+	//const char *clk_id;
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_warn(&pdev->dev, "kzalloc fail\n");
+		return -ENOMEM;
+	}
+	sf_i2s_dai = devm_kzalloc(&pdev->dev, sizeof(*sf_i2s_dai), GFP_KERNEL);
+	if (!sf_i2s_dai)
+		return -ENOMEM;
+	sf_i2s_dai->ops = &sf_i2s_dai_ops;
+	sf_i2s_dai->suspend = sf_i2s_suspend;
+	sf_i2s_dai->resume = sf_i2s_resume;
+
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->i2s_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dev->i2s_base))
+		return PTR_ERR(dev->i2s_base);
+
+	dev->dev = &pdev->dev;
+
+	if (pdata) {
+		dev->capability = pdata->cap;
+		//clk_id = NULL;
+		ret = sf_configure_dai_by_pd(dev, sf_i2s_dai, res, pdata);
+	} else {
+		//clk_id = NULL;
+		dev->i2s_clk_cfg = &sf_i2s_clk_cfg;
+		ret = sf_configure_dai_by_dt(dev, sf_i2s_dai, res);
+	}
+	if (ret < 0)
+		return ret;
+
+	if (dev->capability & SF_I2S_MASTER) {
+		if (pdata) {
+			dev->i2s_clk_cfg = pdata->i2s_clk_cfg;
+			if (!dev->i2s_clk_cfg) {
+				dev_err(&pdev->dev, "no clock configure method\n");
+				return -ENODEV;
+			}
+		}
+		/*Master mode*/
+		i2s_write_reg(dev->i2s_base, IMCR, I2S_MASTER_MODE);
+		i2s_write_reg(dev->i2s_base, ICDR, I2S_CDCLK_DIV);
+
+		dev->clk = devm_clk_get(&pdev->dev, NULL);
+
+		if (IS_ERR(dev->clk))
+			return PTR_ERR(dev->clk);
+
+		ret = clk_prepare_enable(dev->clk);
+		if (ret < 0)
+			return ret;
+	}
+
+	dev_set_drvdata(&pdev->dev, dev);
+	ret = devm_snd_soc_register_component(&pdev->dev, &sf_i2s_component,
+					 sf_i2s_dai, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "not able to register dai\n");
+		goto err_clk_disable;
+	}
+
+	if (!pdata) {
+		ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"Could not register PCM: %d\n", ret);
+			goto err_clk_disable;
+		}
+	}
+	return 0;
+
+err_clk_disable:
+	if (dev->capability & SF_I2S_MASTER)
+		clk_disable_unprepare(dev->clk);
+	return ret;
+}
+
+static int sf_i2s_remove(struct platform_device *pdev)
+{
+	struct sf_i2s_dev *dev = dev_get_drvdata(&pdev->dev);
+
+	if (dev->capability & SF_I2S_MASTER)
+		clk_disable_unprepare(dev->clk);
+
+	if(hold_reset(SF_IIS_SOFT_RESET))
+		return -EFAULT;
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id sf_i2s_of_match[] = {
+	{ .compatible = "siflower,sfax8-i2s",	 },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, sf_i2s_of_match);
+#endif
+
+static struct platform_driver sf_i2s_driver = {
+	.probe		= sf_i2s_probe,
+	.remove		= sf_i2s_remove,
+	.driver		= {
+		.name	= "sfax8-i2s",
+		.of_match_table = of_match_ptr(sf_i2s_of_match),
+	},
+};
+
+module_platform_driver(sf_i2s_driver);
+
+MODULE_DESCRIPTION("SFAX8 I2S SoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sfax8_i2s");
Index: linux-3.18.29/arch/mips/siflower/Platform
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/Platform	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,22 @@
+#
+# Siflower SoC common stuff
+#
+platform-$(CONFIG_SIFLOWER)	+= siflower/
+cflags-$(CONFIG_SIFLOWER)	+= -I$(srctree)/arch/mips/include/asm/mach-siflower
+
+ifdef CONFIG_KVM_GUEST
+    load-$(CONFIG_SIFLOWER)	+= 0x0000000040100000
+else
+    load-$(CONFIG_SIFLOWER)	+= 0xffffffff80100000
+endif
+
+#
+# Siflower sf16a18
+cflags-$(CONFIG_SOC_SF16A18)	+= -I$(srctree)/arch/mips/include/asm/mach-siflower/sf16a18
+
+#
+# Siflower sf16a28
+#
+cflags-$(CONFIG_SOC_SF16A28)	+= -I$(srctree)/arch/mips/include/asm/mach-siflower/sf16a28
+
+all-$(CONFIG_SIFLOWER)	:= $(COMPRESSION_FNAME).bin
Index: linux-3.18.29/arch/mips/siflower/sf16a18-clk.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/sf16a18-clk.c	2017-11-21 20:13:12.462710527 +0800
@@ -0,0 +1,678 @@
+/*
+ * SF16A18 clocks.
+ *
+ * Exposes all configurable internal clock sources to the clk framework.
+ *
+ * We have:
+ *  - Root source, usually 12MHz supplied by an external crystal
+ *  - 4 PLLs which generate multiples of root rate [CPU, DDR, CMN, SPC]
+ *
+ * Dividers:
+ *  - 22 clock dividers with:
+ *   * selectable source [one of the PLLs],
+ *   * output divided between [1 .. 256]
+ *   * can be enabled individually.
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/clk-private.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+
+static DEFINE_SPINLOCK(cm_cfg_lock);
+
+typedef enum cm_cfg_t{
+	BUS1_CFG,
+	BUS2_CFG,
+	BUS3_CFG,
+	CPU_CFG,
+	PBUS_CFG,
+	MEMPHY_CFG,
+	AUDIO_CFG,
+	UART_CFG,
+	SPDIF_CFG,
+	SDIO_CFG,
+	EMMC_CFG,
+	ETH_REF_CFG,
+	ETH_BYP_REF_CFG,
+	ETH_TSU_CFG,
+	M_SFDSP_0_CFG,
+	M_SFDSP_1_CFG,
+	WLAN24_CFG,
+	WLAN5_CFG,
+	USBPHY_CFG,
+	TCLK_CFG,
+	NPU_PE_CFG,
+	GDU0_CFG,
+	GDU0_EITF_CFG,
+	TVIF0_CFG,
+	CRYPTO_CFG
+}sf16a18_cfg;
+
+/*
+ *	CM_CFG_CLK init.
+ */
+static const char ** __init clk_mux_get_parents(struct device_node *np,
+		int *num_parents)
+{
+	const char **parents;
+	int nparents, i;
+
+	nparents = of_count_phandle_with_args(np, "clocks", "#clock-cells");
+	if (WARN_ON(nparents <= 0))
+		return ERR_PTR(-EINVAL);
+
+	parents = kzalloc(nparents * sizeof(const char *), GFP_KERNEL);
+	if (!parents)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < nparents; i++)
+		parents[i] = of_clk_get_parent_name(np, i);
+
+	*num_parents = nparents;
+	return parents;
+}
+typedef struct sf_clk_data {
+	spinlock_t *lock;
+	unsigned long clk_flags;
+}sf_clk_data_t;
+
+static sf_clk_data_t sf16a18_clk_data = {
+	.lock = &cm_cfg_lock,
+	.clk_flags = CLK_SET_PARENT_GATE,
+};
+
+static struct of_device_id sfa18_bus1_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-bus1-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_bus2_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-bus2-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_bus3_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-bus3-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_cpu_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-cpu-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_pbus_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-pbus-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_memphy_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-memphy-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_audio_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-audio-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_uart_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-uart-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_spdif_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-spdif-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_sdio_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-sdhc-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_emmc_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-emmc-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_eth_ref_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-eth-ref-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_eth_byp_ref_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-eth-byp-ref-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_eth_tsu_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-eth-tsu-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_m_SFDSP_0_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-m_SFDSP-0-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+
+static struct of_device_id sfa18_m_SFDSP_1_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-m_SFDSP-1-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+
+static struct of_device_id sfa18_wlan24_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-wlan24-mac-wt-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_wlan5_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-wlan5-mac-wt-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_usbphy_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-usbphy-ref-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_tclk_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-tclk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_npupe_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-npupe-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_gdu0_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-gdu0-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_gdu0_eitf_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-gdu0-eitf-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_tvif0_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-tvif0-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+static struct of_device_id sfa18_crypto_cfg_of_match[] = {
+	{
+		.compatible = "siflower,sf16a18-crypto-clk",
+		.data = &sf16a18_clk_data,
+	},
+	{}
+};
+
+static void sf16a18_cfg_setup(struct device_node *np,int cfg_type)
+{
+	int num_parents;
+	const struct of_device_id *match;
+	struct clk *clk;
+	const char **parents;
+	struct clk_gate *gate;
+	struct clk_divider *div;
+	struct clk_mux *mux;
+	void __iomem *reg = NULL;
+	const char *clk_name;
+	struct clk_onecell_data *clk_data;
+	sf_clk_data_t *data;
+
+	if(!np)
+	{
+		pr_err("%s +%d %s: Device node not available for pll %d.\n",__FILE__,__LINE__,__func__,cfg_type);
+		return;
+	}
+
+	switch(cfg_type){
+		case BUS1_CFG:
+			match = of_match_node(sfa18_bus1_cfg_of_match, np);
+			break;
+		case BUS2_CFG:
+			match = of_match_node(sfa18_bus2_cfg_of_match, np);
+			break;
+		case BUS3_CFG:
+			match = of_match_node(sfa18_bus3_cfg_of_match, np);
+			break;
+		case CPU_CFG:
+			match = of_match_node(sfa18_cpu_cfg_of_match, np);
+			break;
+		case PBUS_CFG:
+			match = of_match_node(sfa18_pbus_cfg_of_match, np);
+			break;
+		case MEMPHY_CFG:
+			match = of_match_node(sfa18_memphy_cfg_of_match, np);
+			break;
+		case AUDIO_CFG:
+			match = of_match_node(sfa18_audio_cfg_of_match, np);
+			break;
+		case UART_CFG:
+			match = of_match_node(sfa18_uart_cfg_of_match, np);
+			break;
+		case SPDIF_CFG:
+			match = of_match_node(sfa18_spdif_cfg_of_match, np);
+			break;
+		case SDIO_CFG:
+			match = of_match_node(sfa18_sdio_cfg_of_match, np);
+			break;
+		case EMMC_CFG:
+			match = of_match_node(sfa18_emmc_cfg_of_match, np);
+			break;
+		case ETH_REF_CFG:
+			match = of_match_node(sfa18_eth_ref_cfg_of_match, np);
+			break;
+		case ETH_BYP_REF_CFG:
+			match = of_match_node(sfa18_eth_byp_ref_cfg_of_match, np);
+			break;
+		case ETH_TSU_CFG:
+			match = of_match_node(sfa18_eth_tsu_cfg_of_match, np);
+			break;
+		case M_SFDSP_0_CFG:
+			match = of_match_node(sfa18_m_SFDSP_0_cfg_of_match, np);
+			break;
+		case M_SFDSP_1_CFG:
+			match = of_match_node(sfa18_m_SFDSP_1_cfg_of_match, np);
+			break;
+		case WLAN24_CFG:
+			match = of_match_node(sfa18_wlan24_cfg_of_match, np);
+			break;
+		case WLAN5_CFG:
+			match = of_match_node(sfa18_wlan5_cfg_of_match, np);
+			break;
+		case USBPHY_CFG:
+			match = of_match_node(sfa18_usbphy_cfg_of_match, np);
+			break;
+		case TCLK_CFG:
+			match = of_match_node(sfa18_tclk_cfg_of_match, np);
+			break;
+		case NPU_PE_CFG:
+			match = of_match_node(sfa18_npupe_cfg_of_match, np);
+			break;
+		case GDU0_CFG:
+			match = of_match_node(sfa18_gdu0_cfg_of_match, np);
+			break;
+		case GDU0_EITF_CFG:
+			match = of_match_node(sfa18_gdu0_eitf_cfg_of_match, np);
+			break;
+		case TVIF0_CFG:
+			match = of_match_node(sfa18_tvif0_cfg_of_match, np);
+			break;
+		case CRYPTO_CFG:
+			match = of_match_node(sfa18_crypto_cfg_of_match, np);
+			break;
+		default:
+			pr_err("%s +%d %s: No such cfg_type: %d.\n",__FILE__,__LINE__,__func__,cfg_type);
+			return;
+	}
+
+	if (!match) {
+		pr_err("%s +%d %s: No matching data.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	data = (sf_clk_data_t *)match->data;
+
+	reg = of_iomap(np, 0);
+	if (!reg)
+	{
+		pr_err("%s +%d %s: Can't get clk base address.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	if (of_property_read_string(np, "clock-output-names", &clk_name))
+	{
+		pr_err("%s +%d %s: No matching name.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+	if (*clk_name == '\0')
+	{
+		pr_err("%s +%d %s: Clock name is empty.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	parents = clk_mux_get_parents(np, &num_parents);
+
+	if(!parents)
+	{
+		pr_err("%s +%d %s: Can't get parent names.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	clk_data = kzalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+	if (!clk_data)
+	{
+		pr_err("%s +%d %s: Can not alloc clk data.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	clk_data->clk_num = 1;
+	clk_data->clks = kzalloc(clk_data->clk_num * sizeof(struct clk *),
+			GFP_KERNEL);
+
+	if (!clk_data->clks)
+	{
+		pr_err("%s +%d %s: Can not alloc clk.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+
+	gate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);
+	if (!gate) {
+		pr_err("%s +%d %s: Out of memory for gate clk.\n",__FILE__,__LINE__,__func__);
+		return;
+	}
+
+	div = kzalloc(sizeof(struct clk_divider), GFP_KERNEL);
+	if (!div) {
+		pr_err("%s +%d %s: Out of memory for div clk.\n",__FILE__,__LINE__,__func__);
+		kfree(gate);
+		return;
+	}
+
+	mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
+	if (!mux)
+	{
+		pr_err("%s +%d %s: Out of memory for mux clk.\n",__FILE__,__LINE__,__func__);
+		kfree(gate);
+		kfree(div);
+		return;
+	}
+
+	gate->reg = reg + 0xc;
+	gate->bit_idx = 0;
+	gate->flags = 0;
+	gate->lock = data->lock;
+
+	div->reg = reg + 0x4;
+	div->shift = 0;
+	div->width = 8;
+	div->lock = data->lock;
+	div->flags = CLK_DIVIDER_ROUND_CLOSEST | CLK_DIVIDER_ALLOW_ZERO;
+
+	mux->reg = reg;
+	mux->shift = 0;
+	mux->mask = 0x7;
+	mux->lock = data->lock;
+	mux->flags = 0;
+
+	switch(cfg_type){
+		case BUS1_CFG:
+		case BUS2_CFG:
+		case BUS3_CFG:
+		case CPU_CFG:
+		case PBUS_CFG:
+		case MEMPHY_CFG:
+			clk = clk_register_composite(NULL,clk_name,parents,num_parents,
+					&mux->hw,&clk_mux_ops,
+					&div->hw,&clk_divider_ops,
+					&gate->hw,&clk_gate_ops,
+					data->clk_flags | CLK_IGNORE_UNUSED);
+			break;
+		case UART_CFG:
+		case SPDIF_CFG:
+		case SDIO_CFG:
+		case EMMC_CFG:
+		case ETH_REF_CFG:
+		case ETH_BYP_REF_CFG:
+		case ETH_TSU_CFG:
+			//case WLAN24_CFG:
+			//case WLAN5_CFG:
+		case TCLK_CFG:
+		case NPU_PE_CFG:
+		case GDU0_CFG:
+		case GDU0_EITF_CFG:
+		case TVIF0_CFG:
+		case CRYPTO_CFG:
+		case AUDIO_CFG:
+		case USBPHY_CFG:
+		case M_SFDSP_0_CFG:
+		case M_SFDSP_1_CFG:
+		case WLAN24_CFG:
+		case WLAN5_CFG:
+			clk = clk_register_composite(NULL,clk_name,parents,num_parents,
+					&mux->hw,&clk_mux_ops,
+					&div->hw,&clk_divider_ops,
+					&gate->hw,&clk_gate_ops,
+					data->clk_flags);
+			break;
+		default:
+			pr_err("%s +%d %s: No such cfg_type: %d.\n",__FILE__,__LINE__,__func__,cfg_type);
+			return;
+	}
+
+	if (!IS_ERR(clk))
+	{
+		clk_data->clks[0] = clk;
+		kfree(parents);
+		of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+		//		printk("%s +%d %s: SF16A18 %s CLOCK INIT DONE!\n",__FILE__,__LINE__,__func__,clk_name);
+	}
+	else
+	{
+		pr_err("%s +%d %s: Clk register failed for %s.\n",__FILE__,__LINE__,__func__,clk_name);
+		kfree(gate);
+		kfree(div);
+		kfree(mux);
+		if (clk_data)
+			kfree(clk_data->clks);
+		kfree(clk_data);
+		kfree(parents);
+	}
+
+	return;
+}
+
+static void __init sf16a18_bus1_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,BUS1_CFG);
+	return;
+}
+static void __init sf16a18_bus2_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,BUS2_CFG);
+	return;
+}
+static void __init sf16a18_bus3_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,BUS3_CFG);
+	return;
+}
+static void __init sf16a18_cpu_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,CPU_CFG);
+	return;
+}
+static void __init sf16a18_pbus_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,PBUS_CFG);
+	return;
+}
+static void __init sf16a18_memphy_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,MEMPHY_CFG);
+	return;
+}
+static void __init sf16a18_audio_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,AUDIO_CFG);
+	return;
+}
+static void __init sf16a18_uart_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,UART_CFG);
+	return;
+}
+static void __init sf16a18_spdif_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,SPDIF_CFG);
+	return;
+}
+static void __init sf16a18_sdio_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,SDIO_CFG);
+	return;
+}
+static void __init sf16a18_emmc_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,EMMC_CFG);
+	return;
+}
+static void __init sf16a18_eth_ref_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,ETH_REF_CFG);
+	return;
+}
+static void __init sf16a18_eth_byp_ref_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,ETH_BYP_REF_CFG);
+	return;
+}
+static void __init sf16a18_eth_tsu_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,ETH_TSU_CFG);
+	return;
+}
+static void __init sf16a18_m_SFDSP_0_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,M_SFDSP_0_CFG);
+	return;
+}
+static void __init sf16a18_m_SFDSP_1_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,M_SFDSP_1_CFG);
+	return;
+}
+static void __init sf16a18_wlan24_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,WLAN24_CFG);
+	return;
+}
+static void __init sf16a18_wlan5_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,WLAN5_CFG);
+	return;
+}
+static void __init sf16a18_usbphy_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,USBPHY_CFG);
+	return;
+}
+static void __init sf16a18_tclk_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,TCLK_CFG);
+	return;
+}
+static void __init sf16a18_npu_pe_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,NPU_PE_CFG);
+	return;
+}
+static void __init sf16a18_gdu0_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,GDU0_CFG);
+	return;
+}
+static void __init sf16a18_gdu0_eitf_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,GDU0_EITF_CFG);
+	return;
+}
+static void __init sf16a18_tvif0_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,TVIF0_CFG);
+	return;
+}
+static void __init sf16a18_crypto_cfg_setup(struct device_node *np)
+{
+	sf16a18_cfg_setup(np,CRYPTO_CFG);
+	return;
+}
+CLK_OF_DECLARE(sf16a18_bus1_cfg,"siflower,sf16a18-bus1-clk",sf16a18_bus1_cfg_setup);
+CLK_OF_DECLARE(sf16a18_bus2_cfg,"siflower,sf16a18-bus2-clk",sf16a18_bus2_cfg_setup);
+CLK_OF_DECLARE(sf16a18_bus3_cfg,"siflower,sf16a18-bus3-clk",sf16a18_bus3_cfg_setup);
+CLK_OF_DECLARE(sf16a18_cpu_cfg,"siflower,sf16a18-cpu-clk",sf16a18_cpu_cfg_setup);
+CLK_OF_DECLARE(sf16a18_pbus_cfg,"siflower,sf16a18-pbus-clk",sf16a18_pbus_cfg_setup);
+CLK_OF_DECLARE(sf16a18_memphy_cfg,"siflower,sf16a18-memphy-clk",sf16a18_memphy_cfg_setup);
+CLK_OF_DECLARE(sf16a18_audio_cfg,"siflower,sf16a18-audio-clk",sf16a18_audio_cfg_setup);
+CLK_OF_DECLARE(sf16a18_uart_cfg,"siflower,sf16a18-uart-clk",sf16a18_uart_cfg_setup);
+CLK_OF_DECLARE(sf16a18_spdif_cfg,"siflower,sf16a18-spdif-clk",sf16a18_spdif_cfg_setup);
+CLK_OF_DECLARE(sf16a18_sdio_cfg,"siflower,sf16a18-sdhc-clk",sf16a18_sdio_cfg_setup);
+CLK_OF_DECLARE(sf16a18_emmc_cfg,"siflower,sf16a18-emmc-clk",sf16a18_emmc_cfg_setup);
+CLK_OF_DECLARE(sf16a18_eth_ref_cfg,"siflower,sf16a18-eth-ref-clk",sf16a18_eth_ref_cfg_setup);
+CLK_OF_DECLARE(sf16a18_eth_byp_ref_cfg,"siflower,sf16a18-eth-byp-ref-clk",sf16a18_eth_byp_ref_cfg_setup);
+CLK_OF_DECLARE(sf16a18_eth_tsu_cfg,"siflower,sf16a18-eth-tsu-clk",sf16a18_eth_tsu_cfg_setup);
+CLK_OF_DECLARE(sf16a18_m_SFDSP_0_cfg,"siflower,sf16a18-m_SFDSP-0-clk",sf16a18_m_SFDSP_0_cfg_setup);
+CLK_OF_DECLARE(sf16a18_m_SFDSP_1_cfg,"siflower,sf16a18-m_SFDSP-1-clk",sf16a18_m_SFDSP_1_cfg_setup);
+CLK_OF_DECLARE(sf16a18_wlan24_cfg,"siflower,sf16a18-wlan24-mac-wt-clk",sf16a18_wlan24_cfg_setup);
+CLK_OF_DECLARE(sf16a18_wlan5_cfg,"siflower,sf16a18-wlan5-mac-wt-clk",sf16a18_wlan5_cfg_setup);
+CLK_OF_DECLARE(sf16a18_usbphy_cfg,"siflower,sf16a18-usbphy-ref-clk",sf16a18_usbphy_cfg_setup);
+CLK_OF_DECLARE(sf16a18_tclk_cfg,"siflower,sf16a18-tclk",sf16a18_tclk_cfg_setup);
+CLK_OF_DECLARE(sf16a18_npu_pe_cfg,"siflower,sf16a18-npupe-clk",sf16a18_npu_pe_cfg_setup);
+CLK_OF_DECLARE(sf16a18_gdu0_cfg,"siflower,sf16a18-gdu0-clk",sf16a18_gdu0_cfg_setup);
+CLK_OF_DECLARE(sf16a18_gdu0_eitf_cfg,"siflower,sf16a18-gdu0-eitf-clk",sf16a18_gdu0_eitf_cfg_setup);
+CLK_OF_DECLARE(sf16a18_tvif0_cfg,"siflower,sf16a18-tvif0-clk",sf16a18_tvif0_cfg_setup);
+CLK_OF_DECLARE(sf16a18_crypto_cfg,"siflower,sf16a18-crypto-clk",sf16a18_crypto_cfg_setup);
Index: linux-3.18.29/arch/mips/kernel/csrc-gic.c
===================================================================
--- linux-3.18.29.orig/arch/mips/kernel/csrc-gic.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/kernel/csrc-gic.c	2017-11-21 20:13:12.466710527 +0800
@@ -38,3 +38,14 @@
 
 	clocksource_register_hz(&gic_clocksource, frequency);
 }
+
+extern void gic_clockevent_update_freq(u32 freq);
+void gic_clocksource_update(unsigned int frequency)
+{
+	clocksource_unregister(&gic_clocksource);
+	clocksource_register_hz(&gic_clocksource, frequency);
+	gic_clockevent_update_freq(frequency);
+
+	return;
+}
+EXPORT_SYMBOL_GPL(gic_clocksource_update);
Index: linux-3.18.29/arch/mips/siflower/cpufreq_debugfs.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/cpufreq_debugfs.c	2017-11-21 20:13:12.466710527 +0800
@@ -0,0 +1,515 @@
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/types.h>
+#include <linux/seq_file.h>
+#include <linux/delay.h>
+#include <asm/cpu-info.h>
+#include <asm/time.h>
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/gic.h>
+
+#include <linux/cpufreq.h>
+#include <linux/kernel_stat.h>
+#include <linux/tick.h>
+#include <linux/cpu.h>
+
+#include <linux/timer.h>
+
+//#define CLKEVENT_TEST
+//#define USE_SYSCON
+
+//syscon
+#ifdef USE_SYSCON
+#include <linux/of.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#endif
+
+//get cpu_clk
+#include <linux/clocksource.h>
+#include <linux/clk-private.h>
+
+//kmalloc/kfree
+#include <linux/slab.h>
+
+//PLL infm
+#ifdef USE_SYSCON
+struct regmap *regmap_base;
+#else
+unsigned int regmap_base = 0xb9e00000;
+static void regmap_read(unsigned int base, unsigned int offset, unsigned int *val)
+{
+	*val = readl((void*)(base + offset));
+}
+static void regmap_write(unsigned int base, unsigned int offset, unsigned int val)
+{
+	writel(val, (void*)(base + offset));
+	return;
+}
+#endif
+static struct mutex g_mutex;
+#define PLL_BASE_OFF         (0x1000)
+#define CPU_PLL_PARA70	     (PLL_BASE_OFF + 4)
+#define PLL_COUNT_MAX        4
+#define PLL_REG_COUNT_MAX    8
+#define PLL_REG_WID          4//btye
+#define PLL_OFFSET           0x40
+
+//CLK infm
+#define CLK_BASE_OFF         (0x1400)
+#define CLK_COUNT_MAX        26
+#define CLK_REG_COUNT_MAX    5
+#define CLK_REG_WID          4//btye
+#define CLK_OFFSET           0x20
+
+#define PLL_PD_DSM_PD         (1 << 5)
+#define PLL_PD_DAC_PD         (1 << 4)
+#define PLL_PD_FOUT_4PHASE_PD (1 << 3)
+#define PLL_PD_FOUT_POST_PD   (1 << 2)
+#define PLL_PD_FOUT_VCO_PD    (1 << 1)
+#define PLL_PD_ALL_PD         (1 << 0)
+
+#define PLL_CFG_LOAD         (1 << 5)
+#define PLL_CFG_GATE         (1 << 4)
+#define PLL_CFG_OCLK_SEL     (1 << 3)
+#define PLL_CFG_SRC_SEL      (3 << 1)
+#define PLL_CFG_BYPASS       (1 << 0)
+
+#define CLK_CFG_USE_NCO       (1 << 3)
+#define CLK_CFG_SRC_SEL       (7 << 0)
+
+/* 6M osc -> 672 cpu_pll */
+#define CRYSTAL_6M_CPU_PARA		(0x4b000000150)
+#define CRYSTAL_6M_DDR_PARA		(0x4900000010a)
+#define CRYSTAL_6M_CMN_PARA		(0x4a00000018c)
+#define CRYSTAL_6M_SPC_PARA		(0x4a0000001f4)
+
+/* 12M osc -> 672 cpu_pll */
+#define CRYSTAL_12M_CPU_PARA	(0x4b0000000a8)
+#define CRYSTAL_12M_DDR_PARA	(0X4a000000085)
+#define CRYSTAL_12M_CMN_PARA	(0x4a0000000c6)
+#define CRYSTAL_12M_SPC_PARA	(0X4a0000000fa)
+
+/* 12M osc -> 336 cpu_pll */
+#define  CRYSTAL_12M_CPU336_PARA (0x4b000000054)
+#define  CRYSTAL_12M_DDR798_PARA (0x4a000000085)
+#define  CRYSTAL_12M_CMN594_PARA (0x4a000000063)
+#define  CRYSTAL_12M_SPC750_PARA (0x4a00000007d)
+
+/* 6M osc -> 1008 cpu_pll */
+#define	CRYSTAL_6M_CPU1008_PARA		(0x4b0000001f8)
+
+/* 6M osc -> 840 cpu_pll */
+#define CRYSTAL_6M_CPU840_PARA		(0x4b0000001a4)
+
+/* 6M osc -> 1176 cpu_pll */
+#define CRYSTAL_6M_CPU1176_PARA		(0x4b00000024c)
+
+/* 6M osc -> 1260 cpu_pll */
+#define CRYSTAL_6M_CPU1260_PARA		(0x4b000000276)
+
+/* 6M osc -> 1344 cpu_pll */
+#define CRYSTAL_6M_CPU1344_PARA		(0x4b0000002a0)
+
+/**
+ * -Description:
+ *    Set pll ratio to fit 6M crystal.
+ *    pll_type: 0 -> cpu_pll 6M        1 -> ddr_pll 6M
+ *              2 -> cmn_pll 6M        3 -> spc_pll 6M
+ *              4 -> cpu_pll 12M       5 -> ddr_pll 12M
+ *              6 -> cmn_pll 12M       7 -> spc_pll 12M
+ *              8 -> cpu_pll_336 12M   9 -> ddr_pll_798 12M
+ *              10 -> cmn_pll_594 12M  11 -> spc_pll_750 12M
+ *              12 -> cpu_pll_840 6M   16 -> cpu_pll_1008 6M
+ *              20 -> cpu_pll_1176 6M  24 -> cpu_pll_1260 6M
+ *              28 -> cpu_pll_1344 6M
+ */
+static int set_pll_ratio(int pll_type, unsigned long long pll_para)
+{
+	unsigned int i, reg, value, offset;
+
+	if(pll_type > 100)
+		return -EINVAL;
+
+	offset = pll_type%4;
+
+	//close clk
+	reg = PLL_BASE_OFF + offset*PLL_OFFSET + 0*PLL_REG_WID;
+	regmap_read(regmap_base, reg, &value);
+	value = value | (PLL_PD_ALL_PD);
+	regmap_write(regmap_base, reg, value);
+
+	regmap_read(regmap_base, reg, &value);
+	printk("%s: %d val is 0x%x\n", __func__, __LINE__, value);
+
+	//clear load bit
+	reg = PLL_BASE_OFF + offset*PLL_OFFSET + 7*PLL_REG_WID;
+	regmap_read(regmap_base, reg, &value);
+	value = value & (~PLL_CFG_LOAD);
+	regmap_write(regmap_base, reg, value);
+
+	regmap_read(regmap_base, reg, &value);
+	printk("%s: %d val is 0x%x\n", __func__, __LINE__, value);
+
+	if(pll_para == 0) {
+		switch(pll_type)
+		{
+			case 0:
+				pll_para = CRYSTAL_6M_CPU_PARA;
+				break;
+			case 1:
+				pll_para = CRYSTAL_6M_DDR_PARA;
+				break;
+			case 2:
+				pll_para = CRYSTAL_6M_CMN_PARA;
+				break;
+			case 3:
+				pll_para = CRYSTAL_6M_SPC_PARA;
+				break;
+			case 4:
+				pll_para = CRYSTAL_12M_CPU_PARA;
+				break;
+			case 5:
+				pll_para = CRYSTAL_12M_DDR_PARA;
+				break;
+			case 6:
+				pll_para = CRYSTAL_12M_CMN_PARA;
+				break;
+			case 7:
+				pll_para = CRYSTAL_12M_SPC_PARA;
+				break;
+			case 8:
+				pll_para = CRYSTAL_12M_CPU336_PARA;
+				break;
+			case 9:
+				pll_para = CRYSTAL_12M_DDR798_PARA;
+				break;
+			case 10:
+				pll_para = CRYSTAL_12M_CMN594_PARA;
+				break;
+			case 11:
+				pll_para = CRYSTAL_12M_SPC750_PARA;
+				break;
+			case 12:
+				pll_para = CRYSTAL_6M_CPU840_PARA;
+				break;
+			case 16:
+				pll_para = CRYSTAL_6M_CPU1008_PARA;
+				break;
+			case 20:
+				pll_para = CRYSTAL_6M_CPU1176_PARA;
+				break;
+			case 24:
+				pll_para = CRYSTAL_6M_CPU1260_PARA;
+				break;
+			case 28:
+				pll_para = CRYSTAL_6M_CPU1344_PARA;
+				break;
+			default:
+				return 0;
+		}
+	}
+
+	for(i=0;i<6;i++) {
+		regmap_write(regmap_base,
+			CPU_PLL_PARA70 + 4*i + offset*PLL_OFFSET, pll_para);
+		pll_para = pll_para >> 8;
+	}
+
+	printk("%s: %d\n", __func__, __LINE__);
+
+	//set load bit
+	reg = PLL_BASE_OFF + offset*PLL_OFFSET + 7*PLL_REG_WID;
+	regmap_read(regmap_base, reg, &value);
+	value = value | (PLL_CFG_LOAD);
+	regmap_write(regmap_base, reg, value);
+
+	regmap_read(regmap_base, reg, &value);
+	printk("%s: %d val is 0x%x\n", __func__, __LINE__, value);
+
+	//clear all powerdown bit
+	reg = PLL_BASE_OFF + offset*PLL_OFFSET + 0*PLL_REG_WID;
+	regmap_read(regmap_base, reg, &value);
+	value = value & (~(PLL_PD_ALL_PD));
+	regmap_write(regmap_base, reg, value);
+
+	regmap_read(regmap_base, reg, &value);
+	printk("%s: %d val is 0x%x\n", __func__, __LINE__, value);
+
+	return 0;
+}
+
+static int get_cpu_clk_div(void)
+{
+	u32 reg;
+	int value;
+
+	reg = CLK_BASE_OFF + 8*CLK_OFFSET + 1*CLK_REG_WID;
+	regmap_read(regmap_base, reg, &value);
+
+	return value;
+}
+
+static int set_cpu_clk_div(int div)
+{
+	u32 reg, time=0, value;
+
+	printk("%s\n", __func__);
+	reg = CLK_BASE_OFF + 8*CLK_OFFSET + 1*CLK_REG_WID;
+	regmap_write(regmap_base, reg, div);
+
+	while(1) {
+		regmap_read(regmap_base, reg, &value);
+		if(value == div)
+			break;
+		else
+			time++;
+	}
+	printk("time is %d\n", time);
+
+	return 0;
+}
+
+static int set_cpu_clk(u32 freq, int cpu_ratio)
+{
+	u32 reg;
+	unsigned long flags;
+	int cpu_clk_div, time = 0, value;
+#ifdef CONFIG_SF16A18_MPW0
+	//FREQ = 2 * X -->6m osc
+	u32 div = freq/1000000/2;
+	unsigned long long pll_para = (CRYSTAL_6M_CPU_PARA >> 16) << 16;
+#else
+	//FREQ = 4 * X -->12m osc
+	u32 div = freq/1000000/4;
+	unsigned long long pll_para = (CRYSTAL_12M_CPU_PARA >> 16) << 16;
+#endif
+
+	preempt_disable();
+	local_irq_save(flags);
+
+	cpu_clk_div = get_cpu_clk_div();
+	set_cpu_clk_div((cpu_clk_div + 1) * 3 - 1);
+
+	//switch cpu clk to spc pll
+	reg = CLK_BASE_OFF + 8*CLK_OFFSET + 0*CLK_REG_WID;
+	regmap_write(regmap_base, reg, 2);
+
+	while(1) {
+		regmap_read(regmap_base, reg, &value);
+		if(value == 2)
+			break;
+		else
+			time++;
+	}
+	printk("time is %d\n", time);
+
+	//set cpu pll ratio
+	set_pll_ratio(0, pll_para + div);
+
+	//swtich cpu clk back to cpu pll
+	reg = CLK_BASE_OFF + 8*CLK_OFFSET + 0*CLK_REG_WID;
+	regmap_write(regmap_base, reg, 0);
+
+	while(1) {
+		regmap_read(regmap_base, reg, &value);
+		if(value == 0)
+			break;
+		else
+			time++;
+	}
+	printk("time is %d\n", time);
+
+	//Cpu_pll is already set to the freq we want.
+	set_cpu_clk_div(cpu_ratio);
+
+	local_irq_restore(flags);
+	preempt_enable();
+
+	return 0;
+}
+
+static struct dentry *entry;
+
+static int cpufreq_show(struct seq_file *m, void *v)
+{
+	seq_printf(m,"Set cpu frequency in SF16A18 board.\n");
+
+	return 0;
+}
+
+static int cpufreq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cpufreq_show, NULL);
+}
+
+#ifdef CLKEVENT_TEST
+static struct timer_list timer;
+static char* msg = "hello world";
+static int64_t counter = 0;
+
+struct hrtimer m_timer;
+
+static void print_func(unsigned long lparam){
+	char* str = (char*)lparam;
+	printk("%s counter=%lld\n",str,counter);
+	mod_timer(&timer, jiffies + 2*HZ);
+}
+
+static enum hrtimer_restart vibrator_timer_func(struct hrtimer *timer)
+{
+	hrtimer_forward_now(&m_timer,ktime_set(0, 1000000));
+	counter++;
+	return HRTIMER_RESTART;
+}
+
+void test_timer(void)
+{
+	init_timer(&timer);
+	timer.expires = jiffies + 2*HZ;
+	timer.function = print_func;
+	timer.data = (unsigned long) msg;
+	add_timer(&timer);
+	//add high res timer
+	hrtimer_init(&m_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_PINNED);
+	m_timer.function = vibrator_timer_func;
+	//set to 10 us
+	hrtimer_start(&m_timer,ktime_set(0, 1000000),HRTIMER_MODE_REL_PINNED);
+}
+#endif
+
+extern void gic_clocksource_update(unsigned int frequency);
+static unsigned int old_cpu_freq;
+
+static ssize_t cpufreq_read(struct file *file, char __user *buffer,
+							size_t count, loff_t *f_ops)
+{
+	char *buf = kmalloc(count, GFP_KERNEL);
+	int n = 0;
+
+	if(!buf)
+		return -ENOMEM;
+
+	if(*f_ops > 0)
+		return 0;
+
+	n = snprintf(buf, count, "cpu frequency now is %d\n", old_cpu_freq);
+	printk("n is %d, buf is %s\n", n, buf);
+
+	if(copy_to_user(buffer, buf, n))
+		n = -EFAULT;
+
+	*f_ops += n;
+	kfree(buf);
+
+	return n;
+}
+static ssize_t cpufreq_write(struct file *file, const char __user *buffer,
+						size_t count, loff_t *f_ops)
+{
+	u64 result;
+	unsigned int val, i;
+
+	printk("%s\n", __func__);
+
+	mutex_lock(&g_mutex);
+
+	sscanf(buffer, "%u", &val);
+	if(!val)
+		sscanf(buffer, "%x", &val);
+	printk("val is %d\n", val);
+
+	if(val > 1500000000 || val < 100000000) {
+		pr_err("cpu frequency overange.\n");
+		return count;
+	}
+
+	set_cpu_clk(val, 0);
+
+	result = ((u64)loops_per_jiffy) * ((u64)val);
+	do_div(result, old_cpu_freq);
+	loops_per_jiffy = (u32)result;
+	for (i = 0; i < NR_CPUS; i++)
+		cpu_data[i].udelay_val = loops_per_jiffy;
+	old_cpu_freq = val;
+
+	gic_clocksource_update(val);
+	pr_info("set cpu clk rate %d done\n", val);
+
+#ifdef CLKEVENT_TEST
+	test_timer();
+#endif
+	mutex_unlock(&g_mutex);
+
+
+	return count;
+}
+
+static struct file_operations cpufreq_ops = {
+	.owner		= THIS_MODULE,
+	.open		= cpufreq_open,
+	.read		= cpufreq_read,
+	.write		= cpufreq_write,
+	.release	= seq_release,
+	.llseek		= seq_lseek,
+};
+
+static int __init cpu_freq_init(void)
+{
+	struct device_node *node;
+	struct clk *sf_cpu_clk;
+
+	mutex_init(&g_mutex);
+
+	node = of_find_compatible_node(NULL, NULL, "siflower,sfax8-syscon");
+
+#ifdef USE_SYSCON
+	if(node)
+		regmap_base = syscon_node_to_regmap(node);
+
+	if(IS_ERR(regmap_base)) {
+		pr_err("can't get syscon base.\n");
+		return 0;
+	}
+#endif
+
+	node = of_find_compatible_node(NULL, NULL, "siflower,sf16a18-cpu-clk");
+
+	if(node)
+		sf_cpu_clk = of_clk_get(node,0);
+
+	if(IS_ERR(sf_cpu_clk)) {
+		printk("Can't get cpu clock!\n");
+		return 0;
+	}
+
+	old_cpu_freq = sf_cpu_clk->rate;
+
+	entry = debugfs_create_file("cpu-freq", 0644, NULL, NULL, &cpufreq_ops);
+	return 0;
+}
+
+static void __exit cpu_freq_exit(void)
+{
+	debugfs_remove(entry);
+#ifdef CLKEVENT_TEST
+	del_timer(&timer);
+#endif
+	mutex_destroy(&g_mutex);
+
+	return;
+}
+static int __init cpu_clkratio_setup(void)
+{
+#ifdef CONFIG_SF16A18_MPW0
+	set_cpu_clk(1344000000, 1);
+#endif
+	return 0;
+}
+arch_initcall(cpu_clkratio_setup);
+
+module_init(cpu_freq_init);
+module_exit(cpu_freq_exit);
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/regulator/sfax8_pwrmgmt.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/regulator/sfax8_pwrmgmt.c	2017-11-21 20:13:12.466710527 +0800
@@ -0,0 +1,357 @@
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+//enable 32k clock
+#include <linux/mfd/sfax8.h>
+
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+#define TOTAL_DCDC	4
+#define TOTAL_LDO	7
+#define VIN_POWER_OVER_VOLTAGE		(1 << 7)
+#define VIN_POWER_BELOW_VOLTAGE		(1 << 6)
+#else
+#define TOTAL_DCDC	4
+#define TOTAL_LDO	5
+#endif
+
+struct pwr_mgmt {
+	struct regulator *regulator;
+	u32 max_v;
+};
+
+static struct pwr_mgmt rt[TOTAL_DCDC + TOTAL_LDO];
+
+
+static ssize_t pwr_mgmt_write(struct file *file, const char __user *buffer,
+							size_t count, loff_t *f_ops)
+{
+	struct regulator *one_rt;
+	unsigned int i, value;
+	char rg_n[8];
+	int ret;
+
+	sscanf(buffer, "%s %u %u", rg_n, &i, &value);
+
+	if(strcmp("ldo", rg_n) == 0) {
+		#ifndef CONFIG_MFD_SFAX8_RN5T567
+		if ((i >= TOTAL_LDO) || (i == 3)){
+		#else
+		if (i > TOTAL_LDO){
+		#endif
+			pr_err("wrong regulator num\n");
+			goto fin;
+		}
+		i += TOTAL_DCDC;
+	} else {
+		if(strcmp("dcdc", rg_n) == 0) {
+		#ifndef CONFIG_MFD_SFAX8_RN5T567
+			if (i >= TOTAL_DCDC){
+		#else
+			if (i > TOTAL_DCDC){
+		#endif
+				pr_err("wrong regulator num\n");
+				goto fin;
+			}
+		} else {
+			pr_err("wrong regulator name\n");
+			goto fin;
+		}
+	}
+
+	#ifdef CONFIG_MFD_SFAX8_RN5T567
+	i = i - 1;
+	#endif
+
+	if (value > rt[i].max_v){
+		pr_err("voltage is over max\n");
+		goto fin;
+	}
+
+	one_rt = rt[i].regulator;
+
+	ret = regulator_set_voltage(one_rt, value, value);
+	if (ret){
+		pr_err("regulator_set_voltage error\n");
+		goto fin;
+	}
+
+	ret = regulator_enable(one_rt);
+	if (ret < 0){
+		pr_err("regulator_enable error\n");
+		goto fin;
+	}
+
+	value = regulator_get_voltage(one_rt);
+	pr_debug("Voltage is %d\n", value);
+
+fin:
+	return count;
+}
+
+static int pwr_mgmt_show(struct seq_file *m, void *v)
+{
+	seq_printf(m,"Nothing to show\n");
+
+	return 0;
+}
+
+static int pwr_mgmt_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pwr_mgmt_show, NULL);
+}
+
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+static int pwr_mgmt_status_show(struct device *dev)
+{
+	unsigned char status;
+	int ret;
+	int i = 0;
+	unsigned char tmp[20];
+	struct sfax8 *data = dev_get_drvdata(dev->parent);
+	if(dev == NULL){
+		dev_err(dev, "device is null.\n");
+		return -ENOMEM;
+	}
+
+
+	/*
+	** get pmu vin power status.
+	*/
+	ret = regmap_bulk_read(data->regmap, SFAX8_PROTECT_REG, &status, 1);
+	if(ret){
+		printk("Can't get vin power status\n");
+	}else {
+		if(status & VIN_POWER_OVER_VOLTAGE)	
+			printk("The vin power's output voltage had been over setting value.\n");
+		else if(status & VIN_POWER_BELOW_VOLTAGE)
+			printk("The vin power's output voltage had been below the setting value.\n");
+		else
+			printk("The vin power's output voltage is OK.\n");
+	}
+	/*
+	** get dc power status.
+	*/
+	ret = regmap_bulk_read(data->regmap, SFAX8_STATUE1_REG, &status, 1);
+	if(ret){
+		printk("Can't get dc power status!\n");
+	}else {
+		for(i = 0; i < 4; i++)
+			printk("The dc%d power's output voltage is %s.\n", i, (status & (1 << i)) ? "OK" :"below exception");
+	}
+
+	/*
+	** get ldo power status.
+	*/
+	ret = regmap_bulk_read(data->regmap, SFAX8_STATUE2_REG, &status, 1);
+	if(ret){
+		printk("Can't get ldo power status!\n");
+	}else {
+		for(i = 0; i < 7; i++){
+			if( i == 3 || i == 5 || i == 6)
+				continue;
+			printk("The ldo%d power's output voltage is %s.\n", i, (status & (1 << i)) ? "OK" :"below exception");
+		}
+	}
+
+	/*
+	** get ldo power status.
+	*/
+	ret = regmap_bulk_read(data->regmap, SFAX8_INT3_REG, &status, 1);
+	if(ret){
+		printk("Can't get ldo power status!\n");
+	}else {
+		for(i = 0; i < 7; i++){
+			if( i == 3 || i == 5 || i == 6)
+				continue;
+			printk("The ldo%d power's output electric current is %s.\n", i, (status & (1 << i)) ? "higher than excepted value" :"OK");
+		}
+	}
+
+	ret = regmap_bulk_read(data->regmap, SFAX8_WAKE0_REG, tmp, 9);
+	for(i = 0; i < 9 ; i++)
+		printk(KERN_DEBUG "reg : 0x%x; val : 0x%x.\n", SFAX8_WAKE0_REG + i, *(tmp + i));
+	return 0;
+}
+
+#endif
+
+static struct file_operations pwr_mgmt_ops = {
+	.owner		= THIS_MODULE,
+	.open		= pwr_mgmt_open,
+	.read		= seq_read,
+	.write		= pwr_mgmt_write,
+	.release	= single_release,
+	.llseek		= seq_lseek,
+};
+
+static int pwr_mgmt_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	struct regulator *rg;
+	struct proc_dir_entry *file;
+	char name[32], vname[32];
+	u32 i;
+	int err;
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "power-management");
+	if (!np) {
+		dev_err(&pdev->dev, "Device is not having regulator configuration.\n");
+	}
+
+	pdev->dev.of_node = np;
+
+	for (i = 0; i < TOTAL_DCDC; i++){
+		#ifndef CONFIG_MFD_SFAX8_RN5T567
+		if( i == 1)
+			continue;
+		sprintf(name, "dcdc%d", i);
+		#else
+		sprintf(name, "dcdc%d", i + 1);
+		#endif
+		dev_dbg(&pdev->dev, "Num %d : name is %s", i, name);
+
+		rg = devm_regulator_get(&pdev->dev, name);
+		if (IS_ERR(rg)) {
+			dev_err(&pdev->dev, "Get regulator error, i=%d\n", i);
+			continue;
+		}
+		rt[i].regulator = rg;
+
+		sprintf(vname, "%s-maxv", name);
+		dev_dbg(&pdev->dev, "Num %d: maxv name is %s", i, vname);
+
+		err = of_property_read_u32(np, vname, &rt[i].max_v);
+		if (err)
+			dev_err(&pdev->dev, "Get num %d max_v error\n", i);
+	}
+
+
+	for (i = TOTAL_DCDC; i < TOTAL_DCDC + TOTAL_LDO; i++){
+		//ldo3 not used.
+		#ifndef CONFIG_MFD_SFAX8_RN5T567
+		if(i - TOTAL_DCDC == 3)
+			continue;
+		sprintf(name, "ldo%d", i - TOTAL_DCDC);
+		#else
+		sprintf(name, "ldo%d", i - TOTAL_DCDC + 1);
+		#endif
+		dev_dbg(&pdev->dev, "Num %d : name is %s", i, name);
+
+		rg = devm_regulator_get(&pdev->dev, name);
+		if (IS_ERR(rg)) {
+			dev_err(&pdev->dev, "Get regulator error, i=%d\n", i);
+			continue;
+		}
+		rt[i].regulator = rg;
+
+		sprintf(vname, "%s-maxv", name);
+		dev_dbg(&pdev->dev, "Num %d: maxv name is %s", i, vname);
+
+		err = of_property_read_u32(np, vname, &rt[i].max_v);
+		if (err)
+			dev_err(&pdev->dev, "Get num %d max_v error\n", i);
+	}
+	
+	#ifndef CONFIG_MFD_SFAX8_RN5T567
+	err = pwr_mgmt_status_show(&pdev->dev);	
+	if(err)
+		printk("Can't get pmu status.\n");
+	#endif
+
+	file = proc_create("power-management", 0644, NULL, &pwr_mgmt_ops);
+	if (!file)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static const struct of_device_id of_pwr_mgmt_match[] = {
+	{ .compatible = "siflower, power-management", },
+	{},
+};
+
+static struct platform_driver pwr_mgmt_driver = {
+	.driver = {
+		.name = "power-management",
+		.owner = THIS_MODULE,
+		.of_match_table = of_pwr_mgmt_match,
+	},
+	.probe = pwr_mgmt_probe,
+};
+
+module_platform_driver(pwr_mgmt_driver);
+
+MODULE_DESCRIPTION("Power Management Driver");
+MODULE_AUTHOR("Allen Guo <xijun.guo@siflower.com.cn>");
+MODULE_LICENSE("GPL");
+
+static int enable_clk_32k(struct device *dev)
+{
+	struct sfax8 *p = dev_get_drvdata(dev->parent);
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+	unsigned char buf = 0xbf;//bit 5 ~ bit 7 : 111-ldo mode; 101-32k
+	if(regmap_bulk_write(p->regmap, SFAX8_MFP_LDO65_REG, &buf, 1)) {
+#else
+	unsigned char buf = 0;
+	int ret;
+	ret = regmap_bulk_read(p->regmap, SFAX8_OUT32KEN, &buf, 1);
+	if(ret){
+		dev_err(dev, "%s Can not get 32k clock config value.\n", __func__);
+		return ret;
+	}
+	buf |= 0x2;	
+	if(regmap_bulk_write(p->regmap, SFAX8_OUT32KEN, &buf, 1)) {
+#endif
+		dev_err(dev, "Setup 32K clock failed.\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(enable_clk_32k);
+
+static int disable_clk_32k(struct device *dev)
+{
+	struct sfax8 *p = dev_get_drvdata(dev->parent);
+#ifndef CONFIG_MFD_SFAX8_RN5T567
+	unsigned char buf = 0xff;
+	if(regmap_bulk_write(p->regmap, SFAX8_MFP_LDO65_REG, &buf, 1)) {
+#else
+	unsigned char buf = 0;
+	int ret;
+	ret = regmap_bulk_read(p->regmap, SFAX8_OUT32KEN, &buf, 1);
+	if(ret){
+		dev_err(dev, "%s Can not get 32k clock config value.\n", __func__);
+		return ret;
+	}
+	buf &= 0x1C;	
+	if(regmap_bulk_write(p->regmap, SFAX8_OUT32KEN, &buf, 1)) {
+#endif
+		dev_err(dev, "Disable 32K clock failed.\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(disable_clk_32k);
+
+static int sfax8_clk_32k_probe(struct platform_device *pdev)
+{
+	return enable_clk_32k(&pdev->dev);
+}
+
+static struct platform_driver sfax8_clk_32k_driver = {
+	.driver = {
+		.name = "sfax8-clk-32k",
+	},
+	.probe = sfax8_clk_32k_probe,
+};
+module_platform_driver(sfax8_clk_32k_driver);
Index: linux-3.18.29/drivers/net/ethernet/siflower/genl_netlink.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/genl_netlink.c	2017-11-21 20:13:12.466710527 +0800
@@ -0,0 +1,129 @@
+// for netlink header
+#include <asm/types.h>
+#include <net/sock.h>
+#include <linux/socket.h>
+#include <linux/netlink.h>
+#include <linux/skbuff.h>
+#include <linux/net.h>
+#include <linux/version.h>
+#include <linux/workqueue.h>
+#include <net/genetlink.h>
+
+#include "genl_netlink.h"
+#include "sf_common.h"
+
+/*
+ *Below is netlink generic code for detect port status
+ */
+
+
+
+#define	DPS_MAXATTR		1
+#define DPS_CMD			1
+#define MSGLEN			2
+
+static struct genl_family dps_genl_family = {
+		.id			= GENL_ID_GENERATE,
+		.hdrsize	= 0,
+		.name		= "DPS_NL",
+		.version	= 1,
+		.maxattr	= DPS_MAXATTR,
+};
+
+int dps_genl_rec(struct sk_buff *skb, struct genl_info *info){
+	printk("Do nothing!\n");
+	return 0;
+}
+
+static struct nla_policy dps_genl_policy[DPS_MAXATTR + 1] = {
+		[DPS_MAXATTR] = {.type = NLA_U8}, /*NLA_U8 should not use in higher linux version*/
+};
+
+static const struct genl_ops dps_genl_ops[] = {
+	{
+		.cmd		= DPS_CMD,
+		.flags		= 0,
+		.policy		= dps_genl_policy,
+		.doit		= dps_genl_rec,
+		.dumpit		= NULL,
+	},
+};
+
+static struct genl_multicast_group dps_genl_group[] = {
+	{
+		.name = "updown",
+	},
+};
+
+int dps_genl_init(void){
+	int ret;
+
+	ret = genl_register_family_with_ops_groups(&dps_genl_family, dps_genl_ops, dps_genl_group);
+	if (ret != 0){
+		printk("register family error return %d!\n", ret);
+		goto fail;
+	}
+/*	ret = genl_register_ops(&dps_genl_family, &dps_genl_ops);
+	if (ret != 0){
+		genl_unregister_family(&dps_genl_family);
+		printk("register ops error return %d!\n", ret);goto fail;
+	}*/
+//	printk("offset is %d!\n", dps_genl_family.mcgrp_offset);
+	printk("init success!\n");
+	return 0;
+fail:
+	printk("init fail!\n");
+	return -1;
+}
+
+int dps_genl_exit(void){
+	int ret;
+
+/*	ret = genl_unregister_ops(&dps_genl_family, &dps_genl_ops);
+	if (ret){
+		printk("unregister ops error！\n");
+		return ret;
+	}*/
+	ret = genl_unregister_family(&dps_genl_family);
+	if (ret){
+		printk("unregister family error!\n");
+	}
+	return ret;
+}
+
+void dps_genl_sendmsg(struct work_struct *work){
+	struct sk_buff *skb;
+	int ret = 0;
+	void *msg_head;
+	u8 data[MSGLEN];
+
+	data[0] = 0x1;//function index, for multi function in the future
+
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (skb == NULL){
+		printk("skb error!\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+	msg_head = genlmsg_put(skb, 0, 0, &dps_genl_family, 0, DPS_CMD);
+	if (msg_head == NULL){
+		printk("msghead error!\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	ret = nla_put(skb, DPS_MAXATTR, MSGLEN, (void *)data);
+	if (ret != 0){
+		printk("nla_put error!\n");
+		ret = -EMSGSIZE;
+		goto fail;
+	}
+
+	genlmsg_end(skb, msg_head);
+
+	ret = genlmsg_multicast(&dps_genl_family, skb, 0, 0, GFP_KERNEL);
+//	printk("multicast return %d\n", ret);
+fail:
+	return;
+
+}
Index: linux-3.18.29/drivers/net/ethernet/siflower/genl_netlink.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/net/ethernet/siflower/genl_netlink.h	2017-11-21 20:13:12.466710527 +0800
@@ -0,0 +1,5 @@
+#include <linux/workqueue.h>
+
+void dps_genl_sendmsg(struct work_struct *work);
+int dps_genl_init(void);
+int dps_genl_exit(void);
Index: linux-3.18.29/arch/mips/include/asm/mach-siflower/gpio.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/include/asm/mach-siflower/gpio.h	2017-11-21 20:13:12.466710527 +0800
@@ -0,0 +1,32 @@
+#ifndef __SIFLOWER_GPIO_H
+#define __SIFLOWER_GPIO_H
+
+#include <linux/errno.h>
+#include <asm-generic/gpio.h>
+
+static inline int gpio_get_value(unsigned int gpio)
+{
+	return __gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned int gpio, int value)
+{
+	__gpio_set_value(gpio, value);
+}
+
+static inline int gpio_cansleep(unsigned int gpio)
+{
+	return __gpio_cansleep(gpio);
+}
+
+static inline int gpio_to_irq(unsigned int gpio)
+{
+	return __gpio_to_irq(gpio);
+}
+
+static inline int irq_to_gpio(unsigned int irq)
+{
+	return -EINVAL;
+}
+
+#endif
Index: linux-3.18.29/drivers/usb/dwc2/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/Kconfig	2017-11-21 20:13:12.174710519 +0800
+++ linux-3.18.29/drivers/usb/dwc2/Kconfig	2017-11-21 20:13:12.466710527 +0800
@@ -23,7 +23,7 @@
 
 config USB_DWC2_HOST
 	bool "Host only mode"
-	depends on USB
+	depends on USB=y || (USB_DWC2=m && USB)
 	help
 	  The Designware USB2.0 high-speed host controller
 	  integrated into many SoCs. Select this option if you want the
@@ -42,7 +42,7 @@
 
 config USB_DWC2_DUAL_ROLE
 	bool "Dual Role mode"
-	depends on (USB=y || USB=USB_DWC2) && (USB_GADGET=y || USB_GADGET=USB_DWC2)
+	depends on (USB=y && USB_GADGET=y) || (USB_DWC2=m && USB && USB_GADGET)
 	help
 	  Select this option if you want the driver to work in a dual-role
 	  mode. In this mode both host and gadget features are enabled, and
@@ -50,20 +50,14 @@
 	  option requires USB_GADGET to be enabled.
 endchoice
 
-config USB_DWC2_PLATFORM
-	tristate "DWC2 Platform"
-	default USB_DWC2_HOST || USB_DWC2_PERIPHERAL
-        help
-          The Designware USB2.0 platform interface module for
-          controllers directly connected to the CPU.
-
 config USB_DWC2_PCI
 	tristate "DWC2 PCI"
-	depends on USB_DWC2_HOST && PCI
-	default USB_DWC2_HOST
+	depends on PCI
+	default n
+	select NOP_USB_XCEIV
 	help
 	  The Designware USB2.0 PCI interface module for controllers
-	  connected to a PCI bus. This is only used for host mode.
+	  connected to a PCI bus.
 
 config USB_DWC2_DEBUG
 	bool "Enable Debugging Messages"
Index: linux-3.18.29/drivers/usb/dwc2/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/Makefile	2017-11-21 20:13:12.174710519 +0800
+++ linux-3.18.29/drivers/usb/dwc2/Makefile	2017-11-21 20:13:12.466710527 +0800
@@ -2,7 +2,7 @@
 ccflags-$(CONFIG_USB_DWC2_VERBOSE)	+= -DVERBOSE_DEBUG
 
 obj-$(CONFIG_USB_DWC2)			+= dwc2.o
-dwc2-y					:= core.o core_intr.o
+dwc2-y					:= core.o core_intr.o platform.o
 
 ifneq ($(filter y,$(CONFIG_USB_DWC2_HOST) $(CONFIG_USB_DWC2_DUAL_ROLE)),)
 	dwc2-y				+= hcd.o hcd_intr.o
@@ -13,16 +13,15 @@
 	dwc2-y       			+= gadget.o
 endif
 
+ifneq ($(CONFIG_DEBUG_FS),)
+	dwc2-y				+= debugfs.o
+endif
+
 # NOTE: The previous s3c-hsotg peripheral mode only driver has been moved to
 # this location and renamed gadget.c. When building for dynamically linked
 # modules, dwc2.ko will get built for host mode, peripheral mode, and dual-role
 # mode. The PCI bus interface module will called dwc2_pci.ko and the platform
 # interface module will be called dwc2_platform.ko.
 
-ifneq ($(CONFIG_USB_DWC2_PCI),)
-	obj-$(CONFIG_USB_DWC2)		+= dwc2_pci.o
-	dwc2_pci-y			:= pci.o
-endif
-
-obj-$(CONFIG_USB_DWC2_PLATFORM)		+= dwc2_platform.o
-dwc2_platform-y				:= platform.o
+obj-$(CONFIG_USB_DWC2_PCI)		+= dwc2_pci.o
+dwc2_pci-y				:= pci.o
Index: linux-3.18.29/drivers/usb/dwc2/hcd.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/hcd.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/hcd.c	2017-11-21 20:13:12.466710527 +0800
@@ -53,6 +53,7 @@
 
 #include "core.h"
 #include "hcd.h"
+#include "debug.h"
 
 /**
  * dwc2_dump_channel_info() - Prints the state of a host channel
@@ -80,10 +81,10 @@
 	if (chan == NULL)
 		return;
 
-	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
-	hcsplt = readl(hsotg->regs + HCSPLT(chan->hc_num));
-	hctsiz = readl(hsotg->regs + HCTSIZ(chan->hc_num));
-	hc_dma = readl(hsotg->regs + HCDMA(chan->hc_num));
+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
+	hcsplt = dwc2_readl(hsotg->regs + HCSPLT(chan->hc_num));
+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chan->hc_num));
+	hc_dma = dwc2_readl(hsotg->regs + HCDMA(chan->hc_num));
 
 	dev_dbg(hsotg->dev, "  Assigned to channel %p:\n", chan);
 	dev_dbg(hsotg->dev, "    hcchar 0x%08x, hcsplt 0x%08x\n",
@@ -134,7 +135,7 @@
 	list_for_each_entry_safe(qh, qh_tmp, qh_list, qh_list_entry) {
 		list_for_each_entry_safe(qtd, qtd_tmp, &qh->qtd_list,
 					 qtd_list_entry) {
-			dwc2_host_complete(hsotg, qtd, -ETIMEDOUT);
+			dwc2_host_complete(hsotg, qtd, -ECONNRESET);
 			dwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);
 		}
 	}
@@ -207,7 +208,7 @@
 		 */
 		hprt0 = dwc2_read_hprt0(hsotg);
 		hprt0 |= HPRT0_RST;
-		writel(hprt0, hsotg->regs + HPRT0);
+		dwc2_writel(hprt0, hsotg->regs + HPRT0);
 	}
 
 	queue_delayed_work(hsotg->wq_otg, &hsotg->start_work,
@@ -228,11 +229,11 @@
 			channel = hsotg->hc_ptr_array[i];
 			if (!list_empty(&channel->hc_list_entry))
 				continue;
-			hcchar = readl(hsotg->regs + HCCHAR(i));
+			hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
 			if (hcchar & HCCHAR_CHENA) {
 				hcchar &= ~(HCCHAR_CHENA | HCCHAR_EPDIR);
 				hcchar |= HCCHAR_CHDIS;
-				writel(hcchar, hsotg->regs + HCCHAR(i));
+				dwc2_writel(hcchar, hsotg->regs + HCCHAR(i));
 			}
 		}
 	}
@@ -241,11 +242,11 @@
 		channel = hsotg->hc_ptr_array[i];
 		if (!list_empty(&channel->hc_list_entry))
 			continue;
-		hcchar = readl(hsotg->regs + HCCHAR(i));
+		hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
 		if (hcchar & HCCHAR_CHENA) {
 			/* Halt the channel */
 			hcchar |= HCCHAR_CHDIS;
-			writel(hcchar, hsotg->regs + HCCHAR(i));
+			dwc2_writel(hcchar, hsotg->regs + HCCHAR(i));
 		}
 
 		dwc2_hc_cleanup(hsotg, channel);
@@ -257,6 +258,14 @@
 		 */
 		channel->qh = NULL;
 	}
+	/* All channels have been freed, mark them available */
+	if (hsotg->core_params->uframe_sched > 0) {
+		hsotg->available_host_channels =
+			hsotg->core_params->host_channels;
+	} else {
+		hsotg->non_periodic_channels = 0;
+		hsotg->periodic_channels = 0;
+	}
 }
 
 /**
@@ -279,11 +288,11 @@
 	 * interrupt mask and status bits and disabling subsequent host
 	 * channel interrupts.
 	 */
-	intr = readl(hsotg->regs + GINTMSK);
+	intr = dwc2_readl(hsotg->regs + GINTMSK);
 	intr &= ~(GINTSTS_NPTXFEMP | GINTSTS_PTXFEMP | GINTSTS_HCHINT);
-	writel(intr, hsotg->regs + GINTMSK);
+	dwc2_writel(intr, hsotg->regs + GINTMSK);
 	intr = GINTSTS_NPTXFEMP | GINTSTS_PTXFEMP | GINTSTS_HCHINT;
-	writel(intr, hsotg->regs + GINTSTS);
+	dwc2_writel(intr, hsotg->regs + GINTSTS);
 
 	/*
 	 * Turn off the vbus power only if the core has transitioned to device
@@ -293,7 +302,7 @@
 	if (dwc2_is_device_mode(hsotg)) {
 		if (hsotg->op_state != OTG_STATE_A_SUSPEND) {
 			dev_dbg(hsotg->dev, "Disconnect: PortPower off\n");
-			writel(0, hsotg->regs + HPRT0);
+			dwc2_writel(0, hsotg->regs + HPRT0);
 		}
 
 		dwc2_disable_host_interrupts(hsotg);
@@ -316,9 +325,12 @@
  */
 static void dwc2_hcd_rem_wakeup(struct dwc2_hsotg *hsotg)
 {
-	if (hsotg->lx_state == DWC2_L2)
+	if (hsotg->bus_suspended) {
 		hsotg->flags.b.port_suspend_change = 1;
-	else
+		usb_hcd_resume_root_hub(hsotg->priv);
+	}
+
+	if (hsotg->lx_state == DWC2_L1)
 		hsotg->flags.b.port_l1_change = 1;
 }
 
@@ -344,15 +356,14 @@
 
 	/* Turn off the vbus power */
 	dev_dbg(hsotg->dev, "PortPower off\n");
-	writel(0, hsotg->regs + HPRT0);
+	dwc2_writel(0, hsotg->regs + HPRT0);
 }
 
+/* Caller must hold driver lock */
 static int dwc2_hcd_urb_enqueue(struct dwc2_hsotg *hsotg,
-				struct dwc2_hcd_urb *urb, void **ep_handle,
-				gfp_t mem_flags)
+				struct dwc2_hcd_urb *urb, struct dwc2_qh *qh,
+				struct dwc2_qtd *qtd)
 {
-	struct dwc2_qtd *qtd;
-	unsigned long flags;
 	u32 intr_mask;
 	int retval;
 	int dev_speed;
@@ -369,29 +380,26 @@
 	if ((dev_speed == USB_SPEED_LOW) &&
 	    (hsotg->hw_params.fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED) &&
 	    (hsotg->hw_params.hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI)) {
-		u32 hprt0 = readl(hsotg->regs + HPRT0);
+		u32 hprt0 = dwc2_readl(hsotg->regs + HPRT0);
 		u32 prtspd = (hprt0 & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;
 
 		if (prtspd == HPRT0_SPD_FULL_SPEED)
 			return -ENODEV;
 	}
 
-	qtd = kzalloc(sizeof(*qtd), mem_flags);
 	if (!qtd)
-		return -ENOMEM;
+		return -EINVAL;
 
 	dwc2_hcd_qtd_init(qtd, urb);
-	retval = dwc2_hcd_qtd_add(hsotg, qtd, (struct dwc2_qh **)ep_handle,
-				  mem_flags);
+	retval = dwc2_hcd_qtd_add(hsotg, qtd, qh);
 	if (retval) {
 		dev_err(hsotg->dev,
 			"DWC OTG HCD URB Enqueue failed adding QTD. Error status %d\n",
 			retval);
-		kfree(qtd);
 		return retval;
 	}
 
-	intr_mask = readl(hsotg->regs + GINTMSK);
+	intr_mask = dwc2_readl(hsotg->regs + GINTMSK);
 	if (!(intr_mask & GINTSTS_SOF)) {
 		enum dwc2_transaction_type tr_type;
 
@@ -403,11 +411,9 @@
 			 */
 			return 0;
 
-		spin_lock_irqsave(&hsotg->lock, flags);
 		tr_type = dwc2_hcd_select_transactions(hsotg);
 		if (tr_type != DWC2_TRANSACTION_NONE)
 			dwc2_hcd_queue_transactions(hsotg, tr_type);
-		spin_unlock_irqrestore(&hsotg->lock, flags);
 	}
 
 	return 0;
@@ -711,9 +717,7 @@
 			/* 3072 = 3 max-size Isoc packets */
 			buf_size = 3072;
 
-		qh->dw_align_buf = dma_alloc_coherent(hsotg->dev, buf_size,
-						      &qh->dw_align_buf_dma,
-						      GFP_ATOMIC);
+		qh->dw_align_buf = kmalloc(buf_size, GFP_ATOMIC | GFP_DMA);
 		if (!qh->dw_align_buf)
 			return -ENOMEM;
 		qh->dw_align_buf_size = buf_size;
@@ -738,6 +742,15 @@
 		}
 	}
 
+	qh->dw_align_buf_dma = dma_map_single(hsotg->dev,
+			qh->dw_align_buf, qh->dw_align_buf_size,
+			chan->ep_is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+	if (dma_mapping_error(hsotg->dev, qh->dw_align_buf_dma)) {
+		dev_err(hsotg->dev, "can't map align_buf\n");
+		chan->align_buf = 0;
+		return -EINVAL;
+	}
+
 	chan->align_buf = qh->dw_align_buf_dma;
 	return 0;
 }
@@ -1059,7 +1072,7 @@
 	if (dbg_perio())
 		dev_vdbg(hsotg->dev, "Queue periodic transactions\n");
 
-	tx_status = readl(hsotg->regs + HPTXSTS);
+	tx_status = dwc2_readl(hsotg->regs + HPTXSTS);
 	qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
 		    TXSTS_QSPCAVAIL_SHIFT;
 	fspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>
@@ -1074,7 +1087,7 @@
 
 	qh_ptr = hsotg->periodic_sched_assigned.next;
 	while (qh_ptr != &hsotg->periodic_sched_assigned) {
-		tx_status = readl(hsotg->regs + HPTXSTS);
+		tx_status = dwc2_readl(hsotg->regs + HPTXSTS);
 		qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
 			    TXSTS_QSPCAVAIL_SHIFT;
 		if (qspcavail == 0) {
@@ -1134,7 +1147,7 @@
 	}
 
 	if (hsotg->core_params->dma_enable <= 0) {
-		tx_status = readl(hsotg->regs + HPTXSTS);
+		tx_status = dwc2_readl(hsotg->regs + HPTXSTS);
 		qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
 			    TXSTS_QSPCAVAIL_SHIFT;
 		fspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>
@@ -1157,9 +1170,9 @@
 			 * level to ensure that new requests are loaded as
 			 * soon as possible.)
 			 */
-			gintmsk = readl(hsotg->regs + GINTMSK);
+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 			gintmsk |= GINTSTS_PTXFEMP;
-			writel(gintmsk, hsotg->regs + GINTMSK);
+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 		} else {
 			/*
 			 * Disable the Tx FIFO empty interrupt since there are
@@ -1168,9 +1181,9 @@
 			 * handlers to queue more transactions as transfer
 			 * states change.
 			 */
-			gintmsk = readl(hsotg->regs + GINTMSK);
+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 			gintmsk &= ~GINTSTS_PTXFEMP;
-			writel(gintmsk, hsotg->regs + GINTMSK);
+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 		}
 	}
 }
@@ -1199,7 +1212,7 @@
 
 	dev_vdbg(hsotg->dev, "Queue non-periodic transactions\n");
 
-	tx_status = readl(hsotg->regs + GNPTXSTS);
+	tx_status = dwc2_readl(hsotg->regs + GNPTXSTS);
 	qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
 		    TXSTS_QSPCAVAIL_SHIFT;
 	fspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>
@@ -1222,7 +1235,7 @@
 	 * available in the request queue or the Tx FIFO
 	 */
 	do {
-		tx_status = readl(hsotg->regs + GNPTXSTS);
+		tx_status = dwc2_readl(hsotg->regs + GNPTXSTS);
 		qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
 			    TXSTS_QSPCAVAIL_SHIFT;
 		if (hsotg->core_params->dma_enable <= 0 && qspcavail == 0) {
@@ -1259,7 +1272,7 @@
 	} while (hsotg->non_periodic_qh_ptr != orig_qh_ptr);
 
 	if (hsotg->core_params->dma_enable <= 0) {
-		tx_status = readl(hsotg->regs + GNPTXSTS);
+		tx_status = dwc2_readl(hsotg->regs + GNPTXSTS);
 		qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
 			    TXSTS_QSPCAVAIL_SHIFT;
 		fspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>
@@ -1279,9 +1292,9 @@
 			 * level to ensure that new requests are loaded as
 			 * soon as possible.)
 			 */
-			gintmsk = readl(hsotg->regs + GINTMSK);
+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 			gintmsk |= GINTSTS_NPTXFEMP;
-			writel(gintmsk, hsotg->regs + GINTMSK);
+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 		} else {
 			/*
 			 * Disable the Tx FIFO empty interrupt since there are
@@ -1290,9 +1303,9 @@
 			 * handlers to queue more transactions as transfer
 			 * states change.
 			 */
-			gintmsk = readl(hsotg->regs + GINTMSK);
+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 			gintmsk &= ~GINTSTS_NPTXFEMP;
-			writel(gintmsk, hsotg->regs + GINTMSK);
+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 		}
 	}
 }
@@ -1330,10 +1343,10 @@
 			 * Ensure NP Tx FIFO empty interrupt is disabled when
 			 * there are no non-periodic transfers to process
 			 */
-			u32 gintmsk = readl(hsotg->regs + GINTMSK);
+			u32 gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
 
 			gintmsk &= ~GINTSTS_NPTXFEMP;
-			writel(gintmsk, hsotg->regs + GINTMSK);
+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
 		}
 	}
 }
@@ -1344,10 +1357,11 @@
 						wf_otg);
 	u32 count = 0;
 	u32 gotgctl;
+	unsigned long flags;
 
 	dev_dbg(hsotg->dev, "%s()\n", __func__);
 
-	gotgctl = readl(hsotg->regs + GOTGCTL);
+	gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 	dev_dbg(hsotg->dev, "gotgctl=%0x\n", gotgctl);
 	dev_dbg(hsotg->dev, "gotgctl.b.conidsts=%d\n",
 		!!(gotgctl & GOTGCTL_CONID_B));
@@ -1371,6 +1385,10 @@
 		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
 		dwc2_core_init(hsotg, false, -1);
 		dwc2_enable_global_interrupts(hsotg);
+		spin_lock_irqsave(&hsotg->lock, flags);
+		dwc2_hsotg_core_init_disconnected(hsotg, false);
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		dwc2_hsotg_core_connect(hsotg);
 	} else {
 		/* A-Device connector (Host Mode) */
 		dev_dbg(hsotg->dev, "connId A\n");
@@ -1408,11 +1426,12 @@
 	hprt0 = dwc2_read_hprt0(hsotg);
 	dev_dbg(hsotg->dev, "Resume: HPRT0=%0x\n", hprt0);
 	hprt0 &= ~HPRT0_RES;
-	writel(hprt0, hsotg->regs + HPRT0);
+	dwc2_writel(hprt0, hsotg->regs + HPRT0);
 	dev_dbg(hsotg->dev, "Clear Resume: HPRT0=%0x\n",
-		readl(hsotg->regs + HPRT0));
+		dwc2_readl(hsotg->regs + HPRT0));
 
 	dwc2_hcd_rem_wakeup(hsotg);
+	hsotg->bus_suspended = 0;
 
 	/* Change to L0 state */
 	hsotg->lx_state = DWC2_L0;
@@ -1438,30 +1457,35 @@
 	spin_lock_irqsave(&hsotg->lock, flags);
 
 	if (windex == hsotg->otg_port && dwc2_host_is_b_hnp_enabled(hsotg)) {
-		gotgctl = readl(hsotg->regs + GOTGCTL);
+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
 		gotgctl |= GOTGCTL_HSTSETHNPEN;
-		writel(gotgctl, hsotg->regs + GOTGCTL);
+		dwc2_writel(gotgctl, hsotg->regs + GOTGCTL);
 		hsotg->op_state = OTG_STATE_A_SUSPEND;
 	}
 
 	hprt0 = dwc2_read_hprt0(hsotg);
 	hprt0 |= HPRT0_SUSP;
-	writel(hprt0, hsotg->regs + HPRT0);
+	dwc2_writel(hprt0, hsotg->regs + HPRT0);
 
-	/* Update lx_state */
-	hsotg->lx_state = DWC2_L2;
+	hsotg->bus_suspended = 1;
 
-	/* Suspend the Phy Clock */
-	pcgctl = readl(hsotg->regs + PCGCTL);
-	pcgctl |= PCGCTL_STOPPCLK;
-	writel(pcgctl, hsotg->regs + PCGCTL);
-	udelay(10);
+	/*
+	 * If hibernation is supported, Phy clock will be suspended
+	 * after registers are backuped.
+	 */
+	if (!hsotg->core_params->hibernation) {
+		/* Suspend the Phy Clock */
+		pcgctl = dwc2_readl(hsotg->regs + PCGCTL);
+		pcgctl |= PCGCTL_STOPPCLK;
+		dwc2_writel(pcgctl, hsotg->regs + PCGCTL);
+		udelay(10);
+	}
 
 	/* For HNP the bus must be suspended for at least 200ms */
 	if (dwc2_host_is_b_hnp_enabled(hsotg)) {
-		pcgctl = readl(hsotg->regs + PCGCTL);
+		pcgctl = dwc2_readl(hsotg->regs + PCGCTL);
 		pcgctl &= ~PCGCTL_STOPPCLK;
-		writel(pcgctl, hsotg->regs + PCGCTL);
+		dwc2_writel(pcgctl, hsotg->regs + PCGCTL);
 
 		spin_unlock_irqrestore(&hsotg->lock, flags);
 
@@ -1471,6 +1495,44 @@
 	}
 }
 
+/* Must NOT be called with interrupt disabled or spinlock held */
+static void dwc2_port_resume(struct dwc2_hsotg *hsotg)
+{
+	unsigned long flags;
+	u32 hprt0;
+	u32 pcgctl;
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+
+	/*
+	 * If hibernation is supported, Phy clock is already resumed
+	 * after registers restore.
+	 */
+	if (!hsotg->core_params->hibernation) {
+		pcgctl = dwc2_readl(hsotg->regs + PCGCTL);
+		pcgctl &= ~PCGCTL_STOPPCLK;
+		dwc2_writel(pcgctl, hsotg->regs + PCGCTL);
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		usleep_range(20000, 40000);
+		spin_lock_irqsave(&hsotg->lock, flags);
+	}
+
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 |= HPRT0_RES;
+	hprt0 &= ~HPRT0_SUSP;
+	dwc2_writel(hprt0, hsotg->regs + HPRT0);
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	msleep(USB_RESUME_TIMEOUT);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 &= ~(HPRT0_RES | HPRT0_SUSP);
+	dwc2_writel(hprt0, hsotg->regs + HPRT0);
+	hsotg->bus_suspended = 0;
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+}
+
 /* Handles hub class-specific requests */
 static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,
 				u16 wvalue, u16 windex, char *buf, u16 wlength)
@@ -1510,23 +1572,15 @@
 				"ClearPortFeature USB_PORT_FEAT_ENABLE\n");
 			hprt0 = dwc2_read_hprt0(hsotg);
 			hprt0 |= HPRT0_ENA;
-			writel(hprt0, hsotg->regs + HPRT0);
+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
 			break;
 
 		case USB_PORT_FEAT_SUSPEND:
 			dev_dbg(hsotg->dev,
 				"ClearPortFeature USB_PORT_FEAT_SUSPEND\n");
-			writel(0, hsotg->regs + PCGCTL);
-			msleep(USB_RESUME_TIMEOUT);
-
-			hprt0 = dwc2_read_hprt0(hsotg);
-			hprt0 |= HPRT0_RES;
-			writel(hprt0, hsotg->regs + HPRT0);
-			hprt0 &= ~HPRT0_SUSP;
-			usleep_range(100000, 150000);
 
-			hprt0 &= ~HPRT0_RES;
-			writel(hprt0, hsotg->regs + HPRT0);
+			if (hsotg->bus_suspended)
+				dwc2_port_resume(hsotg);
 			break;
 
 		case USB_PORT_FEAT_POWER:
@@ -1534,7 +1588,7 @@
 				"ClearPortFeature USB_PORT_FEAT_POWER\n");
 			hprt0 = dwc2_read_hprt0(hsotg);
 			hprt0 &= ~HPRT0_PWR;
-			writel(hprt0, hsotg->regs + HPRT0);
+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
 			break;
 
 		case USB_PORT_FEAT_INDICATOR:
@@ -1604,9 +1658,11 @@
 		dev_dbg(hsotg->dev, "GetHubDescriptor\n");
 		hub_desc = (struct usb_hub_descriptor *)buf;
 		hub_desc->bDescLength = 9;
-		hub_desc->bDescriptorType = 0x29;
+		hub_desc->bDescriptorType = USB_DT_HUB;
 		hub_desc->bNbrPorts = 1;
-		hub_desc->wHubCharacteristics = cpu_to_le16(0x08);
+		hub_desc->wHubCharacteristics =
+			cpu_to_le16(HUB_CHAR_COMMON_LPSM |
+				    HUB_CHAR_INDV_PORT_OCPM);
 		hub_desc->bPwrOn2PwrGood = 1;
 		hub_desc->bHubContrCurrent = 0;
 		hub_desc->u.hs.DeviceRemovable[0] = 0;
@@ -1653,7 +1709,7 @@
 			break;
 		}
 
-		hprt0 = readl(hsotg->regs + HPRT0);
+		hprt0 = dwc2_readl(hsotg->regs + HPRT0);
 		dev_vdbg(hsotg->dev, "  HPRT0: 0x%08x\n", hprt0);
 
 		if (hprt0 & HPRT0_CONNSTS)
@@ -1718,18 +1774,18 @@
 				"SetPortFeature - USB_PORT_FEAT_POWER\n");
 			hprt0 = dwc2_read_hprt0(hsotg);
 			hprt0 |= HPRT0_PWR;
-			writel(hprt0, hsotg->regs + HPRT0);
+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
 			break;
 
 		case USB_PORT_FEAT_RESET:
 			hprt0 = dwc2_read_hprt0(hsotg);
 			dev_dbg(hsotg->dev,
 				"SetPortFeature - USB_PORT_FEAT_RESET\n");
-			pcgctl = readl(hsotg->regs + PCGCTL);
+			pcgctl = dwc2_readl(hsotg->regs + PCGCTL);
 			pcgctl &= ~(PCGCTL_ENBL_SLEEP_GATING | PCGCTL_STOPPCLK);
-			writel(pcgctl, hsotg->regs + PCGCTL);
+			dwc2_writel(pcgctl, hsotg->regs + PCGCTL);
 			/* ??? Original driver does this */
-			writel(0, hsotg->regs + PCGCTL);
+			dwc2_writel(0, hsotg->regs + PCGCTL);
 
 			hprt0 = dwc2_read_hprt0(hsotg);
 			/* Clear suspend bit if resetting from suspend state */
@@ -1744,13 +1800,13 @@
 				hprt0 |= HPRT0_PWR | HPRT0_RST;
 				dev_dbg(hsotg->dev,
 					"In host mode, hprt0=%08x\n", hprt0);
-				writel(hprt0, hsotg->regs + HPRT0);
+				dwc2_writel(hprt0, hsotg->regs + HPRT0);
 			}
 
 			/* Clear reset bit in 10ms (FS/LS) or 50ms (HS) */
 			usleep_range(50000, 70000);
 			hprt0 &= ~HPRT0_RST;
-			writel(hprt0, hsotg->regs + HPRT0);
+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
 			hsotg->lx_state = DWC2_L0; /* Now back to On state */
 			break;
 
@@ -1760,6 +1816,15 @@
 			/* Not supported */
 			break;
 
+		case USB_PORT_FEAT_TEST:
+			hprt0 = dwc2_read_hprt0(hsotg);
+			dev_dbg(hsotg->dev,
+				"SetPortFeature - USB_PORT_FEAT_TEST\n");
+			hprt0 &= ~HPRT0_TSTCTL_MASK;
+			hprt0 |= (windex >> 8) << HPRT0_TSTCTL_SHIFT;
+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
+			break;
+
 		default:
 			retval = -EINVAL;
 			dev_err(hsotg->dev,
@@ -1814,7 +1879,7 @@
 
 int dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg)
 {
-	u32 hfnum = readl(hsotg->regs + HFNUM);
+	u32 hfnum = dwc2_readl(hsotg->regs + HFNUM);
 
 #ifdef DWC2_DEBUG_SOF
 	dev_vdbg(hsotg->dev, "DWC OTG HCD GET FRAME NUMBER %d\n",
@@ -1917,11 +1982,11 @@
 		if (chan->xfer_started) {
 			u32 hfnum, hcchar, hctsiz, hcint, hcintmsk;
 
-			hfnum = readl(hsotg->regs + HFNUM);
-			hcchar = readl(hsotg->regs + HCCHAR(i));
-			hctsiz = readl(hsotg->regs + HCTSIZ(i));
-			hcint = readl(hsotg->regs + HCINT(i));
-			hcintmsk = readl(hsotg->regs + HCINTMSK(i));
+			hfnum = dwc2_readl(hsotg->regs + HFNUM);
+			hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
+			hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(i));
+			hcint = dwc2_readl(hsotg->regs + HCINT(i));
+			hcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(i));
 			dev_dbg(hsotg->dev, "    hfnum: 0x%08x\n", hfnum);
 			dev_dbg(hsotg->dev, "    hcchar: 0x%08x\n", hcchar);
 			dev_dbg(hsotg->dev, "    hctsiz: 0x%08x\n", hctsiz);
@@ -1969,12 +2034,12 @@
 	dev_dbg(hsotg->dev, "  periodic_channels: %d\n",
 		hsotg->periodic_channels);
 	dev_dbg(hsotg->dev, "  periodic_usecs: %d\n", hsotg->periodic_usecs);
-	np_tx_status = readl(hsotg->regs + GNPTXSTS);
+	np_tx_status = dwc2_readl(hsotg->regs + GNPTXSTS);
 	dev_dbg(hsotg->dev, "  NP Tx Req Queue Space Avail: %d\n",
 		(np_tx_status & TXSTS_QSPCAVAIL_MASK) >> TXSTS_QSPCAVAIL_SHIFT);
 	dev_dbg(hsotg->dev, "  NP Tx FIFO Space Avail: %d\n",
 		(np_tx_status & TXSTS_FSPCAVAIL_MASK) >> TXSTS_FSPCAVAIL_SHIFT);
-	p_tx_status = readl(hsotg->regs + HPTXSTS);
+	p_tx_status = dwc2_readl(hsotg->regs + HPTXSTS);
 	dev_dbg(hsotg->dev, "  P Tx Req Queue Space Avail: %d\n",
 		(p_tx_status & TXSTS_QSPCAVAIL_MASK) >> TXSTS_QSPCAVAIL_SHIFT);
 	dev_dbg(hsotg->dev, "  P Tx FIFO Space Avail: %d\n",
@@ -2170,11 +2235,6 @@
 			 usb_pipein(urb->pipe) ? "IN" : "OUT", status,
 			 urb->actual_length);
 
-	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS && dbg_perio()) {
-		for (i = 0; i < urb->number_of_packets; i++)
-			dev_vdbg(hsotg->dev, " ISO Desc %d status %d\n",
-				 i, urb->iso_frame_desc[i].status);
-	}
 
 	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
 		urb->error_count = dwc2_hcd_urb_get_error_count(qtd->urb);
@@ -2187,6 +2247,12 @@
 		}
 	}
 
+	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS && dbg_perio()) {
+		for (i = 0; i < urb->number_of_packets; i++)
+			dev_vdbg(hsotg->dev, " ISO Desc %d status %d\n",
+				 i, urb->iso_frame_desc[i].status);
+	}
+
 	urb->status = status;
 	if (!status) {
 		if ((urb->transfer_flags & URB_SHORT_NOT_OK) &&
@@ -2238,7 +2304,7 @@
 	dev_dbg(hsotg->dev, "USB RESET function called\n");
 	hprt0 = dwc2_read_hprt0(hsotg);
 	hprt0 &= ~HPRT0_RST;
-	writel(hprt0, hsotg->regs + HPRT0);
+	dwc2_writel(hprt0, hsotg->regs + HPRT0);
 	hsotg->flags.b.port_reset_change = 1;
 }
 
@@ -2262,8 +2328,9 @@
 	dev_dbg(hsotg->dev, "DWC OTG HCD START\n");
 
 	spin_lock_irqsave(&hsotg->lock, flags);
-
+	hsotg->lx_state = DWC2_L0;
 	hcd->state = HC_STATE_RUNNING;
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 
 	if (dwc2_is_device_mode(hsotg)) {
 		spin_unlock_irqrestore(&hsotg->lock, flags);
@@ -2292,13 +2359,148 @@
 	struct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);
 	unsigned long flags;
 
+	/* Turn off all host-specific interrupts */
+	dwc2_disable_host_interrupts(hsotg);
+
+	/* Wait for interrupt processing to finish */
+	synchronize_irq(hcd->irq);
+
 	spin_lock_irqsave(&hsotg->lock, flags);
+	/* Ensure hcd is disconnected */
+	dwc2_hcd_disconnect(hsotg);
 	dwc2_hcd_stop(hsotg);
+	hsotg->lx_state = DWC2_L3;
+	hcd->state = HC_STATE_HALT;
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 
 	usleep_range(1000, 3000);
 }
 
+static int _dwc2_hcd_suspend(struct usb_hcd *hcd)
+{
+	struct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);
+	unsigned long flags;
+	int ret = 0;
+	u32 hprt0;
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+
+	if (hsotg->lx_state != DWC2_L0)
+		goto unlock;
+
+	if (!HCD_HW_ACCESSIBLE(hcd))
+		goto unlock;
+
+	if (!hsotg->core_params->hibernation)
+		goto skip_power_saving;
+
+	/*
+	 * Drive USB suspend and disable port Power
+	 * if usb bus is not suspended.
+	 */
+	if (!hsotg->bus_suspended) {
+		hprt0 = dwc2_read_hprt0(hsotg);
+		hprt0 |= HPRT0_SUSP;
+		hprt0 &= ~HPRT0_PWR;
+		dwc2_writel(hprt0, hsotg->regs + HPRT0);
+	}
+
+	/* Enter hibernation */
+	ret = dwc2_enter_hibernation(hsotg);
+	if (ret) {
+		if (ret != -ENOTSUPP)
+			dev_err(hsotg->dev,
+				"enter hibernation failed\n");
+		goto skip_power_saving;
+	}
+
+	/* Ask phy to be suspended */
+	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		usb_phy_set_suspend(hsotg->uphy, true);
+		spin_lock_irqsave(&hsotg->lock, flags);
+	}
+
+	/* After entering hibernation, hardware is no more accessible */
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+skip_power_saving:
+	hsotg->lx_state = DWC2_L2;
+unlock:
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	return ret;
+}
+
+static int _dwc2_hcd_resume(struct usb_hcd *hcd)
+{
+	struct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+
+	if (hsotg->lx_state != DWC2_L2)
+		goto unlock;
+
+	if (!hsotg->core_params->hibernation) {
+		hsotg->lx_state = DWC2_L0;
+		goto unlock;
+	}
+
+	/*
+	 * Set HW accessible bit before powering on the controller
+	 * since an interrupt may rise.
+	 */
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/*
+	 * Enable power if not already done.
+	 * This must not be spinlocked since duration
+	 * of this call is unknown.
+	 */
+	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		usb_phy_set_suspend(hsotg->uphy, false);
+		spin_lock_irqsave(&hsotg->lock, flags);
+	}
+
+	/* Exit hibernation */
+	ret = dwc2_exit_hibernation(hsotg, true);
+	if (ret && (ret != -ENOTSUPP))
+		dev_err(hsotg->dev, "exit hibernation failed\n");
+
+	hsotg->lx_state = DWC2_L0;
+
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	if (hsotg->bus_suspended) {
+		spin_lock_irqsave(&hsotg->lock, flags);
+		hsotg->flags.b.port_suspend_change = 1;
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		dwc2_port_resume(hsotg);
+	} else {
+		/* Wait for controller to correctly update D+/D- level */
+		usleep_range(3000, 5000);
+
+		/*
+		 * Clear Port Enable and Port Status changes.
+		 * Enable Port Power.
+		 */
+		dwc2_writel(HPRT0_PWR | HPRT0_CONNDET |
+				HPRT0_ENACHG, hsotg->regs + HPRT0);
+		/* Wait for controller to detect Port Connect */
+		usleep_range(5000, 7000);
+	}
+
+	return ret;
+unlock:
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	return ret;
+}
+
 /* Returns the current frame number */
 static int _dwc2_hcd_get_frame_number(struct usb_hcd *hcd)
 {
@@ -2401,6 +2603,9 @@
 	u32 tflags = 0;
 	void *buf;
 	unsigned long flags;
+	struct dwc2_qh *qh;
+	bool qh_allocated = false;
+	struct dwc2_qtd *qtd;
 
 	if (dbg_urb(urb)) {
 		dev_vdbg(hsotg->dev, "DWC OTG HCD URB Enqueue\n");
@@ -2454,7 +2659,7 @@
 				"%s: unaligned transfer with no transfer_buffer",
 				__func__);
 			retval = -EINVAL;
-			goto fail1;
+			goto fail0;
 		}
 	}
 
@@ -2473,40 +2678,73 @@
 	dwc2_urb->interval = urb->interval;
 	dwc2_urb->status = -EINPROGRESS;
 
+	#ifdef CONFIG_DEBUG_FS
+	dwc2_statistic_add(urb->transfer_buffer_length);
+	#endif
+
 	for (i = 0; i < urb->number_of_packets; ++i)
 		dwc2_hcd_urb_set_iso_desc_params(dwc2_urb, i,
 						 urb->iso_frame_desc[i].offset,
 						 urb->iso_frame_desc[i].length);
 
 	urb->hcpriv = dwc2_urb;
+	qh = (struct dwc2_qh *) ep->hcpriv;
+	/* Create QH for the endpoint if it doesn't exist */
+	if (!qh) {
+		qh = dwc2_hcd_qh_create(hsotg, dwc2_urb, mem_flags);
+		if (!qh) {
+			retval = -ENOMEM;
+			goto fail0;
+		}
+		ep->hcpriv = qh;
+		qh_allocated = true;
+	}
+
+	qtd = kzalloc(sizeof(*qtd), mem_flags);
+	if (!qtd) {
+		retval = -ENOMEM;
+		goto fail1;
+	}
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 	retval = usb_hcd_link_urb_to_ep(hcd, urb);
-	spin_unlock_irqrestore(&hsotg->lock, flags);
 	if (retval)
-		goto fail1;
+		goto fail2;
 
-	retval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, &ep->hcpriv, mem_flags);
+	retval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, qh, qtd);
 	if (retval)
-		goto fail2;
+		goto fail3;
 
 	if (alloc_bandwidth) {
-		spin_lock_irqsave(&hsotg->lock, flags);
 		dwc2_allocate_bus_bandwidth(hcd,
 				dwc2_hcd_get_ep_bandwidth(hsotg, ep),
 				urb);
-		spin_unlock_irqrestore(&hsotg->lock, flags);
 	}
 
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
 	return 0;
 
-fail2:
-	spin_lock_irqsave(&hsotg->lock, flags);
+fail3:
 	dwc2_urb->priv = NULL;
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
+fail2:
 	spin_unlock_irqrestore(&hsotg->lock, flags);
-fail1:
 	urb->hcpriv = NULL;
+	kfree(qtd);
+fail1:
+	if (qh_allocated) {
+		struct dwc2_qtd *qtd2, *qtd2_tmp;
+
+		ep->hcpriv = NULL;
+		dwc2_hcd_qh_unlink(hsotg, qh);
+		/* Free each QTD in the QH's QTD list */
+		list_for_each_entry_safe(qtd2, qtd2_tmp, &qh->qtd_list,
+							 qtd_list_entry)
+			dwc2_hcd_qtd_unlink_and_free(hsotg, qtd2, qh);
+		dwc2_hcd_qh_free(hsotg, qh);
+	}
+fail0:
 	kfree(dwc2_urb);
 
 	return retval;
@@ -2538,6 +2776,10 @@
 
 	rc = dwc2_hcd_urb_dequeue(hsotg, urb->hcpriv);
 
+	#ifdef CONFIG_DEBUG_FS
+	dwc2_statistic_decrease(urb->transfer_buffer_length);
+	#endif
+
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 	kfree(urb->hcpriv);
@@ -2669,6 +2911,9 @@
 	.hub_status_data = _dwc2_hcd_hub_status_data,
 	.hub_control = _dwc2_hcd_hub_control,
 	.clear_tt_buffer_complete = _dwc2_hcd_clear_tt_buffer_complete,
+
+	.bus_suspend = _dwc2_hcd_suspend,
+	.bus_resume = _dwc2_hcd_resume,
 };
 
 /*
@@ -2715,17 +2960,17 @@
 		hsotg->status_buf = NULL;
 	}
 
-	ahbcfg = readl(hsotg->regs + GAHBCFG);
+	ahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
 
 	/* Disable all interrupts */
 	ahbcfg &= ~GAHBCFG_GLBL_INTR_EN;
-	writel(ahbcfg, hsotg->regs + GAHBCFG);
-	writel(0, hsotg->regs + GINTMSK);
+	dwc2_writel(ahbcfg, hsotg->regs + GAHBCFG);
+	dwc2_writel(0, hsotg->regs + GINTMSK);
 
 	if (hsotg->hw_params.snpsid >= DWC2_CORE_REV_3_00a) {
-		dctl = readl(hsotg->regs + DCTL);
+		dctl = dwc2_readl(hsotg->regs + DCTL);
 		dctl |= DCTL_SFTDISCON;
-		writel(dctl, hsotg->regs + DCTL);
+		dwc2_writel(dctl, hsotg->regs + DCTL);
 	}
 
 	if (hsotg->wq_otg) {
@@ -2734,8 +2979,6 @@
 		destroy_workqueue(hsotg->wq_otg);
 	}
 
-	kfree(hsotg->core_params);
-	hsotg->core_params = NULL;
 	del_timer(&hsotg->wkp_timer);
 }
 
@@ -2748,29 +2991,12 @@
 }
 
 /*
- * Sets all parameters to the given value.
- *
- * Assumes that the dwc2_core_params struct contains only integers.
- */
-void dwc2_set_all_params(struct dwc2_core_params *params, int value)
-{
-	int *p = (int *)params;
-	size_t size = sizeof(*params) / sizeof(*p);
-	int i;
-
-	for (i = 0; i < size; i++)
-		p[i] = value;
-}
-EXPORT_SYMBOL_GPL(dwc2_set_all_params);
-
-/*
  * Initializes the HCD. This function allocates memory for and initializes the
  * static parts of the usb_hcd and dwc2_hsotg structures. It also registers the
  * USB bus with the core and calls the hc_driver->start() function. It returns
  * a negative error on failure.
  */
-int dwc2_hcd_init(struct dwc2_hsotg *hsotg, int irq,
-		  const struct dwc2_core_params *params)
+int dwc2_hcd_init(struct dwc2_hsotg *hsotg, int irq)
 {
 	struct usb_hcd *hcd;
 	struct dwc2_host_chan *channel;
@@ -2778,17 +3004,14 @@
 	int i, num_channels;
 	int retval;
 
-	dev_dbg(hsotg->dev, "DWC OTG HCD INIT\n");
-
-	/* Detect config values from hardware */
-	retval = dwc2_get_hwparams(hsotg);
+	if (usb_disabled())
+		return -ENODEV;
 
-	if (retval)
-		return retval;
+	dev_dbg(hsotg->dev, "DWC OTG HCD INIT\n");
 
 	retval = -ENOMEM;
 
-	hcfg = readl(hsotg->regs + HCFG);
+	hcfg = dwc2_readl(hsotg->regs + HCFG);
 	dev_dbg(hsotg->dev, "hcfg=%08x\n", hcfg);
 
 #ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS
@@ -2804,15 +3027,6 @@
 	hsotg->last_frame_num = HFNUM_MAX_FRNUM;
 #endif
 
-	hsotg->core_params = kzalloc(sizeof(*hsotg->core_params), GFP_KERNEL);
-	if (!hsotg->core_params)
-		goto error1;
-
-	dwc2_set_all_params(hsotg->core_params, -1);
-
-	/* Validate parameter values */
-	dwc2_set_parameters(hsotg, params);
-
 	/* Check if the bus driver or platform code has setup a dma_mask */
 	if (hsotg->core_params->dma_enable > 0 &&
 	    hsotg->dev->dma_mask == NULL) {
@@ -2839,7 +3053,6 @@
 
 	hcd->has_tt = 1;
 
-	spin_lock_init(&hsotg->lock);
 	((struct wrapper_priv_data *) &hcd->hcd_priv)->hsotg = hsotg;
 	hsotg->priv = hcd;
 
@@ -2931,6 +3144,9 @@
 	/* Don't support SG list at this point */
 	hcd->self.sg_tablesize = 0;
 
+	if (!IS_ERR_OR_NULL(hsotg->uphy))
+		otg_set_host(hsotg->uphy->otg, &hcd->self);
+
 	/*
 	 * Finish generic HCD initialization and start the HCD. This function
 	 * allocates the DMA buffer pool, registers the USB bus, requests the
@@ -2963,7 +3179,6 @@
 	dev_err(hsotg->dev, "%s() FAILED, returning %d\n", __func__, retval);
 	return retval;
 }
-EXPORT_SYMBOL_GPL(dwc2_hcd_init);
 
 /*
  * Removes the HCD.
@@ -2984,6 +3199,9 @@
 		return;
 	}
 
+	if (!IS_ERR_OR_NULL(hsotg->uphy))
+		otg_set_host(hsotg->uphy->otg, NULL);
+
 	usb_remove_hcd(hcd);
 	hsotg->priv = NULL;
 	dwc2_hcd_release(hsotg);
@@ -2994,4 +3212,3 @@
 	kfree(hsotg->frame_num_array);
 #endif
 }
-EXPORT_SYMBOL_GPL(dwc2_hcd_remove);
Index: linux-3.18.29/drivers/usb/dwc2/hcd_ddma.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/hcd_ddma.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/hcd_ddma.c	2017-11-21 20:13:12.466710527 +0800
@@ -169,19 +169,19 @@
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 
-	hcfg = readl(hsotg->regs + HCFG);
+	hcfg = dwc2_readl(hsotg->regs + HCFG);
 	if (hcfg & HCFG_PERSCHEDENA) {
 		/* already enabled */
 		spin_unlock_irqrestore(&hsotg->lock, flags);
 		return;
 	}
 
-	writel(hsotg->frame_list_dma, hsotg->regs + HFLBADDR);
+	dwc2_writel(hsotg->frame_list_dma, hsotg->regs + HFLBADDR);
 
 	hcfg &= ~HCFG_FRLISTEN_MASK;
 	hcfg |= fr_list_en | HCFG_PERSCHEDENA;
 	dev_vdbg(hsotg->dev, "Enabling Periodic schedule\n");
-	writel(hcfg, hsotg->regs + HCFG);
+	dwc2_writel(hcfg, hsotg->regs + HCFG);
 
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 }
@@ -193,7 +193,7 @@
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 
-	hcfg = readl(hsotg->regs + HCFG);
+	hcfg = dwc2_readl(hsotg->regs + HCFG);
 	if (!(hcfg & HCFG_PERSCHEDENA)) {
 		/* already disabled */
 		spin_unlock_irqrestore(&hsotg->lock, flags);
@@ -202,7 +202,7 @@
 
 	hcfg &= ~HCFG_PERSCHEDENA;
 	dev_vdbg(hsotg->dev, "Disabling Periodic schedule\n");
-	writel(hcfg, hsotg->regs + HCFG);
+	dwc2_writel(hcfg, hsotg->regs + HCFG);
 
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 }
Index: linux-3.18.29/drivers/usb/dwc2/hcd_queue.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/hcd_queue.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/hcd_queue.c	2017-11-21 20:13:12.466710527 +0800
@@ -106,6 +106,9 @@
 				USB_SPEED_HIGH : dev_speed, qh->ep_is_in,
 				qh->ep_type == USB_ENDPOINT_XFER_ISOC,
 				bytecount));
+
+		/* Ensure frame_number corresponds to the reality */
+		hsotg->frame_number = dwc2_hcd_get_frame_number(hsotg);
 		/* Start in a slightly future (micro)frame */
 		qh->sched_frame = dwc2_frame_num_inc(hsotg->frame_number,
 						     SCHEDULE_SLOP);
@@ -115,7 +118,7 @@
 		if (qh->ep_type == USB_ENDPOINT_XFER_INT)
 			qh->interval = 8;
 #endif
-		hprt = readl(hsotg->regs + HPRT0);
+		hprt = dwc2_readl(hsotg->regs + HPRT0);
 		prtspd = (hprt & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;
 		if (prtspd == HPRT0_SPD_HIGH_SPEED &&
 		    (dev_speed == USB_SPEED_LOW ||
@@ -191,7 +194,7 @@
  *
  * Return: Pointer to the newly allocated QH, or NULL on error
  */
-static struct dwc2_qh *dwc2_hcd_qh_create(struct dwc2_hsotg *hsotg,
+struct dwc2_qh *dwc2_hcd_qh_create(struct dwc2_hsotg *hsotg,
 					  struct dwc2_hcd_urb *urb,
 					  gfp_t mem_flags)
 {
@@ -229,11 +232,13 @@
  */
 void dwc2_hcd_qh_free(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)
 {
-	if (hsotg->core_params->dma_desc_enable > 0)
+	if (hsotg->core_params->dma_desc_enable > 0) {
 		dwc2_hcd_qh_free_ddma(hsotg, qh);
-	else if (qh->dw_align_buf)
-		dma_free_coherent(hsotg->dev, qh->dw_align_buf_size,
-				  qh->dw_align_buf, qh->dw_align_buf_dma);
+	} else {
+		/* kfree(NULL) is safe */
+		kfree(qh->dw_align_buf);
+		qh->dw_align_buf_dma = (dma_addr_t)0;
+	}
 	kfree(qh);
 }
 
@@ -581,6 +586,14 @@
 		/* QH already in a schedule */
 		return 0;
 
+	if (!dwc2_frame_num_le(qh->sched_frame, hsotg->frame_number) &&
+			!hsotg->frame_number) {
+		dev_dbg(hsotg->dev,
+				"reset frame number counter\n");
+		qh->sched_frame = dwc2_frame_num_inc(hsotg->frame_number,
+				SCHEDULE_SLOP);
+	}
+
 	/* Add the new QH to the appropriate schedule */
 	if (dwc2_qh_is_non_per(qh)) {
 		/* Always start in inactive schedule */
@@ -593,9 +606,9 @@
 	if (status)
 		return status;
 	if (!hsotg->periodic_qh_count) {
-		intr_mask = readl(hsotg->regs + GINTMSK);
+		intr_mask = dwc2_readl(hsotg->regs + GINTMSK);
 		intr_mask |= GINTSTS_SOF;
-		writel(intr_mask, hsotg->regs + GINTMSK);
+		dwc2_writel(intr_mask, hsotg->regs + GINTMSK);
 	}
 	hsotg->periodic_qh_count++;
 
@@ -630,9 +643,9 @@
 	dwc2_deschedule_periodic(hsotg, qh);
 	hsotg->periodic_qh_count--;
 	if (!hsotg->periodic_qh_count) {
-		intr_mask = readl(hsotg->regs + GINTMSK);
+		intr_mask = dwc2_readl(hsotg->regs + GINTMSK);
 		intr_mask &= ~GINTSTS_SOF;
-		writel(intr_mask, hsotg->regs + GINTMSK);
+		dwc2_writel(intr_mask, hsotg->regs + GINTMSK);
 	}
 }
 
@@ -761,67 +774,36 @@
 
 /**
  * dwc2_hcd_qtd_add() - Adds a QTD to the QTD-list of a QH
+ *			Caller must hold driver lock.
  *
  * @hsotg:        The DWC HCD structure
  * @qtd:          The QTD to add
- * @qh:           Out parameter to return queue head
- * @atomic_alloc: Flag to do atomic alloc if needed
+ * @qh:           Queue head to add qtd to
  *
  * Return: 0 if successful, negative error code otherwise
  *
- * Finds the correct QH to place the QTD into. If it does not find a QH, it
- * will create a new QH. If the QH to which the QTD is added is not currently
- * scheduled, it is placed into the proper schedule based on its EP type.
+ * If the QH to which the QTD is added is not currently scheduled, it is placed
+ * into the proper schedule based on its EP type.
  */
 int dwc2_hcd_qtd_add(struct dwc2_hsotg *hsotg, struct dwc2_qtd *qtd,
-		     struct dwc2_qh **qh, gfp_t mem_flags)
+		     struct dwc2_qh *qh)
 {
-	struct dwc2_hcd_urb *urb = qtd->urb;
-	unsigned long flags;
-	int allocated = 0;
 	int retval;
 
-	/*
-	 * Get the QH which holds the QTD-list to insert to. Create QH if it
-	 * doesn't exist.
-	 */
-	if (*qh == NULL) {
-		*qh = dwc2_hcd_qh_create(hsotg, urb, mem_flags);
-		if (*qh == NULL)
-			return -ENOMEM;
-		allocated = 1;
+	if (unlikely(!qh)) {
+		dev_err(hsotg->dev, "%s: Invalid QH\n", __func__);
+		retval = -EINVAL;
+		goto fail;
 	}
 
-	spin_lock_irqsave(&hsotg->lock, flags);
-
-	retval = dwc2_hcd_qh_add(hsotg, *qh);
+	retval = dwc2_hcd_qh_add(hsotg, qh);
 	if (retval)
 		goto fail;
 
-	qtd->qh = *qh;
-	list_add_tail(&qtd->qtd_list_entry, &(*qh)->qtd_list);
-	spin_unlock_irqrestore(&hsotg->lock, flags);
+	qtd->qh = qh;
+	list_add_tail(&qtd->qtd_list_entry, &qh->qtd_list);
 
 	return 0;
-
 fail:
-	if (allocated) {
-		struct dwc2_qtd *qtd2, *qtd2_tmp;
-		struct dwc2_qh *qh_tmp = *qh;
-
-		*qh = NULL;
-		dwc2_hcd_qh_unlink(hsotg, qh_tmp);
-
-		/* Free each QTD in the QH's QTD list */
-		list_for_each_entry_safe(qtd2, qtd2_tmp, &qh_tmp->qtd_list,
-					 qtd_list_entry)
-			dwc2_hcd_qtd_unlink_and_free(hsotg, qtd2, qh_tmp);
-
-		spin_unlock_irqrestore(&hsotg->lock, flags);
-		dwc2_hcd_qh_free(hsotg, qh_tmp);
-	} else {
-		spin_unlock_irqrestore(&hsotg->lock, flags);
-	}
-
 	return retval;
 }
Index: linux-3.18.29/drivers/usb/dwc2/pci.c
===================================================================
--- linux-3.18.29.orig/drivers/usb/dwc2/pci.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/usb/dwc2/pci.c	2017-11-21 20:13:12.466710527 +0800
@@ -50,106 +50,97 @@
 
 #include <linux/usb/hcd.h>
 #include <linux/usb/ch11.h>
+#include <linux/platform_device.h>
+#include <linux/usb/usb_phy_generic.h>
 
-#include "core.h"
-#include "hcd.h"
-
-#define PCI_VENDOR_ID_SYNOPSYS		0x16c3
 #define PCI_PRODUCT_ID_HAPS_HSOTG	0xabc0
 
-static const char dwc2_driver_name[] = "dwc2";
+static const char dwc2_driver_name[] = "dwc2-pci";
 
-static const struct dwc2_core_params dwc2_module_params = {
-	.otg_cap			= -1,
-	.otg_ver			= -1,
-	.dma_enable			= -1,
-	.dma_desc_enable		= 0,
-	.speed				= -1,
-	.enable_dynamic_fifo		= -1,
-	.en_multiple_tx_fifo		= -1,
-	.host_rx_fifo_size		= 1024,
-	.host_nperio_tx_fifo_size	= 256,
-	.host_perio_tx_fifo_size	= 1024,
-	.max_transfer_size		= 65535,
-	.max_packet_count		= 511,
-	.host_channels			= -1,
-	.phy_type			= -1,
-	.phy_utmi_width			= -1,
-	.phy_ulpi_ddr			= -1,
-	.phy_ulpi_ext_vbus		= -1,
-	.i2c_enable			= -1,
-	.ulpi_fs_ls			= -1,
-	.host_support_fs_ls_low_power	= -1,
-	.host_ls_low_power_phy_clk	= -1,
-	.ts_dline			= -1,
-	.reload_ctl			= -1,
-	.ahbcfg				= -1,
-	.uframe_sched			= -1,
+struct dwc2_pci_glue {
+	struct platform_device *dwc2;
+	struct platform_device *phy;
 };
 
-/**
- * dwc2_driver_remove() - Called when the DWC_otg core is unregistered with the
- * DWC_otg driver
- *
- * @dev: Bus device
- *
- * This routine is called, for example, when the rmmod command is executed. The
- * device may or may not be electrically present. If it is present, the driver
- * stops device processing. Any resources used on behalf of this device are
- * freed.
- */
-static void dwc2_driver_remove(struct pci_dev *dev)
+static void dwc2_pci_remove(struct pci_dev *pci)
 {
-	struct dwc2_hsotg *hsotg = pci_get_drvdata(dev);
+	struct dwc2_pci_glue *glue = pci_get_drvdata(pci);
 
-	dwc2_hcd_remove(hsotg);
-	pci_disable_device(dev);
+	platform_device_unregister(glue->dwc2);
+	usb_phy_generic_unregister(glue->phy);
+	kfree(glue);
+	pci_set_drvdata(pci, NULL);
 }
 
-/**
- * dwc2_driver_probe() - Called when the DWC_otg core is bound to the DWC_otg
- * driver
- *
- * @dev: Bus device
- *
- * This routine creates the driver components required to control the device
- * (core, HCD, and PCD) and initializes the device. The driver components are
- * stored in a dwc2_hsotg structure. A reference to the dwc2_hsotg is saved
- * in the device private data. This allows the driver to access the dwc2_hsotg
- * structure on subsequent calls to driver methods for this device.
- */
-static int dwc2_driver_probe(struct pci_dev *dev,
-			     const struct pci_device_id *id)
+static int dwc2_pci_probe(struct pci_dev *pci,
+		const struct pci_device_id *id)
 {
-	struct dwc2_hsotg *hsotg;
-	int retval;
+	struct resource		res[2];
+	struct platform_device	*dwc2;
+	struct platform_device	*phy;
+	int			ret;
+	struct device		*dev = &pci->dev;
+	struct dwc2_pci_glue	*glue;
+
+	ret = pcim_enable_device(pci);
+	if (ret) {
+		dev_err(dev, "failed to enable pci device\n");
+		return -ENODEV;
+	}
 
-	hsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);
-	if (!hsotg)
+	pci_set_master(pci);
+
+	dwc2 = platform_device_alloc("dwc2", PLATFORM_DEVID_AUTO);
+	if (!dwc2) {
+		dev_err(dev, "couldn't allocate dwc2 device\n");
 		return -ENOMEM;
+	}
 
-	hsotg->dev = &dev->dev;
-	hsotg->regs = devm_ioremap_resource(&dev->dev, &dev->resource[0]);
-	if (IS_ERR(hsotg->regs))
-		return PTR_ERR(hsotg->regs);
+	memset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));
 
-	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
-		(unsigned long)pci_resource_start(dev, 0), hsotg->regs);
+	res[0].start	= pci_resource_start(pci, 0);
+	res[0].end	= pci_resource_end(pci, 0);
+	res[0].name	= "dwc2";
+	res[0].flags	= IORESOURCE_MEM;
+
+	res[1].start	= pci->irq;
+	res[1].name	= "dwc2";
+	res[1].flags	= IORESOURCE_IRQ;
+
+	ret = platform_device_add_resources(dwc2, res, ARRAY_SIZE(res));
+	if (ret) {
+		dev_err(dev, "couldn't add resources to dwc2 device\n");
+		return ret;
+	}
 
-	if (pci_enable_device(dev) < 0)
-		return -ENODEV;
+	dwc2->dev.parent = dev;
 
-	pci_set_master(dev);
+	phy = usb_phy_generic_register();
+	if (IS_ERR(phy)) {
+		dev_err(dev, "error registering generic PHY (%ld)\n",
+			PTR_ERR(phy));
+		return PTR_ERR(phy);
+	}
 
-	retval = dwc2_hcd_init(hsotg, dev->irq, &dwc2_module_params);
-	if (retval) {
-		pci_disable_device(dev);
-		return retval;
+	ret = platform_device_add(dwc2);
+	if (ret) {
+		dev_err(dev, "failed to register dwc2 device\n");
+		goto err;
 	}
 
-	pci_set_drvdata(dev, hsotg);
+	glue = kzalloc(sizeof(*glue), GFP_KERNEL);
+	if (!glue)
+		return -ENOMEM;
 
-	return retval;
+	glue->phy = phy;
+	glue->dwc2 = dwc2;
+	pci_set_drvdata(pci, glue);
+
+	return 0;
+err:
+	usb_phy_generic_unregister(phy);
+	platform_device_put(dwc2);
+	return ret;
 }
 
 static const struct pci_device_id dwc2_pci_ids[] = {
@@ -167,8 +158,8 @@
 static struct pci_driver dwc2_pci_driver = {
 	.name = dwc2_driver_name,
 	.id_table = dwc2_pci_ids,
-	.probe = dwc2_driver_probe,
-	.remove = dwc2_driver_remove,
+	.probe = dwc2_pci_probe,
+	.remove = dwc2_pci_remove,
 };
 
 module_pci_driver(dwc2_pci_driver);
Index: linux-3.18.29/arch/mips/kernel/module.c
===================================================================
--- linux-3.18.29.orig/arch/mips/kernel/module.c	2017-11-21 20:13:11.354710494 +0800
+++ linux-3.18.29/arch/mips/kernel/module.c	2017-11-21 20:13:12.466710527 +0800
@@ -546,13 +546,19 @@
 
 void module_arch_freeing_init(struct module *mod)
 {
-	if (mod->arch.phys_plt_tbl) {
-		__module_free(mod->arch.phys_plt_tbl);
-		mod->arch.phys_plt_tbl = NULL;
-	}
-	if (mod->arch.virt_plt_tbl) {
-		__module_free(mod->arch.virt_plt_tbl);
-		mod->arch.virt_plt_tbl = NULL;
+	/* Modified by nevermore.
+	 * Phys_plt_tbl and virt_plt_tbl shouldn't be freed
+	 * when module is in live state, for example, in
+	 * do_init_module. */
+	if(mod->state != MODULE_STATE_LIVE) {
+		if (mod->arch.phys_plt_tbl) {
+			__module_free(mod->arch.phys_plt_tbl);
+			mod->arch.phys_plt_tbl = NULL;
+		}
+		if (mod->arch.virt_plt_tbl) {
+			__module_free(mod->arch.virt_plt_tbl);
+			mod->arch.virt_plt_tbl = NULL;
+		}
 	}
 }
 
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw0.dtsi
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw0.dtsi	2017-11-15 11:09:39.304423000 +0800
@@ -0,0 +1,1096 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+/ {
+	compatible = "siflower,sf16a18";
+
+	aliases {
+		gdu = &gdu;
+		gdma = &gdma;
+		usb = &usb;
+		emmc = &emmc;
+		sdio = &sdio;
+		i2s = &i2s0;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		uart0=&uart0;
+		uart1=&uart1;
+		uart2=&uart2;
+		uart3=&uart3;
+		pcm0 = &pcm0;
+		/*pcm1 = &pcm1;*/
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		timer0 = &timer0;
+		watchdog = &watchdog;
+		spdif = &spdif;
+	};
+
+	grfcom: syscon@19e00000 {
+			compatible = "siflower,sfax8-syscon";
+			reg = <0x19e00000 0x30000>;
+		};
+
+	grfgpio: syscon@19e3f000 {
+			compatible = "siflower,sfax8-syscon";
+			reg = <0x19e3f000 0x1000>;
+		};
+
+	clocks{
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		osc: oscillator {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <12000000>;
+			clock-output-names = "osc";
+		};
+
+		cpupll: pll@19e01000 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <112>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "cpu_pll";
+			clock-output-names = "cpupll";
+		};
+
+		ddrpll: pll@19e01040 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <111>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "ddr_pll";
+			clock-output-names = "ddrpll";
+		};
+
+		cmnpll: pll@19e01080 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <99>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "cmn_pll";
+			clock-output-names = "cmnpll";
+		};
+
+		spcpll: pll@19e010c0 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <125>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "spc_pll";
+			clock-output-names = "spcpll";
+		};
+
+		bus1xnclk: cfg@19e01400 {
+			compatible = "siflower,sf16a18-bus1-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "bus1_clk";
+			reg = <0x19e01400 0x20>;
+			clock-output-names = "bus1xnclk";
+		};
+
+		bus2xnclk: cfg@19e01420 {
+			compatible = "siflower,sf16a18-bus2-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "bus2_clk";
+			reg = <0x19e01420 0x20>;
+			clock-output-names = "bus2xnclk";
+		};
+
+		bus3xnclk: cfg@19e01440 {
+			compatible = "siflower,sf16a18-bus3-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "bus3_clk";
+			reg = <0x19e01440 0x20>;
+			clock-output-names = "bus3xnclk";
+		};
+
+		cpuclk: cfg@19e01500 {
+			compatible = "siflower,sf16a18-cpu-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "cpu_clk";
+			reg = <0x19e01500 0x20>;
+			clock-output-names = "cpuclk";
+		};
+
+		pbusclk: cfg@19e01520 {
+			compatible = "siflower,sf16a18-pbus-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "pbus_clk";
+			reg = <0x19e01520 0x20>;
+			clock-output-names = "pbusclk";
+		};
+
+		memphyclk: cfg@19e01540 {
+			compatible = "siflower,sf16a18-memphy-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "mem_phy_clk";
+			reg = <0x19e01540 0x20>;
+			clock-output-names = "memphyclk";
+		};
+
+		audioclk: cfg@19e01560 {
+			compatible = "siflower,sf16a18-audio-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "audio_clk";
+			reg = <0x19e01560 0x20>;
+			clock-output-names = "audioclk";
+		};
+
+		uartclk: cfg@19e01580 {
+			compatible = "siflower,sf16a18-uart-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "uart_clk";
+			reg = <0x19e01580 0x20>;
+			clock-output-names = "uartclk";
+		};
+
+		spdifclk: cfg@19e015a0 {
+			compatible = "siflower,sf16a18-spdif-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "spdif_clk";
+			reg = <0x19e015a0 0x20>;
+			clock-output-names = "spdifclk";
+		};
+
+		sdhcclk: cfg@19e015c0 {
+			compatible = "siflower,sf16a18-sdhc-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "sdio_clk";
+			reg = <0x19e015c0 0x20>;
+			clock-output-names = "sdhcclk";
+		};
+
+		inandclk: cfg@19e015e0 {
+			compatible = "siflower,sf16a18-emmc-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "emmc_clk";
+			reg = <0x19e015e0 0x20>;
+			clock-output-names = "inandclk";
+		};
+
+		ethrefclk: cfg@19e01600 {
+			compatible = "siflower,sf16a18-eth-ref-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "eth_ref_clk";
+			reg = <0x19e01600 0x20>;
+			clock-output-names = "ethrefclk";
+		};
+
+		ethbyprefclk: cfg@19e01620 {
+			compatible = "siflower,sf16a18-eth-byp-ref-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "eth_byp_ref_clk";
+			reg = <0x19e01620 0x20>;
+			clock-output-names = "ethbyprefclk";
+		};
+
+		ethtsuclk: cfg@19e01640 {
+			compatible = "siflower,sf16a18-eth-tsu-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "eth_tsu_clk";
+			reg = <0x19e01640 0x20>;
+			clock-output-names = "ethtsuclk";
+		};
+
+		wlan24clk: cfg@19e016c0 {
+			compatible = "siflower,sf16a18-wlan24-mac-wt-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "wlan24_mac_wt_clk";
+			reg = <0x19e016c0 0x20>;
+			clock-output-names = "wlan24clk";
+		};
+
+		wlan5clk: cfg@19e016e0 {
+			compatible = "siflower,sf16a18-wlan5-mac-wt-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "wlan5_mac_wt_clk";
+			reg = <0x19e016e0 0x20>;
+			clock-output-names = "wlan5clk";
+		};
+
+		usbphyclk: cfg@19e01700 {
+			compatible = "siflower,sf16a18-usbphy-ref-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "usb_phy_clk";
+			reg = <0x19e01700 0x20>;
+			clock-output-names = "usbphyclk";
+		};
+
+		tclk: cfg@19e01720 {
+			compatible = "siflower,sf16a18-tclk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "tclk";
+			reg = <0x19e01720 0x20>;
+			clock-output-names = "tclk";
+		};
+
+		npupeclk: cfg@19e01740 {
+			compatible = "siflower,sf16a18-npupe-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "npu_pe_clk";
+			reg = <0x19e01740 0x20>;
+			clock-output-names = "npupeclk";
+		};
+
+		gdu0clk: cfg@19e01760 {
+			compatible = "siflower,sf16a18-gdu0-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "gdu0_clk";
+			reg = <0x19e01760 0x20>;
+			clock-output-names = "gdu0clk";
+		};
+
+		gdu0eitfclk: cfg@19e01780 {
+			compatible = "siflower,sf16a18-gdu0-eitf-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "gdu0_eitf_clk";
+			reg = <0x19e01780 0x20>;
+			clock-output-names = "gdu0eitfclk";
+		};
+
+		tvif0clk: cfg@19e017a0 {
+			compatible = "siflower,sf16a18-tvif0-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "tvif0_clk";
+			reg = <0x19e017a0 0x20>;
+			clock-output-names = "tvif0clk";
+		};
+
+	};
+
+	cpus{
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,interAptiv";
+			reg = <0>;
+			clocks = <&cpuclk 0>;
+			clock-names = "cpu";
+			clock-latency = <50000>;
+			operating-points = <
+				/* kHz    uV(dummy) */
+				/*750000 900000*/
+				672000 800000
+				594000 800000
+				500000 800000
+				396000 800000
+				336000 800000
+				297000 800000
+				238000 800000
+				198000 800000
+				148500 800000
+				112000 800000
+				56000 800000
+				28000 800000
+				14000 800000
+			>;
+		};
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "mips,interAptiv";
+			reg = <1>;
+			clocks = <&cpuclk 0>;
+			clock-names = "cpu";
+			clock-latency = <50000>;
+			operating-points = <
+				/* kHz    uV(dummy) */
+				/*750000 900000*/
+				672000 800000
+				594000 800000
+				500000 800000
+				396000 800000
+				336000 800000
+				297000 800000
+				238000 800000
+				198000 800000
+				148500 800000
+				112000 800000
+				56000 800000
+				28000 800000
+				14000 800000
+			>;
+		};
+	};
+
+	cpuintc: cpuintc@0 {
+		compatible = "mti,cpu-interrupt-controller";
+		#address-cells = <0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	gic: gic@1bdc0000 {
+		#interrupt-cells = <2>;
+		interrupt-controller;
+		compatible = "siflower,sfax8-gic";
+		reg = <0x1bdc0000 0x20000>;/*gic*/
+		clocks = <&cpuclk 0>;
+	};
+
+	usb_phy: usb-phy {
+		compatible = "siflower,sfax8-usb-phy";
+		clocks = <&usbphyclk 0>;
+		usbgrf = <&grfcom>;
+		#phy-cells = <0>;
+		status = "disabled";
+	};
+
+	palmbus@10000000 {
+		compatible = "palmbus";
+		reg = <0x10000000 0x10000000>;
+		ranges = <0x0 0x10000000 0xFFFFFFF>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&gic>;
+
+		ethernet: ethernet@0000000 {
+			compatible = "siflower,sfax8-eth";
+			reg = <0x0000000 0x6CFFFF>;
+			clocks = <&ethrefclk 0>, <&ethbyprefclk 0>, <&ethtsuclk 0>;
+			mtd-mac-address = <&factory 0>;
+			interrupts = <16 0>;
+			status = "disabled";
+		};
+
+		switch: switch@0000000 {
+			compatible = "siflower,sfax8-switch";
+			reg = <0x0000000 0x6CFFFF>;
+			interrupts = <25 0>;
+			max-speed = <100>;
+			sfax8,port-map = "llllw";
+			status = "disabled";
+		};
+
+		gmac: gmac@800000 {
+			compatible = "siflower,sfax8-gmac";
+			reg = <0x800000 0x200000>;
+			clocks = <&ethbyprefclk 0>, <&ethtsuclk 0>;
+			interrupts = <32 0>;
+
+			mac-address = [ 00 11 22 33 44 55 ];
+			phy = <&phy0>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			phy0: ethernet-phy@0 {
+				reg = <1>;
+				max-speed = <1000>;
+			};
+		};
+
+		gdu: gdu@c00000 {
+			compatible = "siflower,sfax8-gdu";
+			reg = <0xc00000 0x10000>;
+			interrupts = <39 0>;
+			status = "disabled";
+		};
+
+		rng: rng@c00900 {
+			compatible = "siflower,sfax8-rng";
+			reg = <0xc00900 0x28>;
+			rnggrf = <&grfcom>;
+			status = "disabled";
+		};
+
+		gdma: dma@1800000 {
+			compatible = "siflower,sfax8-gdma";
+			reg = <0x1800000 0x1000>;
+			interrupts = <80 0>;
+			#dma-cells = <1>;
+			#dma-channels = <7>;
+			#dma-requests = <32>;
+			status = "disabled";
+		};
+
+		usb: usb@7400000 {
+			compatible = "siflower,sfax8-usb";
+			reg = <0x7400000 0x40000>;
+			interrupts = <128 0>;
+			clocks = <&usbphyclk 0>;
+			dr_mode = "otg";
+			phys = <&usb_phy>;
+			phy-names = "usb2-phy";
+			usbgrf = <&grfcom>;
+			status = "disabled";
+
+			g-use-dma;
+			g-tx-fifo-size = <0x100 0x100 0x100 0x100 0x100
+				0x300 0x300 0x300>;
+		};
+
+		emmc: emmc@7600000 {
+			compatible = "siflower,sfax8-mmc";
+			reg = <0x7600000 0x200000>;
+			clocks = <&inandclk 0>;
+			clock-freq-min-max = <400000 50000000>;
+			fifo-depth = <0x200>;
+			bus-width = <8>;
+			interrupts = <144 0>;
+			read-delayline = <15>;
+			write-delayline = <15>;
+			supports-highspeed;
+			pinctrl-names = "default";
+			pinctrl-0 = <&emmc_data0 &emmc_data1 &emmc_data2 &emmc_data3 \
+						 &emmc_data4 &emmc_data5 &emmc_data6 &emmc_data7 \
+						 &emm_clk &emmc_cmd &emmc_resetn>;
+			status = "disabled";
+		};
+
+		sdio: sdio@7800000 {
+			compatible = "siflower,sfax8-mmc";
+			reg = <0x7800000 0x200000>;
+			clocks = <&sdhcclk 0>;
+			/*clock-names = "biu", "ciu";*/
+			bus-width = <4>;
+			read-delayline = <15>;
+			write-delayline = <15>;
+			interrupts = <160 0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&sdio_data0 &sdio_data1 &sdio_data2 &sdio_data3 \
+						 &sdi_clk &sdio_cmd &sdio_cd>;
+			status = "disabled";
+		};
+
+		i2s0: i2s@8000000 {
+			compatible = "siflower,sfax8-i2s";
+			interrupts = <208 0>;
+			reg = <0x8000000 0x1000>;
+			clocks = <&audioclk 0>;
+			dmas = <&gdma 0
+			&gdma 1>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s0_cdclk &i2s0_sclk &i2s0_lrck &i2s0_sdi0 &i2s0_sdo0>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@8100000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8100000 0x1000>;
+			clocks = <&pbusclk 0>;
+			clock-frequency = <400000>;
+			interrupts = <217 0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names="default";
+			pinctrl-0 = <&i2c0_clk &i2c0_dat>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@8101000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8101000 0x1000>;
+			clocks = <&pbusclk 0>;
+			clock-frequency = <400000>;
+			interrupts = <218 0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names="default";
+			pinctrl-0 = <&i2c1_clk &i2c1_dat>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@8102000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8102000 0x1000>;
+			clocks = <&pbusclk 0>;
+			clock-frequency = <400000>;
+			interrupts = <219 0>;
+			status = "disabled";
+		};
+
+		spi0: spi@8200000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8200000 0x1000>;
+			num-cs = <2>;
+			cs-gpios = <&gpio 5 0>, <&gpio 6 0>;
+			spi-max-frequency = <33000000>;
+
+			clocks = <&pbusclk 0>;
+			sfgrf = <&grfcom>;
+
+			interrupt-parent = <&gic>;
+			interrupts = <223 0>;
+
+			use-dma;
+			dmas = <&gdma 10
+				&gdma 11>;
+			dma-names = "tx", "rx";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi1: spi@8201000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8201000 0x1000>;
+			clocks = <&pbusclk 0>;
+			status = "disabled";
+
+			num-cs = <1>;
+			/*cs-gpios = <&gpio 34 0>;*/
+			spi-max-frequency = <33000000>;
+			sfgrf = <&grfcom>;
+
+			interrupt-parent = <&gic>;
+			interrupts = <224 0>;
+
+		/*	use-dma;
+			dmas = <&gdma 12
+				&gdma 13>;
+			dma-names = "tx", "rx";
+		*/
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		uart0: serial@8300000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8300000 0x1000>;
+			interrupts = <226 0>;
+			clocks = <&uartclk 0>;
+			status = "disabled";
+		};
+
+		uart1: serial@8301000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8301000 0x1000>;
+			interrupts = <227 0>;
+			clocks = <&uartclk 0>;
+			dmas = <&gdma 14
+			&gdma 15>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		uart2: serial@8302000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8302000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <228 0>;
+			status = "disabled";
+		};
+
+		uart3: serial@8303000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8303000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <229 0>;
+			status = "disabled";
+		};
+
+		pcm0: pcm@8400000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8400000 0x1000>;
+			clocks =<&audioclk 0>;
+			id = <0>;
+			dmas = <&gdma 20
+				&gdma 21>;
+			dma-names = "tx","rx";
+			interrupts = <230 0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pcm0_cdclk &pcm0_sclk &pcm0_fsync &pcm0_sin &pcm0_sout>;
+			status = "disabled";
+		};
+
+		/*
+		pcm1: pcm@8401000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8401000 0x1000>;
+			clocks =<&audioclk 0>;
+			id = <1>;
+			dmas = <&gdma 22
+				&gdma 23>;
+			dma-names = "tx","rx";
+			interrupts = <231 0>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&pcm1_cdclk &pcm1_sclk &pcm1_fsync &pcm1_sin &pcm1_sout>;
+		};
+		*/
+
+		pwm0: pwm@8500000 {
+			compatible = "siflower,sfax8-pwm";
+			reg = <0x8500000 0x1000>;
+			interrupts = <232 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm_0>; //36
+			status = "disabled";
+		};
+
+		pwm1: pwm@8501000 {
+			compatible = "siflower,sfax8-pwm";
+			reg = <0x8501000 0x1000>;
+			interrupts = <233 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm_1>; //37
+			status = "disabled";
+		};
+
+		timer0: timer@8600000 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8600000 0x14>, <0x8600014 0x14>, <0x8601000 0x14>, <0x8601014 0x14>;
+			interrupts = <234 0>, <235 0>, <236 0>, <237 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+			status = "disabled";
+		};
+
+		watchdog: watchdog@8700000 {
+			compatible = "siflower,sfax8-wdt";
+			reg = <0x8700000 0x1000>;
+			interrupt-parent = <&gic>;
+			interrupts = <238 0>;
+			clocks = <&pbusclk 0>;
+			status = "disabled";
+		};
+
+		spdif: spdif@8800000 {
+			compatible = "siflower,sfax8-spdif";
+			reg = <0x8800000 0x1000>;
+			interrupts = <239 0>;
+			clocks = <&spdifclk 0>;
+			dmas = <&gdma 8
+				&gdma 9>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		wifi_rf: wifi-rf@7A00000{
+			compatible = "siflower,sf16a18-wifi-rf";
+			reg = <0x7A00000 0x600000>;
+			interrupts = <176 0>;
+			status = "disabled";
+		};
+
+		wifi_lb: wifi-lb@1000000{
+			compatible = "siflower,sf16a18-wifi-lb";
+			reg = <0x1000000 0x400000>;
+			interrupts = <48 0>, <49 0>;
+			mtd-mac-address = <&factory 0>;
+			clocks = <&wlan24clk 0>;
+			status = "disabled";
+		};
+
+		wifi_hb: wifi-hb@1400000{
+			compatible = "siflower,sf16a18-wifi-hb";
+			reg = <0x1400000 0x400000>;
+			interrupts = <64 0>, <65 0>;
+			mtd-mac-address = <&factory 0>;
+			clocks = <&wlan5clk 0>;
+			status = "disabled";
+		};
+
+	}; /* palmbus */
+
+	pinctrl: pinctrl {
+		compatible = "siflower,sfax8-pinctrl";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&gic>;
+		ranges;
+		pad-base = <&grfgpio>;
+
+		gpio: gpio@19d00000 {
+			compatible = "siflower,sfax8-gpio";
+			reg=<0x19d00000 0x100000>;
+			interrupts = <246 0>, <247 0>, <248 0>, <249 0>;
+			clocks = <&pbusclk 0>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		pcfg_pull_up: pcfg-pull-up {
+			bias-pull-up;
+		};
+
+		pcfg_pull_down: pcfg-pull-down {
+			bias-pull-down;
+		};
+
+		pcfg_pull_none: pcfg-pull-none {
+			bias-disable;
+		};
+
+		pcfg_pull_pin_default: pcfg-pull-pin-default {
+			bias-pull-pin-default;
+		};
+
+
+		spi0 {
+			spi0_mosi: spi0-mosi {
+				sfax8,pins = <0 0 1 &pcfg_pull_pin_default>;
+			};
+			spi0_miso: spi0-miso {
+				sfax8,pins = <0 1 1 &pcfg_pull_pin_default>;
+			};
+			spi0_hold: spi0-hold {
+				sfax8,pins = <0 2 1 &pcfg_pull_pin_default>;
+			};
+			spi0_wp: spi0-wp {
+				sfax8,pins = <0 3 1 &pcfg_pull_pin_default>;
+			};
+			spi0_clk: spi0-clk {
+				sfax8,pins = <0 4 1 &pcfg_pull_pin_default>;
+			};
+			spi0_cs0: spi0-cs0 {
+				sfax8,pins = <0 5 1 &pcfg_pull_pin_default>;
+			};
+			spi0_cs1: spi0-cs1 {
+				sfax8,pins = <0 6 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+		spi1 {
+			spi1_txd: spi1-txd {
+				sfax8,pins = <0 31 1 &pcfg_pull_pin_default>;
+			};
+			spi1_rxd: spi1-rxd {
+				sfax8,pins = <0 32 1 &pcfg_pull_pin_default>;
+			};
+			spi1_clk: spi1-clk {
+				sfax8,pins = <0 33 1 &pcfg_pull_pin_default>;
+			};
+			spi1_csn: spi1-csn {
+				sfax8,pins = <0 34 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+
+		emmc {
+			emmc_data0: emmc-data0 {
+				sfax8,pins = <0 0 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data1: emmc-data1 {
+				sfax8,pins = <0 1 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data2: emmc-data2 {
+				sfax8,pins = <0 2 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data3: emmc-data3 {
+				sfax8,pins = <0 3 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data4: emmc-data4 {
+				sfax8,pins = <0 4 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data5: emmc-data5 {
+				sfax8,pins = <0 8 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data6: emmc-data6 {
+				sfax8,pins = <0 9 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data7: emmc-data7 {
+				sfax8,pins = <0 10 0 &pcfg_pull_pin_default>;
+			};
+
+			emm_clk: emmc-clk {
+				sfax8,pins = <0 5 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_cmd: emmc-cmd {
+				sfax8,pins = <0 6 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_resetn: emmc-resetn {
+				sfax8,pins = <0 7 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		sdio {
+			sdio_data0: sdio-data0 {
+				sfax8,pins = <0 11 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_data1: sdio-data1 {
+				sfax8,pins = <0 12 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_data2: sdio-data2 {
+				sfax8,pins = <0 13 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_data3: sdio-data3 {
+				sfax8,pins = <0 14 0 &pcfg_pull_pin_default>;
+			};
+			sdi_clk: sdio-clk {
+				sfax8,pins = <0 15 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_cmd: sdio-cmd {
+				sfax8,pins = <0 16 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_cd: sdio-cd {
+				sfax8,pins = <0 17 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		uart0 {
+			uart0_tx: uart0-tx {
+				sfax8,pins = <0 18 0 &pcfg_pull_pin_default>;
+			};
+
+			uart0_rx: uart0-rx {
+				sfax8,pins = <0 19 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		uart1 {
+			uart1_tx: uart1-tx {
+				sfax8,pins = <0 26 2 &pcfg_pull_pin_default>;
+			};
+
+			uart1_rx: uart1-rx {
+				sfax8,pins = <0 27 2 &pcfg_pull_pin_default>;
+			};
+
+			uart1_cts: uart1-cts {
+				sfax8,pins = <0 30 2 &pcfg_pull_pin_default>;
+			};
+
+			uart1_rts: uart1-rts {
+				sfax8,pins = <0 29 2 &pcfg_pull_pin_default>;
+			};
+
+		};
+
+		uart2 {
+			uart2_tx: uart2-tx {
+				sfax8,pins = <0 22 2 &pcfg_pull_pin_default>;
+			};
+
+			uart2_rx: uart2-rx {
+				sfax8,pins = <0 23 2 &pcfg_pull_pin_default>;
+			};
+
+			uart2_cts: uart2-cts {
+				sfax8,pins = <0 24 2 &pcfg_pull_pin_default>;
+			};
+
+			uart2_rts: uart2-rts {
+				sfax8,pins = <0 25 2 &pcfg_pull_pin_default>;
+			};
+		};
+
+		uart3 {
+			uart3_tx: uart3-tx {
+				sfax8,pins = <0 32 2 &pcfg_pull_pin_default>;
+			};
+
+			uart3_rx: uart3-rx {
+				sfax8,pins = <0 31 2 &pcfg_pull_pin_default>;
+			};
+
+			uart3_cts: uart3-cts {
+				sfax8,pins = <0 35 2 &pcfg_pull_pin_default>;
+			};
+
+			uart3_rts: uart3-rts {
+				sfax8,pins = <0 34 2 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2c0 {
+			i2c0_clk: i2c0-clk {
+				sfax8,pins = <0 20 0 &pcfg_pull_pin_default>;
+			};
+
+			i2c0_dat: i2c0-dat {
+				sfax8,pins = <0 21 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2c1 {
+			i2c1_clk: i2c1-clk {
+				sfax8,pins = <0 22 0 &pcfg_pull_pin_default>;
+			};
+
+			i2c1_dat: i2c1-dat {
+				sfax8,pins = <0 23 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2c2 {
+			i2c2_clk: i2c2-clk {
+				sfax8,pins = <0 24 0 &pcfg_pull_pin_default>;
+			};
+
+			i2c2_dat: i2c2-dat {
+				sfax8,pins = <0 25 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pcm0 {
+			pcm0_cdclk: pcm0-cdclk {
+				sfax8,pins = <0 26 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_sclk: pcm0-sclk {
+				sfax8,pins = <0 27 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_fsync: pcm0-fsync {
+				sfax8,pins = <0 28 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_sin: pcm0-sin {
+				sfax8,pins = <0 29 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_sout: pcm0-sout {
+				sfax8,pins = <0 30 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pcm1 {
+			pcm1_cdclk: pcm1-cdclk {
+				sfax8,pins = <0 22 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_sclk: pcm1-sclk {
+				sfax8,pins = <0 23 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_fsync: pcm1-fsync {
+				sfax8,pins = <0 24 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_sin: pcm1-sin {
+				sfax8,pins = <0 25 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_sout: pcm1-sout {
+				sfax8,pins = <0 36 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2s {
+			i2s0_cdclk: i2s0-cdclk {
+				sfax8,pins = <0 26 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_sclk: i2s0-sclk {
+				sfax8,pins = <0 27 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_lrck: i2s0-lrck {
+				sfax8,pins = <0 28 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_sdi0: i2s0-sdi0 {
+				sfax8,pins = <0 29 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_sdo0: i2s0-sdo0 {
+				sfax8,pins = <0 30 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_cdclk: i2s1-cdclk {
+				sfax8,pins = <0 31 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_sclk: i2s1-sclk {
+				sfax8,pins = <0 32 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_lrck: i2s1-lrck {
+				sfax8,pins = <0 33 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_sdi0: i2s1-sdi0 {
+				sfax8,pins = <0 34 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_sdo0: i2s1-sdo0 {
+				sfax8,pins = <0 35 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		spdif {
+			spdif_0: spdif-0 {
+				sfax8,pins = <0 35 0 &pcfg_pull_pin_default>;
+			};
+
+			spdif_1: spdif-1 {
+				sfax8,pins = <0 62 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pwm0 {
+			pwm_0: pwm-0 {
+				sfax8,pins = <0 36 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pwm1 {
+			pwm_1: pwm-1 {
+				sfax8,pins = <0 37 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+	};
+};
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw0_p10.dts
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw0_p10.dts	2017-11-15 11:09:39.304423000 +0800
@@ -0,0 +1,289 @@
+/dts-v1/;
+
+#include "sf16a18_mpw0.dtsi"
+
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "siflower,sf16a18-soc";
+};
+
+&ethernet {
+	status = "okay";
+};
+
+&switch{
+	status = "okay";
+};
+
+&gmac {
+	status = "okay";
+};
+
+&gdma {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pmu@30 {
+		compatible = "siflower, sfax8-pmu";
+		reg = <0x30>;
+
+		/*
+		IR device
+		miscdev {
+			interrupts = <249 0>;
+		};
+		*/
+        reset-button {
+			rb-gpio = <&gpio 60 0>;
+			led-gpio = <&gpio 57 0>;
+			};
+
+		power-management {
+			dcdc0-supply = <&core>;
+			dcdc0-maxv = <1100000>;
+			/*dcdc0-default-uv = <775000>;*/
+
+			dcdc1-supply = <&dcdc1>;
+			dcdc1-maxv = <2100000>;
+
+			dcdc2-supply = <&ddr>;
+			dcdc2-maxv = <1800000>;
+
+			dcdc3-supply = <&vddio>;
+			dcdc3-maxv = <3300000>;
+
+			ldo0-supply = <&rflb_pa>;
+			ldo0-maxv = <2600000>;
+
+			ldo1-supply = <&rfhb_pa>;
+			ldo1-maxv = <2600000>;
+
+			ldo2-supply = <&vdd18>;
+			ldo2-maxv = <1800000>;
+
+			ldo4-supply = <&rfvdda>;
+			ldo4-maxv = <1500000>;
+
+			ldo5-supply = <&rfpa_en>;
+			ldo5-maxv = <700000>;
+
+			ldo6-supply = <&ldo6_32khz>;
+			ldo6-maxv = <700000>;
+
+		};
+
+		regulators {
+			core: dcdc0 {
+				regulator-name = "VDD_CORE_0.9V";
+				/*set default to 0.8v to save power*/
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			dcdc1: dcdc1 {
+				regulator-name = "DCDC1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2175000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ddr: dcdc2 {
+				regulator-name = "DDR_1.5-1.8V";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vddio: dcdc3 {
+				regulator-name = "VDDIO_3.3V";
+				regulator-min-microvolt = <2200000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <2000000>;
+				regulator-max-microamp = <2000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rflb_pa: ldo0 {
+				regulator-name = "RFLB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfhb_pa: ldo1 {
+				regulator-name = "RFHB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vdd18: ldo2 {
+				regulator-name = "VDD18_1.8V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfvdda: ldo4 {
+				regulator-name = "RF_VDDA_1.5V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfpa_en: ldo5 {
+				regulator-name = "RFPA_EN";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo6_32khz: ldo6 {
+				regulator-name = "LDO6";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			/*
+			svcc {
+				regulator-name = "SVCC";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <50000>;
+				regulator-max-microamp = <50000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+			*/
+		};
+	};
+};
+
+/*
+&cpu0 {
+	cpu0-supply = <&core>;
+	dcdc0-maxv = <950000>;
+};
+*/
+
+&spi0 {
+	status = "okay";
+	use-dma;
+	dmas = <&gdma 10
+	&gdma 11>;
+	dma-names = "tx", "rx";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	w25q128@0 {
+		compatible = "w25q128";
+		reg = <0>;	/* chip select */
+		spi-max-frequency = <33000000>;
+
+		bank-width = <2>;
+		device-width = <2>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "spl-loader";
+			reg = <0x0 0x20000>; /* 128k */
+			read-only;
+		};
+
+		partition@20000 {
+			label = "u-boot";
+			reg = <0x20000 0x60000>; /* 384k */
+		};
+
+		partition@80000 {
+			label = "u-boot-env";
+			reg = <0x80000 0x10000>; /* 64k */
+		};
+
+		factory:partition@90000 {
+			label = "factory";
+			reg = <0x90000 0x10000>; /* 64k */
+		};
+
+		partition@a0000 {
+			label = "firmware";
+			reg = <0xa0000 0xf60000>; /* 640k-16M */
+		};
+	};
+
+	spidev: spi@8200000 {
+		compatible = "rohm,dh2228fv";
+		reg = <1>;
+		clock = <50000000>;
+		spi-cpha;
+		spi-cpol;
+		spi-max-frequency=<12000000>;
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&timer0 {
+	status = "okay";
+};
+
+&watchdog {
+	status = "okay";
+};
+
+&wifi_rf {
+	status = "okay";
+};
+
+&wifi_lb {
+	status = "okay";
+};
+
+&wifi_hb {
+	status = "okay";
+};
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw0_p20.dts
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw0_p20.dts	2017-11-15 11:09:39.320422000 +0800
@@ -0,0 +1,387 @@
+/dts-v1/;
+
+#include "sf16a18_mpw0.dtsi"
+
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "siflower,sf16a18-soc";
+
+	spdif_codec: spdif-codec@0 {
+		compatible = "linux,spdif-dit";
+	};
+
+	w18_wifi_rf: w18_wifi-rf@7A00000{
+		compatible = "siflower,pistachio-uccp";
+		phy = <&phy1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		phy1: w18_wifi-phy@1 {
+			reg = <1>;
+			max-speed = <100>;
+		};
+	};
+
+	spdif-audio@0 {
+		compatible = "siflower,siflower-audio";
+		model = "Siflower Spdif Audio";
+		audio-controller = <&spdif>;
+		audio-codec = <&spdif_codec>;
+		audio-out;
+	};
+
+};
+
+&usb_phy{
+	status = "okay";
+};
+
+&ethernet {
+	status = "okay";
+};
+
+&switch{
+	status = "okay";
+};
+
+&gmac {
+	status = "okay";
+};
+
+&gdu {
+	status = "okay";
+};
+
+&rng {
+	status = "okay";
+};
+
+&gdma {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&emmc {
+	status = "disabled";
+};
+
+&sdio {
+	status = "okay";
+};
+
+&i2s0 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pmu@30 {
+		compatible = "siflower, sfax8-pmu";
+		reg = <0x30>;
+
+		/*
+		IR device
+		miscdev {
+			interrupts = <249 0>;
+		};
+		*/
+
+        reset-button {
+			rb-gpio = <&gpio 60 0>;
+			led-gpio = <&gpio 57 0>;
+			};
+
+		power-management {
+			dcdc0-supply = <&core>;
+			dcdc0-maxv = <1100000>;
+			/*dcdc0-default-uv = <775000>;*/
+
+			dcdc1-supply = <&dcdc1>;
+			dcdc1-maxv = <2100000>;
+
+			dcdc2-supply = <&ddr>;
+			dcdc2-maxv = <1800000>;
+
+			dcdc3-supply = <&vddio>;
+			dcdc3-maxv = <3300000>;
+
+			ldo0-supply = <&rflb_pa>;
+			ldo0-maxv = <2600000>;
+
+			ldo1-supply = <&rfhb_pa>;
+			ldo1-maxv = <2600000>;
+
+			ldo2-supply = <&vdd18>;
+			ldo2-maxv = <1800000>;
+
+			ldo4-supply = <&rfvdda>;
+			ldo4-maxv = <1500000>;
+
+			ldo5-supply = <&rfpa_en>;
+			ldo5-maxv = <700000>;
+
+			ldo6-supply = <&ldo6_32khz>;
+			ldo6-maxv = <700000>;
+
+		};
+
+		regulators {
+			core: dcdc0 {
+				regulator-name = "VDD_CORE_0.9V";
+				/*set default to 0.8v to save power*/
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			dcdc1: dcdc1 {
+				regulator-name = "DCDC1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2175000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ddr: dcdc2 {
+				regulator-name = "DDR_1.5-1.8V";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vddio: dcdc3 {
+				regulator-name = "VDDIO_3.3V";
+				regulator-min-microvolt = <2200000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <2000000>;
+				regulator-max-microamp = <2000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rflb_pa: ldo0 {
+				regulator-name = "RFLB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfhb_pa: ldo1 {
+				regulator-name = "RFHB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vdd18: ldo2 {
+				regulator-name = "VDD18_1.8V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfvdda: ldo4 {
+				regulator-name = "RF_VDDA_1.5V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfpa_en: ldo5 {
+				regulator-name = "RFPA_EN";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo6_32khz: ldo6 {
+				regulator-name = "LDO6";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			/*
+			svcc {
+				regulator-name = "SVCC";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <50000>;
+				regulator-max-microamp = <50000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+			*/
+		};
+	};
+};
+
+/*
+&cpu0 {
+	cpu0-supply = <&core>;
+	dcdc0-maxv = <950000>;
+};
+*/
+
+&i2c1 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+/*
+	codec: es8388s@11{
+		compatible = "ambarella,es8388s";
+		reg = <0x11>;
+	};
+*/
+	codec: es8316@11{
+		compatible = "ESSX8316";
+		reg = <0x11>;
+	};
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&spi0 {
+	status = "okay";
+	use-dma;
+	dmas = <&gdma 10
+	&gdma 11>;
+	dma-names = "tx", "rx";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	w25q128@0 {
+		compatible = "w25q128";
+		reg = <0>;	/* chip select */
+		spi-max-frequency = <33000000>;
+
+		bank-width = <2>;
+		device-width = <2>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "spl-loader";
+			reg = <0x0 0x20000>; /* 128k */
+			read-only;
+		};
+
+		partition@20000 {
+			label = "u-boot";
+			reg = <0x20000 0x60000>; /* 384k */
+		};
+
+		partition@80000 {
+			label = "u-boot-env";
+			reg = <0x80000 0x10000>; /* 64k */
+		};
+
+		factory:partition@90000 {
+			label = "factory";
+			reg = <0x90000 0x10000>; /* 64k */
+		};
+
+		partition@a0000 {
+			label = "firmware";
+			reg = <0xa0000 0xf60000>; /* 640k-16M */
+		};
+	};
+
+	spidev: spi@8200000 {
+		compatible = "rohm,dh2228fv";
+		reg = <1>;
+		clock = <50000000>;
+		spi-cpha;
+		spi-cpol;
+		spi-max-frequency=<12000000>;
+	};
+};
+
+&spi1 {
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&uart1 {
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&uart3 {
+	status = "okay";
+};
+
+&pcm0 {
+	status = "okay";
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&timer0 {
+	status = "okay";
+};
+
+&watchdog {
+	status = "okay";
+};
+
+&spdif
+{
+	status = "okay";
+};
+
+&wifi_rf {
+	status = "okay";
+};
+
+&wifi_lb {
+	status = "okay";
+};
+
+&wifi_hb {
+	status = "okay";
+};
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1.dtsi
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1.dtsi	2017-11-21 09:22:50.029560000 +0800
@@ -0,0 +1,1185 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+/ {
+	compatible = "siflower,sf16a18";
+
+	aliases {
+		gdu = &gdu;
+		gdma = &gdma;
+		usb = &usb;
+		emmc = &emmc;
+		sdio = &sdio;
+		i2s = &i2s0;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		uart0=&uart0;
+		uart1=&uart1;
+		uart2=&uart2;
+		uart3=&uart3;
+		pcm0 = &pcm0;
+		/*pcm1 = &pcm1;*/
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		timer0 = &timer0;
+		watchdog = &watchdog;
+		spdif = &spdif;
+	};
+
+	grfcom: syscon@19e00000 {
+			compatible = "siflower,sfax8-syscon";
+			reg = <0x19e00000 0x30000>;
+		};
+
+	grfgpio: syscon@19e3f000 {
+			compatible = "siflower,sfax8-syscon";
+			reg = <0x19e3f000 0x1000>;
+		};
+
+	clocks{
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		osc: oscillator {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <12000000>;
+			clock-output-names = "osc";
+		};
+
+		cpupll: pll@19e01000 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			/* 1792MHZ */
+			clock-mult = <448>;
+			clock-div = <3>;
+			clocks = <&osc>;
+			clock-names = "cpu_pll";
+			clock-output-names = "cpupll";
+		};
+
+		ddrpll: pll@19e01040 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <111>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "ddr_pll";
+			clock-output-names = "ddrpll";
+		};
+
+		cmnpll: pll@19e01080 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <99>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "cmn_pll";
+			clock-output-names = "cmnpll";
+		};
+
+		spcpll: pll@19e010c0 {
+			compatible = "fixed-factor-clock";
+			#clock-cells = <1>;
+			clock-mult = <125>;
+			clock-div = <1>;
+			clocks = <&osc>;
+			clock-names = "spc_pll";
+			clock-output-names = "spcpll";
+		};
+
+		bus1xnclk: cfg@19e01400 {
+			compatible = "siflower,sf16a18-bus1-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "bus1_clk";
+			reg = <0x19e01400 0x20>;
+			clock-output-names = "bus1xnclk";
+		};
+
+		bus2xnclk: cfg@19e01420 {
+			compatible = "siflower,sf16a18-bus2-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "bus2_clk";
+			reg = <0x19e01420 0x20>;
+			clock-output-names = "bus2xnclk";
+		};
+
+		bus3xnclk: cfg@19e01440 {
+			compatible = "siflower,sf16a18-bus3-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "bus3_clk";
+			reg = <0x19e01440 0x20>;
+			clock-output-names = "bus3xnclk";
+		};
+
+		cpuclk: cfg@19e01500 {
+			compatible = "siflower,sf16a18-cpu-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "cpu_clk";
+			reg = <0x19e01500 0x20>;
+			clock-output-names = "cpuclk";
+		};
+
+		pbusclk: cfg@19e01520 {
+			compatible = "siflower,sf16a18-pbus-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "pbus_clk";
+			reg = <0x19e01520 0x20>;
+			clock-output-names = "pbusclk";
+		};
+
+		memphyclk: cfg@19e01540 {
+			compatible = "siflower,sf16a18-memphy-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "mem_phy_clk";
+			reg = <0x19e01540 0x20>;
+			clock-output-names = "memphyclk";
+		};
+
+		audioclk: cfg@19e01560 {
+			compatible = "siflower,sf16a18-audio-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "audio_clk";
+			reg = <0x19e01560 0x20>;
+			clock-output-names = "audioclk";
+		};
+
+		uartclk: cfg@19e01580 {
+			compatible = "siflower,sf16a18-uart-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "uart_clk";
+			reg = <0x19e01580 0x20>;
+			clock-output-names = "uartclk";
+		};
+
+		spdifclk: cfg@19e015a0 {
+			compatible = "siflower,sf16a18-spdif-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "spdif_clk";
+			reg = <0x19e015a0 0x20>;
+			clock-output-names = "spdifclk";
+		};
+
+		sdhcclk: cfg@19e015c0 {
+			compatible = "siflower,sf16a18-sdhc-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "sdio_clk";
+			reg = <0x19e015c0 0x20>;
+			clock-output-names = "sdhcclk";
+		};
+
+		inandclk: cfg@19e015e0 {
+			compatible = "siflower,sf16a18-emmc-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "emmc_clk";
+			reg = <0x19e015e0 0x20>;
+			clock-output-names = "inandclk";
+		};
+
+		ethrefclk: cfg@19e01600 {
+			compatible = "siflower,sf16a18-eth-ref-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "eth_ref_clk";
+			reg = <0x19e01600 0x20>;
+			clock-output-names = "ethrefclk";
+		};
+
+		ethbyprefclk: cfg@19e01620 {
+			compatible = "siflower,sf16a18-eth-byp-ref-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "eth_byp_ref_clk";
+			reg = <0x19e01620 0x20>;
+			clock-output-names = "ethbyprefclk";
+		};
+
+		ethtsuclk: cfg@19e01640 {
+			compatible = "siflower,sf16a18-eth-tsu-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "eth_tsu_clk";
+			reg = <0x19e01640 0x20>;
+			clock-output-names = "ethtsuclk";
+		};
+
+		m_SFDSP0clk: cfg@19e01680 {
+			compatible = "siflower,sf16a18-m_SFDSP-0-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "m_SFDSP_0_clk";
+			reg = <0x19e01680 0x20>;
+			clock-output-names = "m_SFDSP0clk";
+		};
+
+		m_SFDSP1clk: cfg@19e016a0 {
+			compatible = "siflower,sf16a18-m_SFDSP-1-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "m_SFDSP_1_clk";
+			reg = <0x19e016a0 0x20>;
+			clock-output-names = "m_SFDSP1clk";
+		};
+
+		wlan24clk: cfg@19e016c0 {
+			compatible = "siflower,sf16a18-wlan24-mac-wt-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "wlan24_mac_wt_clk";
+			reg = <0x19e016c0 0x20>;
+			clock-output-names = "wlan24clk";
+		};
+
+		wlan5clk: cfg@19e016e0 {
+			compatible = "siflower,sf16a18-wlan5-mac-wt-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "wlan5_mac_wt_clk";
+			reg = <0x19e016e0 0x20>;
+			clock-output-names = "wlan5clk";
+		};
+
+		usbphyclk: cfg@19e01700 {
+			compatible = "siflower,sf16a18-usbphy-ref-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "usb_phy_clk";
+			reg = <0x19e01700 0x20>;
+			clock-output-names = "usbphyclk";
+		};
+
+		tclk: cfg@19e01720 {
+			compatible = "siflower,sf16a18-tclk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "tclk";
+			reg = <0x19e01720 0x20>;
+			clock-output-names = "tclk";
+		};
+
+		npupeclk: cfg@19e01740 {
+			compatible = "siflower,sf16a18-npupe-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "npu_pe_clk";
+			reg = <0x19e01740 0x20>;
+			clock-output-names = "npupeclk";
+		};
+
+		gdu0clk: cfg@19e01760 {
+			compatible = "siflower,sf16a18-gdu0-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "gdu0_clk";
+			reg = <0x19e01760 0x20>;
+			clock-output-names = "gdu0clk";
+		};
+
+		gdu0eitfclk: cfg@19e01780 {
+			compatible = "siflower,sf16a18-gdu0-eitf-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "gdu0_eitf_clk";
+			reg = <0x19e01780 0x20>;
+			clock-output-names = "gdu0eitfclk";
+		};
+
+		tvif0clk: cfg@19e017a0 {
+			compatible = "siflower,sf16a18-tvif0-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "tvif0_clk";
+			reg = <0x19e017a0 0x20>;
+			clock-output-names = "tvif0clk";
+		};
+
+		cryptoclk: cfg@19e017c0 {
+			compatible = "siflower,sf16a18-crypto-clk";
+			#clock-cells = <1>;
+			clocks = <&cpupll 0>, <&ddrpll 0>, <&cmnpll 0>, <&spcpll 0>;
+			clock-names = "crypto_clk";
+			reg = <0x19e017c0 0x20>;
+			clock-output-names = "cryptoclk";
+		};
+
+	};
+
+	cpus{
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,interAptiv";
+			reg = <0>;
+			clocks = <&cpuclk 0>;
+			clock-names = "cpu";
+			clock-latency = <50000>;
+			operating-points = <
+				/* kHz    uV(dummy) */
+				896000 800000
+				750000 800000
+				666000 800000
+				594000 800000
+				500000 800000
+				444000 800000
+				396000 800000
+			>;
+		};
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "mips,interAptiv";
+			reg = <1>;
+			clocks = <&cpuclk 0>;
+			clock-names = "cpu";
+			clock-latency = <50000>;
+			operating-points = <
+				/* kHz    uV(dummy) */
+				896000 800000
+				750000 800000
+				666000 800000
+				594000 800000
+				500000 800000
+				444000 800000
+				396000 800000
+			>;
+		};
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "mips,interAptiv";
+			reg = <2>;
+			clocks = <&cpuclk 0>;
+			clock-names = "cpu";
+			clock-latency = <50000>;
+			operating-points = <
+				/* kHz    uV(dummy) */
+				896000 800000
+				750000 800000
+				666000 800000
+				594000 800000
+				500000 800000
+				444000 800000
+				396000 800000
+			>;
+		};
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "mips,interAptiv";
+			reg = <3>;
+			clocks = <&cpuclk 0>;
+			clock-names = "cpu";
+			clock-latency = <50000>;
+			operating-points = <
+				/* kHz    uV(dummy) */
+				896000 800000
+				750000 800000
+				666000 800000
+				594000 800000
+				500000 800000
+				444000 800000
+				396000 800000
+			>;
+		};
+	};
+
+	cpuintc: cpuintc@0 {
+		compatible = "mti,cpu-interrupt-controller";
+		#address-cells = <0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	gic: gic@1bdc0000 {
+		#interrupt-cells = <2>;
+		interrupt-controller;
+		compatible = "siflower,sfax8-gic";
+		reg = <0x1bdc0000 0x20000>;/*gic*/
+		clocks = <&cpuclk 0>;
+	};
+
+	usb_phy: usb-phy {
+		compatible = "siflower,sfax8-usb-phy";
+		clocks = <&usbphyclk 0>;
+		usbgrf = <&grfcom>;
+		#phy-cells = <0>;
+		status = "disabled";
+	};
+
+	palmbus@10000000 {
+		compatible = "palmbus";
+		reg = <0x10000000 0x10000000>;
+		ranges = <0x0 0x10000000 0xFFFFFFF>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&gic>;
+
+		ethernet: ethernet@0000000 {
+			compatible = "siflower,sfax8-eth";
+			reg = <0x0000000 0x6CFFFF>;
+			clocks = <&ethrefclk 0>, <&ethbyprefclk 0>, <&ethtsuclk 0>, <&npupeclk 0>;
+			mtd-mac-address = <&factory 0>;
+			interrupts = <16 0>;
+			status = "disabled";
+		};
+
+		switch: switch@0000000 {
+			compatible = "siflower,sfax8-switch";
+			reg = <0x0000000 0x6CFFFF>;
+			interrupts = <25 0>;
+			max-speed = <100>;
+			sfax8,port-map = "llllw";
+			status = "disabled";
+		};
+
+		gmac: gmac@800000 {
+			compatible = "siflower,sfax8-gmac";
+			reg = <0x800000 0x200000>;
+			clocks = <&ethbyprefclk 0>, <&ethtsuclk 0>;
+			interrupts = <32 0>;
+
+			mac-address = [ 00 11 22 33 44 55 ];
+			phy = <&phy0>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+			test-gpios = <&gpio 51 0>,<&gpio 52 0>;
+
+			phy0: ethernet-phy@0 {
+				reg = <1>;
+				max-speed = <1000>;
+			};
+		};
+
+		gdu: gdu@800000 {
+			compatible = "siflower,sfax8-fb";
+			reg = <0x800000 0x10000>;
+			interrupts = <39 0>;
+			status = "disabled";
+			clocks = <&gdu0eitfclk 0>, <&gdu0clk 0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&gdu_0>;
+		};
+
+		rng: rng@c00900 {
+			compatible = "siflower,sfax8-rng";
+			reg = <0xc00900 0x28>;
+			rnggrf = <&grfcom>;
+			status = "disabled";
+		};
+
+		gdma: dma@1800000 {
+			compatible = "siflower,sfax8-gdma";
+			reg = <0x1800000 0x1000>;
+			interrupts = <80 0>;
+			#dma-cells = <1>;
+			#dma-channels = <7>;
+			#dma-requests = <32>;
+			status = "disabled";
+		};
+
+		usb: usb@7000000 {
+			compatible = "siflower,sfax8-usb";
+			reg = <0x7000000 0x40000>;
+			interrupts = <128 0>;
+			clocks = <&usbphyclk 0>;
+			dr_mode = "otg";
+			phys = <&usb_phy>;
+			phy-names = "usb2-phy";
+			usbgrf = <&grfcom>;
+			status = "disabled";
+
+			g-use-dma;
+			g-tx-fifo-size = <0x100 0x100 0x100 0x100 0x100
+				0x300 0x300 0x300>;
+		};
+
+		emmc: emmc@7800000 {
+			compatible = "siflower,sfax8-mmc";
+			reg = <0x7800000 0x200000>;
+			clocks = <&inandclk 0>;
+			clock-frequency = <150000000>;
+			clock-freq-min-max = <400000 50000000>;
+			fifo-depth = <0x200>;
+			bus-width = <8>;
+			interrupts = <144 0>;
+			supports-highspeed;
+			pinctrl-names = "default";
+			pinctrl-0 = <&emmc_data0 &emmc_data1 &emmc_data2 &emmc_data3 \
+						 &emmc_data4 &emmc_data5 &emmc_data6 &emmc_data7 \
+						 &emm_clk &emmc_cmd &emmc_resetn>;
+			status = "disabled";
+		};
+
+		sdio: sdio@7C00000 {
+			compatible = "siflower,sfax8-mmc";
+			reg = <0x7C00000 0x200000>;
+			clocks = <&sdhcclk 0>;
+			clock-frequency = <150000000>;
+			clock-freq-min-max = <400000 25000000>;
+			/*clock-names = "biu", "ciu";*/
+			bus-width = <4>;
+			interrupts = <160 0>;
+			supports-highspeed;
+			pinctrl-names = "default";
+			pinctrl-0 = <&sdio_data0 &sdio_data1 &sdio_data2 &sdio_data3 \
+						 &sdi_clk &sdio_cmd &sdio_cd>;
+			status = "disabled";
+		};
+
+		i2s0: i2s@8000000 {
+			compatible = "siflower,sfax8-i2s";
+			interrupts = <208 0>;
+			reg = <0x8000000 0x1000>;
+			clocks = <&audioclk 0>;
+			dmas = <&gdma 0
+			&gdma 1>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s0_cdclk &i2s0_sclk &i2s0_lrck &i2s0_sdi0 &i2s0_sdo0>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@8100000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8100000 0x1000>;
+			clocks = <&pbusclk 0>;
+			clock-frequency = <400000>;
+			interrupts = <217 0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names="default";
+			pinctrl-0 = <&i2c0_clk &i2c0_dat>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@8101000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8101000 0x1000>;
+			clocks = <&pbusclk 0>;
+			clock-frequency = <400000>;
+			interrupts = <218 0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names="default";
+			pinctrl-0 = <&i2c1_clk &i2c1_dat>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@8102000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8102000 0x1000>;
+			clocks = <&pbusclk 0>;
+			clock-frequency = <400000>;
+			interrupts = <219 0>;
+			status = "disabled";
+		};
+
+		spi0: spi@8200000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8200000 0x1000>;
+			num-cs = <2>;
+			cs-gpios = <&gpio 5 0>, <&gpio 6 0>;
+			spi-max-frequency = <33000000>;
+
+			clocks = <&pbusclk 0>;
+			sfgrf = <&grfcom>;
+
+			interrupt-parent = <&gic>;
+			interrupts = <223 0>;
+
+			use-dma;
+			dmas = <&gdma 10
+				&gdma 11>;
+			dma-names = "tx", "rx";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi1: spi@8201000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8201000 0x1000>;
+			clocks = <&pbusclk 0>;
+			status = "disabled";
+
+			num-cs = <1>;
+			/*cs-gpios = <&gpio 34 0>;*/
+			spi-max-frequency = <33000000>;
+			sfgrf = <&grfcom>;
+
+			interrupt-parent = <&gic>;
+			interrupts = <224 0>;
+
+		/*	use-dma;
+			dmas = <&gdma 12
+				&gdma 13>;
+			dma-names = "tx", "rx";
+		*/
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		uart0: serial@8300000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8300000 0x1000>;
+			interrupts = <226 0>;
+			clocks = <&uartclk 0>;
+			status = "disabled";
+		};
+
+		uart1: serial@8301000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8301000 0x1000>;
+			interrupts = <227 0>;
+			clocks = <&uartclk 0>;
+			dmas = <&gdma 14
+			&gdma 15>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		uart2: serial@8302000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8302000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <228 0>;
+			status = "disabled";
+		};
+
+		uart3: serial@8303000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8303000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <229 0>;
+			status = "disabled";
+		};
+
+		pcm0: pcm@8400000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8400000 0x1000>;
+			clocks =<&audioclk 0>;
+			id = <0>;
+			dmas = <&gdma 20
+				&gdma 21>;
+			dma-names = "tx","rx";
+			interrupts = <230 0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pcm0_cdclk &pcm0_sclk &pcm0_fsync &pcm0_sin &pcm0_sout>;
+			status = "disabled";
+		};
+
+		/*
+		pcm1: pcm@8401000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8401000 0x1000>;
+			clocks =<&audioclk 0>;
+			id = <1>;
+			dmas = <&gdma 22
+				&gdma 23>;
+			dma-names = "tx","rx";
+			interrupts = <231 0>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&pcm1_cdclk &pcm1_sclk &pcm1_fsync &pcm1_sin &pcm1_sout>;
+		};
+		*/
+
+		pwm0: pwm@8500000 {
+			compatible = "siflower,sfax8-pwm";
+			reg = <0x8500000 0x1000>;
+			interrupts = <232 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm_0>; //36
+			status = "disabled";
+		};
+
+		pwm1: pwm@8501000 {
+			compatible = "siflower,sfax8-pwm-output";
+			reg = <0x8501000 0x1000>;
+			interrupts = <233 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm_1>; //37
+			status = "disabled";
+		};
+
+		timer0: timer@8600000 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8600000 0x14>, <0x8600014 0x14>, <0x8601000 0x14>, <0x8601014 0x14>;
+			interrupts = <234 0>, <235 0>, <236 0>, <237 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+			status = "disabled";
+		};
+
+		watchdog: watchdog@8700000 {
+			compatible = "siflower,sfax8-wdt";
+			reg = <0x8700000 0x1000>;
+			interrupt-parent = <&gic>;
+			interrupts = <238 0>;
+			clocks = <&pbusclk 0>;
+			status = "disabled";
+		};
+
+		spdif: spdif@8800000 {
+			compatible = "siflower,sfax8-spdif";
+			reg = <0x8800000 0x1000>;
+			interrupts = <239 0>;
+			clocks = <&spdifclk 0>;
+			dmas = <&gdma 8
+				&gdma 9>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		wifi_rf: wifi-rf@1C00000{
+			compatible = "siflower,sf16a18-wifi-rf";
+			reg = <0x1C00000 0x600000>;
+			interrupts = <176 0>;
+			status = "disabled";
+		};
+
+		wifi_lb: wifi-lb@1000000{
+			compatible = "siflower,sf16a18-wifi-lb";
+			reg = <0x1000000 0x400000>;
+			interrupts = <48 0>, <49 0>;
+			mtd-mac-address = <&factory 0>;
+			clocks = <&wlan24clk 0>;
+			status = "disabled";
+		};
+
+		wifi_hb: wifi-hb@1400000{
+			compatible = "siflower,sf16a18-wifi-hb";
+			reg = <0x1400000 0x400000>;
+			interrupts = <64 0>, <65 0>;
+			mtd-mac-address = <&factory 0>;
+			clocks = <&wlan5clk 0>;
+			status = "disabled";
+		};
+
+	}; /* palmbus */
+
+	pinctrl: pinctrl {
+		compatible = "siflower,sfax8-pinctrl";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&gic>;
+		ranges;
+		pad-base = <&grfgpio>;
+
+		gpio: gpio@19d00000 {
+			compatible = "siflower,sfax8-gpio";
+			reg=<0x19d00000 0x100000>;
+			interrupts = <246 0>, <247 0>, <248 0>, <249 0>;
+			clocks = <&pbusclk 0>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		pcfg_pull_up: pcfg-pull-up {
+			bias-pull-up;
+		};
+
+		pcfg_pull_down: pcfg-pull-down {
+			bias-pull-down;
+		};
+
+		pcfg_pull_none: pcfg-pull-none {
+			bias-disable;
+		};
+
+		pcfg_pull_pin_default: pcfg-pull-pin-default {
+			bias-pull-pin-default;
+		};
+
+
+		spi0 {
+			spi0_mosi: spi0-mosi {
+				sfax8,pins = <0 0 1 &pcfg_pull_pin_default>;
+			};
+			spi0_miso: spi0-miso {
+				sfax8,pins = <0 1 1 &pcfg_pull_pin_default>;
+			};
+			spi0_hold: spi0-hold {
+				sfax8,pins = <0 2 1 &pcfg_pull_pin_default>;
+			};
+			spi0_wp: spi0-wp {
+				sfax8,pins = <0 3 1 &pcfg_pull_pin_default>;
+			};
+			spi0_clk: spi0-clk {
+				sfax8,pins = <0 4 1 &pcfg_pull_pin_default>;
+			};
+			spi0_cs0: spi0-cs0 {
+				sfax8,pins = <0 5 1 &pcfg_pull_pin_default>;
+			};
+			spi0_cs1: spi0-cs1 {
+				sfax8,pins = <0 6 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+		spi1 {
+			spi1_txd: spi1-txd {
+				sfax8,pins = <0 31 1 &pcfg_pull_pin_default>;
+			};
+			spi1_rxd: spi1-rxd {
+				sfax8,pins = <0 32 1 &pcfg_pull_pin_default>;
+			};
+			spi1_clk: spi1-clk {
+				sfax8,pins = <0 33 1 &pcfg_pull_pin_default>;
+			};
+			spi1_csn: spi1-csn {
+				sfax8,pins = <0 34 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+
+		emmc {
+			emmc_data0: emmc-data0 {
+				sfax8,pins = <0 0 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data1: emmc-data1 {
+				sfax8,pins = <0 1 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data2: emmc-data2 {
+				sfax8,pins = <0 2 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data3: emmc-data3 {
+				sfax8,pins = <0 3 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data4: emmc-data4 {
+				sfax8,pins = <0 4 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data5: emmc-data5 {
+				sfax8,pins = <0 8 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data6: emmc-data6 {
+				sfax8,pins = <0 9 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data7: emmc-data7 {
+				sfax8,pins = <0 10 0 &pcfg_pull_pin_default>;
+			};
+
+			emm_clk: emmc-clk {
+				sfax8,pins = <0 5 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_cmd: emmc-cmd {
+				sfax8,pins = <0 6 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_resetn: emmc-resetn {
+				sfax8,pins = <0 7 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		sdio {
+			sdio_data0: sdio-data0 {
+				sfax8,pins = <0 11 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_data1: sdio-data1 {
+				sfax8,pins = <0 12 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_data2: sdio-data2 {
+				sfax8,pins = <0 13 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_data3: sdio-data3 {
+				sfax8,pins = <0 14 0 &pcfg_pull_pin_default>;
+			};
+			sdi_clk: sdio-clk {
+				sfax8,pins = <0 15 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_cmd: sdio-cmd {
+				sfax8,pins = <0 16 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_cd: sdio-cd {
+				sfax8,pins = <0 17 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		uart0 {
+			uart0_tx: uart0-tx {
+				sfax8,pins = <0 18 0 &pcfg_pull_pin_default>;
+			};
+
+			uart0_rx: uart0-rx {
+				sfax8,pins = <0 19 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		uart1 {
+			uart1_tx: uart1-tx {
+				sfax8,pins = <0 26 2 &pcfg_pull_pin_default>;
+			};
+
+			uart1_rx: uart1-rx {
+				sfax8,pins = <0 27 2 &pcfg_pull_pin_default>;
+			};
+
+			uart1_cts: uart1-cts {
+				sfax8,pins = <0 30 2 &pcfg_pull_pin_default>;
+			};
+
+			uart1_rts: uart1-rts {
+				sfax8,pins = <0 29 2 &pcfg_pull_pin_default>;
+			};
+
+		};
+
+		uart2 {
+			uart2_tx: uart2-tx {
+				sfax8,pins = <0 22 2 &pcfg_pull_pin_default>;
+			};
+
+			uart2_rx: uart2-rx {
+				sfax8,pins = <0 23 2 &pcfg_pull_pin_default>;
+			};
+
+			uart2_cts: uart2-cts {
+				sfax8,pins = <0 24 2 &pcfg_pull_pin_default>;
+			};
+
+			uart2_rts: uart2-rts {
+				sfax8,pins = <0 25 2 &pcfg_pull_pin_default>;
+			};
+		};
+
+		uart3 {
+			uart3_tx: uart3-tx {
+				sfax8,pins = <0 32 2 &pcfg_pull_pin_default>;
+			};
+
+			uart3_rx: uart3-rx {
+				sfax8,pins = <0 31 2 &pcfg_pull_pin_default>;
+			};
+
+			uart3_cts: uart3-cts {
+				sfax8,pins = <0 35 2 &pcfg_pull_pin_default>;
+			};
+
+			uart3_rts: uart3-rts {
+				sfax8,pins = <0 34 2 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2c0 {
+			i2c0_clk: i2c0-clk {
+				sfax8,pins = <0 20 0 &pcfg_pull_pin_default>;
+			};
+
+			i2c0_dat: i2c0-dat {
+				sfax8,pins = <0 21 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2c1 {
+			i2c1_clk: i2c1-clk {
+				sfax8,pins = <0 22 0 &pcfg_pull_pin_default>;
+			};
+
+			i2c1_dat: i2c1-dat {
+				sfax8,pins = <0 23 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2c2 {
+			i2c2_clk: i2c2-clk {
+				sfax8,pins = <0 24 0 &pcfg_pull_pin_default>;
+			};
+
+			i2c2_dat: i2c2-dat {
+				sfax8,pins = <0 25 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pcm0 {
+			pcm0_cdclk: pcm0-cdclk {
+				sfax8,pins = <0 26 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_sclk: pcm0-sclk {
+				sfax8,pins = <0 27 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_fsync: pcm0-fsync {
+				sfax8,pins = <0 28 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_sin: pcm0-sin {
+				sfax8,pins = <0 29 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_sout: pcm0-sout {
+				sfax8,pins = <0 30 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pcm1 {
+			pcm1_cdclk: pcm1-cdclk {
+				sfax8,pins = <0 22 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_sclk: pcm1-sclk {
+				sfax8,pins = <0 23 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_fsync: pcm1-fsync {
+				sfax8,pins = <0 24 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_sin: pcm1-sin {
+				sfax8,pins = <0 25 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_sout: pcm1-sout {
+				sfax8,pins = <0 36 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2s {
+			i2s0_cdclk: i2s0-cdclk {
+				sfax8,pins = <0 26 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_sclk: i2s0-sclk {
+				sfax8,pins = <0 27 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_lrck: i2s0-lrck {
+				sfax8,pins = <0 28 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_sdi0: i2s0-sdi0 {
+				sfax8,pins = <0 29 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_sdo0: i2s0-sdo0 {
+				sfax8,pins = <0 30 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_cdclk: i2s1-cdclk {
+				sfax8,pins = <0 31 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_sclk: i2s1-sclk {
+				sfax8,pins = <0 32 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_lrck: i2s1-lrck {
+				sfax8,pins = <0 33 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_sdi0: i2s1-sdi0 {
+				sfax8,pins = <0 34 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_sdo0: i2s1-sdo0 {
+				sfax8,pins = <0 35 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		spdif {
+			spdif_0: spdif-0 {
+				sfax8,pins = <0 35 0 &pcfg_pull_pin_default>;
+			};
+
+			spdif_1: spdif-1 {
+				sfax8,pins = <0 62 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pwm0 {
+			pwm_0: pwm-0 {
+				sfax8,pins = <0 36 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pwm1 {
+			pwm_1: pwm-1 {
+				sfax8,pins = <0 37 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		gdu {
+			gdu_0: gdu-0 {
+				sfax8,pins = <0 7 3 &pcfg_pull_pin_default>,
+					<0 8 3 &pcfg_pull_pin_default>,
+					<0 9 3 &pcfg_pull_pin_default>,
+					<0 10 3 &pcfg_pull_pin_default>,
+					<0 24 3 &pcfg_pull_pin_default>,
+					<0 25 3 &pcfg_pull_pin_default>,
+					<0 31 3 &pcfg_pull_pin_default>,
+					<0 32 3 &pcfg_pull_pin_default>,
+					<0 33 3 &pcfg_pull_pin_default>,
+					<0 34 3 &pcfg_pull_pin_default>,
+					<0 35 3 &pcfg_pull_pin_default>,
+					<0 38 3 &pcfg_pull_pin_default>,
+					<0 39 3 &pcfg_pull_pin_default>,
+					<0 40 3 &pcfg_pull_pin_default>,
+					<0 41 3 &pcfg_pull_pin_default>,
+					<0 42 3 &pcfg_pull_pin_default>,
+					<0 43 3 &pcfg_pull_pin_default>,
+					<0 44 3 &pcfg_pull_pin_default>,
+					<0 45 3 &pcfg_pull_pin_default>,
+					<0 46 3 &pcfg_pull_pin_default>,
+					<0 47 3 &pcfg_pull_pin_default>,
+					<0 48 3 &pcfg_pull_pin_default>,
+					<0 49 3 &pcfg_pull_pin_default>,
+					<0 50 3 &pcfg_pull_pin_default>,
+					<0 51 3 &pcfg_pull_pin_default>,
+					<0 52 3 &pcfg_pull_pin_default>,
+					<0 53 3 &pcfg_pull_pin_default>,
+					<0 54 3 &pcfg_pull_pin_default>,
+					<0 26 5 &pcfg_pull_up>,
+					<0 37 5 &pcfg_pull_up>;
+			};
+		};
+
+	};
+};
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1_fpga.dts
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1_fpga.dts	2017-11-21 20:13:12.466710527 +0800
@@ -0,0 +1,405 @@
+/dts-v1/;
+
+#include "sf16a18_mpw1_fpga.dtsi"
+
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "siflower,sf16a18-soc";
+
+	spdif_codec: spdif-codec@0 {
+		compatible = "linux,spdif-dit";
+	};
+
+	w18_wifi_rf: w18_wifi-rf@7A00000{
+		compatible = "siflower,pistachio-uccp";
+		phy = <&phy1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		phy1: w18_wifi-phy@1 {
+			reg = <1>;
+			max-speed = <100>;
+		};
+	};
+
+	spdif-audio@0 {
+		compatible = "siflower,siflower-audio";
+		model = "Siflower Spdif Audio";
+		audio-controller = <&spdif>;
+		audio-codec = <&spdif_codec>;
+		audio-out;
+	};
+};
+
+&usb_phy{
+	status = "okay";
+};
+
+&ethernet {
+	status = "okay";
+};
+
+&switch{
+	status = "okay";
+};
+
+&gmac {
+	status = "okay";
+};
+
+&gdu {
+	status = "okay";
+	num-windows = <2>;
+	rgb_order = <0 1 2>;
+
+	display-timings {
+		native-mode = <&timing0>;
+		timing0: gm05004001q {
+			clock-frequency = <34539600>;
+			hactive = <800>;
+			vactive = <480>;
+			hback-porch = <46>;
+			hfront-porch = <210>;
+			vback-porch = <23>;
+			vfront-porch = <22>;
+			hsync-len = <20>;
+			vsync-len = <10>;
+		};
+	};
+};
+
+&rng {
+	status = "okay";
+};
+
+&gdma {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&emmc {
+	status = "disabled";
+};
+
+&sdio {
+	status = "okay";
+};
+
+&i2s0 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pmu@30 {
+		compatible = "siflower, sfax8-pmu";
+		reg = <0x30>;
+
+		/*
+		IR device
+		miscdev {
+			interrupts = <249 0>;
+		};
+		*/
+
+        reset-button {
+			rb-gpio = <&gpio 60 0>;
+			led-gpio = <&gpio 57 0>;
+			};
+
+		power-management {
+			dcdc0-supply = <&core>;
+			dcdc0-maxv = <1100000>;
+
+			dcdc1-supply = <&dcdc1>;
+			dcdc1-maxv = <2100000>;
+
+			dcdc2-supply = <&ddr>;
+			dcdc2-maxv = <1800000>;
+
+			dcdc3-supply = <&vddio>;
+			dcdc3-maxv = <3300000>;
+
+			ldo0-supply = <&rflb_pa>;
+			ldo0-maxv = <2600000>;
+
+			ldo1-supply = <&rfhb_pa>;
+			ldo1-maxv = <2600000>;
+
+			ldo2-supply = <&vdd18>;
+			ldo2-maxv = <1800000>;
+
+			ldo4-supply = <&rfvdda>;
+			ldo4-maxv = <1500000>;
+
+			ldo5-supply = <&rfpa_en>;
+			ldo5-maxv = <700000>;
+
+			ldo6-supply = <&ldo6_32khz>;
+			ldo6-maxv = <700000>;
+
+		};
+
+		regulators {
+			core: dcdc0 {
+				regulator-name = "VDD_CORE_0.9V";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <1100000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			dcdc1: dcdc1 {
+				regulator-name = "DCDC1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2175000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ddr: dcdc2 {
+				regulator-name = "DDR_1.5-1.8V";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vddio: dcdc3 {
+				regulator-name = "VDDIO_3.3V";
+				regulator-min-microvolt = <2200000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <2000000>;
+				regulator-max-microamp = <2000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rflb_pa: ldo0 {
+				regulator-name = "RFLB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfhb_pa: ldo1 {
+				regulator-name = "RFHB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vdd18: ldo2 {
+				regulator-name = "VDD18_1.8V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfvdda: ldo4 {
+				regulator-name = "RF_VDDA_1.5V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfpa_en: ldo5 {
+				regulator-name = "RFPA_EN";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo6_32khz: ldo6 {
+				regulator-name = "LDO6";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			/*
+			svcc {
+				regulator-name = "SVCC";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <50000>;
+				regulator-max-microamp = <50000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+			*/
+		};
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+/*
+	codec: es8388s@11{
+		compatible = "ambarella,es8388s";
+		reg = <0x11>;
+	};
+*/
+	codec: es8316@11{
+		compatible = "ESSX8316";
+		reg = <0x11>;
+	};
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&spi0 {
+	status = "okay";
+	use-dma;
+	dmas = <&gdma 10
+	&gdma 11>;
+	dma-names = "tx", "rx";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	w25q128@0 {
+		compatible = "w25q128";
+		reg = <0>;	/* chip select */
+		spi-max-frequency = <33000000>;
+
+		bank-width = <2>;
+		device-width = <2>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "spl-loader";
+			reg = <0x0 0x20000>; /* 128k */
+			read-only;
+		};
+
+		partition@20000 {
+			label = "u-boot";
+			reg = <0x20000 0x60000>; /* 384k */
+		};
+
+		partition@80000 {
+			label = "u-boot-env";
+			reg = <0x80000 0x10000>; /* 64k */
+		};
+
+		factory:partition@90000 {
+			label = "factory";
+			reg = <0x90000 0x10000>; /* 64k */
+		};
+
+		partition@a0000 {
+			label = "firmware";
+			reg = <0xa0000 0xf60000>; /* 640k-16M */
+		};
+	};
+
+	spidev: spi@8200000 {
+		compatible = "rohm,dh2228fv";
+		reg = <1>;
+		clock = <50000000>;
+		spi-cpha;
+		spi-cpol;
+		spi-max-frequency=<12000000>;
+	};
+};
+
+
+&spi1 {
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&uart1 {
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&uart3 {
+	status = "okay";
+};
+
+&pcm0 {
+	status = "okay";
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&pwm1 {
+	status = "okay";
+};
+
+
+&timer0 {
+	status = "okay";
+};
+
+&timer1 {
+	status = "okay";
+};
+
+
+&watchdog {
+	status = "okay";
+};
+
+&spdif
+{
+	status = "okay";
+};
+
+&wifi_rf {
+	status = "disabled";
+};
+
+&wifi_lb {
+	status = "okay";
+};
+
+&wifi_hb {
+	status = "okay";
+};
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1_fpga.dtsi
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1_fpga.dtsi	2017-11-21 20:13:12.466710527 +0800
@@ -0,0 +1,1036 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+/ {
+	compatible = "siflower,sf16a18";
+
+	aliases {
+		gdu = &gdu;
+		gdma = &gdma;
+		usb = &usb;
+		emmc = &emmc;
+		sdio = &sdio;
+		i2s = &i2s0;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		uart0=&uart0;
+		uart1=&uart1;
+		uart2=&uart2;
+		uart3=&uart3;
+		pcm0 = &pcm0;
+		/*pcm1 = &pcm1;*/
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		timer0 = &timer0;
+		timer1 = &timer1;
+		timer2 = &timer2;
+		timer3 = &timer3;
+		watchdog = &watchdog;
+		spdif = &spdif;
+	};
+
+	cpus{
+		cpu@0 {
+			compatible = "mips,interAptiv";
+		};
+		cpu@1 {
+			compatible = "mips,interAptiv";
+		};
+		cpu@2 {
+			compatible = "mips,interAptiv";
+		};
+		cpu@3 {
+			compatible = "mips,interAptiv";
+		};
+	};
+
+	grfcom: syscon@19e00000 {
+			compatible = "siflower,sfax8-syscon";
+			reg = <0x19e00000 0x30000>;
+		};
+
+	grfgpio: syscon@19e3f000 {
+			compatible = "siflower,sfax8-syscon";
+			reg = <0x19e3f000 0x1000>;
+		};
+
+	clocks{
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		osc: oscillator {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <12000000>;
+			clock-output-names = "osc";
+		};
+
+		bus1xnclk: cfg@19e01400 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "bus1xnclk";
+		};
+
+		bus2xnclk: cfg@19e01420 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "bus2xnclk";
+		};
+
+		bus3xnclk: cfg@19e01440 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <80000000>;
+			clock-output-names = "bus3xnclk";
+		};
+
+		cpuclk: cfg@19e01500 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <40000000>;
+			clock-output-names = "cpuclk";
+		};
+
+		pbusclk: cfg@19e01520 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "pbusclk";
+		};
+
+		memphyclk: cfg@19e01540 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <140000000>;
+			clock-output-names = "memphyclk";
+		};
+
+		audioclk: cfg@19e01560 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <60000000>;
+			clock-output-names = "audioclk";
+		};
+
+		uartclk: cfg@19e01580 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <60000000>;
+			clock-output-names = "uartclk";
+		};
+
+		spdifclk: cfg@19e015a0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <60000000>;
+			clock-output-names = "spdifclk";
+		};
+
+		sdhcclk: cfg@19e015c0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "sdhcclk";
+		};
+
+		inandclk: cfg@19e015e0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "inandclk";
+		};
+
+		ethrefclk: cfg@19e01600 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <25000000>;
+			clock-output-names = "ethrefclk";
+		};
+
+		ethbyprefclk: cfg@19e01620 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <125000000>;
+			clock-output-names = "ethbyprefclk";
+		};
+
+		ethtsuclk: cfg@19e01640 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <25000000>;
+			clock-output-names = "ethtsuclk";
+		};
+
+		wlan24clk: cfg@19e016c0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <30000000>;
+			clock-output-names = "wlan24clk";
+		};
+
+		wlan5clk: cfg@19e016e0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <30000000>;
+			clock-output-names = "wlan5clk";
+		};
+
+		usbphyclk: cfg@19e01700 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "usbphyclk";
+		};
+
+		tclk: cfg@19e01720 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <50000000>;
+			clock-output-names = "tclk";
+		};
+
+		npupeclk: cfg@19e01740 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <500000000>;
+			clock-output-names = "npupeclk";
+		};
+
+		gdu0clk: cfg@19e01760 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <198000000>;
+			clock-output-names = "gdu0clk";
+		};
+
+		gdu0eitfclk: cfg@19e01780 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <40000000>;
+			clock-output-names = "gdu0eitfclk";
+		};
+
+		tvif0clk: cfg@19e017a0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency  = <198000000>;
+			clock-output-names = "tvif0clk";
+		};
+
+	};
+	cpuintc: cpuintc@0 {
+		compatible = "mti,cpu-interrupt-controller";
+		#address-cells = <0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	gic: gic@1bdc0000 {
+		#interrupt-cells = <2>;
+		interrupt-controller;
+		compatible = "siflower,sfax8-gic";
+		reg = <0x1bdc0000 0x20000>;/*gic*/
+		clocks = <&cpuclk 0>;
+	};
+
+	usb_phy: usb-phy {
+		compatible = "siflower,sfax8-usb-phy";
+		clocks = <&usbphyclk 0>;
+		usbgrf = <&grfcom>;
+		#phy-cells = <0>;
+		status = "disabled";
+	};
+
+	palmbus@10000000 {
+		compatible = "palmbus";
+		reg = <0x10000000 0x10000000>;
+		ranges = <0x0 0x10000000 0xFFFFFFF>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&gic>;
+
+		ethernet: ethernet@0000000 {
+			compatible = "siflower,sfax8-eth";
+			reg = <0x0000000 0x6CFFFF>;
+			clocks = <&ethrefclk 0>, <&ethbyprefclk 0>, <&ethtsuclk 0>;
+			mtd-mac-address = <&factory 0>;
+			interrupts = <16 0>;
+			status = "disabled";
+		};
+
+		switch: switch@0000000 {
+			compatible = "siflower,sfax8-switch";
+			reg = <0x0000000 0x6CFFFF>;
+			interrupts = <25 0>;
+			max-speed = <100>;
+			sfax8,port-map = "llllw";
+			status = "disabled";
+		};
+
+		gmac: gmac@800000 {
+			compatible = "siflower,sfax8-gmac";
+			reg = <0x800000 0x200000>;
+			clocks = <&ethbyprefclk 0>, <&ethtsuclk 0>;
+			interrupts = <32 0>;
+
+			mac-address = [ 00 11 22 33 44 55 ];
+			phy = <&phy0>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			phy0: ethernet-phy@0 {
+				reg = <1>;
+				max-speed = <1000>;
+			};
+		};
+
+		gdu: gdu@800000 {
+			compatible = "siflower,sfax8-fb";
+			reg = <0x800000 0x10000>;
+			interrupts = <39 0>;
+			status = "disabled";
+			clocks = <&gdu0eitfclk 0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&gdu_0>;
+		};
+
+		rng: rng@c00900 {
+			compatible = "siflower,sfax8-rng";
+			reg = <0xc00900 0x28>;
+			rnggrf = <&grfcom>;
+			status = "disabled";
+		};
+
+		gdma: dma@1800000 {
+			compatible = "siflower,sfax8-gdma";
+			reg = <0x1800000 0x1000>;
+			interrupts = <80 0>;
+			#dma-cells = <1>;
+			#dma-channels = <7>;
+			#dma-requests = <32>;
+			status = "disabled";
+		};
+
+		usb: usb@7400000 {
+			compatible = "siflower,sfax8-usb";
+			reg = <0x7400000 0x40000>;
+			interrupts = <128 0>;
+			clocks = <&usbphyclk 0>;
+			dr_mode = "otg";
+			phys = <&usb_phy>;
+			phy-names = "usb2-phy";
+			usbgrf = <&grfcom>;
+			status = "disabled";
+
+			g-use-dma;
+			g-tx-fifo-size = <0x100 0x100 0x100 0x100 0x100
+				0x300 0x300 0x300>;
+		};
+
+		emmc: emmc@7600000 {
+			compatible = "siflower,sfax8-mmc";
+			reg = <0x7600000 0x200000>;
+			clocks = <&inandclk 0>;
+			clock-freq-min-max = <400000 50000000>;
+			fifo-depth = <0x200>;
+			bus-width = <8>;
+			interrupts = <144 0>;
+			read-delayline = <15>;
+			write-delayline = <15>;
+			supports-highspeed;
+			pinctrl-names = "default";
+			pinctrl-0 = <&emmc_data0 &emmc_data1 &emmc_data2 &emmc_data3 \
+						 &emmc_data4 &emmc_data5 &emmc_data6 &emmc_data7 \
+						 &emm_clk &emmc_cmd &emmc_resetn>;
+			status = "disabled";
+		};
+
+		sdio: sdio@7800000 {
+			compatible = "siflower,sfax8-mmc";
+			reg = <0x7800000 0x200000>;
+			clocks = <&sdhcclk 0>;
+			/*clock-names = "biu", "ciu";*/
+			bus-width = <4>;
+			read-delayline = <15>;
+			write-delayline = <15>;
+			interrupts = <160 0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&sdio_data0 &sdio_data1 &sdio_data2 &sdio_data3 \
+						 &sdi_clk &sdio_cmd &sdio_cd>;
+			status = "disabled";
+		};
+
+		i2s0: i2s@8000000 {
+			compatible = "siflower,sfax8-i2s";
+			interrupts = <208 0>;
+			reg = <0x8000000 0x1000>;
+			clocks = <&audioclk 0>;
+			dmas = <&gdma 0
+			&gdma 1>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s0_cdclk &i2s0_sclk &i2s0_lrck &i2s0_sdi0 &i2s0_sdo0>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@8100000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8100000 0x1000>;
+			clocks = <&pbusclk 0>;
+			clock-frequency = <400000>;
+			interrupts = <217 0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names="default";
+			pinctrl-0 = <&i2c0_clk &i2c0_dat>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@8101000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8101000 0x1000>;
+			clocks = <&pbusclk 0>;
+			clock-frequency = <400000>;
+			interrupts = <218 0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names="default";
+			pinctrl-0 = <&i2c1_clk &i2c1_dat>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@8102000 {
+			compatible = "siflower,sfax8-i2c";
+			reg = <0x8102000 0x1000>;
+			clocks = <&pbusclk 0>;
+			clock-frequency = <400000>;
+			interrupts = <219 0>;
+			status = "disabled";
+		};
+
+		spi0: spi@8200000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8200000 0x1000>;
+			num-cs = <2>;
+			cs-gpios = <&gpio 5 0>, <&gpio 6 0>;
+			spi-max-frequency = <33000000>;
+
+			clocks = <&pbusclk 0>;
+			sfgrf = <&grfcom>;
+
+			interrupt-parent = <&gic>;
+			interrupts = <223 0>;
+
+			use-dma;
+			dmas = <&gdma 10
+				&gdma 11>;
+			dma-names = "tx", "rx";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi1: spi@8201000 {
+			compatible = "siflower,sfax8-spi";
+			reg = <0x8201000 0x1000>;
+			clocks = <&pbusclk 0>;
+			status = "disabled";
+
+			num-cs = <1>;
+			/*cs-gpios = <&gpio 34 0>;*/
+			spi-max-frequency = <33000000>;
+			sfgrf = <&grfcom>;
+
+			interrupt-parent = <&gic>;
+			interrupts = <224 0>;
+
+		/*	use-dma;
+			dmas = <&gdma 12
+				&gdma 13>;
+			dma-names = "tx", "rx";
+		*/
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		uart0: serial@8300000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8300000 0x1000>;
+			interrupts = <226 0>;
+			clocks = <&uartclk 0>;
+			status = "disabled";
+		};
+
+		uart1: serial@8301000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8301000 0x1000>;
+			interrupts = <227 0>;
+			clocks = <&uartclk 0>;
+			dmas = <&gdma 14
+			&gdma 15>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		uart2: serial@8302000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8302000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <228 0>;
+			status = "disabled";
+		};
+
+		uart3: serial@8303000 {
+			compatible = "siflower,sfax8-uart";
+			reg = <0x8303000 0x1000>;
+			clocks = <&uartclk 0>;
+			interrupts = <229 0>;
+			status = "disabled";
+		};
+
+		pcm0: pcm@8400000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8400000 0x1000>;
+			clocks =<&audioclk 0>;
+			id = <0>;
+			dmas = <&gdma 20
+				&gdma 21>;
+			dma-names = "tx","rx";
+			interrupts = <230 0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pcm0_cdclk &pcm0_sclk &pcm0_fsync &pcm0_sin &pcm0_sout>;
+			status = "disabled";
+		};
+
+		/*
+		pcm1: pcm@8401000 {
+			compatible = "siflower,sfax8-pcm";
+			reg = <0x8401000 0x1000>;
+			clocks =<&audioclk 0>;
+			id = <1>;
+			dmas = <&gdma 22
+				&gdma 23>;
+			dma-names = "tx","rx";
+			interrupts = <231 0>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&pcm1_cdclk &pcm1_sclk &pcm1_fsync &pcm1_sin &pcm1_sout>;
+		};
+		*/
+
+		pwm0: pwm@8500000 {
+			compatible = "siflower,sfax8-pwm";
+			reg = <0x8500000 0x1000>;
+			interrupts = <232 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm_0>; //36
+			status = "disabled";
+		};
+
+		pwm1: pwm@8501000 {
+			compatible = "siflower,sfax8-pwm";
+			reg = <0x8501000 0x1000>;
+			interrupts = <233 0>;
+			clocks = <&pbusclk 0>;
+			pwm-outputs = <0>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm_1>; //37
+			status = "disabled";
+		};
+
+		timer0: timer@8600000 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8600000 0x14>;
+			interrupts = <234 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+			status = "disabled";
+		};
+
+		timer1: timer@8600014 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8600014 0x14>;
+			interrupts = <235 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+			status = "disabled";
+		};
+
+		timer2: timer@8601000 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8601000 0x14>;
+			interrupts = <236 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+			status = "disabled";
+		};
+
+		timer3: timer@8601014 {
+			compatible = "siflower,sfax8-timer";
+			reg = <0x8601014 0x14>;
+			interrupts = <237 0>;
+			clocks = <&pbusclk 0>;
+			clock-names = "timer";
+			status = "disabled";
+		};
+
+		watchdog: watchdog@8700000 {
+			compatible = "siflower,sfax8-wdt";
+			reg = <0x8700000 0x1000>;
+			interrupt-parent = <&gic>;
+			interrupts = <238 0>;
+			clocks = <&pbusclk 0>;
+			status = "disabled";
+		};
+
+		spdif: spdif@8800000 {
+			compatible = "siflower,sfax8-spdif";
+			reg = <0x8800000 0x1000>;
+			interrupts = <239 0>;
+			clocks = <&spdifclk 0>;
+			dmas = <&gdma 8
+				&gdma 9>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		wifi_rf: wifi-rf@7A00000{
+			compatible = "siflower,sf16a18-wifi-rf";
+			reg = <0x7A00000 0x600000>;
+			interrupts = <176 0>;
+			status = "disabled";
+		};
+
+		wifi_lb: wifi-lb@1000000{
+			compatible = "siflower,sf16a18-wifi-lb";
+			reg = <0x1000000 0x400000>;
+			interrupts = <48 0>, <49 0>;
+			mtd-mac-address = <&factory 0>;
+			clocks = <&wlan24clk 0>;
+			status = "disabled";
+		};
+
+		wifi_hb: wifi-hb@1400000{
+			compatible = "siflower,sf16a18-wifi-hb";
+			reg = <0x1400000 0x400000>;
+			interrupts = <64 0>, <65 0>;
+			mtd-mac-address = <&factory 0>;
+			clocks = <&wlan5clk 0>;
+			status = "disabled";
+		};
+
+	}; /* palmbus */
+
+	pinctrl: pinctrl {
+		compatible = "siflower,sfax8-pinctrl";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&gic>;
+		ranges;
+		pad-base = <&grfgpio>;
+
+		gpio: gpio@19d00000 {
+			compatible = "siflower,sfax8-gpio";
+			reg=<0x19d00000 0x100000>;
+			interrupts = <246 0>, <247 0>, <248 0>, <249 0>;
+			clocks = <&pbusclk 0>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		pcfg_pull_up: pcfg-pull-up {
+			bias-pull-up;
+		};
+
+		pcfg_pull_down: pcfg-pull-down {
+			bias-pull-down;
+		};
+
+		pcfg_pull_none: pcfg-pull-none {
+			bias-disable;
+		};
+
+		pcfg_pull_pin_default: pcfg-pull-pin-default {
+			bias-pull-pin-default;
+		};
+
+
+		spi0 {
+			spi0_mosi: spi0-mosi {
+				sfax8,pins = <0 0 1 &pcfg_pull_pin_default>;
+			};
+			spi0_miso: spi0-miso {
+				sfax8,pins = <0 1 1 &pcfg_pull_pin_default>;
+			};
+			spi0_hold: spi0-hold {
+				sfax8,pins = <0 2 1 &pcfg_pull_pin_default>;
+			};
+			spi0_wp: spi0-wp {
+				sfax8,pins = <0 3 1 &pcfg_pull_pin_default>;
+			};
+			spi0_clk: spi0-clk {
+				sfax8,pins = <0 4 1 &pcfg_pull_pin_default>;
+			};
+			spi0_cs0: spi0-cs0 {
+				sfax8,pins = <0 5 1 &pcfg_pull_pin_default>;
+			};
+			spi0_cs1: spi0-cs1 {
+				sfax8,pins = <0 6 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+		spi1 {
+			spi1_txd: spi1-txd {
+				sfax8,pins = <0 31 1 &pcfg_pull_pin_default>;
+			};
+			spi1_rxd: spi1-rxd {
+				sfax8,pins = <0 32 1 &pcfg_pull_pin_default>;
+			};
+			spi1_clk: spi1-clk {
+				sfax8,pins = <0 33 1 &pcfg_pull_pin_default>;
+			};
+			spi1_csn: spi1-csn {
+				sfax8,pins = <0 34 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+
+		emmc {
+			emmc_data0: emmc-data0 {
+				sfax8,pins = <0 0 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data1: emmc-data1 {
+				sfax8,pins = <0 1 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data2: emmc-data2 {
+				sfax8,pins = <0 2 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data3: emmc-data3 {
+				sfax8,pins = <0 3 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data4: emmc-data4 {
+				sfax8,pins = <0 4 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data5: emmc-data5 {
+				sfax8,pins = <0 8 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data6: emmc-data6 {
+				sfax8,pins = <0 9 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_data7: emmc-data7 {
+				sfax8,pins = <0 10 0 &pcfg_pull_pin_default>;
+			};
+
+			emm_clk: emmc-clk {
+				sfax8,pins = <0 5 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_cmd: emmc-cmd {
+				sfax8,pins = <0 6 0 &pcfg_pull_pin_default>;
+			};
+
+			emmc_resetn: emmc-resetn {
+				sfax8,pins = <0 7 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		sdio {
+			sdio_data0: sdio-data0 {
+				sfax8,pins = <0 11 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_data1: sdio-data1 {
+				sfax8,pins = <0 12 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_data2: sdio-data2 {
+				sfax8,pins = <0 13 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_data3: sdio-data3 {
+				sfax8,pins = <0 14 0 &pcfg_pull_pin_default>;
+			};
+			sdi_clk: sdio-clk {
+				sfax8,pins = <0 15 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_cmd: sdio-cmd {
+				sfax8,pins = <0 16 0 &pcfg_pull_pin_default>;
+			};
+
+			sdio_cd: sdio-cd {
+				sfax8,pins = <0 17 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		uart0 {
+			uart0_tx: uart0-tx {
+				sfax8,pins = <0 18 0 &pcfg_pull_pin_default>;
+			};
+
+			uart0_rx: uart0-rx {
+				sfax8,pins = <0 19 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		uart1 {
+			uart1_tx: uart1-tx {
+				sfax8,pins = <0 26 2 &pcfg_pull_pin_default>;
+			};
+
+			uart1_rx: uart1-rx {
+				sfax8,pins = <0 27 2 &pcfg_pull_pin_default>;
+			};
+
+			uart1_cts: uart1-cts {
+				sfax8,pins = <0 30 2 &pcfg_pull_pin_default>;
+			};
+
+			uart1_rts: uart1-rts {
+				sfax8,pins = <0 29 2 &pcfg_pull_pin_default>;
+			};
+
+		};
+
+		uart2 {
+			uart2_tx: uart2-tx {
+				sfax8,pins = <0 22 2 &pcfg_pull_pin_default>;
+			};
+
+			uart2_rx: uart2-rx {
+				sfax8,pins = <0 23 2 &pcfg_pull_pin_default>;
+			};
+
+			uart2_cts: uart2-cts {
+				sfax8,pins = <0 24 2 &pcfg_pull_pin_default>;
+			};
+
+			uart2_rts: uart2-rts {
+				sfax8,pins = <0 25 2 &pcfg_pull_pin_default>;
+			};
+		};
+
+		uart3 {
+			uart3_tx: uart3-tx {
+				sfax8,pins = <0 32 2 &pcfg_pull_pin_default>;
+			};
+
+			uart3_rx: uart3-rx {
+				sfax8,pins = <0 31 2 &pcfg_pull_pin_default>;
+			};
+
+			uart3_cts: uart3-cts {
+				sfax8,pins = <0 35 2 &pcfg_pull_pin_default>;
+			};
+
+			uart3_rts: uart3-rts {
+				sfax8,pins = <0 34 2 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2c0 {
+			i2c0_clk: i2c0-clk {
+				sfax8,pins = <0 20 0 &pcfg_pull_pin_default>;
+			};
+
+			i2c0_dat: i2c0-dat {
+				sfax8,pins = <0 21 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2c1 {
+			i2c1_clk: i2c1-clk {
+				sfax8,pins = <0 22 0 &pcfg_pull_pin_default>;
+			};
+
+			i2c1_dat: i2c1-dat {
+				sfax8,pins = <0 23 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2c2 {
+			i2c2_clk: i2c2-clk {
+				sfax8,pins = <0 24 0 &pcfg_pull_pin_default>;
+			};
+
+			i2c2_dat: i2c2-dat {
+				sfax8,pins = <0 25 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pcm0 {
+			pcm0_cdclk: pcm0-cdclk {
+				sfax8,pins = <0 26 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_sclk: pcm0-sclk {
+				sfax8,pins = <0 27 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_fsync: pcm0-fsync {
+				sfax8,pins = <0 28 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_sin: pcm0-sin {
+				sfax8,pins = <0 29 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm0_sout: pcm0-sout {
+				sfax8,pins = <0 30 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pcm1 {
+			pcm1_cdclk: pcm1-cdclk {
+				sfax8,pins = <0 22 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_sclk: pcm1-sclk {
+				sfax8,pins = <0 23 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_fsync: pcm1-fsync {
+				sfax8,pins = <0 24 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_sin: pcm1-sin {
+				sfax8,pins = <0 25 1 &pcfg_pull_pin_default>;
+			};
+
+			pcm1_sout: pcm1-sout {
+				sfax8,pins = <0 36 1 &pcfg_pull_pin_default>;
+			};
+		};
+
+		i2s {
+			i2s0_cdclk: i2s0-cdclk {
+				sfax8,pins = <0 26 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_sclk: i2s0-sclk {
+				sfax8,pins = <0 27 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_lrck: i2s0-lrck {
+				sfax8,pins = <0 28 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_sdi0: i2s0-sdi0 {
+				sfax8,pins = <0 29 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s0_sdo0: i2s0-sdo0 {
+				sfax8,pins = <0 30 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_cdclk: i2s1-cdclk {
+				sfax8,pins = <0 31 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_sclk: i2s1-sclk {
+				sfax8,pins = <0 32 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_lrck: i2s1-lrck {
+				sfax8,pins = <0 33 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_sdi0: i2s1-sdi0 {
+				sfax8,pins = <0 34 0 &pcfg_pull_pin_default>;
+			};
+
+			i2s1_sdo0: i2s1-sdo0 {
+				sfax8,pins = <0 35 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		spdif {
+			spdif_0: spdif-0 {
+				sfax8,pins = <0 35 0 &pcfg_pull_pin_default>;
+			};
+
+			spdif_1: spdif-1 {
+				sfax8,pins = <0 62 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pwm0 {
+			pwm_0: pwm-0 {
+				sfax8,pins = <0 36 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		pwm1 {
+			pwm_1: pwm-1 {
+				sfax8,pins = <0 37 0 &pcfg_pull_pin_default>;
+			};
+		};
+
+		gdu {
+			gdu_0: gdu-0 {
+				sfax8,pins = <0 11 3 &pcfg_pull_pin_default>,
+					<0 12 3 &pcfg_pull_pin_default>,
+					<0 13 3 &pcfg_pull_pin_default>,
+					<0 14 3 &pcfg_pull_pin_default>,
+					<0 24 3 &pcfg_pull_pin_default>,
+					<0 25 3 &pcfg_pull_pin_default>,
+					<0 31 3 &pcfg_pull_pin_default>,
+					<0 32 3 &pcfg_pull_pin_default>,
+					<0 33 3 &pcfg_pull_pin_default>,
+					<0 34 3 &pcfg_pull_pin_default>,
+					<0 35 3 &pcfg_pull_pin_default>,
+					<0 38 3 &pcfg_pull_pin_default>,
+					<0 39 3 &pcfg_pull_pin_default>,
+					<0 40 3 &pcfg_pull_pin_default>,
+					<0 41 3 &pcfg_pull_pin_default>,
+					<0 42 3 &pcfg_pull_pin_default>,
+					<0 43 3 &pcfg_pull_pin_default>,
+					<0 44 3 &pcfg_pull_pin_default>,
+					<0 45 3 &pcfg_pull_pin_default>,
+					<0 46 3 &pcfg_pull_pin_default>,
+					<0 47 3 &pcfg_pull_pin_default>,
+					<0 48 3 &pcfg_pull_pin_default>,
+					<0 49 3 &pcfg_pull_pin_default>,
+					<0 50 3 &pcfg_pull_pin_default>,
+					<0 51 3 &pcfg_pull_pin_default>,
+					<0 52 3 &pcfg_pull_pin_default>,
+					<0 53 3 &pcfg_pull_pin_default>,
+					<0 54 3 &pcfg_pull_pin_default>;
+			};
+		};
+
+	};
+};
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1_p10.dts
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1_p10.dts	2017-11-15 11:09:39.320422000 +0800
@@ -0,0 +1,289 @@
+/dts-v1/;
+
+#include "sf16a18_mpw1.dtsi"
+
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "siflower,sf16a18-soc";
+};
+
+&ethernet {
+	status = "okay";
+};
+
+&switch{
+	status = "okay";
+};
+
+&gmac {
+	status = "okay";
+};
+
+&gdma {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pmu@30 {
+		compatible = "siflower, sfax8-pmu";
+		reg = <0x30>;
+
+		/*
+		IR device
+		miscdev {
+			interrupts = <249 0>;
+		};
+		*/
+        reset-button {
+			rb-gpio = <&gpio 60 0>;
+			led-gpio = <&gpio 57 0>;
+			};
+
+		power-management {
+			dcdc0-supply = <&core>;
+			dcdc0-maxv = <1100000>;
+			/*dcdc0-default-uv = <775000>;*/
+
+			dcdc1-supply = <&dcdc1>;
+			dcdc1-maxv = <2100000>;
+
+			dcdc2-supply = <&ddr>;
+			dcdc2-maxv = <1800000>;
+
+			dcdc3-supply = <&vddio>;
+			dcdc3-maxv = <3300000>;
+
+			ldo0-supply = <&rflb_pa>;
+			ldo0-maxv = <2600000>;
+
+			ldo1-supply = <&rfhb_pa>;
+			ldo1-maxv = <2600000>;
+
+			ldo2-supply = <&vdd18>;
+			ldo2-maxv = <1800000>;
+
+			ldo4-supply = <&rfvdda>;
+			ldo4-maxv = <1500000>;
+
+			ldo5-supply = <&rfpa_en>;
+			ldo5-maxv = <700000>;
+
+			ldo6-supply = <&ldo6_32khz>;
+			ldo6-maxv = <700000>;
+
+		};
+
+		regulators {
+			core: dcdc0 {
+				regulator-name = "VDD_CORE_0.9V";
+				/*set default to 0.8v to save power*/
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			dcdc1: dcdc1 {
+				regulator-name = "DCDC1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2175000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ddr: dcdc2 {
+				regulator-name = "DDR_1.5-1.8V";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vddio: dcdc3 {
+				regulator-name = "VDDIO_3.3V";
+				regulator-min-microvolt = <2200000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <2000000>;
+				regulator-max-microamp = <2000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rflb_pa: ldo0 {
+				regulator-name = "RFLB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfhb_pa: ldo1 {
+				regulator-name = "RFHB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vdd18: ldo2 {
+				regulator-name = "VDD18_1.8V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfvdda: ldo4 {
+				regulator-name = "RF_VDDA_1.5V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfpa_en: ldo5 {
+				regulator-name = "RFPA_EN";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo6_32khz: ldo6 {
+				regulator-name = "LDO6";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			/*
+			svcc {
+				regulator-name = "SVCC";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <50000>;
+				regulator-max-microamp = <50000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+			*/
+		};
+	};
+};
+
+/*
+&cpu0 {
+	cpu0-supply = <&core>;
+	dcdc0-maxv = <950000>;
+};
+*/
+
+&spi0 {
+	status = "okay";
+	use-dma;
+	dmas = <&gdma 10
+	&gdma 11>;
+	dma-names = "tx", "rx";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	w25q128@0 {
+		compatible = "w25q128";
+		reg = <0>;	/* chip select */
+		spi-max-frequency = <33000000>;
+
+		bank-width = <2>;
+		device-width = <2>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "spl-loader";
+			reg = <0x0 0x20000>; /* 128k */
+			read-only;
+		};
+
+		partition@20000 {
+			label = "u-boot";
+			reg = <0x20000 0x60000>; /* 384k */
+		};
+
+		partition@80000 {
+			label = "u-boot-env";
+			reg = <0x80000 0x10000>; /* 64k */
+		};
+
+		factory:partition@90000 {
+			label = "factory";
+			reg = <0x90000 0x10000>; /* 64k */
+		};
+
+		partition@a0000 {
+			label = "firmware";
+			reg = <0xa0000 0xf60000>; /* 640k-16M */
+		};
+	};
+
+	spidev: spi@8200000 {
+		compatible = "rohm,dh2228fv";
+		reg = <1>;
+		clock = <50000000>;
+		spi-cpha;
+		spi-cpol;
+		spi-max-frequency=<12000000>;
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&timer0 {
+	status = "okay";
+};
+
+&watchdog {
+	status = "okay";
+};
+
+&wifi_rf {
+	status = "okay";
+};
+
+&wifi_lb {
+	status = "okay";
+};
+
+&wifi_hb {
+	status = "okay";
+};
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1_p20.dts
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw1_p20.dts	2017-11-21 09:22:50.029560000 +0800
@@ -0,0 +1,409 @@
+/dts-v1/;
+
+#include "sf16a18_mpw1.dtsi"
+
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "siflower,sf16a18-soc";
+
+	spdif_codec: spdif-codec@0 {
+		compatible = "linux,spdif-dit";
+	};
+
+	w18_wifi_rf: w18_wifi-rf@7A00000{
+		compatible = "siflower,pistachio-uccp";
+		phy = <&phy1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		phy1: w18_wifi-phy@1 {
+			reg = <1>;
+			max-speed = <100>;
+		};
+	};
+
+	spdif-audio@0 {
+		compatible = "siflower,siflower-audio";
+		model = "Siflower Spdif Audio";
+		audio-controller = <&spdif>;
+		audio-codec = <&spdif_codec>;
+		audio-out;
+	};
+
+};
+
+&usb_phy{
+	status = "okay";
+};
+
+&ethernet {
+	status = "okay";
+};
+
+&switch{
+	status = "okay";
+};
+
+&gmac {
+	status = "okay";
+};
+
+&gdu {
+	status = "okay";
+	num-windows = <2>;
+	rgb_order = <0 1 2>;
+	power_gpio = <26 37>;
+	bpp-mode = "RGB888";
+
+	display-timings {
+		native-mode = <&timing0>;
+		timing0: gm05004001q {
+			clock-frequency = <34539600>;
+			hactive = <800>;
+			vactive = <480>;
+			hback-porch = <46>;
+			hfront-porch = <210>;
+			vback-porch = <23>;
+			vfront-porch = <22>;
+			hsync-len = <20>;
+			vsync-len = <10>;
+		};
+	};
+};
+
+&rng {
+	status = "okay";
+};
+
+&gdma {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&emmc {
+	status = "disabled";
+};
+
+&sdio {
+	status = "okay";
+};
+
+&i2s0 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pmu@30 {
+		compatible = "siflower, sfax8-pmu";
+		reg = <0x30>;
+
+		/*
+		IR device
+		miscdev {
+			interrupts = <249 0>;
+		};
+		*/
+
+        reset-button {
+			rb-gpio = <&gpio 60 0>;
+			led-gpio = <&gpio 57 0>;
+			};
+
+		power-management {
+			dcdc0-supply = <&core>;
+			dcdc0-maxv = <1100000>;
+			/*dcdc0-default-uv = <775000>;*/
+
+			dcdc1-supply = <&dcdc1>;
+			dcdc1-maxv = <2100000>;
+
+			dcdc2-supply = <&ddr>;
+			dcdc2-maxv = <1800000>;
+
+			dcdc3-supply = <&vddio>;
+			dcdc3-maxv = <3300000>;
+
+			ldo0-supply = <&rflb_pa>;
+			ldo0-maxv = <2600000>;
+
+			ldo1-supply = <&rfhb_pa>;
+			ldo1-maxv = <2600000>;
+
+			ldo2-supply = <&vdd18>;
+			ldo2-maxv = <1800000>;
+
+			ldo4-supply = <&rfvdda>;
+			ldo4-maxv = <1500000>;
+
+			ldo5-supply = <&rfpa_en>;
+			ldo5-maxv = <700000>;
+
+			ldo6-supply = <&ldo6_32khz>;
+			ldo6-maxv = <700000>;
+
+		};
+
+		regulators {
+			core: dcdc0 {
+				regulator-name = "VDD_CORE_0.9V";
+				/*set default to 0.8v to save power*/
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			dcdc1: dcdc1 {
+				regulator-name = "DCDC1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2175000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ddr: dcdc2 {
+				regulator-name = "DDR_1.5-1.8V";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vddio: dcdc3 {
+				regulator-name = "VDDIO_3.3V";
+				regulator-min-microvolt = <2200000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <2000000>;
+				regulator-max-microamp = <2000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rflb_pa: ldo0 {
+				regulator-name = "RFLB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfhb_pa: ldo1 {
+				regulator-name = "RFHB_PA_2.6V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			vdd18: ldo2 {
+				regulator-name = "VDD18_1.8V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <400000>;
+				regulator-max-microamp = <400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfvdda: ldo4 {
+				regulator-name = "RF_VDDA_1.5V";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			rfpa_en: ldo5 {
+				regulator-name = "RFPA_EN";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo6_32khz: ldo6 {
+				regulator-name = "LDO6";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			/*
+			svcc {
+				regulator-name = "SVCC";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <50000>;
+				regulator-max-microamp = <50000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+			*/
+		};
+	};
+};
+
+/*
+&cpu0 {
+	cpu0-supply = <&core>;
+	dcdc0-maxv = <950000>;
+};
+*/
+
+&i2c1 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+/*
+	codec: es8388s@11{
+		compatible = "ambarella,es8388s";
+		reg = <0x11>;
+	};
+*/
+	codec: es8316@11{
+		compatible = "ESSX8316";
+		reg = <0x11>;
+	};
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&spi0 {
+	status = "okay";
+	use-dma;
+	dmas = <&gdma 10
+	&gdma 11>;
+	dma-names = "tx", "rx";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	w25q128@0 {
+		compatible = "w25q128";
+		reg = <0>;	/* chip select */
+		spi-max-frequency = <33000000>;
+
+		bank-width = <2>;
+		device-width = <2>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "spl-loader";
+			reg = <0x0 0x20000>; /* 128k */
+			read-only;
+		};
+
+		partition@20000 {
+			label = "u-boot";
+			reg = <0x20000 0x60000>; /* 384k */
+		};
+
+		partition@80000 {
+			label = "u-boot-env";
+			reg = <0x80000 0x10000>; /* 64k */
+		};
+
+		factory:partition@90000 {
+			label = "factory";
+			reg = <0x90000 0x10000>; /* 64k */
+		};
+
+		partition@a0000 {
+			label = "firmware";
+			reg = <0xa0000 0xf60000>; /* 640k-16M */
+		};
+	};
+
+	spidev: spi@8200000 {
+		compatible = "rohm,dh2228fv";
+		reg = <1>;
+		clock = <50000000>;
+		spi-cpha;
+		spi-cpol;
+		spi-max-frequency=<12000000>;
+	};
+};
+
+&spi1 {
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&uart1 {
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&uart3 {
+	status = "okay";
+};
+
+&pcm0 {
+	status = "okay";
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&pwm1 {
+	status = "okay";
+};
+&timer0 {
+	status = "okay";
+};
+
+&watchdog {
+	status = "okay";
+};
+
+&spdif
+{
+	status = "okay";
+};
+
+&wifi_rf {
+	status = "okay";
+};
+
+&wifi_lb {
+	status = "okay";
+};
+
+&wifi_hb {
+	status = "okay";
+};
Index: linux-3.18.29/arch/mips/configs/sf16a18_mpw0_p10_defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/configs/sf16a18_mpw0_p10_defconfig	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,240 @@
+CONFIG_SIFLOWER=y
+CONFIG_DT_SF16A18_MPW0_P10=y
+CONFIG_CORE1_MEM_RES=y
+CONFIG_SIFLOWER_PWMTIMER_CLKSRC=y
+CONFIG_CEVT_GIC=y
+CONFIG_IMAGE_CMDLINE_HACK=y
+CONFIG_MIPS_MT_SMP=y
+CONFIG_SCHED_SMT=y
+CONFIG_MIPS_CPS=y
+CONFIG_NR_CPUS=2
+CONFIG_HZ_100=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+CONFIG_CRASHLOG=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_BPF_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODULE_STRIPPED=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_SYN_COOKIES=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_RTCACHE=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_ID=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_NF_NAT_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEVELOPER_WARNINGS=y
+CONFIG_CFG80211_REG_DEBUG=y
+CONFIG_CFG80211_CERTIFICATION_ONUS=y
+CONFIG_CFG80211_REG_CELLULAR_HINTS=y
+CONFIG_CFG80211_REG_RELAX_NO_IR=y
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_MINSTREL_VHT=y
+CONFIG_MAC80211_MESH=y
+CONFIG_MAC80211_DEBUGFS=y
+CONFIG_MAC80211_MESSAGE_TRACING=y
+CONFIG_MAC80211_DEBUG_MENU=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_MTD=y
+CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_SIFLOWER=y
+CONFIG_SFAX8_SWITCH=m
+# CONFIG_SFAX8_SWITCH_VLAN is not set
+# CONFIG_SFAX8_SWITCH_POWERSAVE is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+CONFIG_SWCONFIG=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_RTL_CARDS is not set
+# CONFIG_SF16A18_WIFI_LMAC_BUILTIN is not set
+CONFIG_SF16A18_WIFI_RF=m
+CONFIG_SF16A18_WIFI_LB_SMAC=m
+CONFIG_SF16A18_WIFI_HB_SMAC=m
+CONFIG_SF16A18_WIFI_LED=y
+CONFIG_SF16A18_WIIF_TRACING=y
+CONFIG_SF16A18_WIFI_DBG=y
+CONFIG_WIRELESS_VENDOR_SIFLOWER_W18=m
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_SFAX8=y
+CONFIG_SERIAL_SFAX8_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=y
+CONFIG_I2C=y
+CONFIG_I2C_SFAX8=y
+CONFIG_SPI=y
+CONFIG_SPI_DEBUG=y
+CONFIG_SPI_SFAX8=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_SFAX8_WDT=m
+CONFIG_MFD_SFAX8_IP6103=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_SFAX8_IP6103=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_VERBOSE=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_SFAX8_PCM=y
+CONFIG_SND_SOC_SFAX8_I2S=y
+CONFIG_SND_SOC_SFAX8_SPDIF=y
+CONFIG_SND_SOC_SFAX8_MACHINE=y
+CONFIG_SND_SOC_SFAX8_SPDIF_MACHINE=y
+CONFIG_SND_SOC_ES8316=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC2=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_SFAX8=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SFAX8=y
+CONFIG_DMADEVICES=y
+CONFIG_SFAX8_DMA=y
+CONFIG_PWM=y
+CONFIG_PWM_SFAX8=m
+CONFIG_PHY_SFAX8_USB=y
+CONFIG_EXT4_FS=y
+# CONFIG_DIRECT_IO is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_OVERLAY_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_PROC_STRIPPED=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_LZMA=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_VXFS_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_TEST_UDELAY=m
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyS0,115200n8 rootfstype=squashfs,jffs2 rdinit=/sbin/init"
+CONFIG_CRC32_SARWATE=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_TEXTSEARCH=y
Index: linux-3.18.29/arch/mips/configs/sf16a18_mpw0_p20_defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/configs/sf16a18_mpw0_p20_defconfig	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,237 @@
+CONFIG_SIFLOWER=y
+CONFIG_DT_SF16A18_MPW0_P20=y
+CONFIG_CORE1_MEM_RES=y
+CONFIG_SIFLOWER_PWMTIMER_CLKSRC=y
+CONFIG_CEVT_GIC=y
+CONFIG_IMAGE_CMDLINE_HACK=y
+CONFIG_MIPS_MT_SMP=y
+CONFIG_SCHED_SMT=y
+CONFIG_MIPS_CPS=y
+CONFIG_NR_CPUS=2
+CONFIG_HZ_100=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+CONFIG_CRASHLOG=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_BPF_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODULE_STRIPPED=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_SYN_COOKIES=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_RTCACHE=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_ID=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_NF_NAT_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEVELOPER_WARNINGS=y
+CONFIG_CFG80211_REG_DEBUG=y
+CONFIG_CFG80211_CERTIFICATION_ONUS=y
+CONFIG_CFG80211_REG_CELLULAR_HINTS=y
+CONFIG_CFG80211_REG_RELAX_NO_IR=y
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_MINSTREL_VHT=y
+CONFIG_MAC80211_MESH=y
+CONFIG_MAC80211_DEBUGFS=y
+CONFIG_MAC80211_MESSAGE_TRACING=y
+CONFIG_MAC80211_DEBUG_MENU=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_MTD=y
+CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_SIFLOWER=y
+CONFIG_SFAX8_SWITCH=m
+# CONFIG_SFAX8_SWITCH_VLAN is not set
+# CONFIG_SFAX8_SWITCH_POWERSAVE is not set
+CONFIG_SFAX8_RMII_GMAC=m
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+CONFIG_SWCONFIG=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_SF16A18_WIFI_LMAC_BUILTIN is not set
+CONFIG_SF16A18_WIFI_RF=m
+CONFIG_SF16A18_WIFI_LB_SMAC=m
+CONFIG_SF16A18_WIFI_HB_SMAC=m
+CONFIG_SF16A18_WIFI_LED=y
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_SFAX8=y
+CONFIG_SERIAL_SFAX8_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=y
+CONFIG_I2C=y
+CONFIG_I2C_SFAX8=y
+CONFIG_SPI=y
+CONFIG_SPI_DEBUG=y
+CONFIG_SPI_SFAX8=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_SFAX8_WDT=m
+CONFIG_MFD_SFAX8_IP6103=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_SFAX8_IP6103=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_VERBOSE=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_SFAX8_PCM=m
+CONFIG_SND_SOC_SFAX8_I2S=m
+CONFIG_SND_SOC_SFAX8_SPDIF=m
+CONFIG_SND_SOC_SFAX8_MACHINE=m
+CONFIG_SND_SOC_SFAX8_SPDIF_MACHINE=m
+CONFIG_SND_SOC_ES8316=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC2=m
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_SFAX8=m
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SFAX8=y
+CONFIG_DMADEVICES=y
+CONFIG_SFAX8_DMA=y
+CONFIG_PWM=y
+CONFIG_PWM_SFAX8=m
+CONFIG_PHY_SFAX8_USB=m
+CONFIG_EXT4_FS=y
+# CONFIG_DIRECT_IO is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_OVERLAY_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_PROC_STRIPPED=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_LZMA=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_VXFS_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_TEST_UDELAY=m
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyS0,115200n8 rootfstype=squashfs,jffs2 rdinit=/sbin/init"
+CONFIG_CRC32_SARWATE=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_TEXTSEARCH=y
Index: linux-3.18.29/arch/mips/configs/sf16a18_mpw1_fpga_defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/configs/sf16a18_mpw1_fpga_defconfig	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,113 @@
+CONFIG_SIFLOWER=y
+CONFIG_SF16A18_MPW1=y
+CONFIG_DT_SF16A18_MPW1_FPGA=y
+CONFIG_CEVT_GIC=y
+CONFIG_IMAGE_CMDLINE_HACK=y
+CONFIG_MIPS_MT_SMP=y
+CONFIG_SCHED_SMT=y
+CONFIG_MIPS_CPS=y
+CONFIG_NR_CPUS=2
+CONFIG_HZ_100=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+CONFIG_CRASHLOG=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_BPF_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODULE_STRIPPED=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_NET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_MTD=y
+CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+# CONFIG_SF16A18_WIFI_LMAC_BUILTIN is not set
+CONFIG_SF16A18_WIFI_MPW1_FPGA=y
+CONFIG_SF16A18_WIFI_LB_SMAC=m
+CONFIG_SF16A18_WIFI_HB_SMAC=m
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_SFAX8=y
+CONFIG_SERIAL_SFAX8_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_PPS=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_FB=y
+CONFIG_FB_SFAX8=m
+# CONFIG_USB_SUPPORT is not set
+CONFIG_SFAX8_TIMER=y
+CONFIG_PHY_SFAX8_USB=y
+CONFIG_EXT4_FS=y
+# CONFIG_DIRECT_IO is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_OVERLAY_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_PROC_STRIPPED=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_LZMA=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_VXFS_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_TEST_UDELAY=m
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyS0,115200n8 rootfstype=squashfs,jffs2 rdinit=/sbin/init"
+CONFIG_CRC32_SARWATE=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_TEXTSEARCH=y
+CONFIG_CORE1_MEM_RES=y
Index: linux-3.18.29/arch/mips/configs/sf16a18_mpw1_p10_defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/configs/sf16a18_mpw1_p10_defconfig	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,238 @@
+CONFIG_SIFLOWER=y
+CONFIG_SF16A18_MPW1=y
+CONFIG_DT_SF16A18_MPW1_P10=y
+CONFIG_CORE1_MEM_RES=y
+CONFIG_SIFLOWER_PWMTIMER_CLKSRC=y
+CONFIG_CEVT_GIC=y
+CONFIG_IMAGE_CMDLINE_HACK=y
+CONFIG_MIPS_MT_SMP=y
+CONFIG_SCHED_SMT=y
+CONFIG_MIPS_CPS=y
+CONFIG_NR_CPUS=4
+CONFIG_HZ_100=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+CONFIG_CRASHLOG=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_BPF_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODULE_STRIPPED=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_SYN_COOKIES=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_RTCACHE=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_ID=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_NF_NAT_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEVELOPER_WARNINGS=y
+CONFIG_CFG80211_REG_DEBUG=y
+CONFIG_CFG80211_CERTIFICATION_ONUS=y
+CONFIG_CFG80211_REG_CELLULAR_HINTS=y
+CONFIG_CFG80211_REG_RELAX_NO_IR=y
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_MINSTREL_VHT=y
+CONFIG_MAC80211_MESH=y
+CONFIG_MAC80211_DEBUGFS=y
+CONFIG_MAC80211_MESSAGE_TRACING=y
+CONFIG_MAC80211_DEBUG_MENU=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_MTD=y
+CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_SIFLOWER=y
+CONFIG_SFAX8_SWITCH=m
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+CONFIG_SWCONFIG=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_RTL_CARDS is not set
+# CONFIG_SF16A18_WIFI_LMAC_BUILTIN is not set
+CONFIG_SF16A18_WIFI_RF=m
+CONFIG_SF16A18_WIFI_LB_SMAC=m
+CONFIG_SF16A18_WIFI_HB_SMAC=m
+CONFIG_SF16A18_WIFI_LED=y
+CONFIG_SF16A18_WIIF_TRACING=y
+CONFIG_SF16A18_WIFI_DBG=y
+CONFIG_WIRELESS_VENDOR_SIFLOWER_W18=m
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_SFAX8=y
+CONFIG_SERIAL_SFAX8_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_SFAX8=y
+CONFIG_SPI=y
+CONFIG_SPI_DEBUG=y
+CONFIG_SPI_SFAX8=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_SFAX8_WDT=m
+CONFIG_MFD_SFAX8_IP6103=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_SFAX8_IP6103=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_VERBOSE=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_SFAX8_PCM=m
+CONFIG_SND_SOC_SFAX8_I2S=m
+CONFIG_SND_SOC_SFAX8_SPDIF=m
+CONFIG_SND_SOC_SFAX8_MACHINE=m
+CONFIG_SND_SOC_SFAX8_SPDIF_MACHINE=m
+CONFIG_SND_SOC_ES8316=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC2=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_SFAX8=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SFAX8=y
+CONFIG_DMADEVICES=y
+CONFIG_SFAX8_DMA=y
+CONFIG_PWM=y
+CONFIG_PWM_SFAX8=m
+CONFIG_PHY_SFAX8_USB=y
+CONFIG_EXT4_FS=y
+# CONFIG_DIRECT_IO is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_OVERLAY_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_PROC_STRIPPED=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_LZMA=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_VXFS_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_TEST_UDELAY=m
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyS0,115200n8 rootfstype=squashfs,jffs2 rdinit=/sbin/init"
+CONFIG_CRC32_SARWATE=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_TEXTSEARCH=y
Index: linux-3.18.29/arch/mips/configs/sf16a18_mpw1_p20_defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/configs/sf16a18_mpw1_p20_defconfig	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,239 @@
+CONFIG_SIFLOWER=y
+CONFIG_SF16A18_MPW1=y
+CONFIG_DT_SF16A18_MPW1_P20=y
+CONFIG_CORE1_MEM_RES=y
+CONFIG_SIFLOWER_PWMTIMER_CLKSRC=y
+CONFIG_CEVT_GIC=y
+CONFIG_IMAGE_CMDLINE_HACK=y
+CONFIG_MIPS_MT_SMP=y
+CONFIG_SCHED_SMT=y
+CONFIG_MIPS_CPS=y
+CONFIG_NR_CPUS=4
+CONFIG_HZ_100=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+CONFIG_CRASHLOG=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_BPF_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODULE_STRIPPED=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_SYN_COOKIES=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_RTCACHE=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_ID=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_NF_NAT_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEVELOPER_WARNINGS=y
+CONFIG_CFG80211_REG_DEBUG=y
+CONFIG_CFG80211_CERTIFICATION_ONUS=y
+CONFIG_CFG80211_REG_CELLULAR_HINTS=y
+CONFIG_CFG80211_REG_RELAX_NO_IR=y
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_MINSTREL_VHT=y
+CONFIG_MAC80211_MESH=y
+CONFIG_MAC80211_DEBUGFS=y
+CONFIG_MAC80211_MESSAGE_TRACING=y
+CONFIG_MAC80211_DEBUG_MENU=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_MTD=y
+CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_SIFLOWER=y
+CONFIG_SFAX8_SWITCH=m
+CONFIG_SFAX8_SWITCH_AGEING=y
+CONFIG_SFAX8_RMII_GMAC=m
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+CONFIG_SWCONFIG=y
+CONFIG_ICPLUS_PHY=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_SF16A18_WIFI_LMAC_BUILTIN is not set
+CONFIG_SF16A18_WIFI_MPW1_FPGA=y
+CONFIG_SF16A18_WIFI_LB_SMAC=m
+CONFIG_SF16A18_WIFI_HB_SMAC=m
+CONFIG_SF16A18_WIFI_LED=y
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_SFAX8=y
+CONFIG_SERIAL_SFAX8_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_SFAX8=y
+CONFIG_SPI=y
+CONFIG_SPI_DEBUG=y
+CONFIG_SPI_SFAX8=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_SFAX8_WDT=m
+CONFIG_MFD_SFAX8_IP6103=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_SFAX8_IP6103=y
+CONFIG_FB=y
+CONFIG_FB_SFAX8=m
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_VERBOSE=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_SFAX8_PCM=m
+CONFIG_SND_SOC_SFAX8_I2S=m
+CONFIG_SND_SOC_SFAX8_SPDIF=m
+CONFIG_SND_SOC_SFAX8_MACHINE=m
+CONFIG_SND_SOC_SFAX8_SPDIF_MACHINE=m
+CONFIG_SND_SOC_ES8316=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC2=m
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_SFAX8=m
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SFAX8=y
+CONFIG_DMADEVICES=y
+CONFIG_SFAX8_DMA=y
+CONFIG_PWM=y
+CONFIG_PWM_SFAX8=m
+CONFIG_PHY_SFAX8_USB=m
+CONFIG_EXT4_FS=y
+# CONFIG_DIRECT_IO is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_OVERLAY_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_PROC_STRIPPED=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_LZMA=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_VXFS_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_TEST_UDELAY=m
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyS0,115200n8 rootfstype=squashfs,jffs2 rdinit=/sbin/init"
+CONFIG_CRC32_SARWATE=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_TEXTSEARCH=y
Index: linux-3.18.29/arch/mips/siflower/logctl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/siflower/logctl.c	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,179 @@
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/rbtree.h>
+
+struct module_log
+{
+	struct rb_node node;
+	char *module_name;
+	int log_enabled;
+};
+
+struct rb_root log_root = RB_ROOT;
+
+int logctl_rb_insert(struct rb_root *root, struct module_log *data)
+{
+	struct rb_node **new = &(root->rb_node), *parent = NULL;
+
+	/* Figure out where to put new node */
+	while (*new) {
+		struct module_log *this = container_of(*new, struct module_log, node);
+		int result = strcmp(data->module_name, this->module_name);
+
+		parent = *new;
+		if (result < 0)
+			new = &((*new)->rb_left);
+		else if (result > 0)
+			new = &((*new)->rb_right);
+		else
+			return -1;
+	}
+
+	/* Add new node and rebalance tree. */
+	rb_link_node(&data->node, parent, new);
+	rb_insert_color(&data->node, root);
+
+	return 0;
+}
+
+struct module_log *logctl_rb_search(struct rb_root *root, char *string)
+{
+	struct rb_node *node = root->rb_node;
+
+	while (node) {
+		struct module_log *data = container_of(node, struct module_log, node);
+		int result;
+
+		result = strcmp(string, data->module_name);
+
+		if (result < 0)
+			node = node->rb_left;
+		else if (result > 0)
+			node = node->rb_right;
+		else
+			return data;
+	}
+	return NULL;
+}
+
+char *sf_log_entry[] = {
+	"startcore",
+};
+
+static ssize_t sf_logctl_read(struct file *file, char __user *buffer,
+							size_t count, loff_t *f_ops)
+{
+	char *buf = kmalloc(count, GFP_KERNEL);
+	struct rb_node *tmp;
+	int n = 0;
+
+	if(!buf)
+		return -ENOMEM;
+
+	if(*f_ops > 0)
+		return 0;
+
+	for(tmp = rb_first(&log_root); tmp; tmp = rb_next(tmp))
+	{
+		n += snprintf(buf + n, count, "%s %d\n",
+				rb_entry(tmp, struct module_log, node)->module_name,
+				rb_entry(tmp, struct module_log, node)->log_enabled);
+	}
+
+	if(copy_to_user(buffer, buf, n))
+		n = -EFAULT;
+
+	*f_ops += n;
+	kfree(buf);
+
+	return n;
+}
+
+static ssize_t sf_logctl_write(struct file *file, const char __user *buffer,
+							size_t count, loff_t *f_ops)
+{
+	struct module_log *entry;
+	int enable;
+	char sf_module_name[20];
+
+	sscanf(buffer, "%s %d", sf_module_name, &enable);
+	entry = logctl_rb_search(&log_root, sf_module_name);
+	*f_ops += count;
+
+	if(entry)
+		entry->log_enabled = enable;
+	else
+		pr_err("module %s not usable in logctl!\n", sf_module_name);
+
+	return count;
+}
+
+static struct file_operations sf_logctl_ops = {
+	.owner		= THIS_MODULE,
+	.open		= simple_open,
+	.read		= sf_logctl_read,
+	.write		= sf_logctl_write,
+	.llseek		= seq_lseek,
+};
+
+static int sf_log_enabled(char *sf_module_name)
+{
+	struct module_log *tmp;
+
+	tmp = logctl_rb_search(&log_root, sf_module_name);
+	if(!tmp) {
+		return 0;
+	}
+
+	return tmp->log_enabled;
+}
+EXPORT_SYMBOL_GPL(sf_log_enabled);
+
+static int sf_logctl_init(void)
+{
+	struct proc_dir_entry *file;
+	struct module_log *module;
+	int i;
+
+	file = proc_create("logctl", 0644, NULL, &sf_logctl_ops);
+	if (!file)
+		return -ENOMEM;
+
+	for(i = 0; i < ARRAY_SIZE(sf_log_entry); i++)
+	{
+		module = (struct module_log *)kmalloc(sizeof(struct module_log), GFP_KERNEL);
+		module->module_name = sf_log_entry[i];
+		module->log_enabled = 0;
+		if(logctl_rb_insert(&log_root, module) != 0)
+			return -1;
+	}
+	pr_info("SiFlower log system enabled!\n");
+
+	return 0;
+}
+
+static void sf_logctl_exit(void)
+{
+	struct module_log *module;
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(sf_log_entry); i++) {
+		module = logctl_rb_search(&log_root, sf_log_entry[i]);
+		rb_erase(&(module->node), &log_root);
+		kfree(module);
+	}
+	pr_err("SiFlower log system disabled!\n");
+	return;
+}
+
+module_init(sf_logctl_init);
+module_exit(sf_logctl_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nevermore Wang <nevermore.wang@siflower.com.cn>");
+MODULE_DESCRIPTION("SiFlower log system.");
Index: linux-3.18.29/drivers/char/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/char/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/char/Kconfig	2017-11-21 20:13:12.470710527 +0800
@@ -602,5 +602,11 @@
 
 source "drivers/char/xillybus/Kconfig"
 
+config SFAX8_EFUSE
+	bool "Get efuse data."
+	default n
+	help
+		This device provides an interface to get efuse data
+		tranferred from uboot. 
 endmenu
 
Index: linux-3.18.29/drivers/char/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/char/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/char/Makefile	2017-11-21 20:13:12.470710527 +0800
@@ -62,3 +62,4 @@
 
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
 obj-$(CONFIG_XILLYBUS)		+= xillybus/
+obj-$(CONFIG_SFAX8_EFUSE)	+= efuse.o
Index: linux-3.18.29/drivers/char/efuse.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/char/efuse.c	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,78 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/mm.h>
+#include <linux/gfp.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <asm/delay.h>
+
+static char *efuse_data;
+#define EFUSE_MAJOR		231	
+static ssize_t efuse_read(struct file *file, char __user *buf,
+			 size_t count, loff_t *ppos);
+struct file_operations efuse_fops ={
+	owner: THIS_MODULE,
+    read:  efuse_read,
+};
+
+
+static ssize_t efuse_read(struct file *file, char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	int ret = 0;
+	int size = 0;
+	if(efuse_data == NULL)	
+		return 0;
+	size = strlen(efuse_data);
+	if(*ppos == size )
+		return 0;
+	if(*ppos){
+		ret = (size - *ppos) > count ? count : (size - *ppos);
+		copy_to_user(buf, efuse_data + *efuse_data, ret);
+	}else{
+		ret = size > count ? count : size;
+		copy_to_user(buf, efuse_data, ret);
+	}
+	*ppos += ret;
+	return ret;
+}
+static char *efuse_devnode(struct device *dev, umode_t *mode)
+{
+		
+	*mode = (umode_t)0666;
+	return NULL;
+}
+
+static int test_init(void)
+{
+	static struct class *efuse_class;	
+	if(register_chrdev(EFUSE_MAJOR, "efuse", &efuse_fops))
+		printk("unable to get major %d for efuse devs\n", EFUSE_MAJOR);
+	efuse_class = class_create(THIS_MODULE, "efuse");
+	efuse_class->devnode = efuse_devnode;
+	if (IS_ERR(efuse_class))
+		return PTR_ERR(efuse_class);
+	device_create(efuse_class, NULL, MKDEV(EFUSE_MAJOR, 1),
+			      NULL, "efuse");
+	return 0;
+}
+
+static void test_exit(void)
+{
+}
+
+
+static int __init parse_efusedata(char *s)
+{
+	efuse_data = s;
+	return 0;
+}
+__setup("efusedata=", parse_efusedata);
+
+module_init(test_init);
+module_exit(test_exit);
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/video/fbdev/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/video/fbdev/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/video/fbdev/Kconfig	2017-11-21 20:13:12.470710527 +0800
@@ -2501,3 +2501,20 @@
 	help
 	  This driver implements support for the Solomon SSD1307
 	  OLED controller over I2C.
+
+config FB_SFAX8
+	tristate "Siflower Ax8 serial framebuffer support"
+	depends on FB
+	depends on OF
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_MODE_HELPERS
+	select FB_SYS_FOPS
+	select VIDEOMODE_HELPERS
+	---help---
+	  Frame buffer driver for the built-in FB controller in Siflower
+	  Ax8 serial SOCs.
+
+	  There are multiple layers that can be displayed at the same time,
+	  and each layer presents as a "/dev/fb*".
Index: linux-3.18.29/drivers/video/fbdev/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/video/fbdev/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/video/fbdev/Makefile	2017-11-21 20:13:12.470710527 +0800
@@ -132,6 +132,7 @@
 obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-puv3.o
 obj-$(CONFIG_FB_HYPERV)		  += hyperv_fb.o
 obj-$(CONFIG_FB_OPENCORES)	  += ocfb.o
+obj-$(CONFIG_FB_SFAX8)            += sfax8-fb.o
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
Index: linux-3.18.29/drivers/video/fbdev/sfax8-fb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/video/fbdev/sfax8-fb.c	2017-11-15 17:26:54.373090000 +0800
@@ -0,0 +1,1393 @@
+/* linux/drivers/video/sfax8-fb.c
+ *
+ * Copyright 20017 Shanghai Siflower Communication Technology Co., Ltd.
+ *      Qi Zhang <qi.zhang@siflower.com.cn>
+ *      http://www.siflower.com
+ *
+ * Siflower Ax8 Serials SoC Framebuffer Driver
+ *
+ * This driver is based on s3c-fb.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software FoundatIon.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/fb.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <sf16a18.h>
+
+#include <video/sfax8_fb.h>
+
+/* This driver will export a number of framebuffer interfaces depending
+ * on the configuration passed in via the platform data. Each fb instance
+ * maps to a hardware window. Currently there is no support for runtime
+ * setting of the alpha-blending functions that each window has, so only
+ * window 0 is actually useful.
+ *
+ * Window 0 is treated specially, it is used for the basis of the LCD
+ * output timings and as the control for the output power-down state.
+ */
+
+/* note, the previous use of <mach/regs-fb.h> to get platform specific data
+ * has been replaced by using the platform device name to pick the correct
+ * configuration data for the system.
+ */
+//#define CONFIG_FB_SFAX8_DEBUG_REGWRITE
+#ifdef CONFIG_FB_SFAX8_DEBUG_REGWRITE
+#undef writel
+#define writel(v, r)                                                           \
+	do {                                                                   \
+		pr_debug("%s: %08x => %p\n", __func__, (unsigned int)v, r);    \
+		__raw_writel(v, r);                                            \
+	} while (0)
+#endif /* FB_SFAX8_DEBUG_REGWRITE */
+
+/* irq_flags bits */
+#define SFAX8_FB_VSYNC_IRQ_EN 0
+
+#define VSYNC_TIMEOUT_MSEC 50
+#define SFAX8_FB_MAX_WIN 2
+#define SFAX8_FB_PALETTE_SIZE 256
+
+struct sfax8_fb;
+
+#define VALID_BPP(x) (1 << ((x)-1))
+#define VALID_BPP124 (VALID_BPP(1) | VALID_BPP(2) | VALID_BPP(4))
+#define VALID_BPP1248 (VALID_BPP124 | VALID_BPP(8))
+
+#define select_reg(reg0, reg1) (index ? (reg1) : (reg0))
+
+/**
+ * struct sfax8_fb_palette - palette information
+ * @r: Red bitfield.
+ * @g: Green bitfield.
+ * @b: Blue bitfield.
+ * @a: Alpha bitfield.
+ */
+struct sfax8_fb_palette {
+	struct fb_bitfield r;
+	struct fb_bitfield g;
+	struct fb_bitfield b;
+	struct fb_bitfield a;
+};
+
+/**
+ * struct sfax8_fb_win - per window private data for each framebuffer.
+ * @windata: The platform data supplied for the window configuration.
+ * @parent: The hardware that this window is part of.
+ * @fbinfo: Pointer pack to the framebuffer info for this window.
+ * @varint: The variant information for this window.
+ * @pseudo_palette: For use in TRUECOLOUR modes for entries 0..255/
+ * @index: The window number of this window.
+ * @palette: The bitfields for changing r/g/b into a hardware palette entry.
+ */
+struct sfax8_fb_win {
+	struct sfax8_fb *parent;
+	struct fb_info *fbinfo;
+	struct sfax8_fb_palette palette;
+
+	u32 pseudo_palette[SFAX8_FB_PALETTE_SIZE];
+	u32 valid_bpp;
+	unsigned int index;
+};
+
+/**
+ * struct sfax8_fb_vsync - vsync information
+ * @wait:	a queue for processes waiting for vsync
+ * @count:	vsync interrupt count
+ */
+struct sfax8_fb_vsync {
+	wait_queue_head_t wait;
+	unsigned int count;
+};
+
+/**
+ * struct sfax8_fb - overall hardware state of the hardware
+ * @lock: The spinlock protection for this data structure.
+ * @dev: The device that we bound to, for printing, etc.
+ * @bus_clk: The clk (hclk) feeding our interface and possibly pixclk.
+ * @lcd_clk: The clk (sclk) feeding pixclk.
+ * @regs: The mapped hardware registers.
+ * @variant: Variant information for this hardware.
+ * @enabled: A bitmask of enabled hardware windows.
+ * @output_on: Flag if the physical output is enabled.
+ * @windows: The hardware windows that have been claimed.
+ * @irq_num: IRQ line number
+ * @irq_flags: irq flags
+ * @vsync_info: VSYNC-related information (count, queues...)
+ */
+struct sfax8_fb {
+	spinlock_t lock;
+	struct device *dev;
+	struct clk *bus_clk;
+	struct clk *lcd_clk;
+	void __iomem *regs;
+	int power_gpio[2];
+
+	unsigned char enabled;
+	bool output_on;
+
+	int num_windows;
+	struct sfax8_fb_win *windows[SFAX8_FB_MAX_WIN];
+	int irq_num;
+	unsigned long irq_flags;
+	unsigned char rgb_order;
+	enum fb_bpp_mode bpp_mode;
+	unsigned char is_rgb565_interface;
+	struct sfax8_fb_vsync vsync_info;
+	struct fb_videomode vtiming;
+};
+
+/**
+ * sfax8_fb_validate_win_bpp - validate the bits-per-pixel for this mode.
+ * @win: The device window.
+ * @bpp: The bit depth.
+ */
+static bool sfax8_fb_validate_win_bpp(struct sfax8_fb_win *win,
+				      unsigned int bpp)
+{
+	return win->valid_bpp & VALID_BPP(bpp);
+}
+
+static int sfax8_fb_bpp_mode_to_bpp(enum fb_bpp_mode mode)
+{
+	switch (mode) {
+	case rgb565:
+		return 16;
+	case rgb888:
+		return 32;
+	default:
+		return -EINVAL;
+	}
+}
+
+/**
+ * sfax8_fb_check_var() - framebuffer layer request to verify a given mode.
+ * @var: The screen information to verify.
+ * @info: The framebuffer device.
+ *
+ * Framebuffer layer call to verify the given information and allow us to
+ * update various information depending on the hardware capabilities.
+ */
+static int sfax8_fb_check_var(struct fb_var_screeninfo *var,
+			      struct fb_info *info)
+{
+	struct sfax8_fb_win *win = info->par;
+	struct sfax8_fb *sfb = win->parent;
+
+	dev_dbg(sfb->dev, "checking parameters\n");
+
+	var->xres_virtual = max(var->xres_virtual, var->xres);
+	var->yres_virtual = max(var->yres_virtual, var->yres);
+
+	if (!sfax8_fb_validate_win_bpp(win, var->bits_per_pixel)) {
+		dev_dbg(sfb->dev, "win %d: unsupported bpp %d\n", win->index,
+			var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	/* always ensure these are zero, for drop through cases below */
+	var->transp.offset = 0;
+	var->transp.length = 0;
+
+	switch (var->bits_per_pixel) {
+	case 19:
+		/* 666 with one bit alpha/transparency */
+		var->transp.offset = 18;
+		var->transp.length = 1;
+	/* drop through */
+	case 18:
+		/* 666 format */
+		var->red.offset = 12;
+		var->green.offset = 6;
+		var->blue.offset = 0;
+		var->red.length = 6;
+		var->green.length = 6;
+		var->blue.length = 6;
+		var->bits_per_pixel = 32;
+		break;
+
+	case 16:
+		/* 16 bpp, 565 format */
+		var->red.offset = 11;
+		var->green.offset = 5;
+		var->blue.offset = 0;
+		var->red.length = 5;
+		var->green.length = 6;
+		var->blue.length = 5;
+		break;
+
+	case 28:
+	case 25:
+		var->transp.length = var->bits_per_pixel - 24;
+		var->transp.offset = 24;
+	/* drop through */
+	case 24:
+	case 32:
+		var->red.offset = 16;
+		var->red.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->bits_per_pixel = 32;
+		break;
+
+	default:
+		dev_err(sfb->dev, "invalid bpp\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(sfb->dev, "%s: verified parameters\n", __func__);
+	return 0;
+}
+
+/**
+ * sfax8_fb_calc_pixclk() - calculate the divider to create the pixel clock.
+ * @sfb: The hardware state.
+ * @pixclock: The pixel clock wanted, in picoseconds.
+ *
+ * Given the specified pixel clock, work out the necessary divider to get
+ * close to the output frequency.
+ */
+static int sfax8_fb_calc_pixclk(struct sfax8_fb *sfb, unsigned int pixclk)
+{
+	unsigned long clk;
+	unsigned long long tmp;
+	unsigned int result;
+
+	clk = clk_get_rate(sfb->bus_clk);
+
+	tmp = (unsigned long long)clk;
+	tmp *= pixclk;
+
+	do_div(tmp, 1000000000UL);
+	result = (unsigned int)tmp / 1000;
+
+	dev_dbg(sfb->dev, "pixclk=%u, clk=%lu, div=%d (%lu)\n", pixclk, clk,
+		result, result ? clk / result : clk);
+
+	return result;
+}
+#if 0
+/**
+ * sfax8_fb_align_word() - align pixel count to word boundary
+ * @bpp: The number of bits per pixel
+ * @pix: The value to be aligned.
+ *
+ * Align the given pixel count so that it will start on an 32bit word
+ * boundary.
+ */
+static int sfax8_fb_align_word(unsigned int bpp, unsigned int pix)
+{
+	int pix_per_word;
+
+	if (bpp > 16)
+		return pix;
+
+	pix_per_word = (8 * 32) / bpp;
+	return ALIGN(pix, pix_per_word);
+}
+#endif
+
+/**
+ * sfax8_fb_enable() - Set the state of the main LCD output
+ * @sfb: The main framebuffer state.
+ * @enable: The state to set.
+ */
+static void sfax8_lcd_enable(struct sfax8_fb *sfb, int enable)
+{
+	u32 lcdcon1 = readl(sfb->regs + LCDCON1);
+
+	if (enable)
+		lcdcon1 |= 0x1 << LCDCON1_ENVID;
+	else
+		lcdcon1 &= ~(0x1 << LCDCON1_ENVID);
+
+	writel(lcdcon1, sfb->regs + LCDCON1);
+
+	sfb->output_on = enable;
+}
+
+/**
+ * sfax8_fb_set_alpha() - set alpha transparency for a window
+ *
+ * @win: the window to set alpha transparency for
+ * @alpha: alpha value
+ */
+static int sfax8_fb_set_alpha(struct sfax8_fb_win *win,
+			      struct sfax8_fb_alpha *alpha)
+{
+	struct sfax8_fb *sfb = win->parent;
+	u32 data;
+	u32 alpha_value;
+
+	/* only win 1 has alpha setting*/
+	if (win->index == 0)
+		return -EINVAL;
+
+	if (alpha->alpha_sel & (~1))
+		return -EINVAL;
+
+	sfax8_lcd_enable(sfb, 0);
+
+	data = readl(sfb->regs + OVCW1CR);
+	data &= ~(1 << ALPHA_SEL);
+	if (alpha->blend_category == per_plane) {
+		alpha_value = readl(sfb->regs + OVCW1PCCR);
+		data &= ~BLD_PIX;
+		if (alpha->alpha_sel == USING_ALPHA_1) {
+			alpha->alpha_1 &= 0xfff;
+			alpha_value &= ~(0xfff << ALPHA1_SHIFT);
+			alpha_value |= alpha->alpha_1 << ALPHA1_SHIFT;
+		} else if (alpha->alpha_sel == USING_ALPHA_0) {
+			alpha->alpha_0 &= 0xfff;
+			alpha_value &= ~(0xfff << ALPHA0_SHIFT);
+			alpha_value |= alpha->alpha_0 << ALPHA1_SHIFT;
+		}
+		writel(alpha_value, sfb->regs + OVCW1PCCR);
+	} else if (alpha->blend_category == per_pixel)
+		data |= BLD_PIX;
+
+	data |= (alpha->alpha_sel << ALPHA_SEL);
+	writel(data, sfb->regs + OVCW1CR);
+
+	sfax8_lcd_enable(sfb, 1);
+
+	return 0;
+}
+
+/**
+ * sfax8_fb_enable() - Set the state of the specific window.
+ * @sfb: The main framebuffer state.
+ * @enable: The state to set.
+ */
+static void sfax8_fb_enable(struct sfax8_fb_win *win, int enable)
+{
+	void __iomem *reg, *base = win->parent->regs;
+	int index = win->index;
+	u32 wincr;
+
+	reg = base + select_reg(OVCW0CR, OVCW1CR);
+
+	wincr = readl(reg);
+
+	if (enable) {
+		wincr |= OVCWxCR_ENWIN;
+	} else {
+		wincr &= ~OVCWxCR_ENWIN;
+	}
+
+	writel(wincr, reg);
+}
+
+static void sfax8_fb_set_win(struct fb_info *info)
+{
+	struct sfax8_fb_win *win = info->par;
+	struct sfax8_fb *sfb = win->parent;
+	struct fb_var_screeninfo *var = &info->var;
+	void __iomem *reg, *base = sfb->regs;
+	u32 data = 0;
+	int index = win->index;
+
+	/* set screen position */
+	data = (0 << LEFT_TOP_X_SHIFT) | (0 << LEFT_TOP_Y_SHIFT);
+	reg = base + select_reg(OVCW0PCAR, OVCW1PCAR);
+	writel(data, reg);
+	data = ((var->xres - 1) << RIGHT_BOT_X_SHIFT) |
+	       ((var->yres - 1) << RIGHT_BOT_Y_SHIFT);
+	reg = base + select_reg(OVCW0PCBR, OVCW1PCBR);
+	writel(data, reg);
+
+	/* set virtual screen page width in the unit of pixel */
+	reg = base + select_reg(OVCW0VSSR, OVCW1VSSR);
+	data = readl(reg);
+	data &= ~(0xffff << VW_WIDTH_SHIFT);
+	data |= var->xres_virtual << VW_WIDTH_SHIFT;
+	writel(data, reg);
+
+	data = sfb->bpp_mode << BPP_MODE_SHIFT;
+	data |= OVCWxCR_ENWIN;
+	reg = base + select_reg(OVCW0CR, OVCW1CR);
+	writel(data, reg);
+}
+
+/**
+ * sfax8_fb_set_par() - framebuffer request to set new framebuffer state.
+ * @info: The framebuffer to change.
+ *
+ * Framebuffer layer request to set a new mode for the specified framebuffer
+ */
+static int sfax8_fb_set_par(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	struct sfax8_fb_win *win = info->par;
+	struct sfax8_fb *sfb = win->parent;
+	void __iomem *regs = sfb->regs;
+
+	dev_dbg(sfb->dev, "setting framebuffer parameters\n");
+
+	/* disable lcd when change config */
+	sfax8_lcd_enable(sfb, 0);
+
+	switch (var->bits_per_pixel) {
+	case 32:
+	case 24:
+	case 16:
+	case 12:
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+		break;
+	case 8:
+		if (SFAX8_FB_PALETTE_SIZE >= 256)
+			info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+		else
+			info->fix.visual = FB_VISUAL_TRUECOLOR;
+		break;
+	case 1:
+		info->fix.visual = FB_VISUAL_MONO01;
+		break;
+	default:
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+		break;
+	}
+
+	info->fix.line_length = var->xres * var->bits_per_pixel / 8;
+
+	/* enable global parameter load */
+	writel(OVCDCR_LOAD_PARA_EN, regs + OVCDCR);
+
+	sfax8_fb_set_win(info);
+
+	if (!(sfb->enabled & (1 << win->index)))
+		sfax8_fb_enable(win, 1);
+
+	/* disable global parameter load */
+	// writel(0, regs + OVCDCR);
+
+	/* Enable for this window */
+	sfb->enabled |= (1 << win->index);
+
+	sfax8_lcd_enable(sfb, 1);
+
+	return 0;
+}
+
+/**
+ * sfax8_fb_update_palette() - set or schedule a palette update.
+ * @sfb: The hardware information.
+ * @win: The window being updated.
+ * @reg: The palette index being changed.
+ * @value: The computed palette value.
+ *
+ * Change the value of a palette register, either by directly writing to
+ * the palette (this requires the palette RAM to be disconnected from the
+ * hardware whilst this is in progress) or schedule the update for later.
+ *
+ * At the moment, since we have no VSYNC interrupt support, we simply set
+ * the palette entry directly.
+ */
+static void sfax8_fb_update_palette(struct sfax8_fb *sfb,
+				    struct sfax8_fb_win *win, unsigned int reg,
+				    u32 value)
+{
+	void __iomem *palreg;
+	u32 palcon;
+	int index = win->index;
+
+	palreg = sfb->regs + select_reg(OVCW1PAL, OVCW0PAL);
+
+	dev_dbg(sfb->dev, "%s: win %d, reg %d (%p): %08x\n", __func__,
+		win->index, reg, palreg, value);
+
+	palcon = readl(sfb->regs + OVCPCR);
+	writel(palcon | UPDATE_PAL, sfb->regs + OVCPCR);
+
+	writel(value, palreg + (reg * 4));
+
+	writel(palcon, sfb->regs + OVCPCR);
+}
+
+static inline unsigned int chan_to_field(unsigned int chan,
+					 struct fb_bitfield *bf)
+{
+	chan &= ((1 << bf->length) - 1);
+	return chan << bf->offset;
+}
+
+/**
+ * sfax8_fb_setcolreg() - framebuffer layer request to change palette.
+ * @regno: The palette index to change.
+ * @red: The red field for the palette data.
+ * @green: The green field for the palette data.
+ * @blue: The blue field for the palette data.
+ * @trans: The transparency (alpha) field for the palette data.
+ * @info: The framebuffer being changed.
+ */
+static int sfax8_fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			      unsigned blue, unsigned transp,
+			      struct fb_info *info)
+{
+	struct sfax8_fb_win *win = info->par;
+	struct sfax8_fb *sfb = win->parent;
+	unsigned int val;
+
+	dev_dbg(sfb->dev, "%s: win %d: %d => rgb=%d/%d/%d\n", __func__,
+		win->index, regno, red, green, blue);
+
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/* true-colour, use pseudo-palette */
+
+		if (regno < SFAX8_FB_PALETTE_SIZE) {
+			u32 *pal = info->pseudo_palette;
+
+			val = chan_to_field(red, &info->var.red);
+			val |= chan_to_field(green, &info->var.green);
+			val |= chan_to_field(blue, &info->var.blue);
+
+			pal[regno] = val;
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		if (regno < SFAX8_FB_PALETTE_SIZE) {
+			val = chan_to_field(red, &win->palette.r);
+			val |= chan_to_field(green, &win->palette.g);
+			val |= chan_to_field(blue, &win->palette.b);
+
+			sfax8_fb_update_palette(sfb, win, regno, val);
+		}
+
+		break;
+
+	default:
+		return 1; /* unknown type */
+	}
+
+	return 0;
+}
+
+/**
+ * sfax8_fb_blank() - blank or unblank the given window
+ * @blank_mode: The blank state from FB_BLANK_*
+ * @info: The framebuffer to blank.
+ *
+ * Framebuffer layer request to change the power state.
+ */
+static int sfax8_fb_blank(int blank_mode, struct fb_info *info)
+{
+	struct sfax8_fb_win *win = info->par;
+	struct sfax8_fb *sfb = win->parent;
+	unsigned int index = win->index;
+	void __iomem *reg;
+	u32 wincon;
+
+	dev_dbg(sfb->dev, "blank mode %d\n", blank_mode);
+
+	sfax8_lcd_enable(sfb, 0);
+
+	reg = sfb->regs + select_reg(OVCW0CR, OVCW1CR);
+	wincon = readl(reg);
+
+	switch (blank_mode) {
+	case FB_BLANK_POWERDOWN:
+		wincon &= ~OVCWxCR_ENWIN;
+		sfb->enabled &= ~(1 << index);
+	/* fall through to FB_BLANK_NORMAL */
+
+	case FB_BLANK_NORMAL:
+		/* disable the DMA and display 0x0 (black) */
+		writel(MAPCOLEN | MAP_COLOR(0x0),
+		       sfb->regs + select_reg(OVCW0CMR, OVCW1CMR));
+		break;
+
+	case FB_BLANK_UNBLANK:
+		writel(0x0, sfb->regs + select_reg(OVCW0CMR, OVCW1CMR));
+		wincon |= OVCWxCR_ENWIN;
+		sfb->enabled |= (1 << index);
+		break;
+
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	default:
+		return 1;
+	}
+
+	writel(wincon, reg);
+
+	sfax8_lcd_enable(sfb, sfb->enabled ? 1 : 0);
+
+	return 0;
+}
+
+/**
+ * sfax8_fb_pan_display() - Pan the display.
+ *
+ * Note that the offsets can be written to the device at any time, as their
+ * values are latched at each vsync automatically. This also means that only
+ * the last call to this function will have any effect on next vsync, but
+ * there is no need to sleep waiting for it to prevent tearing.
+ *
+ * @var: The screen information to verify.
+ * @info: The framebuffer device.
+ */
+static int sfax8_fb_pan_display(struct fb_var_screeninfo *var,
+				struct fb_info *info)
+{
+	struct sfax8_fb_win *win = info->par;
+	struct sfax8_fb *sfb = win->parent;
+	int index = win->index;
+	u32 left_top_x, left_top_y;
+	u32 right_bot_x, right_bot_y;
+	u32 reg_data;
+
+	/* change settings in PCAR and PCBR */
+	left_top_x = var->xoffset & 0xfff;
+	left_top_y = var->yoffset & 0xfff;
+	reg_data = (left_top_x << LEFT_TOP_X_SHIFT) |
+		   (left_top_y << LEFT_TOP_Y_SHIFT);
+	writel(reg_data, sfb->regs + select_reg(OVCW0PCAR, OVCW1PCAR));
+
+	right_bot_x = var->xoffset & 0xfff;
+	right_bot_y = var->yoffset & 0xfff;
+	reg_data = (right_bot_x << RIGHT_BOT_X_SHIFT) |
+		   (right_bot_y << RIGHT_BOT_Y_SHIFT);
+	writel(reg_data, sfb->regs + select_reg(OVCW0PCBR, OVCW1PCBR));
+
+	return 0;
+}
+
+/**
+ * sfax8_fb_enable_irq() - enable framebuffer interrupts
+ * @sfb: main hardware state
+ */
+static void sfax8_fb_enable_irq(struct sfax8_fb *sfb)
+{
+	void __iomem *regs = sfb->regs;
+	u32 irq_ctrl_reg;
+
+	if (!test_and_set_bit(SFAX8_FB_VSYNC_IRQ_EN, &sfb->irq_flags)) {
+		/* IRQ disabled, enable it */
+		irq_ctrl_reg = readl(regs + GDUINTMASK);
+
+		irq_ctrl_reg &= ~(OSDERRMASK | OSDW0INTMASK | OSDW1INTMASK |
+				  VCLKINTMASK | LCDINTMASK);
+
+		writel(irq_ctrl_reg, regs + GDUINTMASK);
+	}
+}
+
+/**
+ * sfax8_fb_disable_irq() - disable framebuffer interrupts
+ * @sfb: main hardware state
+ */
+static void sfax8_fb_disable_irq(struct sfax8_fb *sfb)
+{
+	void __iomem *regs = sfb->regs;
+	u32 irq_ctrl_reg;
+
+	if (test_and_clear_bit(SFAX8_FB_VSYNC_IRQ_EN, &sfb->irq_flags)) {
+		/* IRQ enabled, disable it */
+		irq_ctrl_reg = readl(regs + GDUINTMASK);
+
+		irq_ctrl_reg |= OSDERRMASK | OSDW0INTMASK | OSDW1INTMASK |
+				VCLKINTMASK | LCDINTMASK;
+
+		writel(irq_ctrl_reg, regs + GDUINTMASK);
+	}
+}
+
+static irqreturn_t sfax8_fb_irq(int irq, void *dev_id)
+{
+	struct sfax8_fb *sfb = dev_id;
+	void __iomem *regs = sfb->regs;
+	u32 irq_sts_reg;
+
+	spin_lock(&sfb->lock);
+
+	irq_sts_reg = readl(regs + GDUINTPND);
+
+	if (irq_sts_reg & LCDINT) {
+
+		/* VSYNC interrupt, accept it */
+		writel(LCDINT, regs + GDUSRCPND);
+		writel(LCDINT, regs + GDUINTPND);
+
+		sfb->vsync_info.count++;
+		wake_up_interruptible(&sfb->vsync_info.wait);
+	}
+
+	/* We only support waiting for VSYNC for now, so it's safe
+	 * to always disable irqs here.
+	 */
+	sfax8_fb_disable_irq(sfb);
+
+	spin_unlock(&sfb->lock);
+	return IRQ_HANDLED;
+}
+
+/**
+ * sfax8_fb_wait_for_vsync() - sleep until next VSYNC interrupt or timeout
+ * @sfb: main hardware state
+ * @crtc: head index.
+ */
+static int sfax8_fb_wait_for_vsync(struct sfax8_fb *sfb, u32 crtc)
+{
+	unsigned long count;
+	int ret;
+
+	if (crtc != 0)
+		return -ENODEV;
+
+	count = sfb->vsync_info.count;
+	sfax8_fb_enable_irq(sfb);
+	ret = wait_event_interruptible_timeout(
+	    sfb->vsync_info.wait, count != sfb->vsync_info.count,
+	    msecs_to_jiffies(VSYNC_TIMEOUT_MSEC));
+
+	if (ret == 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int sfax8_fb_ioctl(struct fb_info *info, unsigned int cmd,
+			  unsigned long arg)
+{
+	struct sfax8_fb_win *win = info->par;
+	struct sfax8_fb *sfb = win->parent;
+	void __user *argp = (void __user *)arg;
+	struct sfax8_fb_alpha alpha;
+	int ret = 0;
+	u32 crtc;
+
+	switch (cmd) {
+	case FBIO_WAITFORVSYNC:
+		if (get_user(crtc, (u32 __user *)arg)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = sfax8_fb_wait_for_vsync(sfb, crtc);
+		break;
+	case SFFB_PUT_ALPHA:
+		if (copy_from_user(&alpha, argp, sizeof(alpha))) {
+			ret = -EFAULT;
+			break;
+		}
+		ret = sfax8_fb_set_alpha(win, &alpha);
+		break;
+	default:
+		ret = -ENOTTY;
+	}
+
+	return ret;
+}
+
+static struct fb_ops sfax8_fb_ops = {
+    .owner = THIS_MODULE,
+    .fb_check_var = sfax8_fb_check_var,
+    .fb_set_par = sfax8_fb_set_par,
+    .fb_blank = sfax8_fb_blank,
+    .fb_setcolreg = sfax8_fb_setcolreg,
+    .fb_fillrect = sys_fillrect,
+    .fb_copyarea = sys_copyarea,
+    .fb_imageblit = sys_imageblit,
+    .fb_pan_display = sfax8_fb_pan_display,
+    .fb_ioctl = sfax8_fb_ioctl,
+};
+
+/**
+ * sfax8_fb_missing_pixclock() - calculates pixel clock
+ * @mode: The video mode to change.
+ *
+ * Calculate the pixel clock when none has been given through platform data.
+ */
+static void sfax8_fb_missing_pixclock(struct fb_videomode *mode)
+{
+	u64 pixclk = 1000000000000ULL;
+	u32 div;
+
+	div = mode->left_margin + mode->hsync_len + mode->right_margin +
+	      mode->xres;
+	div *= mode->upper_margin + mode->vsync_len + mode->lower_margin +
+	       mode->yres;
+	div *= mode->refresh ?: 60;
+
+	do_div(pixclk, div);
+
+	mode->pixclock = pixclk;
+}
+
+/**
+ * sfax8_fb_alloc_memory() - allocate display memory for framebuffer window
+ * @sfb: The base resources for the hardware.
+ * @win: The window to initialise memory for.
+ *
+ * Allocate memory for the given framebuffer.
+ */
+static int sfax8_fb_alloc_memory(struct sfax8_fb *sfb, struct sfax8_fb_win *win)
+{
+	struct fb_videomode *vmode = &sfb->vtiming;
+	struct fb_info *fbi = win->fbinfo;
+	int index = win->index;
+	unsigned int size;
+	dma_addr_t map_dma;
+
+	dev_dbg(sfb->dev, "allocating memory for display\n");
+	dev_dbg(sfb->dev, "size = %u * %u\n", vmode->xres, vmode->yres);
+
+	size = vmode->xres * vmode->yres * sizeof(u32);
+	dev_dbg(sfb->dev, "want %u bytes for window\n", size);
+
+	fbi->screen_base =
+	    dma_alloc_noncoherent(sfb->dev, size, &map_dma, GFP_KERNEL);
+	if (!fbi->screen_base) {
+		dev_err(sfb->dev, "alloc graphic memory failed!\n");
+		return -ENOMEM;
+	}
+	dev_dbg(sfb->dev, "screen_base = %p\n", fbi->screen_base);
+	writel((u32)fbi->screen_base,
+	       sfb->regs + select_reg(OVCW0B0SAR, OVCW1B0SAR));
+
+	fbi->fix.smem_len = size;
+	fbi->fix.smem_start = map_dma;
+
+	return 0;
+}
+
+/**
+ * sfax8_fb_release_win() - release resources for a framebuffer window.
+ * @win: The window to cleanup the resources for.
+ *
+ * Release the resources that where claimed for the hardware window,
+ * such as the framebuffer instance and any memory claimed for it.
+ */
+static void sfax8_fb_release_win(struct sfax8_fb *sfb, struct sfax8_fb_win *win)
+{
+	struct fb_info *info = win->fbinfo;
+
+	if (info) {
+		unregister_framebuffer(info);
+		if (info->cmap.len)
+			fb_dealloc_cmap(&info->cmap);
+		if (info->screen_base)
+			dma_free_noncoherent(sfb->dev, info->fix.smem_len,
+					     info->screen_base,
+					     info->fix.smem_start);
+		framebuffer_release(info);
+	}
+}
+
+/**
+ * sfax8_fb_probe_win() - register an hardware window
+ * @sfb: The base resources for the hardware
+ * @variant: The variant information for this window.
+ * @res: Pointer to where to place the resultant window.
+ *
+ * Allocate and do the basic initialisation for one of the hardware's graphics
+ * windows.
+ */
+static int sfax8_fb_probe_win(struct sfax8_fb *sfb, unsigned int index,
+			      struct sfax8_fb_win **res)
+{
+	struct fb_var_screeninfo *var;
+	struct sfax8_fb_win *win;
+	struct fb_info *fbinfo;
+	int ret;
+
+	dev_dbg(sfb->dev, "probing window %d\n", index);
+
+	init_waitqueue_head(&sfb->vsync_info.wait);
+
+	fbinfo = framebuffer_alloc(sizeof(struct sfax8_fb_win), sfb->dev);
+	if (!fbinfo) {
+		dev_err(sfb->dev, "failed to allocate framebuffer\n");
+		return -ENOENT;
+	}
+
+	win = fbinfo->par;
+	*res = win;
+	var = &fbinfo->var;
+	win->fbinfo = fbinfo;
+	win->parent = sfb;
+	win->index = index;
+	/*win->valid_bpp = VALID_BPP1248 | VALID_BPP(16) | VALID_BPP(18) |
+			 VALID_BPP(19) | VALID_BPP(24) | VALID_BPP(25) |
+			 VALID_BPP(28);*/
+	win->valid_bpp = VALID_BPP(16) | VALID_BPP(32);
+
+	ret = sfax8_fb_alloc_memory(sfb, win);
+	if (ret) {
+		dev_err(sfb->dev, "failed to allocate display memory\n");
+		return ret;
+	}
+
+	/* setup the r/b/g positions for the window's palette */
+	/* Set RGB 888 as default */
+	win->palette.r.offset = 16;
+	win->palette.r.length = 8;
+	win->palette.g.offset = 8;
+	win->palette.g.length = 8;
+	win->palette.b.offset = 0;
+	win->palette.b.length = 8;
+
+	/* setup the initial video mode from the window */
+	fb_videomode_to_var(&fbinfo->var, &sfb->vtiming);
+
+	fbinfo->fix.type = FB_TYPE_PACKED_PIXELS;
+	fbinfo->fix.accel = FB_ACCEL_NONE;
+	fbinfo->fix.xpanstep = 1;
+	fbinfo->fix.ypanstep = 1;
+	fbinfo->var.activate = FB_ACTIVATE_NOW;
+	fbinfo->var.vmode = FB_VMODE_NONINTERLACED;
+	fbinfo->var.bits_per_pixel = sfax8_fb_bpp_mode_to_bpp(sfb->bpp_mode);
+	fbinfo->fbops = &sfax8_fb_ops;
+	fbinfo->flags = FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+	fbinfo->pseudo_palette = &win->pseudo_palette;
+
+	snprintf(fbinfo->fix.id, 16, "Siflower FB%d", index);
+
+	/* prepare to actually start the framebuffer */
+	ret = sfax8_fb_check_var(&fbinfo->var, fbinfo);
+	if (ret < 0) {
+		dev_err(sfb->dev, "check_var failed on initial video params\n");
+		return ret;
+	}
+
+	/* create initial colour map */
+	ret = fb_alloc_cmap(&fbinfo->cmap, SFAX8_FB_PALETTE_SIZE, 1);
+	if (ret == 0)
+		fb_set_cmap(&fbinfo->cmap, fbinfo);
+	else
+		dev_err(sfb->dev, "failed to allocate fb cmap\n");
+
+	sfax8_fb_set_par(fbinfo);
+
+	dev_dbg(sfb->dev, "about to register framebuffer\n");
+
+	/* run the check_var and set_par on our configuration. */
+
+	ret = register_framebuffer(fbinfo);
+	if (ret < 0) {
+		dev_err(sfb->dev, "failed to register framebuffer\n");
+		return ret;
+	}
+
+#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)
+	if (index == 0)
+		if (fb_prepare_logo(fbinfo, FB_ROTATE_UR)) {
+			/* Start display and show logo on boot */
+			fb_show_logo(fbinfo, FB_ROTATE_UR);
+		}
+#endif
+
+	dev_info(sfb->dev, "window %d: fb %s\n", index, fbinfo->fix.id);
+
+	return 0;
+}
+
+/**
+ * sfax8_fb_set_rgb_timing() - set video timing for rgb interface.
+ * @sfb: The base resources for the hardware.
+ *
+ * Set horizontal and vertical lcd rgb interface timing.
+ */
+static void sfax8_fb_set_rgb_timing(struct sfax8_fb *sfb)
+{
+	struct fb_videomode *vmode = &sfb->vtiming;
+	void __iomem *regs = sfb->regs;
+	int clkdiv;
+	u32 data;
+
+	/* disable auto frequency conversion */
+	data = readl(regs + LCDVCLKFSR);
+	data |= 0xf << LCDVCLKFSR_CDOWN;
+	writel(data, regs + LCDVCLKFSR);
+
+	if (!vmode->pixclock)
+		sfax8_fb_missing_pixclock(vmode);
+
+	clkdiv = sfax8_fb_calc_pixclk(sfb, vmode->pixclock);
+	writel((clkdiv - 1) << LCDCON1_CLKVAL, regs + LCDCON1);
+
+	data = ((vmode->lower_margin - 1) << LCDCON2_VFPD) |
+	       ((vmode->upper_margin - 1) << LCDCON2_VBPD);
+	writel(data, regs + LCDCON2);
+
+	data = ((vmode->hsync_len - 1) << LCDCON3_HSPW) |
+	       ((vmode->vsync_len - 1) << LCDCON3_VSPW);
+	writel(data, regs + LCDCON3);
+
+	data = ((vmode->left_margin - 2) << LCDCON4_HBPD) |
+	       (vmode->right_margin << LCDCON4_HFPD);
+	writel(data, regs + LCDCON4);
+
+	data = readl(regs + LCDCON5);
+	if (vmode->sync & FB_SYNC_HOR_HIGH_ACT)
+		data &= ~LCDCON5_INVHSYNC;
+	else
+		data |= LCDCON5_INVHSYNC;
+	if (vmode->sync & FB_SYNC_VERT_HIGH_ACT)
+		data &= ~LCDCON5_INVVSYNC;
+	else
+		data |= LCDCON5_INVVSYNC;
+	writel(data, regs + LCDCON5);
+
+	data = ((vmode->xres - 1) << LCDCON6_HOZVAL) |
+	       ((vmode->yres - 1) << LCDCON6_LINEVAL);
+	writel(data, regs + LCDCON6);
+}
+
+static int sfax8_fb_set_gpio(struct sfax8_fb *sfb)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		ret = gpio_request(sfb->power_gpio[i], NULL);
+		if (ret) {
+			dev_err(sfb->dev, "Failed to request gpio %d\n",
+				sfb->power_gpio[i]);
+			return ret;
+		}
+
+		ret = gpio_direction_output(sfb->power_gpio[i], 1);
+		if (ret) {
+			dev_err(sfb->dev, "Failed to set gpio %d to output\n",
+				sfb->power_gpio[i]);
+			gpio_free(sfb->power_gpio[i]);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void sfax8_fb_free_gpio(struct sfax8_fb *sfb)
+{
+	int i;
+
+	for (i = 0; i < 2; i++)
+		gpio_free(sfb->power_gpio[i]);
+}
+
+static const char *const fb_bpp_modes[] = {
+	[rgb565]		= "RGB565",
+	[rgb888]		= "RGB888",
+	[bpp_mode_unknown]	= "",
+};
+
+static enum fb_bpp_mode sfax8_fb_get_bpp_mode(struct sfax8_fb *sfb, const char *mode)
+{
+	int index, ret;
+	const char *item;
+
+	ret = -EINVAL;
+
+	for (index = 0; index < ARRAY_SIZE(fb_bpp_modes); index++) {
+		item = fb_bpp_modes[index];
+		if (!item) {
+			continue;
+		}
+		if (!strcmp(item, mode)) {
+			ret = index;
+			break;
+		}
+	}
+
+	return (ret < 0) ? bpp_mode_unknown : ret;
+}
+
+static int sfax8_fb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sfax8_fb *sfb;
+	struct device_node *nc;
+	struct resource *res;
+	int win, irq, rgb_order[3];
+	int ret = 0;
+	u32 reg_data;
+	const char *mode;
+
+	if(release_reset(SF_GDU_SOFT_RESET))
+		return -EFAULT;
+
+	nc = pdev->dev.of_node;
+	if (!nc)
+		return -ENODEV;
+
+	sfb = devm_kzalloc(dev, sizeof(struct sfax8_fb), GFP_KERNEL);
+	if (!sfb) {
+		dev_err(dev, "no memory for framebuffers\n");
+		return -ENOMEM;
+	}
+
+	dev_dbg(dev, "allocate new framebuffer %p\n", sfb);
+
+	sfb->dev = dev;
+
+	spin_lock_init(&sfb->lock);
+
+	if (of_property_read_u32(nc, "num-windows", &sfb->num_windows)) {
+		dev_err(dev, "%s has no valid 'num-windows' property\n",
+			nc->full_name);
+		return -EINVAL;
+	}
+
+	ret = of_get_fb_videomode(nc, &sfb->vtiming, 0);
+	if (ret) {
+		dev_err(dev, "Failed to get video mode\n");
+		return -EINVAL;
+	}
+
+	sfb->bus_clk = of_clk_get(dev->of_node, 0);
+	if (IS_ERR(sfb->bus_clk)) {
+		dev_err(dev, "failed to get framebuffer bus clock\n");
+		return PTR_ERR(sfb->bus_clk);
+	}
+	sfb->lcd_clk = of_clk_get(dev->of_node, 1);
+	if (IS_ERR(sfb->lcd_clk)) {
+		dev_err(dev, "failed to get framebuffer lcd clock\n");
+		return PTR_ERR(sfb->lcd_clk);
+	}
+
+	clk_prepare_enable(sfb->bus_clk);
+	clk_prepare_enable(sfb->lcd_clk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sfb->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(sfb->regs)) {
+		ret = PTR_ERR(sfb->regs);
+		goto err_gpio;
+	}
+
+	reg_data = readl(sfb->regs + LCDCON5);
+	if (of_property_read_string(nc, "bpp-mode", &mode) || (!mode)) {
+		dev_err(dev, "failed to get bpp-mode\n");
+		ret = -EINVAL;
+		goto err_gpio;
+	}
+	sfb->bpp_mode = sfax8_fb_get_bpp_mode(sfb, mode);
+	if ((sfb->bpp_mode < 0) || (sfb->bpp_mode == bpp_mode_unknown)) {
+		dev_err(dev, "unknown bpp mode\n");
+		ret = -EINVAL;
+		goto err_gpio;
+	}
+	if (sfb->bpp_mode == rgb565) {
+		sfb->is_rgb565_interface = 1;
+		reg_data |= LCDCON5_RGB565IF;
+	}
+
+	if (of_property_read_u32_array(nc, "rgb_order", rgb_order, 3)) {
+		dev_err(dev, "failed to get rgb_order\n");
+		ret = -EINVAL;
+		goto err_gpio;
+	}
+	sfb->rgb_order = rgb_order[0] | (rgb_order[1] << 2) |
+			(rgb_order[2] << 4);
+	reg_data &= ~(0x3f << LCDCON5_RGBORDER);
+	reg_data |= sfb->rgb_order << LCDCON5_RGBORDER;
+
+	writel(reg_data, sfb->regs + LCDCON5);
+
+	if (of_property_read_u32_array(nc, "power_gpio", sfb->power_gpio,
+				       2)) {
+		dev_err(dev, "failed to get power_gpio\n");
+		ret = -EINVAL;
+		goto err_gpio;
+	}
+	if (sfax8_fb_set_gpio(sfb)) {
+		dev_err(dev, "set gpio fail\n");
+		ret = -ENODEV;
+		goto err_gpio;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "failed to get irq resource\n");
+		ret = -ENOENT;
+		goto err_irq;
+	}
+	sfb->irq_num = irq;
+	ret = devm_request_irq(dev, sfb->irq_num, sfax8_fb_irq, 0, "sfax8_fb",
+			       sfb);
+	if (ret) {
+		dev_err(dev, "irq request failed\n");
+		goto err_irq;
+	}
+
+	dev_dbg(dev, "got resources (regs %p), probing windows\n", sfb->regs);
+
+	platform_set_drvdata(pdev, sfb);
+
+	/* initialise colour key controls */
+	writel(0, sfb->regs + OVCW1CKCR);
+
+	sfax8_fb_set_rgb_timing(sfb);
+
+	/* we have the register setup, start allocating framebuffers */
+	for (win = 0; win < sfb->num_windows; win++) {
+		ret = sfax8_fb_probe_win(sfb, win, &sfb->windows[win]);
+		if (ret < 0) {
+			dev_err(dev, "failed to create window %d\n", win);
+			for (; win >= 0; win--)
+				sfax8_fb_release_win(sfb, sfb->windows[win]);
+			goto err_win;
+		}
+	}
+
+	/* enable LCD */
+	sfax8_lcd_enable(sfb, 1);
+
+	return 0;
+
+err_win:
+err_irq:
+	sfax8_fb_free_gpio(sfb);
+err_gpio:
+	clk_disable_unprepare(sfb->bus_clk);
+	clk_disable_unprepare(sfb->lcd_clk);
+
+	return ret;
+}
+
+/**
+ * sfax8_fb_remove() - Cleanup on module finalisation
+ * @pdev: The platform device we are bound to.
+ *
+ * Shutdown and then release all the resources that the driver allocated
+ * on initialisation.
+ */
+static int sfax8_fb_remove(struct platform_device *pdev)
+{
+	struct sfax8_fb *sfb = platform_get_drvdata(pdev);
+	int win, i;
+
+	for (win = 0; win < SFAX8_FB_MAX_WIN; win++)
+		if (sfb->windows[win])
+			sfax8_fb_release_win(sfb, sfb->windows[win]);
+
+	clk_disable_unprepare(sfb->bus_clk);
+	clk_disable_unprepare(sfb->lcd_clk);
+
+	for (i = 0; i < 2; i++)
+		gpio_free(sfb->power_gpio[i]);
+
+	if(hold_reset(SF_GDU_SOFT_RESET))
+		return -EFAULT;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int sfax8_fb_suspend(struct device *dev)
+{
+	struct sfax8_fb *sfb = dev_get_drvdata(dev);
+	struct sfax8_fb_win *win;
+	int index;
+
+	for (index = SFAX8_FB_MAX_WIN - 1; index >= 0; index--) {
+		win = sfb->windows[index];
+		if (!win)
+			continue;
+
+		/* use the blank function to push into power-down */
+		sfax8_fb_blank(FB_BLANK_POWERDOWN, win->fbinfo);
+	}
+
+	clk_disable_unprepare(sfb->bus_clk);
+	clk_disable_unprepare(sfb->lcd_clk);
+
+	return 0;
+}
+
+static int sfax8_fb_resume(struct device *dev)
+{
+	struct sfax8_fb *sfb = dev_get_drvdata(dev);
+	struct sfax8_fb_win *win;
+	int index;
+
+	clk_prepare_enable(sfb->bus_clk);
+	clk_prepare_enable(sfb->lcd_clk);
+
+	sfax8_fb_set_rgb_timing(sfb);
+
+	/* restore framebuffers */
+	for (index = 0; index < SFAX8_FB_MAX_WIN; index++) {
+		win = sfb->windows[index];
+		if (!win)
+			continue;
+
+		dev_dbg(dev, "resuming window %d\n", index);
+		sfax8_fb_set_par(win->fbinfo);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int sfax8_fb_runtime_suspend(struct device *dev)
+{
+	struct sfax8_fb *sfb = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(sfb->bus_clk);
+	clk_disable_unprepare(sfb->lcd_clk);
+
+	return 0;
+}
+
+static int sfax8_fb_runtime_resume(struct device *dev)
+{
+	struct sfax8_fb *sfb = dev_get_drvdata(dev);
+	struct sfax8_fb_platdata *pd = sfb->pdata;
+
+	clk_prepare_enable(sfb->bus_clk);
+	clk_prepare_enable(sfb->lcd_clk);
+
+	return 0;
+}
+#endif
+
+static const struct of_device_id sfax8_fb_of_match[] = {
+    {
+	.compatible = "siflower,sfax8-fb",
+    },
+    {},
+};
+MODULE_DEVICE_TABLE(of, sfax8_fb_of_match);
+
+static const struct dev_pm_ops sfax8_fb_pm_ops = {
+    SET_SYSTEM_SLEEP_PM_OPS(sfax8_fb_suspend, sfax8_fb_resume)
+	SET_RUNTIME_PM_OPS(sfax8_fb_runtime_suspend, sfax8_fb_runtime_resume,
+			   NULL)};
+
+static struct platform_driver sfax8_fb_driver = {
+    .probe = sfax8_fb_probe,
+    .remove = sfax8_fb_remove,
+    .driver =
+	{
+	    .name = "sfax8-fb",
+	    .of_match_table = sfax8_fb_of_match,
+	    .owner = THIS_MODULE,
+	    .pm = &sfax8_fb_pm_ops,
+	},
+};
+module_platform_driver(sfax8_fb_driver);
+
+MODULE_AUTHOR("Qi Zhang <qi.zhang@siflower.com.cn>");
+MODULE_DESCRIPTION("Siflower Ax8 Serials SoC Framebuffer Driver");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/include/uapi/video/Kbuild
===================================================================
--- linux-3.18.29.orig/include/uapi/video/Kbuild	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/include/uapi/video/Kbuild	2017-11-21 20:13:12.470710527 +0800
@@ -1,4 +1,5 @@
 # UAPI Header export list
 header-y += edid.h
+header-y += sfax8fb.h
 header-y += sisfb.h
 header-y += uvesafb.h
Index: linux-3.18.29/include/uapi/video/sfax8fb.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/uapi/video/sfax8fb.h	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,75 @@
+#ifndef _UAPI_SFAX8_FB_H
+#define _UAPI_SFAX8_FB_H
+
+#include <linux/types.h>
+#include <asm/ioctl.h>
+
+struct fb_fillrect;
+
+enum fb_bpp_mode {
+	pallet_1_bpp = 0,
+	pallet_2_bpp = 1,
+	pallet_4_bpp = 2,
+	pallet_8_bpp = 3,
+	a1_rgb232    = 4,
+	rgb565       = 5,
+	a1_rgb555    = 6,
+	i1_rgb555    = 7,
+	rgb666       = 8,
+	a1_rgb665    = 9,
+	a1_rgb666    = 10,
+	rgb888       = 11,
+	a1_rgb887    = 12,
+	a1_rgb888    = 13,
+	a4_rgb888    = 14,
+	a4_rgb444    = 15,
+	a8_rgb888    = 16,
+	ycbcr_420    = 17,
+	rgb888_a8    = 18,
+	rgb555_a1    = 19,
+	rgb555_i1    = 20,
+	bpp_mode_unknown = 21,
+};
+
+enum blend_category {
+	per_plane,
+	per_pixel,
+};
+
+struct sfax8_fb_alpha {
+	enum blend_category blend_category;
+
+	/* When Per plane blending case( blend_category == per_plane)
+	 *	0 = using alpha_0 values
+	 *	1 = using alpha_1 values
+	 * When Per pixel blending ( blend_category == per_pixel)
+	 *	0 = selected by AEN (A value) or Chroma key
+	 *	1 = using DATA[27:24] data (when BPPMODE=a4_rgb888
+	 *	    &a4_rgb444), using DATA[31:24] data (when
+	 *	    BPPMODE=a8_rgb888)
+	 */
+#define USING_ALPHA_0 0
+#define USING_ALPHA_1 1
+#define USING_AEN 0
+#define USING_DATA_BITS 1
+	__u8 alpha_sel;
+
+	/* used when blend_category == per_plane, and has no meaning
+	 * when blend_category == per_pixel
+	 * alpha_0/1[8:11] = Red alpha value
+	 * alpha_0/1[4:7] = Green alpha value
+	 * alpha_0/1[0:3] = Blue alpha value
+	 */
+#define ALPHA(r, g, b) ((((r) & 0xf) << 8) | \
+			(((g) & 0xf) << 4) | \
+			(((b) & 0xf) << 0))
+	__u16 alpha_0;
+	__u16 alpha_1;
+};
+
+/* sfax8 framebuffer ioctls */
+#define SFFB_GET_ALPHA	_IOR('F', 0x40, struct sfax8_fb_alpha)
+#define SFFB_PUT_ALPHA	_IOW('F', 0x41, struct sfax8_fb_alpha)
+#define SFFB_FILLRECT	_IOW('F', 0x42, struct fb_fillrect)
+
+#endif
Index: linux-3.18.29/include/video/sfax8_fb.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/video/sfax8_fb.h	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,145 @@
+/*
+ * include/video/sfax8_fb.h
+ *
+ * Platform data header for Siflower Ax8 serials Soc frame buffer
+ *
+ * Copyright (c) 2017 Shanghai Siflower Communication Technology Co., Ltd.
+ *
+ * Qi Zhang <qi.zhang@siflower.com.>
+ */
+
+#ifndef __SFAX8_FB_H_
+#define __SFAX8_FB_H_
+
+#include <uapi/video/sfax8fb.h>
+
+#define GDU0_REG(x)		(x)
+#define OVCDCR			GDU0_REG(0x1000)
+#define OVCPCR			GDU0_REG(0x1004)
+#define OVCBKCOLOR		GDU0_REG(0x1008)
+#define OVCWPR			GDU0_REG(0x100c)
+#define OVCW0CR			GDU0_REG(0x1080)
+#define OVCW0PCAR		GDU0_REG(0x1084)
+#define OVCW0PCBR		GDU0_REG(0x1088)
+#define OVCW0VSSR		GDU0_REG(0x108c)
+#define OVCW0CMR		GDU0_REG(0x1090)
+#define OVCW0B0SAR		GDU0_REG(0x1094)
+#define OVCW0B1SAR		GDU0_REG(0x1098)
+#define OVCW0B2SAR		GDU0_REG(0x109c)
+#define OVCW0B3SAR		GDU0_REG(0x10a0)
+#define OVCW1CR			GDU0_REG(0x1100)
+#define OVCW1PCAR		GDU0_REG(0x1104)
+#define OVCW1PCBR		GDU0_REG(0x1108)
+#define OVCW1PCCR		GDU0_REG(0x110c)
+#define OVCW1VSSR		GDU0_REG(0x1110)
+#define OVCW1CKCR		GDU0_REG(0x1114)
+#define OVCW1CKR		GDU0_REG(0x1118)
+#define OVCW1CMR		GDU0_REG(0x111c)
+#define OVCW1B0SAR		GDU0_REG(0x1120)
+#define OVCW1B1SAR		GDU0_REG(0x1124)
+#define OVCW1B2SAR		GDU0_REG(0x1128)
+#define OVCW1B3SAR		GDU0_REG(0x112c)
+#define OVCW0PAL		GDU0_REG(0x1400)
+#define OVCW1PAL		GDU0_REG(0x1800)
+
+// osd offset
+#define OVCDCR_LOAD_PARA_EN     BIT(11)
+#define OVCDCR_IFTYPE		(1)
+#define OVCWxCR_ENWIN		BIT(0)
+
+#define OVCOMC_ToRGB		(31)
+#define OVCOMC_oft_b		(8)
+#define OVCOMC_oft_a		(0)
+#define BUFAUTOEN		BIT(16)
+#define BUFSEL_SHIFT		17
+#define BUF_NUM_SHIFT		14
+#define RBEXG			BIT(6)
+#define BPP_MODE_SHIFT		1
+#define LEFT_TOP_Y_SHIFT	16
+#define LEFT_TOP_X_SHIFT	0
+#define RIGHT_BOT_Y_SHIFT	16
+#define RIGHT_BOT_X_SHIFT	0
+#define VW_WIDTH_SHIFT          0
+#define MAPCOLEN		BIT(24)
+#define MAP_COLOR(color)	((color) << 0)
+
+#define UPDATE_PAL              BIT(15)
+#define W1PALFM                 3
+#define W0PALFM                 0
+#define ALPHA_SEL		(8)
+#define BLD_PIX			BIT(7)
+#define ALPHA0_SHIFT		12
+#define ALPHA1_SHIFT		0
+#define KEYBLEN			BIT(26)
+#define KEYEN			BIT(25)
+#define DIRCON			BIT(24)
+#define COMPKEY_SHIFT		0
+
+// lcd reg & offset
+#define LCDCON1			GDU0_REG(0x000) //LCD control 1
+#define LCDCON2			GDU0_REG(0x004) //LCD control 2
+#define LCDCON3			GDU0_REG(0x008) //LCD control 3
+#define LCDCON4			GDU0_REG(0x00c) //LCD control 4
+#define LCDCON5			GDU0_REG(0x010) //LCD control 5
+#define LCDCON6			GDU0_REG(0x018)
+#define LCDVCLKFSR		GDU0_REG(0x030)
+#define GDUINTPND		GDU0_REG(0x054) //LCD Interrupt pending
+#define GDUSRCPND		GDU0_REG(0x058) //LCD Interrupt source
+#define GDUINTMASK		GDU0_REG(0x05c) //LCD Interrupt mask
+
+/* interrupt bits */
+#define OSDERR			BIT(4)
+#define OSDERRMASK		BIT(4)
+#define OSDW1INT		BIT(3)
+#define OSDW1INTMASK		BIT(3)
+#define OSDW0INT		BIT(2)
+#define OSDW0INTMASK		BIT(2)
+#define VCLKINT			BIT(1)
+#define VCLKINTMASK		BIT(1)
+#define LCDINT			BIT(0)
+#define LCDINTMASK		BIT(0)
+
+/* LCD control register 1 */
+#define LCDCON1_LINECNT 18 // [29:18]
+#define LCDCON1_CLKVAL 8   // [17:8]
+#define LCDCON1_VMMODE 7	 // [7:7]
+#define LCDCON1_PNRMODE 5
+#define LCDCON1_STNBPP 1
+#define LCDCON1_ENVID 0 // [0:0]
+
+#define LCDCON2_VBPD 16 // [26:16]
+#define LCDCON2_VFPD 0  // [10:0]
+
+#define LCDCON3_VSPW 16 // [26:16]
+#define LCDCON3_HSPW 0  // [10:0]
+
+#define LCDCON4_HBPD 16 // [26:16]
+#define LCDCON4_HFPD 0  // [10:0]
+
+#define LCDCON5_RGB565IF BIT(31)
+#define LCDCON5_RGBORDER 24    // [29:24]
+#define LCDCON5_CONFIGORDER 20 // [22:20] 0->dsi24bpp, 1->dsi16bpp1, 2->dsi16bpp2,3->dsi16bpp3,4->dsi18bpp1,5->dsi18bpp2
+#define LCDCON5_VSTATUS 15     // [16:15]
+#define LCDCON5_HSTATUS 13     // [14:13]
+#define LCDCON5_DSPTYPE 11     // [12:11]
+#define LCDCON5_INVVCLK BIT(10)     // [10:10]
+#define LCDCON5_INVHSYNC BIT(9)     // [9:9]
+#define LCDCON5_INVVSYNC BIT(8)    // [8:8]
+#define LCDCON5_INVVD BIT(7)	// [7:7]
+#define LCDCON5_INVVDEN BIT(6)      // [6:6]
+#define LCDCON5_INVPWREN BIT(5)     // [5:5]
+#define LCDCON5_PWREN BIT(3)	// [3:3]
+
+#define LCDCON6_LINEVAL 16 // [26:16]
+#define LCDCON6_HOZVAL 0   // [10:0]
+
+#define LCDVCLKFSR_CDOWN 24
+
+#define DATASIGMAPPING_RGB 0x6  // [5:4]2b'00, [3:2]2b'01, [1:0]2b'10. RGB
+#define DATASIGMAPPING_RBG 0x9  // [5:4]2b'00, [3:2]2b'10, [1:0]2b'01. RBG
+#define DATASIGMAPPING_GRB 0x12 // [5:4]2b'01, [3:2]2b'00, [1:0]2b'10. GRB
+#define DATASIGMAPPING_GBR 0x18 // [5:4]2b'01, [3:2]2b'10, [1:0]2b'00. GBR
+#define DATASIGMAPPING_BRG 0x21 // [5:4]2b'10, [3:2]2b'00, [1:0]2b'01. BRG
+#define DATASIGMAPPING_BGR 0x24 // [5:4]2b'10, [3:2]2b'01, [1:0]2b'00. BGR
+
+#endif
Index: linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw0_p10_rn5t567.dts
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/boot/dts/sf16a18_mpw0_p10_rn5t567.dts	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,279 @@
+/dts-v1/;
+
+#include "sf16a18_mpw0.dtsi"
+
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "siflower,sf16a18-soc";
+};
+
+&ethernet {
+	status = "okay";
+};
+
+&switch{
+	status = "okay";
+};
+
+&gmac {
+	status = "okay";
+};
+
+&gdma {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pmu@36 {
+		compatible = "siflower, sfax8-pmu";
+		reg = <0x36>;
+
+        reset-button {
+			rb-gpio = <&gpio 60 0>;
+			led-gpio = <&gpio 57 0>;
+			};
+
+		power-management{
+			dcdc1-supply = <&dcdc1>;
+			dcdc1-maxv = <3300000>;
+
+			dcdc2-supply = <&dcdc2>;
+			dcdc2-maxv = <2700000>;
+
+			dcdc3-supply = <&core>;
+			dcdc3-maxv = <1000000>;
+			dcdc3-default-uv = <825000>;
+
+			dcdc4-supply = <&dcdc4>;
+			dcdc4-maxv = <1500000>;
+
+			ldo1-supply  = <&ldo1>;
+			ldo1-maxv = <1800000>;
+
+			ldo2-supply  = <&ldo2>;
+			ldo2-maxv = <1800000>;
+
+			ldo3-supply  = <&ldo3>;
+			ldo3-maxv = <600000>;
+
+			ldo4-supply  = <&ldo4>;
+			ldo4-maxv = <900000>;
+
+			ldo5-supply  = <&ldo5>;
+			ldo5-maxv = <1500000>;
+
+		};
+
+		regulators {
+			dcdc1: dcdc1 {
+				regulator-name = "DCDC1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			dcdc2: dcdc2 {
+				regulator-name = "DCDC2";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2700000>;
+				regulator-min-microamp = <3000000>;
+				regulator-max-microamp = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			core: dcdc3 {
+				regulator-name = "DCDC3";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-min-microamp = <2000000>;
+				regulator-max-microamp = <2000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			dcdc4: dcdc4 {
+				regulator-name = "DCDC4";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-min-microamp = <2000000>;
+				regulator-max-microamp = <2000000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo1: ldo1 {
+				regulator-name = "LDO1";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <300000>;
+				regulator-max-microamp = <300000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo2: ldo2 {
+				regulator-name = "LDO2";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-min-microamp = <300000>;
+				regulator-max-microamp = <300000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo3: ldo3 {
+				regulator-name = "LDO3";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <600000>;
+				regulator-min-microamp = <300000>;
+				regulator-max-microamp = <300000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo4: ldo4 {
+				regulator-name = "LDO4";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			ldo5: ldo5 {
+				regulator-name = "LDO5";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+		};
+/*
+			ldo6_32khz: ldo6 {
+				regulator-name = "LDO6";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <700000>;
+				regulator-min-microamp = <200000>;
+				regulator-max-microamp = <200000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+*/
+			/*
+			svcc {
+				regulator-name = "SVCC";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-min-microamp = <50000>;
+				regulator-max-microamp = <50000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+			*/
+	};
+};
+
+/*
+&cpu0 {
+	cpu0-supply = <&dcdc3>;
+	dcdc3-maxv = <950000>;
+};
+*/
+
+&spi0 {
+	status = "okay";
+	use-dma;
+	dmas = <&gdma 10
+	&gdma 11>;
+	dma-names = "tx", "rx";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	w25q128@0 {
+		compatible = "w25q128";
+		reg = <0>;	/* chip select */
+		spi-max-frequency = <33000000>;
+
+		bank-width = <2>;
+		device-width = <2>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "spl-loader";
+			reg = <0x0 0x20000>; /* 128k */
+			read-only;
+		};
+
+		partition@20000 {
+			label = "u-boot";
+			reg = <0x20000 0x60000>; /* 384k */
+		};
+
+		partition@80000 {
+			label = "u-boot-env";
+			reg = <0x80000 0x10000>; /* 64k */
+		};
+
+		factory:partition@90000 {
+			label = "factory";
+			reg = <0x90000 0x10000>; /* 64k */
+		};
+
+		partition@a0000 {
+			label = "firmware";
+			reg = <0xa0000 0xf60000>; /* 640k-16M */
+		};
+	};
+
+	spidev: spi@8200000 {
+		compatible = "rohm,dh2228fv";
+		reg = <1>;
+		clock = <50000000>;
+		spi-cpha;
+		spi-cpol;
+		spi-max-frequency=<12000000>;
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&timer0 {
+	status = "okay";
+};
+
+&watchdog {
+	status = "okay";
+};
+
+&wifi_rf {
+	status = "okay";
+};
+
+&wifi_lb {
+	status = "okay";
+};
+
+&wifi_hb {
+	status = "okay";
+};
Index: linux-3.18.29/arch/mips/configs/sf16a18_mpw0_p10_rn5t567_defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/arch/mips/configs/sf16a18_mpw0_p10_rn5t567_defconfig	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,236 @@
+CONFIG_SIFLOWER=y
+CONFIG_DT_SF16A18_MPW0_P10_RN5T567=y
+CONFIG_CORE1_MEM_RES=y
+CONFIG_SIFLOWER_PWMTIMER_CLKSRC=y
+CONFIG_CEVT_GIC=y
+CONFIG_IMAGE_CMDLINE_HACK=y
+CONFIG_MIPS_MT_SMP=y
+CONFIG_SCHED_SMT=y
+CONFIG_MIPS_CPS=y
+CONFIG_NR_CPUS=2
+CONFIG_HZ_100=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+CONFIG_CRASHLOG=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_BPF_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODULE_STRIPPED=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_SYN_COOKIES=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_RTCACHE=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_ID=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_NF_NAT_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEVELOPER_WARNINGS=y
+CONFIG_CFG80211_REG_DEBUG=y
+CONFIG_CFG80211_CERTIFICATION_ONUS=y
+CONFIG_CFG80211_REG_CELLULAR_HINTS=y
+CONFIG_CFG80211_REG_RELAX_NO_IR=y
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_MINSTREL_VHT=y
+CONFIG_MAC80211_MESH=y
+CONFIG_MAC80211_DEBUGFS=y
+CONFIG_MAC80211_MESSAGE_TRACING=y
+CONFIG_MAC80211_DEBUG_MENU=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_MTD=y
+CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_SIFLOWER=y
+CONFIG_SFAX8_SWITCH=m
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+CONFIG_SWCONFIG=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_RTL_CARDS is not set
+# CONFIG_SF16A18_WIFI_LMAC_BUILTIN is not set
+CONFIG_SF16A18_WIFI_RF=m
+CONFIG_SF16A18_WIFI_LB_SMAC=m
+CONFIG_SF16A18_WIFI_HB_SMAC=m
+CONFIG_SF16A18_WIFI_LED=y
+CONFIG_SF16A18_WIIF_TRACING=y
+CONFIG_SF16A18_WIFI_DBG=y
+CONFIG_WIRELESS_VENDOR_SIFLOWER_W18=m
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_SFAX8=y
+CONFIG_SERIAL_SFAX8_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=y
+CONFIG_I2C=y
+CONFIG_I2C_SFAX8=y
+CONFIG_SPI=y
+CONFIG_SPI_DEBUG=y
+CONFIG_SPI_SFAX8=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_SFAX8_WDT=m
+CONFIG_MFD_SFAX8_RN5T567=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_SFAX8_RN5T567=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_VERBOSE=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_SFAX8_PCM=y
+CONFIG_SND_SOC_SFAX8_I2S=y
+CONFIG_SND_SOC_SFAX8_SPDIF=y
+CONFIG_SND_SOC_SFAX8_MACHINE=y
+CONFIG_SND_SOC_SFAX8_SPDIF_MACHINE=y
+CONFIG_SND_SOC_ES8316=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC2=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_SFAX8=y
+CONFIG_DMADEVICES=y
+CONFIG_SFAX8_DMA=y
+CONFIG_PWM=y
+CONFIG_PWM_SFAX8=m
+CONFIG_PHY_SFAX8_USB=y
+CONFIG_EXT4_FS=y
+# CONFIG_DIRECT_IO is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_OVERLAY_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_PROC_STRIPPED=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_LZMA=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_VXFS_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_TEST_UDELAY=m
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyS0,115200n8 rootfstype=squashfs,jffs2 rdinit=/sbin/init"
+CONFIG_CRC32_SARWATE=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_TEXTSEARCH=y
Index: linux-3.18.29/drivers/mfd/sfax8_ip6103.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/mfd/sfax8_ip6103.c	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,312 @@
+/*
+ * Core driver for ams SF16ax8 PMICs
+ *
+ * Copyright (C) 2013 AMS AG
+ * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.
+ * Copyright (C) 2016 SIFLOWER
+ *
+ * Author: Xijun Guo  <xijun.guo@siflower.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/sfax8_ip6103.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+static const struct resource sfax8_rtc_resource[] = {
+	{
+		.name = "sfax8-rtc-alarm",
+		.start = SF16ax8_IRQ_RTC_ALARM,
+		.end = SF16ax8_IRQ_RTC_ALARM,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static const struct mfd_cell sfax8_devs[] = {
+	{
+		.name = "sfax8-regulator",
+	},
+	{
+		.name = "power-management",
+	},
+	{
+		.name = "sfax8-misc",
+	},
+	{
+		.name = "reset-button"
+	},
+	{
+		.name = "sfax8-rtc",
+		.num_resources = ARRAY_SIZE(sfax8_rtc_resource),
+		.resources = sfax8_rtc_resource,
+	},
+	{
+		.name = "sfax8-clk-32k"
+	},
+};
+
+
+/*static int sfax8_check_device_id(struct sfax8 *as3722)
+{
+	u32 val;
+	int ret;
+
+	ret = sfax8_read(sfax8, SF16ax8_ASIC_ID1_REG, &val);
+	if (ret < 0) {
+		dev_err(sfax8->dev, "ASIC_ID1 read failed: %d\n", ret);
+		return ret;
+	}
+
+	if (val != SF16ax8_DEVICE_ID) {
+		dev_err(sfax8->dev, "Device is not SF16ax8, ID is 0x%x\n", val);
+		return -ENODEV;
+	}
+
+	ret = sfax8_read(sfax8, SF16ax8_ASIC_ID2_REG, &val);
+	if (ret < 0) {
+		dev_err(sfax8->dev, "ASIC_ID2 read failed: %d\n", ret);
+		return ret;
+	}
+
+	dev_info(sfax8->dev, "SF16ax8 with revision 0x%x found\n", val);
+	return 0;
+}
+
+
+static int sfax8_configure_pullups(struct sfax8 *as3722)
+{
+	int ret;
+	u32 val = 0;
+
+	if (sfax8->en_intern_int_pullup)
+		val |= SF16ax8_INT_PULL_UP;
+	if (sfax8->en_intern_i2c_pullup)
+		val |= SF16ax8_I2C_PULL_UP;
+
+	ret = sfax8_update_bits(sfax8, SF16ax8_IOVOLTAGE_REG,
+			SF16ax8_INT_PULL_UP | AS3722_I2C_PULL_UP, val);
+	if (ret < 0)
+		dev_err(sfax8->dev, "IOVOLTAGE_REG update failed: %d\n", ret);
+	return ret;
+}
+*/
+static const struct regmap_range sfax8_readable_ranges[] = {
+	regmap_reg_range(SFAX8_WAKE0_REG, SFAX8_PWR1_REG),
+	regmap_reg_range(SFAX8_PWR2_REG, SFAX8_PWR2_REG),
+	regmap_reg_range(SFAX8_IRC_CONF0_REG, SFAX8_PWR_OFF_FLAG_REG),
+	regmap_reg_range(SFAX8_DCDC_CTL_REG, SFAX8_DCDC0_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC1_CTL0_REG, SFAX8_DCDC1_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC2_CTL0_REG, SFAX8_DCDC2_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC3_CTL0_REG, SFAX8_DCDC3_CTL1_REG),
+	regmap_reg_range(SFAX8_SW_LDO_CTL0_REG, SFAX8_LDO0_REG),
+	regmap_reg_range(SFAX8_LDO1_REG, SFAX8_LDO1_REG),
+	regmap_reg_range(SFAX8_LDO2_REG, SFAX8_LDO2_REG),
+	regmap_reg_range(SFAX8_LDO4_REG, SFAX8_LDO4_REG),
+	regmap_reg_range(SFAX8_LDO5_REG, SFAX8_LDO5_REG),
+	regmap_reg_range(SFAX8_LDO6_REG, SFAX8_LDO6_REG),
+	regmap_reg_range(SFAX8_SVCC_REG, SFAX8_SVCC_REG),
+	regmap_reg_range(SFAX8_INT0_REG, SFAX8_INT3_REG),
+	regmap_reg_range(SFAX8_MFP_LDO65_REG, SFAX8_MFP_GPIO74_PUPD_REG),
+	regmap_reg_range(SFAX8_ALARM_SEC_REG, SFAX8_WATCH_YEAR_REG),
+};
+
+static const struct regmap_access_table sfax8_readable_table = {
+	.yes_ranges = sfax8_readable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sfax8_readable_ranges),
+};
+
+static const struct regmap_range sfax8_writable_ranges[] = {
+	regmap_reg_range(SFAX8_WAKE0_REG, SFAX8_STATUE0_REG),
+	regmap_reg_range(SFAX8_PWR0_REG, SFAX8_PWR1_REG),
+	regmap_reg_range(SFAX8_PWR2_REG, SFAX8_PWR2_REG),
+	regmap_reg_range(SFAX8_IRC_CONF0_REG, SFAX8_IRC_IWKDC_REG),
+	regmap_reg_range(SFAX8_PWR_OFF_FLAG_REG, SFAX8_PWR_OFF_FLAG_REG),
+	regmap_reg_range(SFAX8_DCDC_CTL_REG, SFAX8_DCDC0_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC1_CTL0_REG, SFAX8_DCDC1_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC2_CTL0_REG, SFAX8_DCDC2_CTL1_REG),
+	regmap_reg_range(SFAX8_DCDC3_CTL0_REG, SFAX8_DCDC3_CTL1_REG),
+	regmap_reg_range(SFAX8_SW_LDO_CTL0_REG, SFAX8_LDO0_REG),
+	regmap_reg_range(SFAX8_LDO1_REG, SFAX8_LDO1_REG),
+	regmap_reg_range(SFAX8_LDO2_REG, SFAX8_LDO2_REG),
+	regmap_reg_range(SFAX8_LDO4_REG, SFAX8_LDO4_REG),
+	regmap_reg_range(SFAX8_LDO5_REG, SFAX8_LDO5_REG),
+	regmap_reg_range(SFAX8_LDO6_REG, SFAX8_LDO6_REG),
+	regmap_reg_range(SFAX8_SVCC_REG, SFAX8_SVCC_REG),
+	regmap_reg_range(SFAX8_INT0_REG, SFAX8_INT3_REG),
+	regmap_reg_range(SFAX8_MFP_LDO65_REG, SFAX8_MFP_GPIO74_PUPD_REG),
+	regmap_reg_range(SFAX8_ALARM_SEC_REG, SFAX8_WATCH_YEAR_REG),
+};
+
+static const struct regmap_access_table sfax8_writable_table = {
+	.yes_ranges = sfax8_writable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sfax8_writable_ranges),
+};
+
+static const struct regmap_range sfax8_cacheable_ranges[] = {
+	regmap_reg_range(SFAX8_WAKE1_REG, SFAX8_SLEEP_REG),
+	regmap_reg_range(SFAX8_PWR0_REG, SFAX8_PWR2_REG),
+	regmap_reg_range(SFAX8_DCDC_CTL_REG, SFAX8_INT1_REG),
+	regmap_reg_range(SFAX8_MFP_LDO65_REG, SFAX8_MFP_GPIO74_PUPD_REG),
+};
+
+static const struct regmap_access_table sfax8_volatile_table = {
+	.no_ranges = sfax8_cacheable_ranges,
+	.n_no_ranges = ARRAY_SIZE(sfax8_cacheable_ranges),
+};
+
+static const struct regmap_config sfax8_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = SFAX8_MAX_REGISTER,
+	.cache_type = REGCACHE_RBTREE,
+	.rd_table = &sfax8_readable_table,
+	.wr_table = &sfax8_writable_table,
+	.volatile_table = &sfax8_volatile_table,
+};
+
+static int sfax8_i2c_of_probe(struct i2c_client *i2c,
+			struct sfax8 *sfax8)
+{
+	struct device_node *np = i2c->dev.of_node;
+	//struct irq_data *irq_data;
+
+	if (!np) {
+		dev_err(&i2c->dev, "Device Tree not found\n");
+		return -EINVAL;
+	}
+
+/*	irq_data = irq_get_irq_data(i2c->irq);
+	if (!irq_data) {
+		dev_err(&i2c->dev, "Invalid IRQ: %d\n", i2c->irq);
+		return -EINVAL;
+	}
+
+	sfax8->en_intern_int_pullup = of_property_read_bool(np,
+					"ams,enable-internal-int-pullup");
+	sfax8->en_intern_i2c_pullup = of_property_read_bool(np,
+					"ams,enable-internal-i2c-pullup");
+	sfax8->irq_flags = irqd_get_trigger_type(irq_data);
+	dev_dbg(&i2c->dev, "IRQ flags are 0x%08lx\n", sfax8->irq_flags);*/
+	return 0;
+}
+
+static int sfax8_i2c_probe(struct i2c_client *i2c,
+			const struct i2c_device_id *id)
+{
+	struct sfax8 *sfax8;
+	//unsigned long irq_flags;
+	int ret;
+
+	sfax8 = devm_kzalloc(&i2c->dev, sizeof(struct sfax8), GFP_KERNEL);
+	if (!sfax8)
+		return -ENOMEM;
+
+	sfax8->dev = &i2c->dev;
+	sfax8->chip_irq = i2c->irq;
+	i2c_set_clientdata(i2c, sfax8);
+
+	ret = sfax8_i2c_of_probe(i2c, sfax8);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(sfax8->dev, "start regmap init\n");
+
+	sfax8->regmap = devm_regmap_init_i2c(i2c, &sfax8_regmap_config);
+	if (IS_ERR(sfax8->regmap)) {
+		ret = PTR_ERR(sfax8->regmap);
+		dev_err(&i2c->dev, "regmap init failed: %d\n", ret);
+		return ret;
+	}
+/*
+	ret = sfax8_check_device_id(sfax8);
+	if (ret < 0)
+		return ret;
+
+	irq_flags = sfax8->irq_flags | IRQF_ONESHOT;
+	ret = regmap_add_irq_chip(sfax8->regmap, sfax8->chip_irq,
+			irq_flags, -1, &sfax8_irq_chip,
+			&sfax8->irq_data);
+	if (ret < 0) {
+		dev_err(sfax8->dev, "Failed to add regmap irq: %d\n", ret);
+		return ret;
+	}
+
+	ret = sfax8_configure_pullups(sfax8);
+	if (ret < 0)
+		goto scrub;
+*/
+	dev_dbg(sfax8->dev, "start add devices\n");
+	ret = mfd_add_devices(&i2c->dev, -1, sfax8_devs,
+			ARRAY_SIZE(sfax8_devs), NULL, 0,NULL);
+//			regmap_irq_get_domain(sfax8->irq_data));
+	if (ret) {
+		dev_err(sfax8->dev, "Failed to add MFD devices: %d\n", ret);
+		goto scrub;
+	}
+
+	dev_dbg(sfax8->dev, "SF16ax8 core driver initialized successfully\n");
+	return 0;
+
+scrub:
+//	regmap_del_irq_chip(sfax8->chip_irq, sfax8->irq_data);
+	return ret;
+}
+
+static int sfax8_i2c_remove(struct i2c_client *i2c)
+{
+	struct sfax8 *sfax8 = i2c_get_clientdata(i2c);
+
+	mfd_remove_devices(sfax8->dev);
+//	regmap_del_irq_chip(sfax8->chip_irq, sfax8->irq_data);
+	return 0;
+}
+
+static const struct of_device_id sfax8_of_match[] = {
+	{ .compatible = "siflower, sfax8-pmu", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sfax8_of_match);
+
+static const struct i2c_device_id sfax8_i2c_id[] = {
+	{ "sfax8", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, sfax8_i2c_id);
+
+static struct i2c_driver sfax8_i2c_driver = {
+	.driver = {
+		.name = "sfax8-pmu",
+		.owner = THIS_MODULE,
+		.of_match_table = sfax8_of_match,
+	},
+	.probe = sfax8_i2c_probe,
+	.remove = sfax8_i2c_remove,
+	.id_table = sfax8_i2c_id,
+};
+
+module_i2c_driver(sfax8_i2c_driver);
+
+MODULE_DESCRIPTION("I2C support for SF16ax8 PMU");
+MODULE_AUTHOR("Xijun Guo <xijun.guo@siflower.com.cn>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/mfd/sfax8_rn5t567.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/mfd/sfax8_rn5t567.c	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,230 @@
+/*
+ * Core driver for ams SF16ax8 PMICs
+ *
+ * Copyright (C) 2013 AMS AG
+ * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.
+ * Copyright (C) 2016 SIFLOWER
+ *
+ * Author: Xijun Guo  <xijun.guo@siflower.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/sfax8_rn5t567.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+static const struct mfd_cell sfax8_devs[] = {
+	{
+		.name = "sfax8-regulator",
+	},
+	{
+		.name = "power-management",
+	},
+	{
+		.name = "sfax8-clk-32k"
+	},
+	{
+		.name = "reset-button"
+	},
+};
+
+
+
+static const struct regmap_range sfax8_readable_ranges[] = {
+	regmap_reg_range(SFAX8_LSIVER, SFAX8_LDO5_SLOT),
+	regmap_reg_range(SFAX8_DC1CTL, SFAX8_DC4DAC),
+	regmap_reg_range(SFAX8_DC1DAC_SLP, SFAX8_DC4DAC_SLP),
+	regmap_reg_range(SFAX8_DCIREN, SFAX8_LDODIS),
+	regmap_reg_range(SFAX8_LDO1DAC, SFAX8_LDO5DAC),
+	regmap_reg_range(SFAX8_LDORTCDAC, SFAX8_LDO5DAC_SLP),
+	regmap_reg_range(SFAX8_IOSEL, SFAX8_GPLED_FUNC),
+	regmap_reg_range(SFAX8_INTPOL, SFAX8_INTMON),
+	regmap_reg_range(SFAX8_PREVINDAC, SFAX8_OVTEMP),
+};
+static const struct regmap_access_table sfax8_readable_table = {
+	.yes_ranges = sfax8_readable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sfax8_readable_ranges),
+};
+
+static const struct regmap_range sfax8_writable_ranges[] = {
+	regmap_reg_range(SFAX8_LSIVER, SFAX8_LDO5_SLOT),
+	regmap_reg_range(SFAX8_DC1CTL, SFAX8_DC4DAC),
+	regmap_reg_range(SFAX8_DC1DAC_SLP, SFAX8_DC4DAC_SLP),
+	regmap_reg_range(SFAX8_DCIREN, SFAX8_LDODIS),
+	regmap_reg_range(SFAX8_LDO1DAC, SFAX8_LDO5DAC),
+	regmap_reg_range(SFAX8_LDORTCDAC, SFAX8_LDO5DAC_SLP),
+	regmap_reg_range(SFAX8_IOSEL, SFAX8_GPLED_FUNC),
+	regmap_reg_range(SFAX8_INTPOL, SFAX8_INTMON),
+	regmap_reg_range(SFAX8_PREVINDAC, SFAX8_OVTEMP),
+};
+static const struct regmap_access_table sfax8_writable_table = {
+	.yes_ranges = sfax8_writable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sfax8_writable_ranges),
+};
+
+static const struct regmap_range sfax8_cacheable_ranges[] = {
+	regmap_reg_range(SFAX8_LDO1DAC_SLP, SFAX8_LDO5DAC_SLP),
+	regmap_reg_range(SFAX8_DC1DAC_SLP, SFAX8_DC4DAC_SLP),
+
+};
+static const struct regmap_access_table sfax8_volatile_table = {
+	.no_ranges = sfax8_cacheable_ranges,
+	.n_no_ranges = ARRAY_SIZE(sfax8_cacheable_ranges),
+};
+
+static const struct regmap_config sfax8_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = SFAX8_MAX_REGISTER,
+	.cache_type = REGCACHE_RBTREE,
+	.rd_table = &sfax8_readable_table,
+	.wr_table = &sfax8_writable_table,
+	.volatile_table = &sfax8_volatile_table,
+};
+
+static int sfax8_i2c_of_probe(struct i2c_client *i2c,
+			struct sfax8 *sfax8)
+{
+	struct device_node *np = i2c->dev.of_node;
+	//struct irq_data *irq_data;
+
+	if (!np) {
+		dev_err(&i2c->dev, "Device Tree not found\n");
+		return -EINVAL;
+	}
+
+/*	irq_data = irq_get_irq_data(i2c->irq);
+	if (!irq_data) {
+		dev_err(&i2c->dev, "Invalid IRQ: %d\n", i2c->irq);
+		return -EINVAL;
+	}
+
+	sfax8->en_intern_int_pullup = of_property_read_bool(np,
+					"ams,enable-internal-int-pullup");
+	sfax8->en_intern_i2c_pullup = of_property_read_bool(np,
+					"ams,enable-internal-i2c-pullup");
+	sfax8->irq_flags = irqd_get_trigger_type(irq_data);
+	dev_dbg(&i2c->dev, "IRQ flags are 0x%08lx\n", sfax8->irq_flags);*/
+	return 0;
+}
+
+static int sfax8_i2c_probe(struct i2c_client *i2c,
+			const struct i2c_device_id *id)
+{
+	struct sfax8 *sfax8;
+	//unsigned long irq_flags;
+	int ret;
+
+	sfax8 = devm_kzalloc(&i2c->dev, sizeof(struct sfax8), GFP_KERNEL);
+	if (!sfax8)
+		return -ENOMEM;
+
+	sfax8->dev = &i2c->dev;
+	sfax8->chip_irq = i2c->irq;
+	i2c_set_clientdata(i2c, sfax8);
+
+	ret = sfax8_i2c_of_probe(i2c, sfax8);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(sfax8->dev, "start regmap init\n");
+
+	sfax8->regmap = devm_regmap_init_i2c(i2c, &sfax8_regmap_config);
+	if (IS_ERR(sfax8->regmap)) {
+		ret = PTR_ERR(sfax8->regmap);
+		dev_err(&i2c->dev, "regmap init failed: %d\n", ret);
+		return ret;
+	}
+/*
+	ret = sfax8_check_device_id(sfax8);
+	if (ret < 0)
+		return ret;
+
+	irq_flags = sfax8->irq_flags | IRQF_ONESHOT;
+	ret = regmap_add_irq_chip(sfax8->regmap, sfax8->chip_irq,
+			irq_flags, -1, &sfax8_irq_chip,
+			&sfax8->irq_data);
+	if (ret < 0) {
+		dev_err(sfax8->dev, "Failed to add regmap irq: %d\n", ret);
+		return ret;
+	}
+
+	ret = sfax8_configure_pullups(sfax8);
+	if (ret < 0)
+		goto scrub;
+*/
+	dev_dbg(sfax8->dev, "start add devices\n");
+	ret = mfd_add_devices(&i2c->dev, -1, sfax8_devs,
+			ARRAY_SIZE(sfax8_devs), NULL, 0,NULL);
+//			regmap_irq_get_domain(sfax8->irq_data));
+	if (ret) {
+		dev_err(sfax8->dev, "Failed to add MFD devices: %d\n", ret);
+		goto scrub;
+	}
+
+	dev_dbg(sfax8->dev, "SF16ax8 core driver initialized successfully\n");
+	return 0;
+
+scrub:
+//	regmap_del_irq_chip(sfax8->chip_irq, sfax8->irq_data);
+	return ret;
+}
+
+static int sfax8_i2c_remove(struct i2c_client *i2c)
+{
+	struct sfax8 *sfax8 = i2c_get_clientdata(i2c);
+
+	mfd_remove_devices(sfax8->dev);
+//	regmap_del_irq_chip(sfax8->chip_irq, sfax8->irq_data);
+	return 0;
+}
+
+static const struct of_device_id sfax8_of_match[] = {
+	{ .compatible = "siflower, sfax8-pmu", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sfax8_of_match);
+
+static const struct i2c_device_id sfax8_i2c_id[] = {
+	{ "sfax8", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, sfax8_i2c_id);
+
+static struct i2c_driver sfax8_i2c_driver = {
+	.driver = {
+		.name = "sfax8-pmu",
+		.owner = THIS_MODULE,
+		.of_match_table = sfax8_of_match,
+	},
+	.probe = sfax8_i2c_probe,
+	.remove = sfax8_i2c_remove,
+	.id_table = sfax8_i2c_id,
+};
+
+module_i2c_driver(sfax8_i2c_driver);
+
+MODULE_DESCRIPTION("I2C support for SF16ax8 PMU");
+MODULE_AUTHOR("Xijun Guo <xijun.guo@siflower.com.cn>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/regulator/sfax8_pwrmgmt_ip6103.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/regulator/sfax8_pwrmgmt_ip6103.c	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,375 @@
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+
+//enable 32k clock
+#include <linux/mfd/sfax8_ip6103.h>
+
+#define TOTAL_DCDC	4
+#define TOTAL_LDO	7
+#define VIN_POWER_OVER_VOLTAGE		(1 << 7)
+#define VIN_POWER_BELOW_VOLTAGE		(1 << 6)
+
+struct pwr_mgmt {
+	struct regulator *regulator;
+//	u32 max_v;
+	char name[20];
+	u32 default_uv;
+};
+
+static struct pwr_mgmt rt[TOTAL_DCDC + TOTAL_LDO];
+
+
+static ssize_t pwr_mgmt_write(struct file *file, const char __user *buffer,
+							size_t count, loff_t *f_ops)
+{
+	struct regulator *one_rt;
+	unsigned int  value;
+	char *data, name[20];
+	int ret, i;
+
+	sscanf(buffer, "%u", &value);
+
+	data = ((struct seq_file *)file->private_data)->private;
+	strcpy(name, data);
+
+	for( i = 0; i < TOTAL_DCDC + TOTAL_LDO; i++){
+		if(!strcmp(name, rt[i].name))
+			break;
+	}
+	one_rt = rt[i].regulator;
+
+	ret = regulator_set_voltage(one_rt, value, value);
+	if (ret){
+		pr_err("regulator_set_voltage error\n");
+		goto fin;
+	}
+
+	ret = regulator_enable(one_rt);
+	if (ret < 0){
+		pr_err("regulator_enable error\n");
+		goto fin;
+	}
+
+	value = regulator_get_voltage(one_rt);
+	pr_debug("Voltage is %d\n", value);
+
+fin:
+	return count;
+}
+
+static ssize_t pwr_mgmt_read(struct file *file, char __user *buffer,
+							size_t count, loff_t *f_ops)
+{
+	struct regulator *one_rt;
+	unsigned int  value;
+	char *data, name[20];
+	int ret, i, step;
+
+	char *buff = kmalloc(sizeof(char) * count, GFP_KERNEL);
+	if(!buff)
+		return -ENOMEM;
+
+	if(*f_ops > 0)
+		return 0;
+
+	data = ((struct seq_file *)file->private_data)->private;
+
+	strcpy(name, data);
+
+	for( i = 0; i < TOTAL_DCDC + TOTAL_LDO; i++){
+		if(!strcmp(name, rt[i].name))
+			break;
+	}
+	one_rt = rt[i].regulator;
+	if(!strncmp(rt[i].name, "ldo", 3))
+		step = 25000;
+	else
+		step = 12500;
+
+	value = regulator_get_voltage(one_rt);
+	pr_debug("Voltage is %d\n", value);
+	ret = snprintf(buff, count, "%s's current voltage is %d uv, step is %d uv.\n", name, value, step);
+	if(copy_to_user(buffer, buff, ret))
+		ret = -EFAULT;
+	*f_ops += ret;
+	kfree(buff);
+	return ret;
+}
+
+static int pwr_mgmt_show(struct seq_file *m, void *v)
+{
+	seq_printf(m,"Nothing to show\n");
+
+	return 0;
+}
+
+static int pwr_mgmt_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pwr_mgmt_show, PDE_DATA(inode));
+}
+
+static int pwr_mgmt_status_show(struct device *dev)
+{
+	unsigned char status;
+	int ret;
+	int i = 0;
+	unsigned char tmp[20];
+	struct sfax8 *data = dev_get_drvdata(dev->parent);
+	if(dev == NULL){
+		dev_err(dev, "device is null.\n");
+		return -ENOMEM;
+	}
+
+
+	/*
+	** get pmu vin power status.
+	*/
+	ret = regmap_bulk_read(data->regmap, SFAX8_PROTECT_REG, &status, 1);
+	if(ret){
+		printk("Can't get vin power status\n");
+	}else {
+		if(status & VIN_POWER_OVER_VOLTAGE)	
+			printk("The vin power's output voltage had been over setting value.\n");
+		else if(status & VIN_POWER_BELOW_VOLTAGE)
+			printk("The vin power's output voltage had been below the setting value.\n");
+		else
+			printk("The vin power's output voltage is OK.\n");
+	}
+	/*
+	** get dc power status.
+	*/
+	ret = regmap_bulk_read(data->regmap, SFAX8_STATUE1_REG, &status, 1);
+	if(ret){
+		printk("Can't get dc power status!\n");
+	}else {
+		for(i = 0; i < 4; i++)
+			printk("The dc%d power's output voltage is %s.\n", i, (status & (1 << i)) ? "OK" :"below exception");
+	}
+
+	/*
+	** get ldo power status.
+	*/
+	ret = regmap_bulk_read(data->regmap, SFAX8_STATUE2_REG, &status, 1);
+	if(ret){
+		printk("Can't get ldo power status!\n");
+	}else {
+		for(i = 0; i < 7; i++){
+			if( i == 3 || i == 5 || i == 6)
+				continue;
+			printk("The ldo%d power's output voltage is %s.\n", i, (status & (1 << i)) ? "OK" :"below exception");
+		}
+	}
+
+	/*
+	** get ldo power status.
+	*/
+	ret = regmap_bulk_read(data->regmap, SFAX8_INT3_REG, &status, 1);
+	if(ret){
+		printk("Can't get ldo power status!\n");
+	}else {
+		for(i = 0; i < 7; i++){
+			if( i == 3 || i == 5 || i == 6)
+				continue;
+			printk("The ldo%d power's output electric current is %s.\n", i, (status & (1 << i)) ? "higher than excepted value" :"OK");
+		}
+	}
+
+	ret = regmap_bulk_read(data->regmap, SFAX8_WAKE0_REG, tmp, 9);
+	for(i = 0; i < 9 ; i++)
+		printk(KERN_DEBUG "reg : 0x%x; val : 0x%x.\n", SFAX8_WAKE0_REG + i, *(tmp + i));
+	return 0;
+}
+
+
+static struct file_operations pwr_mgmt_ops = {
+	.owner		= THIS_MODULE,
+	.open		= pwr_mgmt_open,
+	.read		= pwr_mgmt_read,
+	.write		= pwr_mgmt_write,
+	.release	= single_release,
+	.llseek		= seq_lseek,
+};
+
+static int create_pwrmgmt_file(void )
+{
+
+	struct proc_dir_entry *parent, *file;
+	int i;
+	parent = proc_mkdir("power-manager", NULL);
+	if(!parent){
+		printk(KERN_ERR "%s: can not create power-manager dir\n", __func__);
+		return -ENOMEM;
+	}
+	for( i = 0; i < TOTAL_DCDC + TOTAL_LDO; i++){
+		if( i == 1 || i - TOTAL_DCDC == 3)
+			continue;
+		if (IS_ERR(rt[i].regulator)) {
+			continue;
+		}else{
+			file = proc_create_data(rt[i].name, 0644, parent, &pwr_mgmt_ops, rt[i].name);
+			if(!file){
+				printk(KERN_ERR "%s: can not create %s file\n", __func__, rt[i].name);
+				return -ENOMEM;
+			}
+		}
+	}
+	return 0;
+}
+
+static int pwr_mgmt_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	struct regulator *rg;
+	char name[32], vname[32];
+	u32 i;
+	int err;
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "power-management");
+	if (!np) {
+		dev_err(&pdev->dev, "Device is not having regulator configuration.\n");
+	}
+
+	pdev->dev.of_node = np;
+
+	for (i = 0; i < TOTAL_DCDC; i++){
+		if( i == 1)
+			continue;
+		sprintf(name, "dcdc%d", i);
+		dev_dbg(&pdev->dev, "Num %d : name is %s", i, name);
+
+		rg = devm_regulator_get(&pdev->dev, name);
+		if (IS_ERR(rg)) {
+			dev_err(&pdev->dev, "Get regulator error, i=%d\n", i);
+			continue;
+		}
+		rt[i].regulator = rg;
+		
+		if(!strcmp(name, "dcdc0"))
+			strcpy(rt[i].name, "core");
+		else
+			strcpy(rt[i].name, name);
+
+		sprintf(vname, "%s-default-uv", name);
+		dev_dbg(&pdev->dev, "Num %d: default uv name is %s", i, vname);
+
+		err = of_property_read_u32(np, vname, &rt[i].default_uv);
+		if (err)
+			rt[i].default_uv = 0;
+		else{
+			printk(KERN_DEBUG "%s defualt voltage will be set to %d uv.\n", rt[i].name, rt[i].default_uv);
+			err = regulator_set_voltage(rg, rt[i].default_uv, rt[i].default_uv);
+			if (err){
+				pr_err("Can not set %s voltage to %d uv.\n", name, rt[i].default_uv);
+				return -EINVAL;
+			}
+		}
+	}
+
+
+	for (i = TOTAL_DCDC; i < TOTAL_DCDC + TOTAL_LDO; i++){
+		//ldo3 not used.
+		if(i - TOTAL_DCDC == 3)
+			continue;
+		sprintf(name, "ldo%d", i - TOTAL_DCDC);
+		dev_dbg(&pdev->dev, "Num %d : name is %s", i, name);
+
+		rg = devm_regulator_get(&pdev->dev, name);
+		if (IS_ERR(rg)) {
+			dev_err(&pdev->dev, "Get regulator error, i=%d\n", i);
+			continue;
+		}
+		rt[i].regulator = rg;
+		strcpy(rt[i].name, name);
+
+		sprintf(vname, "%s-default-uv", name);
+		dev_dbg(&pdev->dev, "Num %d: default uv name is %s", i, vname);
+
+		err = of_property_read_u32(np, vname, &rt[i].default_uv);
+		if (err)
+			rt[i].default_uv = 0;
+		else{
+			printk(KERN_DEBUG "%s defualt voltage will be set to %d uv.\n", rt[i].name, rt[i].default_uv);
+			err = regulator_set_voltage(rg, rt[i].default_uv, rt[i].default_uv);
+			if (err){
+				pr_err("Can not set %s voltage to %d uv.\n", name, rt[i].default_uv);
+				return -EINVAL;
+			}
+		}
+	}
+	
+	err = pwr_mgmt_status_show(&pdev->dev);	
+	if(err)
+		printk("Can't get pmu status.\n");
+
+	if(create_pwrmgmt_file())
+		return -ENOMEM;
+	return 0;
+}
+
+static const struct of_device_id of_pwr_mgmt_match[] = {
+	{ .compatible = "siflower, power-management", },
+	{},
+};
+
+static struct platform_driver pwr_mgmt_driver = {
+	.driver = {
+		.name = "power-management",
+		.owner = THIS_MODULE,
+		.of_match_table = of_pwr_mgmt_match,
+	},
+	.probe = pwr_mgmt_probe,
+};
+
+module_platform_driver(pwr_mgmt_driver);
+
+MODULE_DESCRIPTION("Power Management Driver");
+MODULE_AUTHOR("Allen Guo <xijun.guo@siflower.com.cn>");
+MODULE_LICENSE("GPL");
+
+static int enable_clk_32k(struct device *dev)
+{
+	struct sfax8 *p = dev_get_drvdata(dev->parent);
+	unsigned char buf = 0xbf;//bit 5 ~ bit 7 : 111-ldo mode; 101-32k
+	if(regmap_bulk_write(p->regmap, SFAX8_MFP_LDO65_REG, &buf, 1)) {
+		dev_err(dev, "Setup 32K clock failed.\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(enable_clk_32k);
+
+static int disable_clk_32k(struct device *dev)
+{
+	struct sfax8 *p = dev_get_drvdata(dev->parent);
+	unsigned char buf = 0xff;
+	if(regmap_bulk_write(p->regmap, SFAX8_MFP_LDO65_REG, &buf, 1)) {
+		dev_err(dev, "Disable 32K clock failed.\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(disable_clk_32k);
+
+static int sfax8_clk_32k_probe(struct platform_device *pdev)
+{
+	return enable_clk_32k(&pdev->dev);
+}
+
+static struct platform_driver sfax8_clk_32k_driver = {
+	.driver = {
+		.name = "sfax8-clk-32k",
+	},
+	.probe = sfax8_clk_32k_probe,
+};
+module_platform_driver(sfax8_clk_32k_driver);
Index: linux-3.18.29/drivers/regulator/sfax8_pwrmgmt_rn5t567.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/regulator/sfax8_pwrmgmt_rn5t567.c	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,350 @@
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+
+//enable 32k clock
+#include <linux/mfd/sfax8_rn5t567.h>
+
+#define TOTAL_DCDC	4
+#define TOTAL_LDO	5
+
+struct pwr_mgmt {
+	struct regulator *regulator;
+	//u32 max_v;
+	char name[20];
+	u32 default_uv;
+};
+
+static struct pwr_mgmt rt[TOTAL_DCDC + TOTAL_LDO];
+
+
+static ssize_t pwr_mgmt_write(struct file *file, const char __user *buffer,
+							size_t count, loff_t *f_ops)
+{
+	struct regulator *one_rt;
+	unsigned int  value;
+	char *data, name[20];
+	int ret, i;
+
+	sscanf(buffer, "%u", &value);
+
+	data = ((struct seq_file *)file->private_data)->private;
+
+	strcpy(name, data);
+
+	for( i = 0; i < TOTAL_DCDC + TOTAL_LDO; i++){
+		if(!strcmp(name, rt[i].name))
+			break;
+	}
+	one_rt = rt[i].regulator;
+
+	ret = regulator_set_voltage(one_rt, value, value);
+	if (ret){
+		pr_err("regulator_set_voltage error\n");
+		goto fin;
+	}
+
+	ret = regulator_enable(one_rt);
+	if (ret < 0){
+		pr_err("regulator_enable error\n");
+		goto fin;
+	}
+
+	value = regulator_get_voltage(one_rt);
+	pr_debug("Voltage is %d\n", value);
+
+fin:
+	return count;
+}
+
+static ssize_t pwr_mgmt_read(struct file *file, char __user *buffer,
+							size_t count, loff_t *f_ops)
+{
+	struct regulator *one_rt;
+	unsigned int  value;
+	char *data, name[20];
+	int ret, i, step;
+
+	char *buff = kmalloc(sizeof(char) * count, GFP_KERNEL);
+	if(!buff)
+		return -ENOMEM;
+
+	if(*f_ops > 0)
+		return 0;
+
+	data = ((struct seq_file *)file->private_data)->private;
+	strcpy(name, data);
+
+	for( i = 0; i < TOTAL_DCDC + TOTAL_LDO; i++){
+		if(!strcmp(name, rt[i].name))
+			break;
+	}
+	one_rt = rt[i].regulator;
+
+	if(!strncmp(rt[i].name, "ldo", 3))
+		step = 50000;
+	else
+		step = 12500;
+
+	value = regulator_get_voltage(one_rt);
+	pr_debug("Voltage is %d\n", value);
+	ret = snprintf(buff, count, "%s's current voltage is %d uv, step is %d uv.\n", name, value, step);
+	if(copy_to_user(buffer, buff, ret))
+		ret = -EFAULT;
+	*f_ops += ret;
+	kfree(buff);
+	return ret;
+}
+
+static int pwr_mgmt_show(struct seq_file *m, void *v)
+{
+	seq_printf(m,"Nothing to show\n");
+
+	return 0;
+}
+
+static int pwr_mgmt_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pwr_mgmt_show, PDE_DATA(inode));
+}
+
+static int pwr_mgmt_status_show(struct device *dev)
+{
+	unsigned char status;
+	int ret;
+	int i = 0;
+	struct sfax8 *data = dev_get_drvdata(dev->parent);
+	char * info[] = {
+	"by PWRON assert.",
+	"detecting an abnormal temperature.",
+	"detecting the low power condition in VINDET circuit.",
+	"by IODET asserts.",
+	"by SWPWROFF bit setting, PSHOLD(GPIO*) is low or PSHOLD(GPIO*) is timeout.",
+	"by the watchdog function.",
+	"by the overcurrent of DCDC1-4 by the current limit circuit.",
+	"by N_OE asserts or HRESET asserts.",
+	};
+
+	if(dev == NULL){
+		dev_err(dev, "device is null.\n");
+		return -ENOMEM;
+	}
+	ret = regmap_bulk_read(data->regmap, SFAX8_PONHIS, &status, 1);
+	if(ret){
+		printk("Can't get power on status\n");
+	}else {
+		printk("PMU power on status is 0x%x\n", status);
+	}
+
+	ret = regmap_bulk_read(data->regmap, SFAX8_POFFHIS, &status, 1);
+	if(ret){
+		printk("Can't get power off history status.\n");
+	}else {
+		printk("PMU power off history status is 0x%x\n", status);
+		i = 0;
+		while( i < 8){
+			if(status & BIT(i))
+				printk("PMU power-off has occurred %s\n", info[i]);
+			i++;
+		}
+	}
+
+	return 0;
+}
+static struct file_operations pwr_mgmt_ops = {
+	.owner		= THIS_MODULE,
+	.open		= pwr_mgmt_open,
+	.read		= pwr_mgmt_read,
+	.write		= pwr_mgmt_write,
+	.release	= single_release,
+	.llseek		= seq_lseek,
+};
+
+static int create_pwrmgmt_file(void )
+{
+
+	struct proc_dir_entry *parent, *file;
+	int i;
+	parent = proc_mkdir("power-manager", NULL);
+	if(!parent){
+		printk(KERN_ERR "%s: can not creat power-manager dir\n", __func__);
+		return -ENOMEM;
+	}
+	for( i = 0; i < TOTAL_DCDC + TOTAL_LDO; i++){
+		if (IS_ERR(rt[i].regulator)) {
+			continue;
+		}else{
+			file = proc_create_data(rt[i].name, 0644, parent, &pwr_mgmt_ops, rt[i].name);
+			if(!file){
+				printk(KERN_ERR "%s: can not create %s file\n", __func__, rt[i].name);
+				return -ENOMEM;
+			}
+		}
+	}
+	return 0;
+}
+
+static int pwr_mgmt_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	struct regulator *rg;
+	char name[32], vname[32];
+	u32 i;
+	int err;
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "power-management");
+	if (!np) {
+		dev_err(&pdev->dev, "Device is not having regulator configuration.\n");
+	}
+
+	pdev->dev.of_node = np;
+
+	for (i = 0; i < TOTAL_DCDC; i++){
+		sprintf(name, "dcdc%d", i + 1);
+		dev_dbg(&pdev->dev, "Num %d : name is %s", i, name);
+
+		rg = devm_regulator_get(&pdev->dev, name);
+		if (IS_ERR(rg)) {
+			dev_err(&pdev->dev, "Get regulator error, i=%d\n", i);
+			continue;
+		}
+		rt[i].regulator = rg;
+		if(!strcmp(name, "dcdc3"))
+			strcpy(rt[i].name, "core");
+		else
+			strcpy(rt[i].name, name);
+
+		sprintf(vname, "%s-default-uv", name);
+		dev_dbg(&pdev->dev, "Num %d: default uv name is %s", i, vname);
+
+		err = of_property_read_u32(np, vname, &rt[i].default_uv);
+		if (err)
+			rt[i].default_uv = 0;
+		else{
+			printk(KERN_DEBUG "%s defualt voltage will be set to %d uv.\n", rt[i].name, rt[i].default_uv);
+			err = regulator_set_voltage(rg, rt[i].default_uv, rt[i].default_uv);
+			if (err){
+				pr_err("Can not set %s voltage to %d uv.\n", name, rt[i].default_uv);
+				return -EINVAL;
+			}
+		}
+	}
+
+
+	for (i = TOTAL_DCDC; i < TOTAL_DCDC + TOTAL_LDO; i++){
+		//ldo3 not used.
+		sprintf(name, "ldo%d", i - TOTAL_DCDC + 1);
+		dev_dbg(&pdev->dev, "Num %d : name is %s", i, name);
+
+		rg = devm_regulator_get(&pdev->dev, name);
+		if (IS_ERR(rg)) {
+			continue;
+		}
+		rt[i].regulator = rg;
+		strcpy(rt[i].name, name);
+
+		sprintf(vname, "%s-maxv", name);
+		dev_dbg(&pdev->dev, "Num %d: maxv name is %s", i, vname);
+
+		err = of_property_read_u32(np, vname, &rt[i].default_uv);
+		if (err)
+			rt[i].default_uv = 0;
+		else{
+			printk(KERN_DEBUG "%s defualt voltage will be set to %d uv.\n", rt[i].name, rt[i].default_uv);
+			err = regulator_set_voltage(rg, rt[i].default_uv, rt[i].default_uv);
+			if (err){
+				pr_err("Can not set %s voltage to %d uv.\n", name, rt[i].default_uv);
+				return -EINVAL;
+			}
+		}
+	}
+	
+	err = pwr_mgmt_status_show(&pdev->dev);	
+	if(err)
+		printk("Can't get pmu status.\n");
+	if(create_pwrmgmt_file())
+		return -ENOMEM;
+
+	return 0;
+}
+
+static const struct of_device_id of_pwr_mgmt_match[] = {
+	{ .compatible = "siflower, power-management", },
+	{},
+};
+
+static struct platform_driver pwr_mgmt_driver = {
+	.driver = {
+		.name = "power-management",
+		.owner = THIS_MODULE,
+		.of_match_table = of_pwr_mgmt_match,
+	},
+	.probe = pwr_mgmt_probe,
+};
+
+module_platform_driver(pwr_mgmt_driver);
+
+MODULE_DESCRIPTION("Power Management Driver");
+MODULE_AUTHOR("Allen Guo <xijun.guo@siflower.com.cn>");
+MODULE_LICENSE("GPL");
+
+static int enable_clk_32k(struct device *dev)
+{
+	struct sfax8 *p = dev_get_drvdata(dev->parent);
+	unsigned char buf = 0;
+	int ret;
+	ret = regmap_bulk_read(p->regmap, SFAX8_OUT32KEN, &buf, 1);
+	if(ret){
+		dev_err(dev, "%s Can not get 32k clock config value.\n", __func__);
+		return ret;
+	}
+	buf |= 0x2;	
+	if(regmap_bulk_write(p->regmap, SFAX8_OUT32KEN, &buf, 1)) {
+		dev_err(dev, "Setup 32K clock failed.\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(enable_clk_32k);
+
+static int disable_clk_32k(struct device *dev)
+{
+	struct sfax8 *p = dev_get_drvdata(dev->parent);
+	unsigned char buf = 0;
+	int ret;
+	ret = regmap_bulk_read(p->regmap, SFAX8_OUT32KEN, &buf, 1);
+	if(ret){
+		dev_err(dev, "%s Can not get 32k clock config value.\n", __func__);
+		return ret;
+	}
+	buf &= 0x1C;	
+	if(regmap_bulk_write(p->regmap, SFAX8_OUT32KEN, &buf, 1)) {
+		dev_err(dev, "Disable 32K clock failed.\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(disable_clk_32k);
+
+static int sfax8_clk_32k_probe(struct platform_device *pdev)
+{
+	return enable_clk_32k(&pdev->dev);
+}
+
+static struct platform_driver sfax8_clk_32k_driver = {
+	.driver = {
+		.name = "sfax8-clk-32k",
+	},
+	.probe = sfax8_clk_32k_probe,
+};
+module_platform_driver(sfax8_clk_32k_driver);
Index: linux-3.18.29/drivers/regulator/sfax8_regulator_ip6103.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/regulator/sfax8_regulator_ip6103.c	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,463 @@
+/*
+ * Voltage regulator support for AMS SFAX8 PMIC
+ *
+ * Copyright (C) 2013 ams
+ *
+ * Author: Florian Lobmaier <florian.lobmaier@ams.com>
+ * Author: Laxman Dewangan <ldewangan@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/sfax8_ip6103.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/slab.h>
+
+//#define ENABLE_DCDC1
+
+/* Regulator IDs */
+enum sfax8_regulators_id {
+	SFAX8_REGULATOR_DCDC0,
+#ifdef ENABLE_DCDC1
+	SFAX8_REGULATOR_DCDC1,
+#endif
+	SFAX8_REGULATOR_DCDC2,
+	SFAX8_REGULATOR_DCDC3,
+	SFAX8_REGULATOR_LDO0,
+	SFAX8_REGULATOR_LDO1,
+	SFAX8_REGULATOR_LDO2,
+	SFAX8_REGULATOR_LDO4,
+	SFAX8_REGULATOR_LDO5,
+	SFAX8_REGULATOR_LDO6,
+/*	SFAX8_REGULATOR_SVCC,*/
+	SFAX8_REGULATOR_ID_MAX,
+};
+
+struct sfax8_register_mapping {
+	u8 regulator_id;
+	const char *name;
+	const char *sname;
+	u8 vsel_reg;
+	u8 vsel_mask;
+	int n_voltages;
+	u32 enable_reg;
+	u8 enable_mask;
+	u32 control_reg;
+	u8 mode_mask;
+	u32 sleep_ctrl_reg;
+	u8 sleep_ctrl_mask;
+	int sf_pmu_current;
+};
+
+struct sfax8_regulator_config_data {
+	struct regulator_init_data *reg_init;
+	bool enable_tracking;
+	int ext_control;
+};
+
+struct sfax8_regulators {
+	struct device *dev;
+	struct sfax8 *sfax8;
+	struct regulator_dev *rdevs[SFAX8_REGULATOR_ID_MAX];
+	struct regulator_desc desc[SFAX8_REGULATOR_ID_MAX];
+	struct sfax8_regulator_config_data
+			reg_config_data[SFAX8_REGULATOR_ID_MAX];
+};
+
+static const struct sfax8_register_mapping sfax8_reg_lookup[] = {
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC0,
+		.name = "sfax8-dcdc0",
+		.vsel_reg = SFAX8_DCDC0_CTL0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_DCDC_CTL_REG,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.sleep_ctrl_reg = SFAX8_PWR0_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+#ifdef ENABLE_DCDC1
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC1,
+		.name = "sfax8-dcdc1",
+		.vsel_reg = SFAX8_DCDC1_CTL0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_DCDC_CTL_REG,
+		.enable_mask = ONE_BIT_SHIFT(1),
+		.sleep_ctrl_reg = SFAX8_PWR0_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(1),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+#endif
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC2,
+		.name = "sfax8-dcdc2",
+		.vsel_reg = SFAX8_DCDC2_CTL0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_DCDC_CTL_REG,
+		.enable_mask = ONE_BIT_SHIFT(2),
+		.sleep_ctrl_reg = SFAX8_PWR0_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(2),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC3,
+		.name = "sfax8-dcdc3",
+		.vsel_reg = SFAX8_DCDC3_CTL0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_DCDC_CTL_REG,
+		.enable_mask = ONE_BIT_SHIFT(3),
+		.sleep_ctrl_reg = SFAX8_PWR0_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(3),
+		.n_voltages = SFAX8_DCDC3_VOLTAGES,
+		.sf_pmu_current = 2000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO0,
+		.name = "sfax8-ldo0",
+		.vsel_reg = SFAX8_LDO0_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 400000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO1,
+		.name = "sfax8-ldo1",
+		.vsel_reg = SFAX8_LDO1_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(1),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(1),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 400000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO2,
+		.name = "sfax8-ldo2",
+		.vsel_reg = SFAX8_LDO2_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(2),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(2),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 400000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO4,
+		.name = "sfax8-ldo4",
+		.vsel_reg = SFAX8_LDO4_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(4),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(4),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO5,
+		.name = "sfax8-ldo5",
+		.vsel_reg = SFAX8_LDO5_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(5),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(5),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO6,
+		.name = "sfax8-ldo6",
+		.vsel_reg = SFAX8_LDO6_REG,
+		.vsel_mask = SFAX8_VREG_MASK_6_0,
+		.enable_reg = SFAX8_SW_LDO_CTL1_REG,
+		.enable_mask = ONE_BIT_SHIFT(6),
+		.sleep_ctrl_reg = SFAX8_PWR1_REG,
+		.sleep_ctrl_mask = ONE_BIT_SHIFT(6),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+	/*
+	{
+		.regulator_id = SFAX8_REGULATOR_SVCC,
+		.name = "sfax8-svcc",
+		.vsel_reg = SFAX8_SVCC_REG,
+		.vsel_mask = SFAX8_VREG_MASK_2_0,
+		.n_voltages = SFAX8_SVCC_VOLTAGES,
+		.sf_pmu_current = 50000,
+	},*/
+};
+static int sfax8_pmu_get_current_limit(struct regulator_dev *rdev)
+{
+	int id = rdev_get_id(rdev);
+	return sfax8_reg_lookup[id].sf_pmu_current;
+}
+
+static int sfax8_pmu_set_current_limit(struct regulator_dev *rdev,
+		int min_uA, int max_uA)
+{
+	struct sfax8_regulators *sfax8_regs = rdev_get_drvdata(rdev);
+	dev_err(sfax8_regs->dev,"Current is fixed\n");
+	return 0;
+}
+
+/*static int sfax8_regulator_enable_disable(struct regulator_dev *rdev)
+{
+	struct sfax8_regulators *sfax8_regs = rdev_get_drvdata(rdev);
+	dev_dbg(sfax8_regs->dev,"svcc can not support enable or disable\n");
+	return 0;
+}*/
+
+static struct regulator_ops sfax8_ops = {
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+	.map_voltage = regulator_map_voltage_linear,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_current_limit = sfax8_pmu_get_current_limit,
+	.set_current_limit = sfax8_pmu_set_current_limit,
+};
+
+/*static struct regulator_ops sfax8_svcc_ops = {
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = sfax8_regulator_enable_disable,
+	.disable = sfax8_regulator_enable_disable,
+	.list_voltage = regulator_list_voltage_linear,
+	.map_voltage = regulator_map_voltage_linear,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_current_limit = sfax8_pmu_get_current_limit,
+	.set_current_limit = sfax8_pmu_set_current_limit,
+};*/
+
+static struct of_regulator_match sfax8_regulator_matches[] = {
+	{ .name = "dcdc0", },
+#ifdef ENABLE_DCDC1
+	{ .name = "dcdc1", },
+#endif
+	{ .name = "dcdc2", },
+	{ .name = "dcdc3", },
+	{ .name = "ldo0", },
+	{ .name = "ldo1", },
+	{ .name = "ldo2", },
+	{ .name = "ldo4", },
+	{ .name = "ldo5", },
+	{ .name = "ldo6", },
+/*	{ .name = "svcc", },*/
+};
+static int sfax8_get_regulator_dt_data(struct platform_device *pdev,
+		struct sfax8_regulators *sfax8_regs)
+{
+	struct device_node *np;
+	struct sfax8_regulator_config_data *reg_config;
+	int id;
+	int ret;
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "regulators");
+	if (!np) {
+		dev_err(&pdev->dev, "Device is not having regulators node\n");
+		return -ENODEV;
+	}
+	pdev->dev.of_node = np;
+
+	ret = of_regulator_match(&pdev->dev, np, sfax8_regulator_matches,
+			ARRAY_SIZE(sfax8_regulator_matches));
+	of_node_put(np);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Parsing of regulator node failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	for (id = 0; id < ARRAY_SIZE(sfax8_regulator_matches); ++id) {
+		reg_config = &sfax8_regs->reg_config_data[id];
+		reg_config->reg_init = sfax8_regulator_matches[id].init_data;
+	}
+	return 0;
+}
+
+static int sfax8_regulator_probe(struct platform_device *pdev)
+{
+	struct sfax8 *sfax8 = dev_get_drvdata(pdev->dev.parent);
+	struct sfax8_regulators *sfax8_regs;
+	struct sfax8_regulator_config_data *reg_config;
+	struct regulator_dev *rdev;
+	struct regulator_config config = { };
+	struct regulator_ops *ops;
+	int id;
+	int ret;
+
+	dev_dbg(&pdev->dev, "start probe sfax8 regulator\n");
+
+	sfax8_regs = devm_kzalloc(&pdev->dev, sizeof(*sfax8_regs),
+				GFP_KERNEL);
+	if (!sfax8_regs)
+		return -ENOMEM;
+
+	sfax8_regs->dev = &pdev->dev;
+	sfax8_regs->sfax8 = sfax8;
+	platform_set_drvdata(pdev, sfax8_regs);
+
+	ret = sfax8_get_regulator_dt_data(pdev, sfax8_regs);
+	if (ret < 0)
+		return ret;
+
+	config.dev = &pdev->dev;
+	config.driver_data = sfax8_regs;
+	config.regmap = sfax8->regmap;
+
+	for (id = 0; id < SFAX8_REGULATOR_ID_MAX; id++) {
+		reg_config = &sfax8_regs->reg_config_data[id];
+
+		sfax8_regs->desc[id].name = sfax8_reg_lookup[id].name;
+		sfax8_regs->desc[id].supply_name = sfax8_reg_lookup[id].sname;
+		sfax8_regs->desc[id].id = sfax8_reg_lookup[id].regulator_id;
+		sfax8_regs->desc[id].n_voltages =
+					sfax8_reg_lookup[id].n_voltages;
+		sfax8_regs->desc[id].type = REGULATOR_VOLTAGE;
+		sfax8_regs->desc[id].owner = THIS_MODULE;
+		sfax8_regs->desc[id].vsel_reg = sfax8_reg_lookup[id].vsel_reg;
+		sfax8_regs->desc[id].vsel_mask =
+					sfax8_reg_lookup[id].vsel_mask;
+/*		if (id != SFAX8_REGULATOR_SVCC){
+			sfax8_regs->desc[id].enable_reg =
+					sfax8_reg_lookup[id].enable_reg;
+			sfax8_regs->desc[id].enable_mask =
+					sfax8_reg_lookup[id].enable_mask;
+			ops = &sfax8_ops;
+		}else{
+			ops = &sfax8_svcc_ops;
+		}*/
+		sfax8_regs->desc[id].enable_reg =
+				sfax8_reg_lookup[id].enable_reg;
+		sfax8_regs->desc[id].enable_mask =
+				sfax8_reg_lookup[id].enable_mask;
+		ops = &sfax8_ops;
+		switch (id) {
+		case SFAX8_REGULATOR_DCDC0:
+#ifdef ENABLE_DCDC1
+		case SFAX8_REGULATOR_DCDC1:
+#endif
+		case SFAX8_REGULATOR_DCDC2:
+			sfax8_regs->desc[id].min_uV = 600000;
+			sfax8_regs->desc[id].uV_step = 12500;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+		case SFAX8_REGULATOR_DCDC3:
+			sfax8_regs->desc[id].min_uV = 2200000;
+			sfax8_regs->desc[id].uV_step = 12500;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+		case SFAX8_REGULATOR_LDO0:
+		case SFAX8_REGULATOR_LDO1:
+		case SFAX8_REGULATOR_LDO2:
+		case SFAX8_REGULATOR_LDO4:
+		case SFAX8_REGULATOR_LDO5:
+		case SFAX8_REGULATOR_LDO6:
+			sfax8_regs->desc[id].min_uV = 700000;
+			sfax8_regs->desc[id].uV_step = 25000;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+/*		case SFAX8_REGULATOR_SVCC:
+			sfax8_regs->desc[id].min_uV = 2600000;
+			sfax8_regs->desc[id].uV_step = 100000;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;*/
+		default:
+			break;
+		}
+
+		sfax8_regs->desc[id].ops = ops;
+		config.init_data = reg_config->reg_init;
+		config.of_node = sfax8_regulator_matches[id].of_node;
+
+		dev_dbg(&pdev->dev, "register regulator num %d\n", id);
+
+		rdev = devm_regulator_register(&pdev->dev,
+					&sfax8_regs->desc[id], &config);
+		if (IS_ERR(rdev)) {
+			ret = PTR_ERR(rdev);
+			dev_err(&pdev->dev, "regulator %d register failed %d\n",
+				id, ret);
+			return ret;
+		}
+
+		sfax8_regs->rdevs[id] = rdev;
+		ret = regulator_enable_regmap(rdev);
+		if (ret < 0) {
+			dev_err(&pdev->dev,
+				"Regulator %d enable failed: %d\n",
+				id, ret);
+			return ret;
+		}
+/*
+			ret = sfax8_extreg_init(sfax8_regs, id,
+					reg_config->ext_control);
+			if (ret < 0) {
+				dev_err(&pdev->dev,
+					"SFAX8 ext control failed: %d", ret);
+				return ret;
+			}
+		}*/
+	}
+	return 0;
+}
+
+static const struct of_device_id of_sfax8_regulator_match[] = {
+	{ .compatible = "siflower, sfax8-regulator", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_sfax8_regulator_match);
+
+static struct platform_driver sfax8_regulator_driver = {
+	.driver = {
+		.name = "sfax8-regulator",
+		.owner = THIS_MODULE,
+		.of_match_table = of_sfax8_regulator_match,
+	},
+	.probe = sfax8_regulator_probe,
+};
+
+module_platform_driver(sfax8_regulator_driver);
+
+MODULE_ALIAS("platform:sfax8-regulator");
+MODULE_DESCRIPTION("SFAX8 regulator driver");
+MODULE_AUTHOR("Xijun Guo <xijun.guo@siflower.com.cn>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/regulator/sfax8_regulator_rn5t567.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/regulator/sfax8_regulator_rn5t567.c	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,408 @@
+/*
+ * Voltage regulator support for AMS SFAX8 PMIC
+ *
+ * Copyright (C) 2013 ams
+ *
+ * Author: Florian Lobmaier <florian.lobmaier@ams.com>
+ * Author: Laxman Dewangan <ldewangan@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/sfax8_rn5t567.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/slab.h>
+
+//#define ENABLE_DCDC1
+
+/* Regulator IDs */
+enum sfax8_regulators_id {
+	SFAX8_REGULATOR_DCDC1,
+	SFAX8_REGULATOR_DCDC2,
+	SFAX8_REGULATOR_DCDC3,
+	SFAX8_REGULATOR_DCDC4,
+	SFAX8_REGULATOR_LDO1,
+	SFAX8_REGULATOR_LDO2,
+	SFAX8_REGULATOR_LDO3,
+	SFAX8_REGULATOR_LDO4,
+	SFAX8_REGULATOR_LDO5,
+	SFAX8_REGULATOR_ID_MAX,
+};
+
+
+struct sfax8_register_mapping {
+	u8 regulator_id;
+	const char *name;
+	const char *sname;
+	u8 vsel_reg;
+	u8 vsel_mask;
+	int n_voltages;
+	u32 enable_reg;
+	u8 enable_mask;
+	u32 control_reg;
+	u8 mode_mask;
+	u32 sleep_ctrl_reg;
+	u8 sleep_ctrl_mask;
+	int sf_pmu_current;
+};
+
+struct sfax8_regulator_config_data {
+	struct regulator_init_data *reg_init;
+	bool enable_tracking;
+	int ext_control;
+};
+
+struct sfax8_regulators {
+	struct device *dev;
+	struct sfax8 *sfax8;
+	struct regulator_dev *rdevs[SFAX8_REGULATOR_ID_MAX];
+	struct regulator_desc desc[SFAX8_REGULATOR_ID_MAX];
+	struct sfax8_regulator_config_data
+			reg_config_data[SFAX8_REGULATOR_ID_MAX];
+};
+
+static const struct sfax8_register_mapping sfax8_reg_lookup[] = {
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC1,
+		.name = "sfax8-dcdc1",
+		.vsel_reg = SFAX8_DC1DAC,
+		.vsel_mask = SFAX8_VREG_MASK_7_0,
+		.enable_reg = SFAX8_DC1CTL,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC2,
+		.name = "sfax8-dcdc2",
+		.vsel_reg = SFAX8_DC2DAC,
+		.vsel_mask = SFAX8_VREG_MASK_7_0,
+		.enable_reg = SFAX8_DC2CTL,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 3000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC3,
+		.name = "sfax8-dcdc3",
+		.vsel_reg = SFAX8_DC3DAC,
+		.vsel_mask = SFAX8_VREG_MASK_7_0,
+		.enable_reg = SFAX8_DC3CTL,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC_VOLTAGES,
+		.sf_pmu_current = 2000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_DCDC4,
+		.name = "sfax8-dcdc4",
+		.vsel_reg = SFAX8_DC4DAC,
+		.vsel_mask = SFAX8_VREG_MASK_7_0,
+		.enable_reg = SFAX8_DC4CTL,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_DCDC3_VOLTAGES,
+		.sf_pmu_current = 2000000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO1,
+		.name = "sfax8-ldo1",
+		.vsel_reg = SFAX8_LDO1DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(0),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 300000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO2,
+		.name = "sfax8-ldo2",
+		.vsel_reg = SFAX8_LDO2DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(1),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 300000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO3,
+		.name = "sfax8-ldo3",
+		.vsel_reg = SFAX8_LDO3DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(2),
+		.n_voltages = SFAX8_LDO3_VOLTAGES,
+		.sf_pmu_current = 300000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO4,
+		.name = "sfax8-ldo4",
+		.vsel_reg = SFAX8_LDO4DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(3),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+	{
+		.regulator_id = SFAX8_REGULATOR_LDO5,
+		.name = "sfax8-ldo5",
+		.vsel_reg = SFAX8_LDO5DAC,
+		.vsel_mask = SFAX8_VREG_MASK_6_1,
+		.enable_reg = SFAX8_LDOEN1,
+		.enable_mask = ONE_BIT_SHIFT(4),
+		.n_voltages = SFAX8_LDO_VOLTAGES,
+		.sf_pmu_current = 200000,
+	},
+};
+
+static int sfax8_pmu_get_current_limit(struct regulator_dev *rdev)
+{
+	int id = rdev_get_id(rdev);
+	return sfax8_reg_lookup[id].sf_pmu_current;
+}
+
+static int sfax8_pmu_set_current_limit(struct regulator_dev *rdev,
+		int min_uA, int max_uA)
+{
+	struct sfax8_regulators *sfax8_regs = rdev_get_drvdata(rdev);
+	dev_err(sfax8_regs->dev,"Current is fixed\n");
+	return 0;
+}
+
+/*static int sfax8_regulator_enable_disable(struct regulator_dev *rdev)
+{
+	struct sfax8_regulators *sfax8_regs = rdev_get_drvdata(rdev);
+	dev_dbg(sfax8_regs->dev,"svcc can not support enable or disable\n");
+	return 0;
+}*/
+
+static struct regulator_ops sfax8_ops = {
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+	.map_voltage = regulator_map_voltage_linear,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_current_limit = sfax8_pmu_get_current_limit,
+	.set_current_limit = sfax8_pmu_set_current_limit,
+};
+
+/*static struct regulator_ops sfax8_svcc_ops = {
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = sfax8_regulator_enable_disable,
+	.disable = sfax8_regulator_enable_disable,
+	.list_voltage = regulator_list_voltage_linear,
+	.map_voltage = regulator_map_voltage_linear,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_current_limit = sfax8_pmu_get_current_limit,
+	.set_current_limit = sfax8_pmu_set_current_limit,
+};*/
+
+static struct of_regulator_match sfax8_regulator_matches[] = {
+	{ .name = "dcdc1", },
+	{ .name = "dcdc2", },
+	{ .name = "dcdc3", },
+	{ .name = "dcdc4", },
+	{ .name = "ldo1", },
+	{ .name = "ldo2", },
+	{ .name = "ldo3", },
+	{ .name = "ldo4", },
+	{ .name = "ldo5", },
+};
+
+static int sfax8_get_regulator_dt_data(struct platform_device *pdev,
+		struct sfax8_regulators *sfax8_regs)
+{
+	struct device_node *np;
+	struct sfax8_regulator_config_data *reg_config;
+	int id;
+	int ret;
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "regulators");
+	if (!np) {
+		dev_err(&pdev->dev, "Device is not having regulators node\n");
+		return -ENODEV;
+	}
+	pdev->dev.of_node = np;
+
+	ret = of_regulator_match(&pdev->dev, np, sfax8_regulator_matches,
+			ARRAY_SIZE(sfax8_regulator_matches));
+	of_node_put(np);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Parsing of regulator node failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	for (id = 0; id < ARRAY_SIZE(sfax8_regulator_matches); ++id) {
+		reg_config = &sfax8_regs->reg_config_data[id];
+		reg_config->reg_init = sfax8_regulator_matches[id].init_data;
+	}
+	return 0;
+}
+
+static int sfax8_regulator_probe(struct platform_device *pdev)
+{
+	struct sfax8 *sfax8 = dev_get_drvdata(pdev->dev.parent);
+	struct sfax8_regulators *sfax8_regs;
+	struct sfax8_regulator_config_data *reg_config;
+	struct regulator_dev *rdev;
+	struct regulator_config config = { };
+	struct regulator_ops *ops;
+	int id;
+	int ret;
+
+	dev_dbg(&pdev->dev, "start probe sfax8 regulator\n");
+
+	sfax8_regs = devm_kzalloc(&pdev->dev, sizeof(*sfax8_regs),
+				GFP_KERNEL);
+	if (!sfax8_regs)
+		return -ENOMEM;
+
+	sfax8_regs->dev = &pdev->dev;
+	sfax8_regs->sfax8 = sfax8;
+	platform_set_drvdata(pdev, sfax8_regs);
+
+	ret = sfax8_get_regulator_dt_data(pdev, sfax8_regs);
+	if (ret < 0)
+		return ret;
+
+	config.dev = &pdev->dev;
+	config.driver_data = sfax8_regs;
+	config.regmap = sfax8->regmap;
+
+	for (id = 0; id < SFAX8_REGULATOR_ID_MAX; id++) {
+		reg_config = &sfax8_regs->reg_config_data[id];
+
+		sfax8_regs->desc[id].name = sfax8_reg_lookup[id].name;
+		sfax8_regs->desc[id].supply_name = sfax8_reg_lookup[id].sname;
+		sfax8_regs->desc[id].id = sfax8_reg_lookup[id].regulator_id;
+		sfax8_regs->desc[id].n_voltages =
+					sfax8_reg_lookup[id].n_voltages;
+		sfax8_regs->desc[id].type = REGULATOR_VOLTAGE;
+		sfax8_regs->desc[id].owner = THIS_MODULE;
+		sfax8_regs->desc[id].vsel_reg = sfax8_reg_lookup[id].vsel_reg;
+		sfax8_regs->desc[id].vsel_mask =
+					sfax8_reg_lookup[id].vsel_mask;
+/*		if (id != SFAX8_REGULATOR_SVCC){
+			sfax8_regs->desc[id].enable_reg =
+					sfax8_reg_lookup[id].enable_reg;
+			sfax8_regs->desc[id].enable_mask =
+					sfax8_reg_lookup[id].enable_mask;
+			ops = &sfax8_ops;
+		}else{
+			ops = &sfax8_svcc_ops;
+		}*/
+		sfax8_regs->desc[id].enable_reg =
+				sfax8_reg_lookup[id].enable_reg;
+		sfax8_regs->desc[id].enable_mask =
+				sfax8_reg_lookup[id].enable_mask;
+		ops = &sfax8_ops;
+		switch (id) {
+		case SFAX8_REGULATOR_DCDC1:
+		case SFAX8_REGULATOR_DCDC2:
+		case SFAX8_REGULATOR_DCDC3:
+		case SFAX8_REGULATOR_DCDC4:
+			sfax8_regs->desc[id].min_uV = 600000;
+			sfax8_regs->desc[id].uV_step = 12500;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+		case SFAX8_REGULATOR_LDO1:
+		case SFAX8_REGULATOR_LDO2:
+		case SFAX8_REGULATOR_LDO4:
+		case SFAX8_REGULATOR_LDO5:
+			sfax8_regs->desc[id].min_uV = 900000;
+			sfax8_regs->desc[id].uV_step = 50000;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+		case SFAX8_REGULATOR_LDO3:
+			sfax8_regs->desc[id].min_uV = 600000;
+			sfax8_regs->desc[id].uV_step = 50000;
+			sfax8_regs->desc[id].linear_min_sel = 0;
+			sfax8_regs->desc[id].enable_time = 500;
+			break;
+		default:
+			break;
+		}
+
+		sfax8_regs->desc[id].ops = ops;
+		config.init_data = reg_config->reg_init;
+		config.of_node = sfax8_regulator_matches[id].of_node;
+
+		dev_dbg(&pdev->dev, "register regulator num %d\n", id);
+
+		rdev = devm_regulator_register(&pdev->dev,
+					&sfax8_regs->desc[id], &config);
+		if (IS_ERR(rdev)) {
+			ret = PTR_ERR(rdev);
+			dev_err(&pdev->dev, "regulator %d register failed %d\n",
+				id, ret);
+			return ret;
+		}
+
+		sfax8_regs->rdevs[id] = rdev;
+		ret = regulator_enable_regmap(rdev);
+		if (ret < 0) {
+			dev_err(&pdev->dev,
+				"Regulator %d enable failed: %d\n",
+				id, ret);
+			return ret;
+		}
+/*
+			ret = sfax8_extreg_init(sfax8_regs, id,
+					reg_config->ext_control);
+			if (ret < 0) {
+				dev_err(&pdev->dev,
+					"SFAX8 ext control failed: %d", ret);
+				return ret;
+			}
+		}*/
+	}
+	return 0;
+}
+
+static const struct of_device_id of_sfax8_regulator_match[] = {
+	{ .compatible = "siflower, sfax8-regulator", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_sfax8_regulator_match);
+
+static struct platform_driver sfax8_regulator_driver = {
+	.driver = {
+		.name = "sfax8-regulator",
+		.owner = THIS_MODULE,
+		.of_match_table = of_sfax8_regulator_match,
+	},
+	.probe = sfax8_regulator_probe,
+};
+
+module_platform_driver(sfax8_regulator_driver);
+
+MODULE_ALIAS("platform:sfax8-regulator");
+MODULE_DESCRIPTION("SFAX8 regulator driver");
+MODULE_AUTHOR("Xijun Guo <xijun.guo@siflower.com.cn>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/include/linux/mfd/sfax8_ip6103.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/linux/mfd/sfax8_ip6103.h	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,185 @@
+/*
+ * sfax8 definitions
+ *
+ * Copyright (C) 2013 ams
+ * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.
+ *
+ * Author: Florian Lobmaier <florian.lobmaier@ams.com>
+ * Author: Laxman Dewangan <ldewangan@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/regmap.h>
+/* SFAX8 registers */
+#define SFAX8_WAKE0_REG				0x00
+#define SFAX8_WAKE1_REG				0x01
+#define SFAX8_SLEEP_REG				0x02
+#define SFAX8_PROTECT_REG				0x03
+#define SFAX8_STATUE0_REG				0x04
+#define SFAX8_STATUE1_REG				0x05
+#define SFAX8_STATUE2_REG				0x06
+#define SFAX8_PWR0_REG				0x07
+#define SFAX8_PWR1_REG				0x08
+#define SFAX8_PWR2_REG				0x11
+#define SFAX8_IRC_CONF0_REG			0x13
+#define SFAX8_IRC_CONF1_REG			0x14
+#define SFAX8_IRC_ICCC_REG			0x15
+#define SFAX8_IRC_IWKDC_REG			0x16
+#define SFAX8_IRC_IKDC0_REG			0x17
+#define SFAX8_IRC_IKDC1_REG			0x18
+#define SFAX8_IRC_IRCC0_REG			0x19
+#define SFAX8_IRC_IRCC1_REG			0x1a
+#define SFAX8_PWR_OFF_FLAG_REG		0x1b
+#define SFAX8_DCDC_CTL_REG			0x20
+#define SFAX8_DCDC0_CTL0_REG			0x21
+#define SFAX8_DCDC0_CTL1_REG			0x22
+#define SFAX8_DCDC1_CTL0_REG				0x28
+#define SFAX8_DCDC1_CTL1_REG				0x29
+#define SFAX8_DCDC2_CTL0_REG				0x2F
+#define SFAX8_DCDC2_CTL1_REG				0x30
+#define SFAX8_DCDC3_CTL0_REG				0x36
+#define SFAX8_DCDC3_CTL1_REG				0x37
+#define SFAX8_SW_LDO_CTL0_REG				0x40
+#define SFAX8_SW_LDO_CTL1_REG				0x41
+#define SFAX8_LDO0_REG					0x42
+#define SFAX8_LDO1_REG					0x44
+#define SFAX8_LDO2_REG					0x46
+#define SFAX8_LDO4_REG					0x4A
+#define SFAX8_LDO5_REG					0x4C
+#define SFAX8_LDO6_REG					0x4E
+#define SFAX8_SVCC_REG					0x51
+#define SFAX8_INT0_REG					0x60
+#define SFAX8_INT1_REG					0x61
+#define SFAX8_INT2_REG					0x62
+#define SFAX8_INT3_REG					0x63
+#define SFAX8_RST_CTRL_REG	0x70
+#define SFAX8_ALARM_SEC_REG	0x71
+#define SFAX8_ALARM_MIN_REG	0x72
+#define SFAX8_ALARM_HOUR_REG	0x73
+#define SFAX8_ALARM_DAY_REG	0x74
+#define SFAX8_ALARM_MON_REG	0x75
+#define SFAX8_ALARM_YEAR_REG	0x76
+
+#define SFAX8_WATCH_SEC_REG	0x77
+#define SFAX8_WATCH_MIN_REG	0x78
+#define SFAX8_WATCH_HOUR_REG	0x79
+#define SFAX8_WATCH_DAY_REG	0x7A
+#define SFAX8_WATCH_MON_REG	0x7B
+#define SFAX8_WATCH_YEAR_REG	0x7C
+
+#define SFAX8_MFP_LDO65_REG				0x80
+#define SFAX8_MFP_LDO4_REG				0x81
+#define SFAX8_MFP_GPIO2_REG				0x82
+#define SFAX8_MFP_GPIO10_REG				0x83
+#define SFAX8_MFP_GPIO_PUPD_REG			0x84
+#define SFAX8_MFP_IRQ_REG					0x85
+#define SFAX8_MFP_RESET_EN_REG			0x86
+#define SFAX8_MFP_GPIO74_PUPD_REG			0x87
+#define SFAX8_MAX_REGISTER				0x90
+
+#define ONE_BIT_SHIFT(n)					(0x1 << n)
+#define TWO_BITS_SHIFT(n)					(0x3 << n)
+#define SFAX8_IRC_MODE_MASK				0x3
+#define SFAX8_VREG_MASK_2_0				0x07
+#define SFAX8_VREG_MASK_6_0				0x7f
+#define SFAX8_VREG_MASK_6_1				0x7e
+#define SFAX8_DCDC_VOLTAGES				0x7f
+#define SFAX8_DCDC3_VOLTAGES				0x68
+#define SFAX8_LDO_VOLTAGES				0x6c
+#define SFAX8_SVCC_VOLTAGES				0x7
+#define SF16ax8_IRQ_RTC_ALARM               5
+
+/* Interrupt IDs */
+/*enum sfax8_irq {
+	SFAX8_IRQ_LID,
+	SFAX8_IRQ_ACOK,
+	SFAX8_IRQ_ENABLE1,
+	SFAX8_IRQ_OCCUR_ALARM_SD0,
+	SFAX8_IRQ_ONKEY_LONG_PRESS,
+	SFAX8_IRQ_ONKEY,
+	SFAX8_IRQ_OVTMP,
+	SFAX8_IRQ_LOWBAT,
+	SFAX8_IRQ_SD0_LV,
+	SFAX8_IRQ_SD1_LV,
+	SFAX8_IRQ_SD2_LV,
+	SFAX8_IRQ_PWM1_OV_PROT,
+	SFAX8_IRQ_PWM2_OV_PROT,
+	SFAX8_IRQ_ENABLE2,
+	SFAX8_IRQ_SD6_LV,
+	SFAX8_IRQ_RTC_REP,
+	SFAX8_IRQ_RTC_ALARM,
+	SFAX8_IRQ_GPIO1,
+	SFAX8_IRQ_GPIO2,
+	SFAX8_IRQ_GPIO3,
+	SFAX8_IRQ_GPIO4,
+	SFAX8_IRQ_GPIO5,
+	SFAX8_IRQ_WATCHDOG,
+	SFAX8_IRQ_ENABLE3,
+	SFAX8_IRQ_TEMP_SD0_SHUTDOWN,
+	SFAX8_IRQ_TEMP_SD1_SHUTDOWN,
+	SFAX8_IRQ_TEMP_SD2_SHUTDOWN,
+	SFAX8_IRQ_TEMP_SD0_ALARM,
+	SFAX8_IRQ_TEMP_SD1_ALARM,
+	SFAX8_IRQ_TEMP_SD6_ALARM,
+	SFAX8_IRQ_OCCUR_ALARM_SD6,
+	SFAX8_IRQ_ADC,
+	SFAX8_IRQ_MAX,
+};
+*/
+struct sfax8 {
+	struct device *dev;
+	struct regmap *regmap;
+	int chip_irq;
+	unsigned long irq_flags;
+	bool en_intern_int_pullup;
+	bool en_intern_i2c_pullup;
+	struct regmap_irq_chip_data *irq_data;
+};
+
+static inline int sfax8_read(struct sfax8 *sfax8, u32 reg, u32 *dest)
+{
+	return regmap_read(sfax8->regmap, reg, dest);
+}
+
+static inline int sfax8_write(struct sfax8 *sfax8, u32 reg, u32 value)
+{
+	return regmap_write(sfax8->regmap, reg, value);
+}
+
+static inline int sfax8_block_read(struct sfax8 *sfax8, u32 reg,
+		int count, u8 *buf)
+{
+	return regmap_bulk_read(sfax8->regmap, reg, buf, count);
+}
+
+static inline int sfax8_block_write(struct sfax8 *sfax8, u32 reg,
+		int count, u8 *data)
+{
+	return regmap_bulk_write(sfax8->regmap, reg, data, count);
+}
+
+static inline int sfax8_update_bits(struct sfax8 *sfax8, u32 reg,
+		u32 mask, u8 val)
+{
+	return regmap_update_bits(sfax8->regmap, reg, mask, val);
+}
+/*
+static inline int sfax8_irq_get_virq(struct sfax8 *sfax8, int irq)
+{
+	return regmap_irq_get_virq(sfax8->irq_data, irq);
+}
+*/
Index: linux-3.18.29/include/linux/mfd/sfax8_rn5t567.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/linux/mfd/sfax8_rn5t567.h	2017-11-21 20:13:12.470710527 +0800
@@ -0,0 +1,200 @@
+/*
+ * sfax8 definitions
+ *
+ * Copyright (C) 2013 ams
+ * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.
+ *
+ * Author: Florian Lobmaier <florian.lobmaier@ams.com>
+ * Author: Laxman Dewangan <ldewangan@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/regmap.h>
+
+#define SFAX8_LSIVER    0x00
+#define SFAX8_OTPVER    0x01
+#define SFAX8_IODAC     0x02
+#define SFAX8_VINDAC    0x03
+#define SFAX8_OUT32KEN  0x05
+#define SFAX8_CPUCNT    0x06
+#define SFAX8_PSWR      0x07
+#define SFAX8_PONHIS    0x09
+#define SFAX8_POFFHIS   0x0A
+#define SFAX8_WATCHDOG  0x0B
+#define SFAX8_WATCHDOGCNT       0x0C
+#define SFAX8_PWRFUNC   0x0D
+#define SFAX8_SLPCNT    0x0E
+#define SFAX8_REPCNT    0x0F
+#define SFAX8_PWRONTIMSET       0x10
+#define SFAX8_NOETIMSET 0x11
+#define SFAX8_PWRIREN   0x12
+#define SFAX8_PWRIRQ    0x13
+#define SFAX8_PWRMON    0x14
+#define SFAX8_PWRIRSEL  0x15
+
+#define SFAX8_DC1_SLOT  0x16
+#define SFAX8_DC2_SLOT  0x17
+#define SFAX8_DC3_SLOT  0x18
+#define SFAX8_DC4_SLOT  0x19
+
+#define SFAX8_LDO1_SLOT  0x1B
+#define SFAX8_LD02_SLOT  0x1C
+#define SFAX8_LDO3_SLOT  0x1D
+#define SFAX8_LDO4_SLOT  0x1E
+#define SFAX8_LDO5_SLOT  0x1F
+
+#define SFAX8_DC1CTL    0x2C
+#define SFAX8_DC1CTL2   0x2D
+#define SFAX8_DC2CTL    0x2E
+#define SFAX8_DC2CTL2   0x2F
+#define SFAX8_DC3CTL    0x30
+#define SFAX8_DC3CTL2   0x31
+#define SFAX8_DC4CTL    0x32
+#define SFAX8_DC4CTL2   0x33
+#define SFAX8_DC1DAC    0x36
+#define SFAX8_DC2DAC    0x37
+#define SFAX8_DC3DAC    0x38
+#define SFAX8_DC4DAC    0x39
+#define SFAX8_DC1DAC_SLP        0x3B
+#define SFAX8_DC2DAC_SLP        0x3C
+#define SFAX8_DC3DAC_SLP        0x3D
+#define SFAX8_DC4DAC_SLP        0x3E
+#define SFAX8_DCIREN    0x40
+#define SFAX8_DCIRQ     0x41
+#define SFAX8_DCIRMON   0x42
+#define SFAX8_LDOEN1    0x44
+#define SFAX8_LDOEN2    0x45
+#define SFAX8_LDODIS    0x46
+#define SFAX8_LDO1DAC   0x4C
+#define SFAX8_LDO2DAC   0x4D
+#define SFAX8_LDO3DAC   0x4E
+#define SFAX8_LDO4DAC   0x4F
+#define SFAX8_LDO5DAC   0x50
+#define SFAX8_LDORTCDAC 0x56
+#define SFAX8_LDORTC2DAC        0x57
+#define SFAX8_LDO1DAC_SLP       0x58
+#define SFAX8_LDO2DAC_SLP       0x59
+#define SFAX8_LDO3DAC_SLP       0x5A
+#define SFAX8_LDO4DAC_SLP       0x5B
+#define SFAX8_LDO5DAC_SLP       0x5C
+#define SFAX8_IOSEL     0x90
+#define SFAX8_IOOUT     0x91
+#define SFAX8_GPEDGE1   0x92
+#define SFAX8_EN_GPIR   0x94
+#define SFAX8_IR_GPR    0x95
+#define SFAX8_IR_GPF    0x96
+#define SFAX8_MON_IOIN  0x97
+#define SFAX8_GPLED_FUNC        0x98
+#define SFAX8_INTPOL    0x9C
+#define SFAX8_INTEN     0x9D
+#define SFAX8_INTMON    0x9E
+#define SFAX8_PREVINDAC 0xB0
+#define SFAX8_OVTEMP    0xBC
+#define SFAX8_MAX_REGISTER		0xBC
+#define ONE_BIT_SHIFT(n)					(0x1 << n)
+#define TWO_BITS_SHIFT(n)					(0x3 << n)
+#define SFAX8_IRC_MODE_MASK				0x3
+#define SFAX8_VREG_MASK_2_0				0x07
+#define SFAX8_VREG_MASK_6_1				0x7e
+#define SFAX8_VREG_MASK_7_0				0xff
+#define SFAX8_DCDC_VOLTAGES				0xe9
+#define SFAX8_DCDC3_VOLTAGES				0x68
+#define SFAX8_LDO_VOLTAGES				0x69
+#define SFAX8_LDO3_VOLTAGES				0x75
+#define SFAX8_SVCC_VOLTAGES				0x7
+#define SF16ax8_IRQ_RTC_ALARM               5
+
+/* Interrupt IDs */
+/*enum sfax8_irq {
+	SFAX8_IRQ_LID,
+	SFAX8_IRQ_ACOK,
+	SFAX8_IRQ_ENABLE1,
+	SFAX8_IRQ_OCCUR_ALARM_SD0,
+	SFAX8_IRQ_ONKEY_LONG_PRESS,
+	SFAX8_IRQ_ONKEY,
+	SFAX8_IRQ_OVTMP,
+	SFAX8_IRQ_LOWBAT,
+	SFAX8_IRQ_SD0_LV,
+	SFAX8_IRQ_SD1_LV,
+	SFAX8_IRQ_SD2_LV,
+	SFAX8_IRQ_PWM1_OV_PROT,
+	SFAX8_IRQ_PWM2_OV_PROT,
+	SFAX8_IRQ_ENABLE2,
+	SFAX8_IRQ_SD6_LV,
+	SFAX8_IRQ_RTC_REP,
+	SFAX8_IRQ_RTC_ALARM,
+	SFAX8_IRQ_GPIO1,
+	SFAX8_IRQ_GPIO2,
+	SFAX8_IRQ_GPIO3,
+	SFAX8_IRQ_GPIO4,
+	SFAX8_IRQ_GPIO5,
+	SFAX8_IRQ_WATCHDOG,
+	SFAX8_IRQ_ENABLE3,
+	SFAX8_IRQ_TEMP_SD0_SHUTDOWN,
+	SFAX8_IRQ_TEMP_SD1_SHUTDOWN,
+	SFAX8_IRQ_TEMP_SD2_SHUTDOWN,
+	SFAX8_IRQ_TEMP_SD0_ALARM,
+	SFAX8_IRQ_TEMP_SD1_ALARM,
+	SFAX8_IRQ_TEMP_SD6_ALARM,
+	SFAX8_IRQ_OCCUR_ALARM_SD6,
+	SFAX8_IRQ_ADC,
+	SFAX8_IRQ_MAX,
+};
+*/
+struct sfax8 {
+	struct device *dev;
+	struct regmap *regmap;
+	int chip_irq;
+	unsigned long irq_flags;
+	bool en_intern_int_pullup;
+	bool en_intern_i2c_pullup;
+	struct regmap_irq_chip_data *irq_data;
+};
+
+static inline int sfax8_read(struct sfax8 *sfax8, u32 reg, u32 *dest)
+{
+	return regmap_read(sfax8->regmap, reg, dest);
+}
+
+static inline int sfax8_write(struct sfax8 *sfax8, u32 reg, u32 value)
+{
+	return regmap_write(sfax8->regmap, reg, value);
+}
+
+static inline int sfax8_block_read(struct sfax8 *sfax8, u32 reg,
+		int count, u8 *buf)
+{
+	return regmap_bulk_read(sfax8->regmap, reg, buf, count);
+}
+
+static inline int sfax8_block_write(struct sfax8 *sfax8, u32 reg,
+		int count, u8 *data)
+{
+	return regmap_bulk_write(sfax8->regmap, reg, data, count);
+}
+
+static inline int sfax8_update_bits(struct sfax8 *sfax8, u32 reg,
+		u32 mask, u8 val)
+{
+	return regmap_update_bits(sfax8->regmap, reg, mask, val);
+}
+/*
+static inline int sfax8_irq_get_virq(struct sfax8 *sfax8, int irq)
+{
+	return regmap_irq_get_virq(sfax8->irq_data, irq);
+}
+*/
Index: linux-3.18.29/drivers/dma/dmaengine.c
===================================================================
--- linux-3.18.29.orig/drivers/dma/dmaengine.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/dma/dmaengine.c	2017-11-21 20:13:12.474710527 +0800
@@ -521,10 +521,18 @@
 	mutex_lock(&dma_list_mutex);
 
 	if (chan->client_count == 0) {
+		struct dma_device *device = chan->device;
+
+		dma_cap_set(DMA_PRIVATE, device->cap_mask);
+		device->privatecnt++;
 		err = dma_chan_get(chan);
-		if (err)
+		if (err) {
 			pr_debug("%s: failed to get %s: (%d)\n",
 				__func__, dma_chan_name(chan), err);
+			chan = NULL;
+			if (--device->privatecnt == 0)
+				dma_cap_clear(DMA_PRIVATE, device->cap_mask);
+		}
 	} else
 		chan = NULL;
 
Index: linux-3.18.29/drivers/misc/Kconfig
===================================================================
--- linux-3.18.29.orig/drivers/misc/Kconfig	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/misc/Kconfig	2017-11-21 20:13:12.474710527 +0800
@@ -456,6 +456,18 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called bmp085-spi.
 
+config SFAX8_RESET_BUTTON_IP6103
+	tristate "SIFLOWER recovery driver"
+	default MFD_SFAX8_IP6103
+	help
+		Say Y here if you want to support recovery by pressing power-on button.
+
+config SFAX8_RESET_BUTTON_RN5T567
+	tristate "SIFLOWER recovery driver"
+	default MFD_SFAX8_RN5T567
+	help
+		Say Y here if you want to support recovery by pressing power-on button.
+
 config PCH_PHUB
 	tristate "Intel EG20T PCH/LAPIS Semicon IOH(ML7213/ML7223/ML7831) PHUB"
 	select GENERIC_NET_UTILS
Index: linux-3.18.29/drivers/misc/Makefile
===================================================================
--- linux-3.18.29.orig/drivers/misc/Makefile	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/drivers/misc/Makefile	2017-11-21 09:22:50.297559000 +0800
@@ -26,6 +26,14 @@
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
+obj-$(CONFIG_SFAX8_RESET_BUTTON_IP6103)		+= sfax8_reset_button.o
+obj-$(CONFIG_SFAX8_RESET_BUTTON_RN5T567)	+= sfax8_reset_button.o
+ifdef CONFIG_SFAX8_RESET_BUTTON_IP6103
+sfax8_reset_button-objs 	:= sfax8_reset_button_ip6103.o
+endif
+ifdef CONFIG_SFAX8_RESET_BUTTON_RN5T567
+sfax8_reset_button-objs		:= sfax8_reset_button_rn5t567.o
+endif
 obj-$(CONFIG_CS5535_MFGPT)	+= cs5535-mfgpt.o
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
 obj-$(CONFIG_APDS9802ALS)	+= apds9802als.o
Index: linux-3.18.29/drivers/misc/sfax8_reset_button_ip6103.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/misc/sfax8_reset_button_ip6103.c	2017-11-21 20:13:12.474710527 +0800
@@ -0,0 +1,202 @@
+/*
+ *	A18 not use IR device on IP6103, and this driver is not full testing,
+ *	add this driver just for future to use.
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/sfax8_ip6103.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/sched.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <misc/sfax8.h>
+
+#define PMU_ONOFF_TIME		0x02
+#define ONOFF_TIME_V		0x83
+#define ONOFF_TIME_MASK		0xc3
+#define PMU_INT				0x85
+#define INT_V				0x11
+#define INT_MASK			0x13
+#define PMU_ONOFF_MODE		0x60
+#define ONOFF_MODE_V		0x04
+#define ONOFF_MODE_MASK		0x04
+#define PMU_ONOFF_INT		0x62
+#define ONOFF_INT_V			0x04
+#define ONOFF_INT_MASK		0x04
+#define LED_ON				0
+#define LED_OFF				1
+
+
+struct sfax8_data *data;
+struct sfax8 *parent_data;
+static int gpio;
+
+int sfax8_recovery_clear_interrupt(void)
+{
+	int ret = 0, value = 0;
+	ret = regmap_read(parent_data->regmap, PMU_ONOFF_INT, &value);
+	if(ret){
+		printk(KERN_ERR "Read reg fail!\n");
+		return -EINVAL;
+	}
+	if( value & ONOFF_INT_MASK){
+		ret = regmap_write(parent_data->regmap, PMU_ONOFF_INT, ONOFF_INT_V);
+		if (ret){
+			printk(KERN_ERR "Clear reset button irq error\n");
+			return -EINVAL;
+		}else{
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL(sfax8_recovery_clear_interrupt);
+
+int sfax8_recovery_reg_init(void)
+{
+	int ret = 0;	
+	ret |= regmap_update_bits(parent_data->regmap, PMU_ONOFF_TIME, ONOFF_TIME_MASK, ONOFF_TIME_V);
+	ret |= regmap_update_bits(parent_data->regmap, PMU_INT, INT_MASK, INT_V);
+	ret |= regmap_update_bits(parent_data->regmap, PMU_ONOFF_MODE, ONOFF_MODE_MASK, ONOFF_MODE_V);
+
+	if (ret){
+		printk(KERN_ERR "Configure pmu reset button, error %d\n", ret);
+	}
+	return ret;
+}
+
+int sfax8_recovery_init(struct sfax8_data *u_data)
+{
+		if(sfax8_recovery_reg_init())
+			return -EINVAL;
+		else{
+			u_data->irq = data->irq;
+			u_data->dev = data->dev;
+			return 0;
+		}
+};
+
+EXPORT_SYMBOL(sfax8_recovery_init);
+/*
+* if the parameter is true, the led will be set on,
+* else set off
+*/
+int sfax8_recovery_led_on(bool on)
+{
+	int ret;
+	if(gpio < 0){
+		printk(KERN_ERR "%s: bad gpio number.\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = gpio_direction_output(gpio, LED_OFF);
+	if (ret){
+		printk(KERN_ERR "Set led gpio output fail!\n");
+		return -EINVAL;
+	}
+	if(on)
+		gpio_set_value(gpio, LED_ON);
+	else
+		gpio_set_value(gpio, LED_OFF);
+	return 0;
+}
+EXPORT_SYMBOL(sfax8_recovery_led_on);
+
+static int sfax8_rb_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	int ret = 0;
+	int irq;
+	u16 rb_gpio, led_gpio;
+
+	printk(KERN_DEBUG "Start reset button probe!\n");
+
+	data = devm_kzalloc(&pdev->dev, sizeof(struct sfax8_data), GFP_KERNEL);
+	if (!data){
+		printk(KERN_ERR "Alloc sfax8 recovery data error\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	data->dev = &pdev->dev;
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "reset-button");
+	pdev->dev.of_node = np;
+
+	led_gpio = of_get_named_gpio(pdev->dev.of_node, "led-gpio", 0);
+	if (!gpio_is_valid(led_gpio)){
+		printk( "Get reset led gpio fail!\n");
+		ret = -1;
+		gpio = -1;
+		goto err;
+	}
+	gpio = led_gpio;
+
+	ret = devm_gpio_request(&pdev->dev, led_gpio, "reset led gpio");
+	if (ret){
+		printk(KERN_ERR "Request reset led gpio fail! %d\n", ret);
+		goto err;
+	}
+
+	rb_gpio = of_get_named_gpio(pdev->dev.of_node, "rb-gpio", 0);
+	if (!gpio_is_valid(rb_gpio)){
+		printk( "Get reset gpio fail!\n");
+		ret = -1;
+		goto err;
+	}
+	ret = devm_gpio_request(&pdev->dev, rb_gpio, "reset button gpio");
+	if (ret){
+		printk("Request gpio fail! %d\n", ret);
+		goto err;
+	}
+
+	ret = gpio_direction_input(rb_gpio);
+	if (ret){
+		printk("Set gpio input fail!\n");
+		goto err;
+	}
+
+	irq = gpio_to_irq(rb_gpio);
+	if (irq <= 0){
+		printk("GPIO to irq fail!\n");
+		ret = -1;
+		data->irq = -1;
+		goto err;
+	}
+	data->irq = irq;
+
+	parent_data = dev_get_drvdata(pdev->dev.parent);
+	
+	regcache_cache_bypass(parent_data->regmap, true);
+
+
+err:
+	return ret;
+
+}
+
+static int sfax8_rb_exit(struct platform_device *pdev){
+		return 0;
+}
+
+static struct platform_driver sfax8_rb_driver = {
+		.driver			= {
+				.name	= "reset-button",
+				.owner	= THIS_MODULE,
+		},
+		.probe			= sfax8_rb_probe,
+		.remove			= sfax8_rb_exit,
+};
+
+module_platform_driver(sfax8_rb_driver);
+
+MODULE_AUTHOR("Chang Li <chang.li@siflower.com.cn>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/drivers/misc/sfax8_reset_button_rn5t567.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/drivers/misc/sfax8_reset_button_rn5t567.c	2017-11-21 20:13:12.474710527 +0800
@@ -0,0 +1,220 @@
+/*
+ *	A18 not use IR device on IP6103, and this driver is not full testing,
+ *	add this driver just for future to use.
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/sfax8_rn5t567.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/sched.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <misc/sfax8.h>
+
+#define PMU_ONOFF_TIME		0x10
+#define ONOFF_TIME_V		0x3d
+#define ONOFF_TIME_MASK		0xff
+
+#define PMU_PORTION_INT		0x12
+#define INT_PORTION_V		0x11
+#define INT_PORTION_MASK	0x7f
+
+#define PMU_INT_TYPE		0x9c
+#define INT_TYPE_V			0x1
+#define INT_TYPE_MASK		0x1
+
+#define PMU_INT				0x9d
+#define INT_V				0x1
+#define INT_MASK			0x13
+
+#define PMU_ONOFF_MODE		0x60
+#define ONOFF_MODE_V		0x04
+#define ONOFF_MODE_MASK		0x04
+
+#define PMU_ONOFF_INT		0x13
+#define ONOFF_INT_V			0x0
+#define ONOFF_INT_MASK_PWON	0x01
+#define ONOFF_INT_MASK_PWOF	0x10
+
+
+#define LED_ON				0
+#define LED_OFF				1
+static int gpio;
+
+struct sfax8_data *data;
+struct sfax8 *parent_data;
+
+int sfax8_recovery_clear_interrupt(void)
+{
+	int ret = 0, value = 0;	
+	ret = regmap_read(parent_data->regmap, PMU_ONOFF_INT, &value);
+	if(ret){
+		printk(KERN_DEBUG "Read reg fail!\n");
+		return -EINVAL;
+	}
+
+	if( value & ONOFF_INT_MASK_PWON){
+		ret = regmap_write(parent_data->regmap, PMU_ONOFF_INT, ONOFF_INT_V);
+		if (ret){
+			printk(KERN_DEBUG "Clear reset button irq error\n");
+			return -EINVAL;
+		}
+	} else if (value & ONOFF_INT_MASK_PWOF){
+		ret = regmap_write(parent_data->regmap, PMU_ONOFF_INT, ONOFF_INT_V);
+		if (ret){
+			printk(KERN_DEBUG "Clear reset button irq error\n");
+			return -EINVAL;
+		}else
+			return 0;
+	}
+	return -EINVAL;
+
+}
+EXPORT_SYMBOL(sfax8_recovery_clear_interrupt);
+
+int sfax8_recovery_reg_init(void)
+{
+	int ret = 0;	
+	ret |= regmap_update_bits(parent_data->regmap, PMU_ONOFF_TIME, ONOFF_TIME_MASK, ONOFF_TIME_V);
+	ret |= regmap_update_bits(parent_data->regmap, PMU_INT, INT_MASK, INT_V);
+	ret |= regmap_update_bits(parent_data->regmap, PMU_INT_TYPE, INT_TYPE_MASK, INT_TYPE_V);
+	ret |= regmap_update_bits(parent_data->regmap, PMU_PORTION_INT, INT_PORTION_MASK, INT_PORTION_V);
+	if (ret)
+		printk(KERN_DEBUG "Configure pmu reset button, error %d\n", ret);
+	return ret;
+}
+
+int sfax8_recovery_init(struct sfax8_data *u_data)
+{
+		if(sfax8_recovery_reg_init())
+			return -EINVAL;
+		else{
+			u_data->irq = data->irq;
+			u_data->dev = data->dev;
+			return 0;
+		}
+};
+EXPORT_SYMBOL(sfax8_recovery_init);
+
+/*
+* if the parameter is true, the led will be set on,
+* else set off
+*/
+int sfax8_recovery_led_on(bool on)
+{
+	int ret;
+	if(gpio < 0){
+		printk(KERN_ERR "%s: bad gpio number.\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = gpio_direction_output(gpio, LED_OFF);
+	if (ret){
+		printk(KERN_ERR "Set led gpio output fail!\n");
+		return -EINVAL;
+	}
+	if(on)
+		gpio_set_value(gpio, LED_ON);
+	else
+		gpio_set_value(gpio, LED_OFF);
+	return 0;
+}
+EXPORT_SYMBOL(sfax8_recovery_led_on);
+
+static int sfax8_rb_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	int ret = 0;
+	int irq;
+	u16 rb_gpio, led_gpio;
+
+	printk( "Start reset button probe!\n");
+
+	data = devm_kzalloc(&pdev->dev, sizeof(struct sfax8_data), GFP_KERNEL);
+	if (!data){
+		printk( "Alloc sfax8 recovery data error\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	data->dev = &pdev->dev;
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "reset-button");
+	pdev->dev.of_node = np;
+
+	led_gpio = of_get_named_gpio(pdev->dev.of_node, "led-gpio", 0);
+	if (!gpio_is_valid(led_gpio)){
+		printk( "Get reset led gpio fail!\n");
+		ret = -1;
+		gpio = -1;
+		goto err;
+	}
+	gpio = led_gpio;
+
+	ret = devm_gpio_request(&pdev->dev, led_gpio, "reset led gpio");
+	if (ret){
+		printk("Request reset led gpio fail! %d\n", ret);
+		goto err;
+	}
+
+	rb_gpio = of_get_named_gpio(pdev->dev.of_node, "rb-gpio", 0);
+	if (!gpio_is_valid(rb_gpio)){
+		printk( "Get reset gpio fail!\n");
+		ret = -1;
+		goto err;
+	}
+	ret = devm_gpio_request(&pdev->dev, rb_gpio, "reset button gpio");
+	if (ret){
+		printk("Request gpio fail! %d\n", ret);
+		goto err;
+	}
+
+	ret = gpio_direction_input(rb_gpio);
+	if (ret){
+		printk("Set gpio input fail!\n");
+		goto err;
+	}
+
+	irq = gpio_to_irq(rb_gpio);
+	if (irq <= 0){
+		printk("GPIO to irq fail!\n");
+		ret = -1;
+		data->irq = -1;
+		goto err;
+	}
+	data->irq = irq;
+
+	parent_data = dev_get_drvdata(pdev->dev.parent);
+
+	regcache_cache_bypass(parent_data->regmap, true);
+
+err:
+	return ret;
+
+}
+
+static int sfax8_rb_exit(struct platform_device *pdev){
+	return 0;
+}
+
+static struct platform_driver sfax8_rb_driver = {
+		.driver			= {
+				.name	= "reset-button",
+				.owner	= THIS_MODULE,
+		},
+		.probe			= sfax8_rb_probe,
+		.remove			= sfax8_rb_exit,
+};
+
+module_platform_driver(sfax8_rb_driver);
+
+MODULE_AUTHOR("Chang Li <chang.li@siflower.com.cn>");
+MODULE_LICENSE("GPL");
Index: linux-3.18.29/arch/mips/kernel/irq-gic.c
===================================================================
--- linux-3.18.29.orig/arch/mips/kernel/irq-gic.c	2016-03-18 02:09:52.000000000 +0800
+++ linux-3.18.29/arch/mips/kernel/irq-gic.c	2017-11-21 20:13:12.474710527 +0800
@@ -248,7 +248,7 @@
 	unsigned long	flags;
 	int		i;
 
-	cpumask_and(&tmp, cpumask, cpu_online_mask);
+	cpumask_and(&tmp, cpumask, force ? cpumask : cpu_online_mask);
 	if (cpus_empty(tmp))
 		return -1;
 
Index: linux-3.18.29/include/misc/sfax8.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.29/include/misc/sfax8.h	2017-11-21 20:13:12.474710527 +0800
@@ -0,0 +1,20 @@
+/*
+	Siflower sfax8 recovery driver head file.
+*/
+struct sfax8_data{
+	int irq;
+	struct device *dev;
+};
+/*
+*	if init error, retrun NULL
+*/
+extern int sfax8_recovery_init(struct sfax8_data *data);
+/*
+*  return true if  irq matched the recovery condition,
+*  else return flase.
+*/
+extern int sfax8_recovery_clear_interrupt(void); 
+/*
+* set led on  and off
+*/
+extern int sfax8_recovery_led_on(bool);
