--- a/src/dnsmasq.c
+++ b/src/dnsmasq.c
@@ -4,12 +4,12 @@
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; version 2 dated June, 1991, or
    (at your option) version 3 dated 29 June, 2007.
- 
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-     
+
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
@@ -19,6 +19,11 @@
 
 #include "dnsmasq.h"
 
+#ifdef URL_LIST
+#define URLFILE "/etc/url_list"
+struct mac_node * gpmac_list_hdr = NULL;
+#endif
+
 struct daemon *daemon;
 
 static volatile pid_t pid = 0;
@@ -53,7 +58,7 @@ int main (int argc, char **argv)
   cap_user_data_t data = NULL;
   char *bound_device = NULL;
   int did_bind = 0;
-#endif 
+#endif
 #if defined(HAVE_DHCP) || defined(HAVE_DHCP6)
   struct dhcp_context *context;
   struct dhcp_relay *relay;
@@ -64,7 +69,7 @@ int main (int argc, char **argv)
 
 #ifdef LOCALEDIR
   setlocale(LC_ALL, "");
-  bindtextdomain("dnsmasq", LOCALEDIR); 
+  bindtextdomain("dnsmasq", LOCALEDIR);
   textdomain("dnsmasq");
 #endif
 
@@ -83,30 +88,30 @@ int main (int argc, char **argv)
   sigaction(SIGPIPE, &sigact, NULL);
 
   umask(022); /* known umask, create leases and pid files as 0644 */
- 
+
   rand_init(); /* Must precede read_opts() */
-  
+
   read_opts(argc, argv, compile_opts);
- 
+
   if (daemon->edns_pktsz < PACKETSZ)
     daemon->edns_pktsz = PACKETSZ;
 
-  daemon->packet_buff_sz = daemon->edns_pktsz > DNSMASQ_PACKETSZ ? 
+  daemon->packet_buff_sz = daemon->edns_pktsz > DNSMASQ_PACKETSZ ?
     daemon->edns_pktsz : DNSMASQ_PACKETSZ;
   daemon->packet = safe_malloc(daemon->packet_buff_sz);
-  
+
   daemon->addrbuff = safe_malloc(ADDRSTRLEN);
   if (option_bool(OPT_EXTRALOG))
     daemon->addrbuff2 = safe_malloc(ADDRSTRLEN);
-  
+
 #ifdef HAVE_DNSSEC
   if (option_bool(OPT_DNSSEC_VALID))
     {
       /* Note that both /000 and '.' are allowed within labels. These get
 	 represented in presentation format using NAME_ESCAPE as an escape
-	 character when in DNSSEC mode. 
+	 character when in DNSSEC mode.
 	 In theory, if all the characters in a name were /000 or
-	 '.' or NAME_ESCAPE then all would have to be escaped, so the 
+	 '.' or NAME_ESCAPE then all would have to be escaped, so the
 	 presentation format would be twice as long as the spec.
 
 	 daemon->namebuff was previously allocated by the option-reading
@@ -125,20 +130,20 @@ int main (int argc, char **argv)
 	daemon->lease_file = LEASEFILE;
     }
 #endif
-  
-  /* Close any file descriptors we inherited apart from std{in|out|err} 
-     
+
+  /* Close any file descriptors we inherited apart from std{in|out|err}
+
      Ensure that at least stdin, stdout and stderr (fd 0, 1, 2) exist,
-     otherwise file descriptors we create can end up being 0, 1, or 2 
-     and then get accidentally closed later when we make 0, 1, and 2 
-     open to /dev/null. Normally we'll be started with 0, 1 and 2 open, 
-     but it's not guaranteed. By opening /dev/null three times, we 
+     otherwise file descriptors we create can end up being 0, 1, or 2
+     and then get accidentally closed later when we make 0, 1, and 2
+     open to /dev/null. Normally we'll be started with 0, 1 and 2 open,
+     but it's not guaranteed. By opening /dev/null three times, we
      ensure that we're not using those fds for real stuff. */
   for (i = 0; i < max_fd; i++)
     if (i != STDOUT_FILENO && i != STDERR_FILENO && i != STDIN_FILENO)
       close(i);
     else
-      open("/dev/null", O_RDWR); 
+      open("/dev/null", O_RDWR);
 
 #ifndef HAVE_LINUX_NETWORK
 #  if !(defined(IP_RECVDSTADDR) && defined(IP_RECVIF) && defined(IP_SENDSRCADDR))
@@ -148,7 +153,7 @@ int main (int argc, char **argv)
       set_option_bool(OPT_NOWILD);
     }
 #  endif
-  
+
   /* -- bind-dynamic not supported on !Linux, fall back to --bind-interfaces */
   if (option_bool(OPT_CLEVERBIND))
     {
@@ -162,16 +167,16 @@ int main (int argc, char **argv)
   if (daemon->dynamic_dirs)
     die(_("dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"), NULL, EC_BADCONF);
 #endif
-  
+
   if (option_bool(OPT_DNSSEC_VALID))
     {
 #ifdef HAVE_DNSSEC
       if (!daemon->ds)
 	die(_("no trust anchors provided for DNSSEC"), NULL, EC_BADCONF);
-      
+
       if (daemon->cachesize < CACHESIZ)
 	die(_("cannot reduce cache size from default when DNSSEC enabled"), NULL, EC_BADCONF);
-#else 
+#else
       die(_("DNSSEC not available: set HAVE_DNSSEC in src/config.h"), NULL, EC_BADCONF);
 #endif
     }
@@ -183,7 +188,7 @@ int main (int argc, char **argv)
 
 #ifdef HAVE_CONNTRACK
   if (option_bool(OPT_CONNTRACK) && (daemon->query_port != 0 || daemon->osport))
-    die (_("cannot use --conntrack AND --query-port"), NULL, EC_BADCONF); 
+    die (_("cannot use --conntrack AND --query-port"), NULL, EC_BADCONF);
 #else
   if (option_bool(OPT_CONNTRACK))
     die(_("conntrack support not available: set HAVE_CONNTRACK in src/config.h"), NULL, EC_BADCONF);
@@ -193,7 +198,7 @@ int main (int argc, char **argv)
   if (daemon->max_logs != 0)
     die(_("asychronous logging is not available under Solaris"), NULL, EC_BADCONF);
 #endif
-  
+
 #ifdef __ANDROID__
   if (daemon->max_logs != 0)
     die(_("asychronous logging is not available under Android"), NULL, EC_BADCONF);
@@ -208,7 +213,7 @@ int main (int argc, char **argv)
   if (option_bool(OPT_LOOP_DETECT))
     die(_("loop detection not available: set HAVE_LOOP in src/config.h"), NULL, EC_BADCONF);
 #endif
-  
+
   now = dnsmasq_time();
 
   /* Create a serial at startup if not configured. */
@@ -218,12 +223,12 @@ int main (int argc, char **argv)
 #else
   daemon->soa_sn = now;
 #endif
-  
+
 #ifdef HAVE_DHCP6
   if (daemon->dhcp6)
     {
       daemon->doing_ra = option_bool(OPT_RA);
-      
+
       for (context = daemon->dhcp6; context; context = context->next)
 	{
 	  if (context->flags & CONTEXT_DHCP)
@@ -233,11 +238,11 @@ int main (int argc, char **argv)
 #if !defined(HAVE_LINUX_NETWORK) && !defined(HAVE_BSD_NETWORK)
 	  if (context->flags & CONTEXT_TEMPLATE)
 	    die (_("dhcp-range constructor not available on this platform"), NULL, EC_BADCONF);
-#endif 
+#endif
 	}
     }
 #endif
-  
+
 #ifdef HAVE_DHCP
   /* Note that order matters here, we must call lease_init before
      creating any file descriptors which shouldn't be leaked
@@ -249,14 +254,14 @@ int main (int argc, char **argv)
       if (daemon->dhcp || daemon->doing_dhcp6)
 	lease_init(now);
     }
-  
+
   if (daemon->dhcp || daemon->relay4)
     dhcp_init();
-  
+
 #  ifdef HAVE_DHCP6
   if (daemon->doing_ra || daemon->doing_dhcp6 || daemon->relay6)
     ra_init(now);
-  
+
   if (daemon->doing_dhcp6 || daemon->relay6)
     dhcp6_init();
 #  endif
@@ -276,14 +281,14 @@ int main (int argc, char **argv)
 
   if (option_bool(OPT_NOWILD) && option_bool(OPT_CLEVERBIND))
     die(_("cannot set --bind-interfaces and --bind-dynamic"), NULL, EC_BADCONF);
-  
+
   if (!enumerate_interfaces(1) || !enumerate_interfaces(0))
     die(_("failed to find list of interfaces: %s"), NULL, EC_MISC);
-  
-  if (option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND)) 
+
+  if (option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND))
     {
       create_bound_listeners(1);
-      
+
       if (!option_bool(OPT_CLEVERBIND))
 	for (if_tmp = daemon->if_names; if_tmp; if_tmp = if_tmp->next)
 	  if (if_tmp->name && !if_tmp->used)
@@ -292,7 +297,7 @@ int main (int argc, char **argv)
 #if defined(HAVE_LINUX_NETWORK) && defined(HAVE_DHCP)
       /* after enumerate_interfaces()  */
       bound_device = whichdevice();
-      
+
       if (daemon->dhcp)
 	{
 	  if (!daemon->relay4 && bound_device)
@@ -316,9 +321,9 @@ int main (int argc, char **argv)
 	}
 #endif
     }
-  else 
+  else
     create_wildcard_listeners();
- 
+
 #ifdef HAVE_DHCP6
   /* after enumerate_interfaces() */
   if (daemon->doing_dhcp6 || daemon->relay6 || daemon->doing_ra)
@@ -327,7 +332,7 @@ int main (int argc, char **argv)
   /* After netlink_init() and before create_helper() */
   lease_make_duid(now);
 #endif
-  
+
   if (daemon->port != 0)
     {
       cache_init();
@@ -343,7 +348,7 @@ int main (int argc, char **argv)
   else
     daemon->inotifyfd = -1;
 #endif
-       
+
   if (option_bool(OPT_DBUS))
 #ifdef HAVE_DBUS
     {
@@ -362,8 +367,8 @@ int main (int argc, char **argv)
 
 #if defined(HAVE_SCRIPT)
   /* Note getpwnam returns static storage */
-  if ((daemon->dhcp || daemon->dhcp6) && 
-      daemon->scriptuser && 
+  if ((daemon->dhcp || daemon->dhcp6) &&
+      daemon->scriptuser &&
       (daemon->lease_change_command || daemon->luascript))
     {
       if ((ent_pw = getpwnam(daemon->scriptuser)))
@@ -375,7 +380,7 @@ int main (int argc, char **argv)
 	baduser = daemon->scriptuser;
     }
 #endif
-  
+
   if (daemon->username && !(ent_pw = getpwnam(daemon->username)))
     baduser = daemon->username;
   else if (daemon->groupname && !(gp = getgrnam(daemon->groupname)))
@@ -389,10 +394,10 @@ int main (int argc, char **argv)
     {
       if (!(gp = getgrnam(CHGRP)) && ent_pw)
 	gp = getgrgid(ent_pw->pw_gid);
-      
+
       /* for error message */
       if (gp)
-	daemon->groupname = gp->gr_name; 
+	daemon->groupname = gp->gr_name;
     }
 
 #if defined(HAVE_LINUX_NETWORK)
@@ -406,7 +411,7 @@ int main (int argc, char **argv)
       /* find version supported by kernel */
       memset(hdr, 0, sizeof(*hdr));
       capget(hdr, NULL);
-      
+
       if (hdr->version != LINUX_CAPABILITY_VERSION_1)
 	{
 	  /* if unknown version, use largest supported version (3) */
@@ -414,44 +419,44 @@ int main (int argc, char **argv)
 	    hdr->version = LINUX_CAPABILITY_VERSION_3;
 	  capsize = 2;
 	}
-      
+
       data = safe_malloc(sizeof(*data) * capsize);
       memset(data, 0, sizeof(*data) * capsize);
     }
 #endif
 
-  /* Use a pipe to carry signals and other events back to the event loop 
+  /* Use a pipe to carry signals and other events back to the event loop
      in a race-free manner and another to carry errors to daemon-invoking process */
   safe_pipe(pipefd, 1);
-  
+
   piperead = pipefd[0];
   pipewrite = pipefd[1];
   /* prime the pipe to load stuff first time. */
-  send_event(pipewrite, EVENT_INIT, 0, NULL); 
+  send_event(pipewrite, EVENT_INIT, 0, NULL);
 
   err_pipe[1] = -1;
-  
-  if (!option_bool(OPT_DEBUG))   
+
+  if (!option_bool(OPT_DEBUG))
     {
-      /* The following code "daemonizes" the process. 
+      /* The following code "daemonizes" the process.
 	 See Stevens section 12.4 */
-      
+
       if (chdir("/") != 0)
-	die(_("cannot chdir to filesystem root: %s"), NULL, EC_MISC); 
+	die(_("cannot chdir to filesystem root: %s"), NULL, EC_MISC);
 
-#ifndef NO_FORK      
+#ifndef NO_FORK
       if (!option_bool(OPT_NO_FORK))
 	{
 	  pid_t pid;
-	  
+
 	  /* pipe to carry errors back to original process.
 	     When startup is complete we close this and the process terminates. */
 	  safe_pipe(err_pipe, 0);
-	  
+
 	  if ((pid = fork()) == -1)
 	    /* fd == -1 since we've not forked, never returns. */
 	    send_event(-1, EVENT_FORK_ERR, errno, NULL);
-	   
+
 	  if (pid != 0)
 	    {
 	      struct event_desc ev;
@@ -459,28 +464,28 @@ int main (int argc, char **argv)
 
 	      /* close our copy of write-end */
 	      while (retry_send(close(err_pipe[1])));
-	      
+
 	      /* check for errors after the fork */
 	      if (read_event(err_pipe[0], &ev, &msg))
 		fatal_event(&ev, msg);
-	      
+
 	      _exit(EC_GOOD);
-	    } 
-	  
+	    }
+
 	  while (retry_send(close(err_pipe[0])));
 
 	  /* NO calls to die() from here on. */
-	  
+
 	  setsid();
-	 
+
 	  if ((pid = fork()) == -1)
 	    send_event(err_pipe[1], EVENT_FORK_ERR, errno, NULL);
-	 
+
 	  if (pid != 0)
 	    _exit(0);
 	}
 #endif
-            
+
       /* write pidfile _after_ forking ! */
       if (daemon->runfile)
 	{
@@ -490,25 +495,25 @@ int main (int argc, char **argv)
 
 	  /* Explanation: Some installations of dnsmasq (eg Debian/Ubuntu) locate the pid-file
 	     in a directory which is writable by the non-privileged user that dnsmasq runs as. This
-	     allows the daemon to delete the file as part of its shutdown. This is a security hole to the 
-	     extent that an attacker running as the unprivileged  user could replace the pidfile with a 
-	     symlink, and have the target of that symlink overwritten as root next time dnsmasq starts. 
+	     allows the daemon to delete the file as part of its shutdown. This is a security hole to the
+	     extent that an attacker running as the unprivileged  user could replace the pidfile with a
+	     symlink, and have the target of that symlink overwritten as root next time dnsmasq starts.
 
 	     The folowing code first deletes any existing file, and then opens it with the O_EXCL flag,
-	     ensuring that the open() fails should there be any existing file (because the unlink() failed, 
+	     ensuring that the open() fails should there be any existing file (because the unlink() failed,
 	     or an attacker exploited the race between unlink() and open()). This ensures that no symlink
-	     attack can succeed. 
+	     attack can succeed.
 
 	     Any compromise of the non-privileged user still theoretically allows the pid-file to be
-	     replaced whilst dnsmasq is running. The worst that could allow is that the usual 
+	     replaced whilst dnsmasq is running. The worst that could allow is that the usual
 	     "shutdown dnsmasq" shell command could be tricked into stopping any other process.
 
-	     Note that if dnsmasq is started as non-root (eg for testing) it silently ignores 
+	     Note that if dnsmasq is started as non-root (eg for testing) it silently ignores
 	     failure to write the pid-file.
 	  */
 
-	  unlink(daemon->runfile); 
-	  
+	  unlink(daemon->runfile);
+
 	  if ((fd = open(daemon->runfile, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH)) == -1)
 	    {
 	      /* only complain if started as root */
@@ -519,7 +524,7 @@ int main (int argc, char **argv)
 	    {
 	      if (!read_write(fd, (unsigned char *)daemon->namebuff, strlen(daemon->namebuff), 0))
 		err = 1;
-	      else 
+	      else
 		{
 		  while (retry_send(close(fd)));
 		  if (errno != 0)
@@ -534,11 +539,11 @@ int main (int argc, char **argv)
 	    }
 	}
     }
-  
+
    log_err = log_start(ent_pw, err_pipe[1]);
 
-   if (!option_bool(OPT_DEBUG)) 
-     {       
+   if (!option_bool(OPT_DEBUG))
+     {
        /* open  stdout etc to /dev/null */
        int nullfd = open("/dev/null", O_RDWR);
        dup2(nullfd, STDOUT_FILENO);
@@ -546,51 +551,51 @@ int main (int argc, char **argv)
        dup2(nullfd, STDIN_FILENO);
        close(nullfd);
      }
-   
+
    /* if we are to run scripts, we need to fork a helper before dropping root. */
   daemon->helperfd = -1;
-#ifdef HAVE_SCRIPT 
+#ifdef HAVE_SCRIPT
   if ((daemon->dhcp || daemon->dhcp6) && (daemon->lease_change_command || daemon->luascript))
     daemon->helperfd = create_helper(pipewrite, err_pipe[1], script_uid, script_gid, max_fd);
 #endif
 
-  if (!option_bool(OPT_DEBUG) && getuid() == 0)   
+  if (!option_bool(OPT_DEBUG) && getuid() == 0)
     {
       int bad_capabilities = 0;
       gid_t dummy;
-      
+
       /* remove all supplimentary groups */
-      if (gp && 
+      if (gp &&
 	  (setgroups(0, &dummy) == -1 ||
 	   setgid(gp->gr_gid) == -1))
 	{
 	  send_event(err_pipe[1], EVENT_GROUP_ERR, errno, daemon->groupname);
 	  _exit(0);
 	}
-  
+
       if (ent_pw && ent_pw->pw_uid != 0)
-	{     
-#if defined(HAVE_LINUX_NETWORK)	  
+	{
+#if defined(HAVE_LINUX_NETWORK)
 	  /* On linux, we keep CAP_NETADMIN (for ARP-injection) and
-	     CAP_NET_RAW (for icmp) if we're doing dhcp. If we have yet to bind 
+	     CAP_NET_RAW (for icmp) if we're doing dhcp. If we have yet to bind
 	     ports because of DAD, or we're doing it dynamically,
 	     we need CAP_NET_BIND_SERVICE too. */
 	  if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
 	    data->effective = data->permitted = data->inheritable =
-	      (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | 
+	      (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) |
 	      (1 << CAP_SETUID) | (1 << CAP_NET_BIND_SERVICE);
 	  else
 	    data->effective = data->permitted = data->inheritable =
 	      (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_SETUID);
-	  
+
 	  /* Tell kernel to not clear capabilities when dropping root */
 	  if (capset(hdr, data) == -1 || prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) == -1)
 	    bad_capabilities = errno;
-			  
+
 #elif defined(HAVE_SOLARIS_NETWORK)
 	  /* http://developers.sun.com/solaris/articles/program_privileges.html */
 	  priv_set_t *priv_set;
-	  
+
 	  if (!(priv_set = priv_str_to_set("basic", ",", NULL)) ||
 	      priv_addset(priv_set, PRIV_NET_ICMPACCESS) == -1 ||
 	      priv_addset(priv_set, PRIV_SYS_NET_CONFIG) == -1)
@@ -599,7 +604,7 @@ int main (int argc, char **argv)
 	  if (priv_set && bad_capabilities == 0)
 	    {
 	      priv_inverse(priv_set);
-	  
+
 	      if (setppriv(PRIV_OFF, PRIV_LIMIT, priv_set) == -1)
 		bad_capabilities = errno;
 	    }
@@ -607,30 +612,30 @@ int main (int argc, char **argv)
 	  if (priv_set)
 	    priv_freeset(priv_set);
 
-#endif    
+#endif
 
 	  if (bad_capabilities != 0)
 	    {
 	      send_event(err_pipe[1], EVENT_CAP_ERR, bad_capabilities, NULL);
 	      _exit(0);
 	    }
-	  
+
 	  /* finally drop root */
 	  if (setuid(ent_pw->pw_uid) == -1)
 	    {
 	      send_event(err_pipe[1], EVENT_USER_ERR, errno, daemon->username);
 	      _exit(0);
-	    }     
+	    }
 
 #ifdef HAVE_LINUX_NETWORK
 	  if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
 	   data->effective = data->permitted =
 	     (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_NET_BIND_SERVICE);
 	 else
-	   data->effective = data->permitted = 
+	   data->effective = data->permitted =
 	     (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW);
 	  data->inheritable = 0;
-	  
+
 	  /* lose the setuid and setgid capbilities */
 	  if (capset(hdr, data) == -1)
 	    {
@@ -638,14 +643,14 @@ int main (int argc, char **argv)
 	      _exit(0);
 	    }
 #endif
-	  
+
 	}
     }
-  
+
 #ifdef HAVE_LINUX_NETWORK
   free(hdr);
   free(data);
-  if (option_bool(OPT_DEBUG)) 
+  if (option_bool(OPT_DEBUG))
     prctl(PR_SET_DUMPABLE, 1, 0, 0, 0);
 #endif
 
@@ -654,7 +659,7 @@ int main (int argc, char **argv)
     {
       DIR *dir;
       struct tftp_prefix *p;
-      
+
       if (daemon->tftp_prefix)
 	{
 	  if (!((dir = opendir(daemon->tftp_prefix))))
@@ -694,9 +699,9 @@ int main (int argc, char **argv)
     my_syslog(LOG_INFO, _("started, version %s cachesize %d"), VERSION, daemon->cachesize);
   else
     my_syslog(LOG_INFO, _("started, version %s cache disabled"), VERSION);
-  
+
   my_syslog(LOG_INFO, _("compile time options: %s"), compile_opts);
-  
+
 #ifdef HAVE_DBUS
   if (option_bool(OPT_DBUS))
     {
@@ -709,35 +714,35 @@ int main (int argc, char **argv)
 
   if (option_bool(OPT_LOCAL_SERVICE))
     my_syslog(LOG_INFO, _("DNS service limited to local subnets"));
-  
+
 #ifdef HAVE_DNSSEC
   if (option_bool(OPT_DNSSEC_VALID))
     {
       int rc;
 
       /* Delay creating the timestamp file until here, after we've changed user, so that
-	 it has the correct owner to allow updating the mtime later. 
+	 it has the correct owner to allow updating the mtime later.
 	 This means we have to report fatal errors via the pipe. */
       if ((rc = setup_timestamp()) == -1)
 	{
 	  send_event(err_pipe[1], EVENT_TIME_ERR, errno, daemon->timestamp_file);
 	  _exit(0);
 	}
-      
+
       my_syslog(LOG_INFO, _("DNSSEC validation enabled"));
-      
+
       if (option_bool(OPT_DNSSEC_TIME))
 	my_syslog(LOG_INFO, _("DNSSEC signature timestamps not checked until first cache reload"));
-      
+
       if (rc == 1)
 	my_syslog(LOG_INFO, _("DNSSEC signature timestamps not checked until system time valid"));
     }
 #endif
 
   if (log_err != 0)
-    my_syslog(LOG_WARNING, _("warning: failed to change owner of %s: %s"), 
+    my_syslog(LOG_WARNING, _("warning: failed to change owner of %s: %s"),
 	      daemon->log_file, strerror(log_err));
-  
+
   if (bind_fallback)
     my_syslog(LOG_WARNING, _("setting --bind-interfaces option because of OS limitations"));
 
@@ -745,12 +750,12 @@ int main (int argc, char **argv)
     warn_bound_listeners();
 
   warn_int_names();
-  
-  if (!option_bool(OPT_NOWILD)) 
+
+  if (!option_bool(OPT_NOWILD))
     for (if_tmp = daemon->if_names; if_tmp; if_tmp = if_tmp->next)
       if (if_tmp->name && !if_tmp->used)
 	my_syslog(LOG_WARNING, _("warning: interface %s does not currently exist"), if_tmp->name);
-   
+
   if (daemon->port != 0 && option_bool(OPT_NO_RESOLV))
     {
       if (daemon->resolv_files && !daemon->resolv_files->is_default)
@@ -758,11 +763,11 @@ int main (int argc, char **argv)
       daemon->resolv_files = NULL;
       if (!daemon->servers)
 	my_syslog(LOG_WARNING, _("warning: no upstream servers configured"));
-    } 
+    }
 
   if (daemon->max_logs != 0)
     my_syslog(LOG_INFO, _("asynchronous logging enabled, queue limit is %d messages"), daemon->max_logs);
-  
+
 
 #ifdef HAVE_DHCP
   for (context = daemon->dhcp; context; context = context->next)
@@ -777,10 +782,10 @@ int main (int argc, char **argv)
 
   for (relay = daemon->relay6; relay; relay = relay->next)
     log_relay(AF_INET6, relay);
-  
+
   if (daemon->doing_dhcp6 || daemon->doing_ra)
     dhcp_construct_contexts(now);
-  
+
   if (option_bool(OPT_RA))
     my_syslog(MS_DHCP | LOG_INFO, _("IPv6 router advertisement enabled"));
 #  endif
@@ -804,7 +809,7 @@ int main (int argc, char **argv)
 	max_fd = FD_SETSIZE;
 #endif
 
-      my_syslog(MS_TFTP | LOG_INFO, "TFTP %s%s %s", 
+      my_syslog(MS_TFTP | LOG_INFO, "TFTP %s%s %s",
 		daemon->tftp_prefix ? _("root is ") : _("enabled"),
 		daemon->tftp_prefix ? daemon->tftp_prefix: "",
 		option_bool(OPT_TFTP_SECURE) ? _("secure mode") : "");
@@ -816,21 +821,21 @@ int main (int argc, char **argv)
 	if (p->missing)
 	   my_syslog(MS_TFTP | LOG_WARNING, _("warning: TFTP directory %s inaccessible"), p->prefix);
 
-      /* This is a guess, it assumes that for small limits, 
-	 disjoint files might be served, but for large limits, 
+      /* This is a guess, it assumes that for small limits,
+	 disjoint files might be served, but for large limits,
 	 a single file will be sent to may clients (the file only needs
 	 one fd). */
 
       max_fd -= 30; /* use other than TFTP */
-      
+
       if (max_fd < 0)
 	max_fd = 5;
       else if (max_fd < 100)
 	max_fd = max_fd/2;
       else
 	max_fd = max_fd - 20;
-      
-      /* if we have to use a limited range of ports, 
+
+      /* if we have to use a limited range of ports,
 	 that will limit the number of transfers */
       if (daemon->start_tftp_port != 0 &&
 	  daemon->end_tftp_port - daemon->start_tftp_port + 1 < max_fd)
@@ -839,8 +844,8 @@ int main (int argc, char **argv)
       if (daemon->tftp_max > max_fd)
 	{
 	  daemon->tftp_max = max_fd;
-	  my_syslog(MS_TFTP | LOG_WARNING, 
-		    _("restricting maximum simultaneous TFTP transfers to %d"), 
+	  my_syslog(MS_TFTP | LOG_WARNING,
+		    _("restricting maximum simultaneous TFTP transfers to %d"),
 		    daemon->tftp_max);
 	}
     }
@@ -849,27 +854,27 @@ int main (int argc, char **argv)
   /* finished start-up - release original process */
   if (err_pipe[1] != -1)
     while (retry_send(close(err_pipe[1])));
-  
+
   if (daemon->port != 0)
     check_servers();
-  
+
   pid = getpid();
-  
+
 #ifdef HAVE_INOTIFY
   /* Using inotify, have to select a resolv file at startup */
   poll_resolv(1, 0, now);
 #endif
-  
+
   while (1)
     {
       int maxfd = -1;
       struct timeval t, *tp = NULL;
       fd_set rset, wset, eset;
-      
+
       FD_ZERO(&rset);
       FD_ZERO(&wset);
       FD_ZERO(&eset);
-      
+
       /* if we are out of resources, find how long we have to wait
 	 for some to come free, we'll loop around then and restart
 	 listening for queries */
@@ -897,8 +902,8 @@ int main (int argc, char **argv)
 
 #ifdef HAVE_DBUS
       set_dbus_listeners(&maxfd, &rset, &wset, &eset);
-#endif	
-  
+#endif
+
 #ifdef HAVE_DHCP
       if (daemon->dhcp || daemon->relay4)
 	{
@@ -922,10 +927,10 @@ int main (int argc, char **argv)
       if (daemon->doing_ra)
 	{
 	  FD_SET(daemon->icmp6fd, &rset);
-	  bump_maxfd(daemon->icmp6fd, &maxfd); 
+	  bump_maxfd(daemon->icmp6fd, &maxfd);
 	}
 #endif
-    
+
 #ifdef HAVE_INOTIFY
       if (daemon->inotifyfd != -1)
 	{
@@ -941,7 +946,7 @@ int main (int argc, char **argv)
       FD_SET(daemon->routefd, &rset);
       bump_maxfd(daemon->routefd, &maxfd);
 #endif
-      
+
       FD_SET(piperead, &rset);
       bump_maxfd(piperead, &maxfd);
 
@@ -962,17 +967,17 @@ int main (int argc, char **argv)
       /* need this for other side-effects */
       while (do_script_run(now));
 
-#    ifdef HAVE_TFTP 
+#    ifdef HAVE_TFTP
       while (do_tftp_script_run());
 #    endif
 
 #  endif
 #endif
-   
+
       /* must do this just before select(), when we know no
 	 more calls to my_syslog() can occur */
       set_log_writer(&wset, &maxfd);
-      
+
       if (select(maxfd+1, &rset, &wset, &eset, tp) < 0)
 	{
 	  /* otherwise undefined after error */
@@ -1009,27 +1014,27 @@ int main (int argc, char **argv)
 	{
 	  if (daemon->port != 0 && !option_bool(OPT_NO_POLL))
 	    poll_resolv(1, 1, now);
-	} 	  
+	}
 #else
       /* Check for changes to resolv files once per second max. */
       /* Don't go silent for long periods if the clock goes backwards. */
-      if (daemon->last_resolv == 0 || 
-	  difftime(now, daemon->last_resolv) > 1.0 || 
+      if (daemon->last_resolv == 0 ||
+	  difftime(now, daemon->last_resolv) > 1.0 ||
 	  difftime(now, daemon->last_resolv) < -1.0)
 	{
-	  /* poll_resolv doesn't need to reload first time through, since 
+	  /* poll_resolv doesn't need to reload first time through, since
 	     that's queued anyway. */
 
-	  poll_resolv(0, daemon->last_resolv != 0, now); 	  
+	  poll_resolv(0, daemon->last_resolv != 0, now);
 	  daemon->last_resolv = now;
 	}
 #endif
 
       if (FD_ISSET(piperead, &rset))
 	async_event(piperead, now);
-      
+
 #ifdef HAVE_DBUS
-      /* if we didn't create a DBus connection, retry now. */ 
+      /* if we didn't create a DBus connection, retry now. */
      if (option_bool(OPT_DBUS) && !daemon->dbus)
 	{
 	  char *err;
@@ -1040,12 +1045,12 @@ int main (int argc, char **argv)
 	}
       check_dbus_listeners(&rset, &wset, &eset);
 #endif
-      
+
       check_dns_listeners(&rset, now);
 
 #ifdef HAVE_TFTP
       check_tftp_listeners(&rset, now);
-#endif      
+#endif
 
 #ifdef HAVE_DHCP
       if (daemon->dhcp || daemon->relay4)
@@ -1073,6 +1078,239 @@ int main (int argc, char **argv)
     }
 }
 
+#ifdef URL_LIST
+unsigned short char_to_short(char* src){
+	unsigned short dst = *src | (*(src + 1) << 8 );
+	return dst;
+}
+void short_to_char(unsigned short src, char* dst){
+	*dst = src & 0x00ff;
+	*(dst + 1) = (src & 0xff00) >> 8;
+	return ;
+}
+
+struct mac_node * find_mac_node(unsigned char* mac, struct mac_node * pmac_list_hdr){
+	struct mac_node * ptmp = pmac_list_hdr;
+	my_syslog(LOG_WARNING, _("mac search is %02x:%02x:%02x:%02x:%02x:%02x"), mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	while(ptmp){
+		my_syslog(LOG_WARNING, _("mac in list is %02x:%02x:%02x:%02x:%02x:%02x"), ptmp->mac[0], ptmp->mac[1], ptmp->mac[2], ptmp->mac[3], ptmp->mac[4], ptmp->mac[5]);
+		if(memcmp(mac,ptmp->mac, 6) == 0 ) return ptmp;
+		ptmp = ptmp->pnext;
+	}
+	return NULL;
+}
+
+static int free_url_list(struct url_node** ppurl_list_hdr){
+
+	struct url_node * ptmp = *ppurl_list_hdr, * pfree = NULL;
+
+	while(ptmp){
+		pfree = ptmp;
+		ptmp = ptmp->pnext;
+		free(pfree->url_str);
+		free(pfree);
+	}
+
+	*ppurl_list_hdr = NULL;
+}
+// free old url list, and set new
+static int build_url_list(struct url_node** ppurl_list_hdr, char* flat_url_list){
+	struct url_node *  pnew = NULL, *plast= NULL;
+	unsigned short count = char_to_short(flat_url_list);
+	unsigned short i = 0, len = 0;
+	char * flat_url_string = flat_url_list + 2 + 2*count;
+
+	free_url_list(ppurl_list_hdr);
+
+	for(i = 0; i < count; i++){
+		pnew = (struct url_node *)malloc(sizeof(struct url_node));
+		pnew->pnext = NULL;
+		if(i == 0)
+		  *ppurl_list_hdr = pnew;
+		else
+		  plast->pnext = pnew;
+
+		// should include in len
+		len = char_to_short(flat_url_list + 2 + 2*i);
+		pnew->str_len= len;
+		pnew->url_str = malloc(len + 1);
+		memcpy(pnew->url_str, flat_url_string, len);
+		pnew->url_str[len] = '\0';
+
+		my_syslog(LOG_WARNING, _("string %s len is %d"), pnew->url_str, pnew->str_len);
+		flat_url_string += len;
+		plast = pnew;
+	}
+	return 0;
+}
+static int change_node_form_flat(struct mac_node * pmac_list_hdr, char * flat_mac_node_hdr, char* flat_url_list){
+	unsigned char * mac = flat_mac_node_hdr + 2;
+	struct mac_node * ptmp = NULL;
+
+	if((ptmp = find_mac_node(mac,pmac_list_hdr)) == NULL) return -1;
+	if(ptmp->list_type != *(flat_mac_node_hdr + 8)) ptmp->list_type = *(flat_mac_node_hdr + 8);
+	if(build_url_list( &ptmp->purl_list_hdr, flat_url_list) < 0 ) return -2;
+
+	return  0;
+}
+
+static int add_node_form_flat(struct mac_node ** ppmac_list_hdr, char * flat_mac_node_hdr, char* flat_url_list){
+	struct mac_node *pnew = malloc(sizeof(struct mac_node));
+
+	pnew->pnext = *ppmac_list_hdr;
+	*ppmac_list_hdr = pnew;
+
+	pnew->purl_list_hdr = NULL;
+
+	memcpy(pnew->mac, (flat_mac_node_hdr + 2), 6);
+	pnew->list_type = *(flat_mac_node_hdr + 8);
+	if(build_url_list( &pnew->purl_list_hdr, flat_url_list) < 0 ) return -2;
+
+	return 0;
+}
+
+static int delete_node(struct mac_node ** ppmac_list_hdr, char * mac_addr){
+	struct mac_node * ptmp = *ppmac_list_hdr, *plast = NULL;
+	int ret = -1;
+	if(*ppmac_list_hdr == NULL)
+	  return 0;
+	if(mac_addr){
+		while(ptmp){
+			if(memcmp(mac_addr,ptmp->mac, 6) == 0) {
+				ret = 0;
+				break;
+			}
+			plast = ptmp;
+			ptmp = ptmp->pnext;
+		}
+		if(ret == 0){
+			if(plast == NULL){
+				*ppmac_list_hdr = ptmp->pnext;
+			}
+			else{
+				plast->pnext = ptmp->pnext;
+			}
+			free_url_list(&ptmp->purl_list_hdr);
+			free(ptmp);
+		}
+	}else{
+		while(ptmp){
+			plast = ptmp;
+			ptmp = ptmp->pnext;
+			free_url_list(&ptmp->purl_list_hdr);
+			free(ptmp);
+		}
+		*ppmac_list_hdr = NULL;
+		ret = 0;
+	}
+	return  ret ;
+}
+
+void dump_list(struct mac_node * pmac_list_node, unsigned short count){
+
+	struct mac_node * pnode = pmac_list_node;
+	while(pnode && count){
+		unsigned char * mac = pnode->mac;
+		my_syslog(LOG_ERR, _("dump mac node"));
+		my_syslog(LOG_ERR, _("mac is %02x:%02x:%02x:%02x:%02x:%02x"), mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+		my_syslog(LOG_ERR, _("list type %d"), pmac_list_node->list_type);
+		struct url_node * purl_node = pnode->purl_list_hdr;
+		while(purl_node){
+			my_syslog(LOG_ERR, _("url string %s len %d"), purl_node->url_str, purl_node->str_len);
+			purl_node = purl_node->pnext;
+		}
+		count--;
+		pnode = pnode->pnext;
+	}
+	return;
+}
+static void update_url_list(void){
+	int fd, i, ret = 0;
+	struct stat sb;
+	unsigned int len = 0, map_size = 0;
+	unsigned char* addr = NULL, * op_mac= NULL,  op_type = 0, * flat_mac_node_hdr = NULL,* flat_url_list = NULL;
+	unsigned short node_count = 0;
+
+	my_syslog(LOG_ERR, _("update list here"));
+	fd = open(URLFILE, O_RDONLY);
+	if(fd < 0){
+		my_syslog(LOG_ERR, _("failed to open url list"));
+		return;
+	}
+
+	if (fstat(fd, &sb) == -1){ /* To obtain file size */
+		my_syslog(LOG_ERR, _("get file info error"));
+		close(fd);
+		return;
+	}
+	if(sb.st_size <= 18){
+		my_syslog(LOG_ERR, _("file size is too small %d"), sb.st_size);
+		close(fd);
+		return;
+	}
+
+	map_size =  ((sb.st_size + 4096 - 1) & (~( 4096 - 1 )));
+// memory ref to dns_control.pdf
+	addr =(unsigned char *) mmap(NULL, map_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	close(fd);
+	if (addr == MAP_FAILED){
+		my_syslog(LOG_ERR, _("map file error"));
+		return;
+	}
+	op_mac = addr;
+	op_type  = *(addr + 6);
+// every time change for one mac node, and the node will be the last one when ssst prepare the data, node_count at least is 1
+	node_count = char_to_short(addr+7);
+	switch (op_type) {
+		//add
+		case  0:
+			// get last mac node hdr
+			my_syslog(LOG_ERR, _("add mac here"));
+			flat_mac_node_hdr = addr + 9 + 9 * (node_count-1);
+			len = char_to_short(flat_mac_node_hdr);
+			flat_url_list = addr + (sb.st_size) - len;
+			add_node_form_flat( &gpmac_list_hdr, flat_mac_node_hdr, flat_url_list);
+			dump_list(gpmac_list_hdr,100);
+			break;
+		//change
+		case  1 :
+			// get last mac node hdr
+			my_syslog(LOG_ERR, _("change mac here"));
+			flat_mac_node_hdr = addr + 9 + 9 * (node_count-1);
+			len = char_to_short(flat_mac_node_hdr);
+			flat_url_list = addr + (sb.st_size) - len;
+			change_node_form_flat( gpmac_list_hdr, flat_mac_node_hdr, flat_url_list);
+			dump_list(gpmac_list_hdr,100);
+			break;
+		// delete
+		case  2 :
+			my_syslog(LOG_ERR, _("delete mac here"));
+			delete_node (&gpmac_list_hdr, op_mac);
+			dump_list(gpmac_list_hdr,100);
+			break;
+		// init
+		case  3 :
+			my_syslog(LOG_ERR, _("init list here"));
+			delete_node(&gpmac_list_hdr, NULL);
+			flat_url_list = addr + 9 + 9*node_count;
+			for(i = 0; i < node_count; i++){
+				flat_mac_node_hdr = addr + 9 + 9 * i;
+				len = char_to_short(flat_mac_node_hdr);
+				add_node_form_flat( &gpmac_list_hdr, flat_mac_node_hdr, flat_url_list);
+				flat_url_list += len;
+			}
+			dump_list(gpmac_list_hdr,node_count);
+			break;
+		default:
+			return;
+
+	}
+	return;
+}
+
+#endif
+
+
 static void sig_handler(int sig)
 {
   if (pid == 0)
@@ -1092,7 +1330,7 @@ static void sig_handler(int sig)
     {
       /* master process */
       int event, errsave = errno;
-      
+
       if (sig == SIGHUP)
 	event = EVENT_RELOAD;
       else if (sig == SIGCHLD)
@@ -1104,11 +1342,18 @@ static void sig_handler(int sig)
       else if (sig == SIGUSR1)
 	event = EVENT_DUMP;
       else if (sig == SIGUSR2)
+#ifdef URL_LIST
+	  {
+		  my_syslog(LOG_ERR, _("sigal event usr2"));
+		  event = EVENT_UPDATE_LIST;
+	  }
+#else
 	event = EVENT_REOPEN;
+#endif
       else
 	return;
 
-      send_event(pipewrite, event, 0, NULL); 
+      send_event(pipewrite, event, 0, NULL);
       errno = errsave;
     }
 }
@@ -1121,8 +1366,8 @@ void send_alarm(time_t event, time_t now
       /* alarm(0) or alarm(-ve) doesn't do what we want.... */
       if ((now == 0 || difftime(event, now) <= 0.0))
 	send_event(pipewrite, EVENT_ALARM, 0, NULL);
-      else 
-	alarm((unsigned)difftime(event, now)); 
+      else
+	alarm((unsigned)difftime(event, now));
     }
 }
 
@@ -1139,12 +1384,12 @@ void send_event(int fd, int event, int d
   ev.event = event;
   ev.data = data;
   ev.msg_sz = msg ? strlen(msg) : 0;
-  
+
   iov[0].iov_base = &ev;
   iov[0].iov_len = sizeof(ev);
   iov[1].iov_base = msg;
   iov[1].iov_len = ev.msg_sz;
-  
+
   /* error pipe, debug mode. */
   if (fd == -1)
     fatal_event(&ev, msg);
@@ -1162,10 +1407,10 @@ static int read_event(int fd, struct eve
 
   if (!read_write(fd, (unsigned char *)evp, sizeof(struct event_desc), 1))
     return 0;
-  
+
   *msg = NULL;
-  
-  if (evp->msg_sz != 0 && 
+
+  if (evp->msg_sz != 0 &&
       (buf = malloc(evp->msg_sz + 1)) &&
       read_write(fd, (unsigned char *)buf, evp->msg_sz, 1))
     {
@@ -1175,11 +1420,11 @@ static int read_event(int fd, struct eve
 
   return 1;
 }
-    
+
 static void fatal_event(struct event_desc *ev, char *msg)
 {
   errno = ev->data;
-  
+
   switch (ev->event)
     {
     case EVENT_DIE:
@@ -1187,10 +1432,10 @@ static void fatal_event(struct event_des
 
     case EVENT_FORK_ERR:
       die(_("cannot fork into background: %s"), NULL, EC_MISC);
-  
+
     case EVENT_PIPE_ERR:
       die(_("failed to create helper: %s"), NULL, EC_MISC);
-  
+
     case EVENT_CAP_ERR:
       die(_("setting capabilities failed: %s"), NULL, EC_MISC);
 
@@ -1199,34 +1444,34 @@ static void fatal_event(struct event_des
 
     case EVENT_GROUP_ERR:
       die(_("failed to change group-id to %s: %s"), msg, EC_MISC);
-      
+
     case EVENT_PIDFILE:
       die(_("failed to open pidfile %s: %s"), msg, EC_FILE);
 
     case EVENT_LOG_ERR:
       die(_("cannot open log %s: %s"), msg, EC_FILE);
-    
+
     case EVENT_LUA_ERR:
       die(_("failed to load Lua script: %s"), msg, EC_MISC);
 
     case EVENT_TFTP_ERR:
       die(_("TFTP directory %s inaccessible: %s"), msg, EC_FILE);
-    
+
     case EVENT_TIME_ERR:
       die(_("cannot create timestamp file %s: %s" ), msg, EC_BADCONF);
     }
-}	
-      
+}
+
 static void async_event(int pipe, time_t now)
 {
   pid_t p;
   struct event_desc ev;
   int i, check = 0;
   char *msg;
-  
+
   /* NOTE: the memory used to return msg is leaked: use msgs in events only
      to describe fatal errors. */
-  
+
   if (read_event(pipe, &ev, &msg))
     switch (ev.event)
       {
@@ -1236,13 +1481,13 @@ static void async_event(int pipe, time_t
 	  {
 	    my_syslog(LOG_INFO, _("now checking DNSSEC signature timestamps"));
 	    reset_option_bool(OPT_DNSSEC_TIME);
-	  } 
+	  }
 #endif
 	/* fall through */
-	
+
       case EVENT_INIT:
 	clear_cache_and_reload(now);
-	
+
 	if (daemon->port != 0)
 	  {
 	    if (daemon->resolv_files && option_bool(OPT_NO_POLL))
@@ -1265,12 +1510,12 @@ static void async_event(int pipe, time_t
 	rerun_scripts();
 #endif
 	break;
-	
+
       case EVENT_DUMP:
 	if (daemon->port != 0)
 	  dump_cache(now);
 	break;
-	
+
       case EVENT_ALARM:
 #ifdef HAVE_DHCP
 	if (daemon->dhcp || daemon->doing_dhcp6)
@@ -1285,7 +1530,7 @@ static void async_event(int pipe, time_t
 #endif
 #endif
 	break;
-		
+
       case EVENT_CHILD:
 	/* See Stevens 5.10 */
 	while ((p = waitpid(-1, NULL, WNOHANG)) != 0)
@@ -1293,13 +1538,13 @@ static void async_event(int pipe, time_t
 	    {
 	      if (errno != EINTR)
 		break;
-	    }      
-	  else 
+	    }
+	  else
 	    for (i = 0 ; i < MAX_PROCS; i++)
 	      if (daemon->tcp_pids[i] == p)
 		daemon->tcp_pids[i] = 0;
 	break;
-	
+
       case EVENT_KILLED:
 	my_syslog(LOG_WARNING, _("script process killed by signal %d"), ev.data);
 	break;
@@ -1309,7 +1554,7 @@ static void async_event(int pipe, time_t
 	break;
 
       case EVENT_EXEC_ERR:
-	my_syslog(LOG_ERR, _("failed to execute %s: %s"), 
+	my_syslog(LOG_ERR, _("failed to execute %s: %s"),
 		  daemon->lease_change_command, strerror(ev.data));
 	break;
 
@@ -1338,32 +1583,38 @@ static void async_event(int pipe, time_t
 	poll_resolv(0, 1, now);
 	break;
 
+#ifdef URL_LIST
+	  case EVENT_UPDATE_LIST:
+		update_url_list();
+		break;
+#endif
+
       case EVENT_TERM:
 	/* Knock all our children on the head. */
 	for (i = 0; i < MAX_PROCS; i++)
 	  if (daemon->tcp_pids[i] != 0)
 	    kill(daemon->tcp_pids[i], SIGALRM);
-	
+
 #if defined(HAVE_SCRIPT)
 	/* handle pending lease transitions */
 	if (daemon->helperfd != -1)
 	  {
 	    /* block in writes until all done */
 	    if ((i = fcntl(daemon->helperfd, F_GETFL)) != -1)
-	      fcntl(daemon->helperfd, F_SETFL, i & ~O_NONBLOCK); 
+	      fcntl(daemon->helperfd, F_SETFL, i & ~O_NONBLOCK);
 	    do {
 	      helper_write();
 	    } while (!helper_buf_empty() || do_script_run(now));
 	    while (retry_send(close(daemon->helperfd)));
 	  }
 #endif
-	
+
 	if (daemon->lease_stream)
 	  fclose(daemon->lease_stream);
 
 	if (daemon->runfile)
 	  unlink(daemon->runfile);
-	
+
 	my_syslog(LOG_INFO, _("exiting on receipt of SIGTERM"));
 	flush_log();
 	exit(EC_GOOD);
@@ -1375,28 +1626,28 @@ static void poll_resolv(int force, int d
   struct resolvc *res, *latest;
   struct stat statbuf;
   time_t last_change = 0;
-  /* There may be more than one possible file. 
+  /* There may be more than one possible file.
      Go through and find the one which changed _last_.
      Warn of any which can't be read. */
 
   if (daemon->port == 0 || option_bool(OPT_NO_POLL))
     return;
-  
+
   for (latest = NULL, res = daemon->resolv_files; res; res = res->next)
     if (stat(res->name, &statbuf) == -1)
       {
 	if (force)
 	  {
-	    res->mtime = 0; 
+	    res->mtime = 0;
 	    continue;
 	  }
 
 	if (!res->logged)
 	  my_syslog(LOG_WARNING, _("failed to access %s: %s"), res->name, strerror(errno));
 	res->logged = 1;
-	
+
 	if (res->mtime != 0)
-	  { 
+	  {
 	    /* existing file evaporated, force selection of the latest
 	       file even if its mtime hasn't changed since we last looked */
 	    poll_resolv(1, do_reload, now);
@@ -1416,7 +1667,7 @@ static void poll_resolv(int force, int d
 	      }
 	  }
       }
-  
+
   if (latest)
     {
       static int warned = 0;
@@ -1428,7 +1679,7 @@ static void poll_resolv(int force, int d
 	  if (option_bool(OPT_RELOAD) && do_reload)
 	    clear_cache_and_reload(now);
 	}
-      else 
+      else
 	{
 	  latest->mtime = 0;
 	  if (!warned)
@@ -1438,7 +1689,7 @@ static void poll_resolv(int force, int d
 	    }
 	}
     }
-}       
+}
 
 void clear_cache_and_reload(time_t now)
 {
@@ -1446,7 +1697,7 @@ void clear_cache_and_reload(time_t now)
 
   if (daemon->port != 0)
     cache_reload();
-  
+
 #ifdef HAVE_DHCP
   if (daemon->dhcp || daemon->doing_dhcp6)
     {
@@ -1457,13 +1708,13 @@ void clear_cache_and_reload(time_t now)
       set_dynamic_inotify(AH_DHCP_HST | AH_DHCP_OPT, 0, NULL, 0);
 #endif
       dhcp_update_configs(daemon->dhcp_conf);
-      lease_update_from_configs(); 
-      lease_update_file(now); 
+      lease_update_from_configs();
+      lease_update_file(now);
       lease_update_dns(1);
     }
 #ifdef HAVE_DHCP6
   else if (daemon->doing_ra)
-    /* Not doing DHCP, so no lease system, manage 
+    /* Not doing DHCP, so no lease system, manage
        alarms for ra only */
     send_alarm(periodic_ra(now), now);
 #endif
@@ -1475,7 +1726,7 @@ static int set_dns_listeners(time_t now,
   struct serverfd *serverfdp;
   struct listener *listener;
   int wait = 0, i;
-  
+
 #ifdef HAVE_TFTP
   int  tftp = 0;
   struct tftp_transfer *transfer;
@@ -1486,11 +1737,11 @@ static int set_dns_listeners(time_t now,
       bump_maxfd(transfer->sockfd, maxfdp);
     }
 #endif
-  
+
   /* will we be able to get memory? */
   if (daemon->port != 0)
     get_new_frec(now, &wait, 0);
-  
+
   for (serverfdp = daemon->sfds; serverfdp; serverfdp = serverfdp->next)
     {
       FD_SET(serverfdp->fd, set);
@@ -1504,7 +1755,7 @@ static int set_dns_listeners(time_t now,
 	  FD_SET(daemon->randomsocks[i].fd, set);
 	  bump_maxfd(daemon->randomsocks[i].fd, maxfdp);
 	}
-  
+
   for (listener = daemon->listeners; listener; listener = listener->next)
     {
       /* only listen for queries if we have resources */
@@ -1534,7 +1785,7 @@ static int set_dns_listeners(time_t now,
 #endif
 
     }
-  
+
   return wait;
 }
 
@@ -1547,19 +1798,19 @@ static void check_dns_listeners(fd_set *
   for (serverfdp = daemon->sfds; serverfdp; serverfdp = serverfdp->next)
     if (FD_ISSET(serverfdp->fd, set))
       reply_query(serverfdp->fd, serverfdp->source_addr.sa.sa_family, now);
-  
+
   if (daemon->port != 0 && !daemon->osport)
     for (i = 0; i < RANDOM_SOCKS; i++)
-      if (daemon->randomsocks[i].refcount != 0 && 
+      if (daemon->randomsocks[i].refcount != 0 &&
 	  FD_ISSET(daemon->randomsocks[i].fd, set))
 	reply_query(daemon->randomsocks[i].fd, daemon->randomsocks[i].family, now);
-  
+
   for (listener = daemon->listeners; listener; listener = listener->next)
     {
       if (listener->fd != -1 && FD_ISSET(listener->fd, set))
-	receive_query(listener, now); 
-      
-#ifdef HAVE_TFTP     
+	receive_query(listener, now);
+
+#ifdef HAVE_TFTP
       if (listener->tftpfd != -1 && FD_ISSET(listener->tftpfd, set))
 	tftp_request(listener, now);
 #endif
@@ -1573,18 +1824,18 @@ static void check_dns_listeners(fd_set *
 	  socklen_t tcp_len = sizeof(union mysockaddr);
 
 	  while ((confd = accept(listener->tcpfd, NULL, NULL)) == -1 && errno == EINTR);
-	  
+
 	  if (confd == -1)
 	    continue;
-	  
+
 	  if (getsockname(confd, (struct sockaddr *)&tcp_addr, &tcp_len) == -1)
 	    {
 	      while (retry_send(close(confd)));
 	      continue;
 	    }
-	  
+
 	  /* Make sure that the interface list is up-to-date.
-	     
+
 	     We do this here as we may need the results below, and
 	     the DNS code needs them for --interface-name stuff.
 
@@ -1593,16 +1844,16 @@ static void check_dns_listeners(fd_set *
 	     have no effect. This avoids two processes reading from the same
 	     netlink fd and screwing the pooch entirely.
 	  */
- 
+
 	  enumerate_interfaces(0);
-	  
+
 	  if (option_bool(OPT_NOWILD))
 	    iface = listener->iface; /* May be NULL */
-	  else 
+	  else
 	    {
 	      int if_index;
 	      char intr_name[IF_NAMESIZE];
-	      
+
 	      /* if we can find the arrival interface, check it's one that's allowed */
 	      if ((if_index = tcp_interface(confd, tcp_addr.sa.sa_family)) != 0 &&
 		  indextoname(listener->tcpfd, if_index, intr_name))
@@ -1613,34 +1864,34 @@ static void check_dns_listeners(fd_set *
 		  if (tcp_addr.sa.sa_family == AF_INET6)
 		    addr.addr.addr6 = tcp_addr.in6.sin6_addr;
 #endif
-		  
+
 		  for (iface = daemon->interfaces; iface; iface = iface->next)
 		    if (iface->index == if_index)
 		      break;
-		  
+
 		  if (!iface && !loopback_exception(listener->tcpfd, tcp_addr.sa.sa_family, &addr, intr_name))
 		    client_ok = 0;
 		}
-	      
+
 	      if (option_bool(OPT_CLEVERBIND))
 		iface = listener->iface; /* May be NULL */
 	      else
 		{
 		  /* Check for allowed interfaces when binding the wildcard address:
-		     we do this by looking for an interface with the same address as 
+		     we do this by looking for an interface with the same address as
 		     the local address of the TCP connection, then looking to see if that's
 		     an allowed interface. As a side effect, we get the netmask of the
 		     interface too, for localisation. */
-		  
+
 		  for (iface = daemon->interfaces; iface; iface = iface->next)
 		    if (sockaddr_isequal(&iface->addr, &tcp_addr))
 		      break;
-		  
+
 		  if (!iface)
 		    client_ok = 0;
 		}
 	    }
-	  
+
 	  if (!client_ok)
 	    {
 	      shutdown(confd, SHUT_RDWR);
@@ -1668,7 +1919,7 @@ static void check_dns_listeners(fd_set *
 	  else
 	    {
 	      unsigned char *buff;
-	      struct server *s; 
+	      struct server *s;
 	      int flags;
 	      struct in_addr netmask;
 	      int auth_dns;
@@ -1693,29 +1944,29 @@ static void check_dns_listeners(fd_set *
 
 	      /* start with no upstream connections. */
 	      for (s = daemon->servers; s; s = s->next)
-		 s->tcpfd = -1; 
-	      
+		 s->tcpfd = -1;
+
 	      /* The connected socket inherits non-blocking
-		 attribute from the listening socket. 
+		 attribute from the listening socket.
 		 Reset that here. */
 	      if ((flags = fcntl(confd, F_GETFL, 0)) != -1)
 		fcntl(confd, F_SETFL, flags & ~O_NONBLOCK);
-	      
+
 	      buff = tcp_request(confd, now, &tcp_addr, netmask, auth_dns);
-	       
+
 	      shutdown(confd, SHUT_RDWR);
 	      while (retry_send(close(confd)));
-	      
+
 	      if (buff)
 		free(buff);
-	      
+
 	      for (s = daemon->servers; s; s = s->next)
 		if (s->tcpfd != -1)
 		  {
 		    shutdown(s->tcpfd, SHUT_RDWR);
 		    while (retry_send(close(s->tcpfd)));
 		  }
-#ifndef NO_FORK		   
+#ifndef NO_FORK
 	      if (!option_bool(OPT_DEBUG))
 		{
 		  flush_log();
@@ -1750,14 +2001,14 @@ int icmp_ping(struct in_addr addr)
 {
   /* Try and get an ICMP echo from a machine. */
 
-  /* Note that whilst in the three second wait, we check for 
+  /* Note that whilst in the three second wait, we check for
      (and service) events on the DNS and TFTP  sockets, (so doing that
      better not use any resources our caller has in use...)
      but we remain deaf to signals or further DHCP packets. */
 
   int fd;
   struct sockaddr_in saddr;
-  struct { 
+  struct {
     struct ip ip;
     struct icmp icmp;
   } packet;
@@ -1781,45 +2032,45 @@ int icmp_ping(struct in_addr addr)
 #ifdef HAVE_SOCKADDR_SA_LEN
   saddr.sin_len = sizeof(struct sockaddr_in);
 #endif
-  
+
   memset(&packet.icmp, 0, sizeof(packet.icmp));
   packet.icmp.icmp_type = ICMP_ECHO;
   packet.icmp.icmp_id = id;
   for (j = 0, i = 0; i < sizeof(struct icmp) / 2; i++)
     j += ((u16 *)&packet.icmp)[i];
   while (j>>16)
-    j = (j & 0xffff) + (j >> 16);  
+    j = (j & 0xffff) + (j >> 16);
   packet.icmp.icmp_cksum = (j == 0xffff) ? j : ~j;
-  
-  while (retry_send(sendto(fd, (char *)&packet.icmp, sizeof(struct icmp), 0, 
+
+  while (retry_send(sendto(fd, (char *)&packet.icmp, sizeof(struct icmp), 0,
 			   (struct sockaddr *)&saddr, sizeof(saddr))));
-  
-  for (now = start = dnsmasq_time(); 
+
+  for (now = start = dnsmasq_time();
        difftime(now, start) < (float)PING_WAIT;)
     {
       struct timeval tv;
       fd_set rset, wset;
       struct sockaddr_in faddr;
-      int maxfd = fd; 
+      int maxfd = fd;
       socklen_t len = sizeof(faddr);
-      
+
       tv.tv_usec = 250000;
-      tv.tv_sec = 0; 
-      
+      tv.tv_sec = 0;
+
       FD_ZERO(&rset);
       FD_ZERO(&wset);
       FD_SET(fd, &rset);
       set_dns_listeners(now, &rset, &maxfd);
       set_log_writer(&wset, &maxfd);
-      
+
 #ifdef HAVE_DHCP6
       if (daemon->doing_ra)
 	{
 	  FD_SET(daemon->icmp6fd, &rset);
-	  bump_maxfd(daemon->icmp6fd, &maxfd); 
+	  bump_maxfd(daemon->icmp6fd, &maxfd);
 	}
 #endif
-      
+
       if (select(maxfd+1, &rset, &wset, NULL, &tv) < 0)
 	{
 	  FD_ZERO(&rset);
@@ -1835,7 +2086,7 @@ int icmp_ping(struct in_addr addr)
       if (daemon->doing_ra && FD_ISSET(daemon->icmp6fd, &rset))
 	icmp6_packet(now);
 #endif
-      
+
 #ifdef HAVE_TFTP
       check_tftp_listeners(&rset, now);
 #endif
@@ -1852,7 +2103,7 @@ int icmp_ping(struct in_addr addr)
 	  break;
 	}
     }
-  
+
 #if defined(HAVE_LINUX_NETWORK) || defined(HAVE_SOLARIS_NETWORK)
   while (retry_send(close(fd)));
 #else
@@ -1863,5 +2114,3 @@ int icmp_ping(struct in_addr addr)
   return gotreply;
 }
 #endif
-
- 
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -1,21 +1,22 @@
 /* dnsmasq is Copyright (c) 2000-2015 Simon Kelley
- 
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; version 2 dated June, 1991, or
    (at your option) version 3 dated 29 June, 2007.
- 
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-     
+
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
-#define COPYRIGHT "Copyright (c) 2000-2015 Simon Kelley" 
+#define COPYRIGHT "Copyright (c) 2000-2015 Simon Kelley"
 
+#define URL_LIST
 #ifndef NO_LARGEFILE
 /* Ensure we can use files >2GB (log files may grow this big) */
 #  define _LARGEFILE_SOURCE 1
@@ -27,7 +28,7 @@
 #  ifndef __ANDROID__
 #      define _GNU_SOURCE
 #  endif
-#  include <features.h> 
+#  include <features.h>
 #endif
 
 /* Need these defined early */
@@ -37,7 +38,7 @@
 #endif
 
 /* get these before config.h  for IPv6 stuff... */
-#include <sys/types.h> 
+#include <sys/types.h>
 #include <sys/socket.h>
 
 #ifdef __APPLE__
@@ -72,7 +73,7 @@ typedef unsigned long long u64;
 #  define _(S) (S)
 #else
 #  include <libintl.h>
-#  include <locale.h>   
+#  include <locale.h>
 #  define _(S) gettext(S)
 #endif
 
@@ -111,6 +112,10 @@ typedef unsigned long long u64;
 #  include <net/ethernet.h>
 #endif
 #include <net/if_arp.h>
+#ifdef URL_LIST
+#include<sys/mman.h>
+#include <sys/ioctl.h>
+#endif
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/ip_icmp.h>
@@ -123,7 +128,7 @@ typedef unsigned long long u64;
 
 #if defined(HAVE_LINUX_NETWORK)
 #include <linux/capability.h>
-/* There doesn't seem to be a universally-available 
+/* There doesn't seem to be a universally-available
    userpace header for these. */
 extern int capset(cap_user_header_t header, cap_user_data_t data);
 extern int capget(cap_user_header_t header, cap_user_data_t data);
@@ -169,6 +174,9 @@ struct event_desc {
 #define EVENT_NEWROUTE  23
 #define EVENT_TIME_ERR  24
 
+#ifdef URL_LIST
+#define EVENT_UPDATE_LIST 25
+#endif
 /* Exit codes. */
 #define EC_GOOD        0
 #define EC_BADCONF     1
@@ -178,7 +186,7 @@ struct event_desc {
 #define EC_MISC        5
 #define EC_INIT_OFFSET 10
 
-/* Min buffer size: we check after adding each record, so there must be 
+/* Min buffer size: we check after adding each record, so there must be
    memory for the largest packet, and the largest record so the
    min for DNS is PACKETSZ+MAXDNAME+RRFIXEDSZ which is < 1000.
    This might be increased is EDNS packet size if greater than the minimum.
@@ -213,7 +221,7 @@ struct event_desc {
 #define OPT_LEASE_RO       22
 #define OPT_ALL_SERVERS    23
 #define OPT_RELOAD         24
-#define OPT_LOCAL_REBIND   25  
+#define OPT_LOCAL_REBIND   25
 #define OPT_TFTP_SECURE    26
 #define OPT_TFTP_NOBLOCK   27
 #define OPT_LOG_OPTS       28
@@ -236,17 +244,17 @@ struct event_desc {
 #define OPT_DNSSEC_VALID   45
 #define OPT_DNSSEC_TIME    46
 #define OPT_DNSSEC_DEBUG   47
-#define OPT_DNSSEC_NO_SIGN 48 
+#define OPT_DNSSEC_NO_SIGN 48
 #define OPT_LOCAL_SERVICE  49
 #define OPT_LOOP_DETECT    50
 #define OPT_EXTRALOG       51
 #define OPT_TFTP_NO_FAIL   52
 #define OPT_LAST           53
 
-/* extra flags for my_syslog, we use a couple of facilities since they are known 
+/* extra flags for my_syslog, we use a couple of facilities since they are known
    not to occupy the same bits as priorities, no matter how syslog.h is set up. */
 #define MS_TFTP LOG_USER
-#define MS_DHCP LOG_DAEMON 
+#define MS_DHCP LOG_DAEMON
 
 struct all_addr {
   union {
@@ -259,7 +267,7 @@ struct all_addr {
     /* for cache_insert if RRSIG, DNSKEY, DS */
     struct {
       unsigned short class, type;
-    } dnssec;      
+    } dnssec;
   } addr;
 };
 
@@ -311,7 +319,7 @@ struct ptr_record {
 struct cname {
   char *alias, *target;
   struct cname *next;
-}; 
+};
 
 struct ds_config {
   char *name, *digest;
@@ -325,7 +333,7 @@ struct ds_config {
 
 struct addrlist {
   struct all_addr addr;
-  int flags, prefixlen; 
+  int flags, prefixlen;
   struct addrlist *next;
 };
 
@@ -374,7 +382,7 @@ struct blockdata {
   unsigned char key[KEYBLOCK_LEN];
 };
 
-struct crec { 
+struct crec {
   struct crec *next, *prev, *hash_next;
   /* union is 16 bytes when doing IPv6, 8 bytes on 32 bit machines without IPv6 */
   union {
@@ -390,13 +398,13 @@ struct crec {
       struct blockdata *keydata;
       unsigned short keylen, flags, keytag;
       unsigned char algo;
-    } key; 
+    } key;
     struct {
       struct blockdata *keydata;
       unsigned short keylen, keytag;
       unsigned char algo;
-      unsigned char digest; 
-    } ds; 
+      unsigned char digest;
+    } ds;
     struct {
       struct blockdata *keydata;
       unsigned short keylen, type_covered, keytag;
@@ -405,7 +413,7 @@ struct crec {
   } addr;
   time_t ttd; /* time to die */
   /* used as class if DNSKEY/DS/RRSIG, index to source for F_HOSTS */
-  unsigned int uid; 
+  unsigned int uid;
   unsigned short flags;
   union {
     char sname[SMALLDNAME];
@@ -419,7 +427,7 @@ struct crec {
 #define F_REVERSE   (1u<<2)
 #define F_FORWARD   (1u<<3)
 #define F_DHCP      (1u<<4)
-#define F_NEG       (1u<<5)       
+#define F_NEG       (1u<<5)
 #define F_HOSTS     (1u<<6)
 #define F_IPV4      (1u<<7)
 #define F_IPV6      (1u<<8)
@@ -473,7 +481,7 @@ union mysockaddr {
 
 #define SERV_FROM_RESOLV       1  /* 1 for servers from resolv, 0 for command line. */
 #define SERV_NO_ADDR           2  /* no server, this domain is local only */
-#define SERV_LITERAL_ADDRESS   4  /* addr is the answer, not the server */ 
+#define SERV_LITERAL_ADDRESS   4  /* addr is the answer, not the server */
 #define SERV_HAS_DOMAIN        8  /* server for one domain only */
 #define SERV_HAS_SOURCE       16  /* source address defined */
 #define SERV_FOR_NODOTS       32  /* server for names with no domain part only */
@@ -498,18 +506,18 @@ struct randfd {
   int fd;
   unsigned short refcount, family;
 };
-  
+
 struct server {
   union mysockaddr addr, source_addr;
   char interface[IF_NAMESIZE+1];
-  struct serverfd *sfd; 
-  char *domain; /* set if this server only handles a domain. */ 
+  struct serverfd *sfd;
+  char *domain; /* set if this server only handles a domain. */
   int flags, tcpfd, edns_pktsz;
   unsigned int queries, failed_queries;
 #ifdef HAVE_LOOP
   u32 uid;
 #endif
-  struct server *next; 
+  struct server *next;
 };
 
 struct ipsets {
@@ -522,7 +530,7 @@ struct irec {
   union mysockaddr addr;
   struct in_addr netmask; /* only valid for IPv4 */
   int tftp_ok, dhcp_ok, mtu, done, warned, dad, dns_auth, index, multicast_done, found;
-  char *name; 
+  char *name;
   struct irec *next;
 };
 
@@ -615,7 +623,7 @@ struct frec {
   int log_id, fd, forwardall, flags;
   time_t time;
   unsigned char *hash[HASH_SIZE];
-#ifdef HAVE_DNSSEC 
+#ifdef HAVE_DNSSEC
   int class, work_counter;
   struct blockdata *stash; /* Saved reply, whilst we validate */
   struct blockdata *orig_domain; /* domain of original query, whilst
@@ -633,7 +641,7 @@ struct frec {
 #define OT_INTERNAL     0x2000
 #define OT_NAME         0x1000
 #define OT_CSTRING      0x0800
-#define OT_DEC          0x0400 
+#define OT_DEC          0x0400
 #define OT_TIME         0x0200
 
 /* actions in the daemon->helper RPC */
@@ -663,7 +671,7 @@ struct dhcp_lease {
   unsigned int length;
 #endif
   int hwaddr_len, hwaddr_type;
-  unsigned char hwaddr[DHCP_CHADDR_MAX]; 
+  unsigned char hwaddr[DHCP_CHADDR_MAX];
   struct in_addr addr, override, giaddr;
   unsigned char *extradata;
   unsigned int extradata_len, extradata_size;
@@ -723,7 +731,7 @@ struct dhcp_config {
   struct dhcp_config *next;
 };
 
-#define have_config(config, mask) ((config) && ((config)->flags & (mask))) 
+#define have_config(config, mask) ((config) && ((config)->flags & (mask)))
 
 #define CONFIG_DISABLE           1
 #define CONFIG_CLID              2
@@ -773,7 +781,7 @@ struct dhcp_boot {
 };
 
 struct pxe_service {
-  unsigned short CSA, type; 
+  unsigned short CSA, type;
   char *menu, *basename, *sname;
   struct in_addr server;
   struct dhcp_netid *netid;
@@ -816,9 +824,9 @@ struct cond_domain {
 #endif
   int is6;
   struct cond_domain *next;
-}; 
+};
 
-#ifdef OPTION6_PREFIX_CLASS 
+#ifdef OPTION6_PREFIX_CLASS
 struct prefix_class {
   int class;
   struct dhcp_netid tag;
@@ -917,7 +925,7 @@ struct dhcp_relay {
 };
 
 extern struct daemon {
-  /* datastuctures representing the command-line and 
+  /* datastuctures representing the command-line and
      config file arguments. All set (including defaults)
      in option.c */
 
@@ -936,7 +944,7 @@ extern struct daemon {
   char *mxtarget;
   int addr4_netmask;
   int addr6_netmask;
-  char *lease_file; 
+  char *lease_file;
   char *username, *groupname, *scriptuser;
   char *luascript;
   char *authserver, *hostmaster;
@@ -945,7 +953,7 @@ extern struct daemon {
   int group_set, osport;
   char *domain_suffix;
   struct cond_domain *cond_domain, *synth_domains;
-  char *runfile; 
+  char *runfile;
   char *lease_change_command;
   struct iname *if_names, *if_addrs, *if_except, *dhcp_except, *auth_peers, *tftp_interfaces;
   struct bogus_addr *bogus_addr, *ignore_addr;
@@ -966,28 +974,28 @@ extern struct daemon {
   struct dhcp_mac *dhcp_macs;
   struct dhcp_boot *boot_config;
   struct pxe_service *pxe_services;
-  struct tag_if *tag_if; 
+  struct tag_if *tag_if;
   struct addr_list *override_relays;
   struct dhcp_relay *relay4, *relay6;
   int override;
   int enable_pxe;
   int doing_ra, doing_dhcp6;
-  struct dhcp_netid_list *dhcp_ignore, *dhcp_ignore_names, *dhcp_gen_names; 
+  struct dhcp_netid_list *dhcp_ignore, *dhcp_ignore_names, *dhcp_gen_names;
   struct dhcp_netid_list *force_broadcast, *bootp_dynamic;
   struct hostsfile *dhcp_hosts_file, *dhcp_opts_file, *dynamic_dirs;
   int dhcp_max, tftp_max;
   int dhcp_server_port, dhcp_client_port;
-  int start_tftp_port, end_tftp_port; 
+  int start_tftp_port, end_tftp_port;
   unsigned int min_leasetime;
   struct doctor *doctors;
   unsigned short edns_pktsz;
-  char *tftp_prefix; 
+  char *tftp_prefix;
   struct tftp_prefix *if_prefix; /* per-interface TFTP prefixes */
   unsigned int duid_enterprise, duid_config_len;
   unsigned char *duid_config;
   char *dbus_name;
   unsigned long soa_sn, soa_refresh, soa_retry, soa_expiry;
-#ifdef OPTION6_PREFIX_CLASS 
+#ifdef OPTION6_PREFIX_CLASS
   struct prefix_class *prefix_classes;
 #endif
 #ifdef HAVE_DNSSEC
@@ -1016,13 +1024,13 @@ extern struct daemon {
   struct randfd *rfd_save; /*      "        "        */
   pid_t tcp_pids[MAX_PROCS];
   struct randfd randomsocks[RANDOM_SOCKS];
-  int v6pktinfo; 
+  int v6pktinfo;
   struct addrlist *interface_addrs; /* list of all addresses/prefix lengths associated with all local interfaces */
   int log_id, log_display_id; /* ids of transactions for logging */
   union mysockaddr *log_source_addr;
 
   /* DHCP state */
-  int dhcpfd, helperfd, pxefd; 
+  int dhcpfd, helperfd, pxefd;
 #ifdef HAVE_INOTIFY
   int inotifyfd;
 #endif
@@ -1060,13 +1068,13 @@ extern struct daemon {
 
 /* cache.c */
 void cache_init(void);
-void log_query(unsigned int flags, char *name, struct all_addr *addr, char *arg); 
+void log_query(unsigned int flags, char *name, struct all_addr *addr, char *arg);
 char *record_source(unsigned int index);
 char *querystr(char *desc, unsigned short type);
 struct crec *cache_find_by_addr(struct crec *crecp,
-				struct all_addr *addr, time_t now, 
+				struct all_addr *addr, time_t now,
 				unsigned int prot);
-struct crec *cache_find_by_name(struct crec *crecp, 
+struct crec *cache_find_by_name(struct crec *crecp,
 				char *name, time_t now, unsigned int prot);
 void cache_end_insert(void);
 void cache_start_insert(void);
@@ -1081,7 +1089,7 @@ int cache_make_stat(struct txt_record *t
 char *cache_get_name(struct crec *crecp);
 char *cache_get_cname_target(struct crec *crecp);
 struct crec *cache_enumerate(int init);
-int read_hostsfile(char *filename, unsigned int index, int cache_size, 
+int read_hostsfile(char *filename, unsigned int index, int cache_size,
 		   struct crec **rhash, int hashsz);
 
 /* blockdata.c */
@@ -1102,30 +1110,30 @@ int is_name_synthetic(int flags, char *n
 int is_rev_synth(int flag, struct all_addr *addr, char *name);
 
 /* rfc1035.c */
-int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
+int extract_name(struct dns_header *header, size_t plen, unsigned char **pp,
                  char *name, int isExtract, int extrabytes);
 unsigned char *skip_name(unsigned char *ansp, struct dns_header *header, size_t plen, int extrabytes);
 unsigned char *skip_questions(struct dns_header *header, size_t plen);
 unsigned char *skip_section(unsigned char *ansp, int count, struct dns_header *header, size_t plen);
-unsigned int extract_request(struct dns_header *header, size_t qlen, 
+unsigned int extract_request(struct dns_header *header, size_t qlen,
 			       char *name, unsigned short *typep);
 size_t setup_reply(struct dns_header *header, size_t  qlen,
 		   struct all_addr *addrp, unsigned int flags,
 		   unsigned long local_ttl);
-int extract_addresses(struct dns_header *header, size_t qlen, char *namebuff, 
+int extract_addresses(struct dns_header *header, size_t qlen, char *namebuff,
 		      time_t now, char **ipsets, int is_sign, int checkrebind,
 		      int no_cache, int secure, int *doctored);
-size_t answer_request(struct dns_header *header, char *limit, size_t qlen,  
-		      struct in_addr local_addr, struct in_addr local_netmask, 
+size_t answer_request(struct dns_header *header, char *limit, size_t qlen,
+		      struct in_addr local_addr, struct in_addr local_netmask,
 		      time_t now, int *ad_reqd, int *do_bit);
-int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, 
+int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name,
 			     struct bogus_addr *addr, time_t now);
 int check_for_ignored_address(struct dns_header *header, size_t qlen, struct bogus_addr *baddr);
 unsigned char *find_pseudoheader(struct dns_header *header, size_t plen,
 				 size_t *len, unsigned char **p, int *is_sign);
 int check_for_local_domain(char *name, time_t now);
 unsigned int questions_crc(struct dns_header *header, size_t plen, char *buff);
-size_t resize_packet(struct dns_header *header, size_t plen, 
+size_t resize_packet(struct dns_header *header, size_t plen,
 		  unsigned char *pheader, size_t hlen);
 size_t add_mac(struct dns_header *header, size_t plen, char *limit, union mysockaddr *l3);
 size_t add_source_addr(struct dns_header *header, size_t plen, char *limit, union mysockaddr *source);
@@ -1134,17 +1142,17 @@ size_t add_do_bit(struct dns_header *hea
 #endif
 int check_source(struct dns_header *header, size_t plen, unsigned char *pseudoheader, union mysockaddr *peer);
 int add_resource_record(struct dns_header *header, char *limit, int *truncp,
-			int nameoffset, unsigned char **pp, unsigned long ttl, 
+			int nameoffset, unsigned char **pp, unsigned long ttl,
 			int *offset, unsigned short type, unsigned short class, char *format, ...);
 unsigned char *skip_questions(struct dns_header *header, size_t plen);
-int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
+int extract_name(struct dns_header *header, size_t plen, unsigned char **pp,
 		 char *name, int isExtract, int extrabytes);
 int in_arpa_name_2_addr(char *namein, struct all_addr *addrp);
 int private_net(struct in_addr addr, int ban_localhost);
 
 /* auth.c */
 #ifdef HAVE_AUTH
-size_t answer_auth(struct dns_header *header, char *limit, size_t qlen, 
+size_t answer_auth(struct dns_header *header, char *limit, size_t qlen,
 		   time_t now, union mysockaddr *peer_addr, int local_query);
 int in_zone(struct auth_zone *zone, char *name, char **cut);
 #endif
@@ -1185,9 +1193,9 @@ void setaddr6part(struct in6_addr *addr,
 int retry_send(ssize_t rc);
 void prettyprint_time(char *buf, unsigned int t);
 int prettyprint_addr(union mysockaddr *addr, char *buf);
-int parse_hex(char *in, unsigned char *out, int maxlen, 
+int parse_hex(char *in, unsigned char *out, int maxlen,
 	      unsigned int *wildcard_mask, int *mac_type);
-int memcmp_masked(unsigned char *a, unsigned char *b, int len, 
+int memcmp_masked(unsigned char *a, unsigned char *b, int len,
 		  unsigned int mask);
 int expand_buf(struct iovec *iov, size_t size);
 char *print_mac(char *buff, unsigned char *mac, int len);
@@ -1208,14 +1216,14 @@ void flush_log(void);
 
 /* option.c */
 void read_opts (int argc, char **argv, char *compile_opts);
-char *option_string(int prot, unsigned int opt, unsigned char *val, 
+char *option_string(int prot, unsigned int opt, unsigned char *val,
 		    int opt_len, char *buf, int buf_len);
 void reread_dhcp(void);
 void read_servers_file(void);
 void set_option_bool(unsigned int opt);
 void reset_option_bool(unsigned int opt);
 struct hostsfile *expand_filelist(struct hostsfile *list);
-char *parse_server(char *arg, union mysockaddr *addr, 
+char *parse_server(char *arg, union mysockaddr *addr,
 		   union mysockaddr *source_addr, char *interface, int *flags);
 int option_read_dynfile(char *file, int flags);
 
@@ -1226,7 +1234,7 @@ unsigned char *tcp_request(int confd, ti
 			   union mysockaddr *local_addr, struct in_addr netmask, int auth_dns);
 void server_gone(struct server *server);
 struct frec *get_new_frec(time_t now, int *wait, int force);
-int send_from(int fd, int nowild, char *packet, size_t len, 
+int send_from(int fd, int nowild, char *packet, size_t len,
 	       union mysockaddr *to, struct all_addr *source,
 	       unsigned int iface);
 void resend_query();
@@ -1273,10 +1281,10 @@ void newaddress(time_t now);
 #ifdef HAVE_DHCP
 void dhcp_init(void);
 void dhcp_packet(time_t now, int pxe_fd);
-struct dhcp_context *address_available(struct dhcp_context *context, 
+struct dhcp_context *address_available(struct dhcp_context *context,
 				       struct in_addr addr,
 				       struct dhcp_netid *netids);
-struct dhcp_context *narrow_context(struct dhcp_context *context, 
+struct dhcp_context *narrow_context(struct dhcp_context *context,
 				    struct in_addr taddr,
 				    struct dhcp_netid *netids);
 int address_allocate(struct dhcp_context *context,
@@ -1295,7 +1303,7 @@ void lease_init(time_t now);
 struct dhcp_lease *lease4_allocate(struct in_addr addr);
 #ifdef HAVE_DHCP6
 struct dhcp_lease *lease6_allocate(struct in6_addr *addrp, int lease_type);
-struct dhcp_lease *lease6_find(unsigned char *clid, int clid_len, 
+struct dhcp_lease *lease6_find(unsigned char *clid, int clid_len,
 			       int lease_type, int iaid, struct in6_addr *addr);
 void lease6_reset(void);
 struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first, int lease_type, unsigned char *clid, int clid_len, int iaid);
@@ -1312,7 +1320,7 @@ void lease_set_hwaddr(struct dhcp_lease
 void lease_set_hostname(struct dhcp_lease *lease, const char *name, int auth, char *domain, char *config_domain);
 void lease_set_expires(struct dhcp_lease *lease, unsigned int len, time_t now);
 void lease_set_interface(struct dhcp_lease *lease, int interface, time_t now);
-struct dhcp_lease *lease_find_by_client(unsigned char *hwaddr, int hw_len, int hw_type,  
+struct dhcp_lease *lease_find_by_client(unsigned char *hwaddr, int hw_len, int hw_type,
 					unsigned char *clid, int clid_len);
 struct dhcp_lease *lease_find_by_addr(struct in_addr addr);
 struct in_addr lease_find_max_addr(struct dhcp_context *context);
@@ -1322,7 +1330,7 @@ int do_script_run(time_t now);
 void rerun_scripts(void);
 void lease_find_interfaces(time_t now);
 #ifdef HAVE_SCRIPT
-void lease_add_extradata(struct dhcp_lease *lease, unsigned char *data, 
+void lease_add_extradata(struct dhcp_lease *lease, unsigned char *data,
 			 unsigned int len, int delim);
 #endif
 #endif
@@ -1331,7 +1339,7 @@ void lease_add_extradata(struct dhcp_lea
 #ifdef HAVE_DHCP
 size_t dhcp_reply(struct dhcp_context *context, char *iface_name, int int_index,
 		  size_t sz, time_t now, int unicast_dest, int *is_inform, int pxe_fd, struct in_addr fallback);
-unsigned char *extended_hwaddr(int hwtype, int hwlen, unsigned char *hwaddr, 
+unsigned char *extended_hwaddr(int hwtype, int hwlen, unsigned char *hwaddr,
 			       int clid_len, unsigned char *clid, int *len_out);
 #endif
 
@@ -1383,7 +1391,7 @@ int add_to_ipset(const char *setname, co
 #if defined(HAVE_SCRIPT)
 int create_helper(int event_fd, int err_fd, uid_t uid, gid_t gid, long max_fd);
 void helper_write(void);
-void queue_script(int action, struct dhcp_lease *lease, 
+void queue_script(int action, struct dhcp_lease *lease,
 		  char *hostname, time_t now);
 #ifdef HAVE_TFTP
 void queue_tftp(off_t file_len, char *filename, union mysockaddr *peer);
@@ -1411,25 +1419,25 @@ void dhcp6_packet(time_t now);
 struct dhcp_context *address6_allocate(struct dhcp_context *context,  unsigned char *clid, int clid_len, int temp_addr,
 				       int iaid, int serial, struct dhcp_netid *netids, int plain_range, struct in6_addr *ans);
 int config_valid(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr);
-struct dhcp_context *address6_available(struct dhcp_context *context, 
+struct dhcp_context *address6_available(struct dhcp_context *context,
 					struct in6_addr *taddr,
 					struct dhcp_netid *netids,
 					int plain_range);
-struct dhcp_context *address6_valid(struct dhcp_context *context, 
+struct dhcp_context *address6_valid(struct dhcp_context *context,
 				    struct in6_addr *taddr,
 				    struct dhcp_netid *netids,
 				    int plain_range);
-struct dhcp_config *config_find_by_address6(struct dhcp_config *configs, struct in6_addr *net, 
+struct dhcp_config *config_find_by_address6(struct dhcp_config *configs, struct in6_addr *net,
 					    int prefix, u64 addr);
 void make_duid(time_t now);
 void dhcp_construct_contexts(time_t now);
-void get_client_mac(struct in6_addr *client, int iface, unsigned char *mac, 
+void get_client_mac(struct in6_addr *client, int iface, unsigned char *mac,
 		    unsigned int *maclenp, unsigned int *mactypep);
 #endif
-  
+
 /* rfc3315.c */
 #ifdef HAVE_DHCP6
-unsigned short dhcp6_reply(struct dhcp_context *context, int interface, char *iface_name,  
+unsigned short dhcp6_reply(struct dhcp_context *context, int interface, char *iface_name,
 			   struct in6_addr *fallback, struct in6_addr *ll_addr, struct in6_addr *ula_addr,
 			   size_t sz, struct in6_addr *client_addr, time_t now);
 void relay_upstream6(struct dhcp_relay *relay, ssize_t sz, struct in6_addr *peer_address, u32 scope_id);
@@ -1452,12 +1460,12 @@ void dhcp_update_configs(struct dhcp_con
 void display_opts(void);
 int lookup_dhcp_opt(int prot, char *name);
 int lookup_dhcp_len(int prot, int val);
-char *option_string(int prot, unsigned int opt, unsigned char *val, 
+char *option_string(int prot, unsigned int opt, unsigned char *val,
 		    int opt_len, char *buf, int buf_len);
 struct dhcp_config *find_config(struct dhcp_config *configs,
 				struct dhcp_context *context,
 				unsigned char *clid, int clid_len,
-				unsigned char *hwaddr, int hw_len, 
+				unsigned char *hwaddr, int hw_len,
 				int hw_type, char *hostname);
 int config_has_mac(struct dhcp_config *config, unsigned char *hwaddr, int len, int type);
 #ifdef HAVE_LINUX_NETWORK
@@ -1492,7 +1500,7 @@ time_t periodic_ra(time_t now);
 void ra_start_unsolicted(time_t now, struct dhcp_context *context);
 #endif
 
-/* slaac.c */ 
+/* slaac.c */
 #ifdef HAVE_DHCP6
 void slaac_add_addrs(struct dhcp_lease *lease, time_t now, int force);
 time_t periodic_slaac(time_t now, struct dhcp_lease *leases);
@@ -1511,3 +1519,26 @@ void inotify_dnsmasq_init();
 int inotify_check(time_t now);
 void set_dynamic_inotify(int flag, int total_size, struct crec **rhash, int revhashsz);
 #endif
+
+#ifdef URL_LIST
+
+unsigned short char_to_short(char* src);
+void short_to_char(unsigned short src, char* dst);
+struct mac_node * find_mac_node(unsigned char* mac, struct mac_node * pmac_list_hdr);
+
+struct url_node{
+	struct url_node* pnext;
+	unsigned short str_len;
+	char* url_str;
+};
+
+struct mac_node {
+	// mac addr
+	unsigned char mac[6];
+	// 0 white list 1 black list
+	char list_type;
+	struct mac_node * pnext;
+	// url list with this mac
+	struct url_node * purl_list_hdr;
+};
+#endif
--- a/src/forward.c
+++ b/src/forward.c
@@ -4,18 +4,21 @@
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; version 2 dated June, 1991, or
    (at your option) version 3 dated 29 June, 2007.
- 
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-     
+
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "dnsmasq.h"
 
+#ifdef URL_LIST
+extern struct mac_node * gpmac_list_hdr;
+#endif
 static struct frec *lookup_frec(unsigned short id, void *hash);
 static struct frec *lookup_frec_by_sender(unsigned short id,
 					  union mysockaddr *addr,
@@ -24,22 +27,22 @@ static unsigned short get_id(void);
 static void free_frec(struct frec *f);
 
 #ifdef HAVE_DNSSEC
-static int tcp_key_recurse(time_t now, int status, struct dns_header *header, size_t n, 
+static int tcp_key_recurse(time_t now, int status, struct dns_header *header, size_t n,
 			   int class, char *name, char *keyname, struct server *server, int *keycount);
 static int do_check_sign(struct frec *forward, int status, time_t now, char *name, char *keyname);
-static int send_check_sign(struct frec *forward, time_t now, struct dns_header *header, size_t plen, 
+static int send_check_sign(struct frec *forward, time_t now, struct dns_header *header, size_t plen,
 			   char *name, char *keyname);
 #endif
 
 
-/* Send a UDP packet with its source address set as "source" 
+/* Send a UDP packet with its source address set as "source"
    unless nowild is true, when we just send it with the kernel default */
-int send_from(int fd, int nowild, char *packet, size_t len, 
+int send_from(int fd, int nowild, char *packet, size_t len,
 	      union mysockaddr *to, struct all_addr *source,
 	      unsigned int iface)
 {
   struct msghdr msg;
-  struct iovec iov[1]; 
+  struct iovec iov[1];
   union {
     struct cmsghdr align; /* this ensures alignment */
 #if defined(HAVE_LINUX_NETWORK)
@@ -51,7 +54,7 @@ int send_from(int fd, int nowild, char *
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
 #endif
   } control_u;
-  
+
   iov[0].iov_base = packet;
   iov[0].iov_len = len;
 
@@ -62,7 +65,7 @@ int send_from(int fd, int nowild, char *
   msg.msg_namelen = sa_len(to);
   msg.msg_iov = iov;
   msg.msg_iovlen = 1;
-  
+
   if (!nowild)
     {
       struct cmsghdr *cmptr;
@@ -102,7 +105,7 @@ int send_from(int fd, int nowild, char *
       (void)iface; /* eliminate warning */
 #endif
     }
-  
+
   while (retry_send(sendmsg(fd, &msg, 0)));
 
   /* If interface is still in DAD, EINVAL results - ignore that. */
@@ -111,46 +114,46 @@ int send_from(int fd, int nowild, char *
       my_syslog(LOG_ERR, _("failed to send packet: %s"), strerror(errno));
       return 0;
     }
-  
+
   return 1;
 }
-          
-static unsigned int search_servers(time_t now, struct all_addr **addrpp, 
+
+static unsigned int search_servers(time_t now, struct all_addr **addrpp,
 				     unsigned int qtype, char *qdomain, int *type, char **domain, int *norebind)
-			      
+
 {
   /* If the query ends in the domain in one of our servers, set
      domain to point to that name. We find the largest match to allow both
      domain.org and sub.domain.org to exist. */
-  
+
   unsigned int namelen = strlen(qdomain);
   unsigned int matchlen = 0;
   struct server *serv;
   unsigned int flags = 0;
-  
+
   for (serv = daemon->servers; serv; serv=serv->next)
     /* domain matches take priority over NODOTS matches */
     if ((serv->flags & SERV_FOR_NODOTS) && *type != SERV_HAS_DOMAIN && !strchr(qdomain, '.') && namelen != 0)
       {
-	unsigned int sflag = serv->addr.sa.sa_family == AF_INET ? F_IPV4 : F_IPV6; 
+	unsigned int sflag = serv->addr.sa.sa_family == AF_INET ? F_IPV4 : F_IPV6;
 	*type = SERV_FOR_NODOTS;
 	if (serv->flags & SERV_NO_ADDR)
 	  flags = F_NXDOMAIN;
-	else if (serv->flags & SERV_LITERAL_ADDRESS) 
-	  { 
+	else if (serv->flags & SERV_LITERAL_ADDRESS)
+	  {
 	    if (sflag & qtype)
 	      {
 		flags = sflag;
-		if (serv->addr.sa.sa_family == AF_INET) 
+		if (serv->addr.sa.sa_family == AF_INET)
 		  *addrpp = (struct all_addr *)&serv->addr.in.sin_addr;
 #ifdef HAVE_IPV6
 		else
 		  *addrpp = (struct all_addr *)&serv->addr.in6.sin6_addr;
-#endif 
+#endif
 	      }
 	    else if (!flags || (flags & F_NXDOMAIN))
 	      flags = F_NOERR;
-	  } 
+	  }
       }
     else if (serv->flags & SERV_HAS_DOMAIN)
       {
@@ -160,7 +163,7 @@ static unsigned int search_servers(time_
 	    hostname_isequal(matchstart, serv->domain) &&
 	    (domainlen == 0 || namelen == domainlen || *(matchstart-1) == '.' ))
 	  {
-	    if (serv->flags & SERV_NO_REBIND)	
+	    if (serv->flags & SERV_NO_REBIND)
 	      *norebind = 1;
 	    else
 	      {
@@ -181,7 +184,7 @@ static unsigned int search_servers(time_
 			  continue;
 		      }
 		  }
-		
+
 		if (domainlen >= matchlen)
 		  {
 		    *type = serv->flags & (SERV_HAS_DOMAIN | SERV_USE_RESOLV | SERV_NO_REBIND);
@@ -194,7 +197,7 @@ static unsigned int search_servers(time_
 			if (sflag & qtype)
 			  {
 			    flags = sflag;
-			    if (serv->addr.sa.sa_family == AF_INET) 
+			    if (serv->addr.sa.sa_family == AF_INET)
 			      *addrpp = (struct all_addr *)&serv->addr.in.sin_addr;
 #ifdef HAVE_IPV6
 			    else
@@ -206,26 +209,26 @@ static unsigned int search_servers(time_
 		      }
 		    else
 		      flags = 0;
-		  } 
+		  }
 	      }
 	  }
       }
-  
-  if (flags == 0 && !(qtype & F_QUERY) && 
+
+  if (flags == 0 && !(qtype & F_QUERY) &&
       option_bool(OPT_NODOTS_LOCAL) && !strchr(qdomain, '.') && namelen != 0)
     /* don't forward A or AAAA queries for simple names, except the empty name */
     flags = F_NOERR;
-  
+
   if (flags == F_NXDOMAIN && check_for_local_domain(qdomain, now))
     flags = F_NOERR;
 
   if (flags)
     {
       int logflags = 0;
-      
+
       if (flags == F_NXDOMAIN || flags == F_NOERR)
 	logflags = F_NEG | qtype;
-  
+
       log_query(logflags | flags | F_CONFIG | F_FORWARD, qdomain, *addrpp, NULL);
     }
   else if ((*type) & SERV_USE_RESOLV)
@@ -238,7 +241,7 @@ static unsigned int search_servers(time_
 
 static int forward_query(int udpfd, union mysockaddr *udpaddr,
 			 struct all_addr *dst_addr, unsigned int dst_iface,
-			 struct dns_header *header, size_t plen, time_t now, 
+			 struct dns_header *header, size_t plen, time_t now,
 			 struct frec *forward, int ad_reqd, int do_bit)
 {
   char *domain = NULL;
@@ -267,34 +270,34 @@ static int forward_query(int udpfd, unio
 	 If that generates an answer, it will become the new default
 	 for this server */
       forward->flags |= FREC_TEST_PKTSZ;
-      
+
 #ifdef HAVE_DNSSEC
       /* If we've already got an answer to this query, but we're awaiting keys for validation,
 	 there's no point retrying the query, retry the key query instead...... */
       if (forward->blocking_query)
 	{
 	  int fd;
-	  
+
 	  forward->flags &= ~FREC_TEST_PKTSZ;
-	  
+
 	  while (forward->blocking_query)
 	    forward = forward->blocking_query;
-	   
+
 	  forward->flags |= FREC_TEST_PKTSZ;
-	  
+
 	  blockdata_retrieve(forward->stash, forward->stash_len, (void *)header);
 	  plen = forward->stash_len;
-	  
+
 	  if (find_pseudoheader(header, plen, NULL, &pheader, NULL))
 	    PUTSHORT((forward->flags & FREC_TEST_PKTSZ) ? SAFE_PKTSZ : forward->sentto->edns_pktsz, pheader);
 
-	  if (forward->sentto->addr.sa.sa_family == AF_INET) 
+	  if (forward->sentto->addr.sa.sa_family == AF_INET)
 	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, "retry", (struct all_addr *)&forward->sentto->addr.in.sin_addr, "dnssec");
 #ifdef HAVE_IPV6
 	  else
 	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, "retry", (struct all_addr *)&forward->sentto->addr.in6.sin6_addr, "dnssec");
 #endif
-  
+
 	  if (forward->sentto->sfd)
 	    fd = forward->sentto->sfd->fd;
 	  else
@@ -306,11 +309,11 @@ static int forward_query(int udpfd, unio
 #endif
 		fd = forward->rfd4->fd;
 	    }
-	  
+
 	  while (retry_send( sendto(fd, (char *)header, plen, 0,
 				    &forward->sentto->addr.sa,
 				    sa_len(&forward->sentto->addr))));
-	  
+
 	  return 1;
 	}
 #endif
@@ -328,15 +331,15 @@ static int forward_query(int udpfd, unio
 	start = daemon->servers; /* at end of list, recycle */
       header->id = htons(forward->new_id);
     }
-  else 
+  else
     {
       if (gotname)
 	flags = search_servers(now, &addrp, gotname, daemon->namebuff, &type, &domain, &norebind);
-      
+
       if (!flags && !(forward = get_new_frec(now, NULL, 0)))
 	/* table full - server failure. */
 	flags = F_NEG;
-      
+
       if (forward)
 	{
 	  forward->source = *udpaddr;
@@ -359,14 +362,14 @@ static int forward_query(int udpfd, unio
 	  if (do_bit)
 	    forward->flags |= FREC_DO_QUESTION;
 #endif
-	  
+
 	  header->id = htons(forward->new_id);
-	  
-	  /* In strict_order mode, always try servers in the order 
-	     specified in resolv.conf, if a domain is given 
+
+	  /* In strict_order mode, always try servers in the order
+	     specified in resolv.conf, if a domain is given
 	     always try all the available servers,
 	     otherwise, use the one last known to work. */
-	  
+
 	  if (type == 0)
 	    {
 	      if (option_bool(OPT_ORDER))
@@ -390,24 +393,24 @@ static int forward_query(int udpfd, unio
 	}
     }
 
-  /* check for send errors here (no route to host) 
+  /* check for send errors here (no route to host)
      if we fail to send to all nameservers, send back an error
      packet straight away (helps modem users when offline)  */
-  
+
   if (!flags && forward)
     {
       struct server *firstsentto = start;
       int forwarded = 0;
-      
+
       /* If a query is retried, use the log_id for the retry when logging the answer. */
       forward->log_id = daemon->log_id;
-      
+
       if (option_bool(OPT_ADD_MAC))
 	plen = add_mac(header, plen, ((char *) header) + daemon->packet_buff_sz, &forward->source);
-      
+
       if (option_bool(OPT_CLIENT_SUBNET))
 	{
-	  size_t new = add_source_addr(header, plen, ((char *) header) + daemon->packet_buff_sz, &forward->source); 
+	  size_t new = add_source_addr(header, plen, ((char *) header) + daemon->packet_buff_sz, &forward->source);
 	  if (new != plen)
 	    {
 	      plen = new;
@@ -419,7 +422,7 @@ static int forward_query(int udpfd, unio
       if (option_bool(OPT_DNSSEC_VALID))
 	{
 	  size_t new_plen = add_do_bit(header, plen, ((char *) header) + daemon->packet_buff_sz);
-	 
+
 	  /* For debugging, set Checking Disabled, otherwise, have the upstream check too,
 	     this allows it to select auth servers when one is returning bad data. */
 	  if (option_bool(OPT_DNSSEC_DEBUG))
@@ -431,13 +434,13 @@ static int forward_query(int udpfd, unio
 	  plen = new_plen;
 	}
 #endif
-      
+
       while (1)
-	{ 
+	{
 	  /* only send to servers dealing with our domain.
-	     domain may be NULL, in which case server->domain 
+	     domain may be NULL, in which case server->domain
 	     must be NULL also. */
-	  
+
 	  if (type == (start->flags & SERV_TYPE) &&
 	      (type != SERV_HAS_DOMAIN || hostname_isequal(domain, start->domain)) &&
 	      !(start->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
@@ -447,7 +450,7 @@ static int forward_query(int udpfd, unio
 	      /* find server socket to use, may need to get random one. */
 	      if (start->sfd)
 		fd = start->sfd->fd;
-	      else 
+	      else
 		{
 #ifdef HAVE_IPV6
 		  if (start->addr.sa.sa_family == AF_INET6)
@@ -481,52 +484,52 @@ static int forward_query(int udpfd, unio
 
 	      if (find_pseudoheader(header, plen, NULL, &pheader, NULL))
 		PUTSHORT((forward->flags & FREC_TEST_PKTSZ) ? SAFE_PKTSZ : start->edns_pktsz, pheader);
-	      
+
 	      if (retry_send(sendto(fd, (char *)header, plen, 0,
 				    &start->addr.sa,
 				    sa_len(&start->addr))))
 		continue;
-	    
+
 	      if (errno == 0)
 		{
 		  /* Keep info in case we want to re-send this packet */
 		  daemon->srv_save = start;
 		  daemon->packet_len = plen;
-		  
+
 		  if (!gotname)
 		    strcpy(daemon->namebuff, "query");
 		  if (start->addr.sa.sa_family == AF_INET)
-		    log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff, 
-			      (struct all_addr *)&start->addr.in.sin_addr, NULL); 
+		    log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff,
+			      (struct all_addr *)&start->addr.in.sin_addr, NULL);
 #ifdef HAVE_IPV6
 		  else
-		    log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff, 
+		    log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff,
 			      (struct all_addr *)&start->addr.in6.sin6_addr, NULL);
-#endif 
+#endif
 		  start->queries++;
 		  forwarded = 1;
 		  forward->sentto = start;
-		  if (!forward->forwardall) 
+		  if (!forward->forwardall)
 		    break;
 		  forward->forwardall++;
 		}
-	    } 
-	  
+	    }
+
 	  if (!(start = start->next))
  	    start = daemon->servers;
-	  
+
 	  if (start == firstsentto)
 	    break;
 	}
-      
+
       if (forwarded)
 	return 1;
-      
-      /* could not send on, prepare to return */ 
+
+      /* could not send on, prepare to return */
       header->id = htons(forward->orig_id);
       free_frec(forward); /* cancel */
-    }	  
-  
+    }
+
   /* could not send on, return empty answer or address if known for whole domain */
   if (udpfd != -1)
     {
@@ -537,14 +540,14 @@ static int forward_query(int udpfd, unio
   return 0;
 }
 
-static size_t process_reply(struct dns_header *header, time_t now, struct server *server, size_t n, int check_rebind, 
-			    int no_cache, int cache_secure, int bogusanswer, int ad_reqd, int do_bit, int added_pheader, 
+static size_t process_reply(struct dns_header *header, time_t now, struct server *server, size_t n, int check_rebind,
+			    int no_cache, int cache_secure, int bogusanswer, int ad_reqd, int do_bit, int added_pheader,
 			    int check_subnet, union mysockaddr *query_source)
 {
   unsigned char *pheader, *sizep;
   char **sets = 0;
   int munged = 0, is_sign;
-  size_t plen; 
+  size_t plen;
 
   (void)ad_reqd;
   (void)do_bit;
@@ -557,13 +560,13 @@ static size_t process_reply(struct dns_h
       struct ipsets *ipset_pos;
       unsigned int namelen = strlen(daemon->namebuff);
       unsigned int matchlen = 0;
-      for (ipset_pos = daemon->ipsets; ipset_pos; ipset_pos = ipset_pos->next) 
+      for (ipset_pos = daemon->ipsets; ipset_pos; ipset_pos = ipset_pos->next)
 	{
 	  unsigned int domainlen = strlen(ipset_pos->domain);
 	  char *matchstart = daemon->namebuff + namelen - domainlen;
 	  if (namelen >= domainlen && hostname_isequal(matchstart, ipset_pos->domain) &&
 	      (domainlen == 0 || namelen == domainlen || *(matchstart - 1) == '.' ) &&
-	      domainlen >= matchlen) 
+	      domainlen >= matchlen)
 	    {
 	      matchlen = domainlen;
 	      sets = ipset_pos->sets;
@@ -571,7 +574,7 @@ static size_t process_reply(struct dns_h
 	}
     }
 #endif
-  
+
   /* If upstream is advertising a larger UDP packet size
      than we allow, trim it so that we don't get overlarge
      requests for the client. We can't do this for signed packets. */
@@ -580,32 +583,32 @@ static size_t process_reply(struct dns_h
     {
       unsigned short udpsz;
       unsigned char *psave = sizep;
-      
+
       GETSHORT(udpsz, sizep);
 
       if (!is_sign && udpsz > daemon->edns_pktsz)
 	PUTSHORT(daemon->edns_pktsz, psave);
-      
+
       if (check_subnet && !check_source(header, plen, pheader, query_source))
 	{
 	  my_syslog(LOG_WARNING, _("discarding DNS reply: subnet option mismatch"));
 	  return 0;
 	}
-      
+
       if (added_pheader)
 	{
-	  pheader = 0; 
+	  pheader = 0;
 	  header->arcount = htons(0);
 	}
     }
-  
+
   /* RFC 4035 sect 4.6 para 3 */
   if (!is_sign && !option_bool(OPT_DNSSEC_PROXY))
      header->hb4 &= ~HB4_AD;
-  
+
   if (OPCODE(header) != QUERY || (RCODE(header) != NOERROR && RCODE(header) != NXDOMAIN))
     return resize_packet(header, n, pheader, plen);
-  
+
   /* Complain loudly if the upstream server is non-recursive. */
   if (!(header->hb4 & HB4_RA) && RCODE(header) == NOERROR && ntohs(header->ancount) == 0 &&
       server && !(server->flags & SERV_WARNED_RECURSIVE))
@@ -614,7 +617,7 @@ static size_t process_reply(struct dns_h
       my_syslog(LOG_WARNING, _("nameserver %s refused to do a recursive query"), daemon->namebuff);
       if (!option_bool(OPT_LOG))
 	server->flags |= SERV_WARNED_RECURSIVE;
-    }  
+    }
 
   if (daemon->bogus_addr && RCODE(header) != NXDOMAIN &&
       check_for_bogus_wildcard(header, n, daemon->namebuff, daemon->bogus_addr, now))
@@ -624,15 +627,15 @@ static size_t process_reply(struct dns_h
       header->hb3 &= ~HB3_AA;
       cache_secure = 0;
     }
-  else 
+  else
     {
       int doctored = 0;
-      
-      if (RCODE(header) == NXDOMAIN && 
+
+      if (RCODE(header) == NXDOMAIN &&
 	  extract_request(header, n, daemon->namebuff, NULL) &&
 	  check_for_local_domain(daemon->namebuff, now))
 	{
-	  /* if we forwarded a query for a locally known name (because it was for 
+	  /* if we forwarded a query for a locally known name (because it was for
 	     an unknown type) and the answer is NXDOMAIN, convert that to NODATA,
 	     since we know that the domain exists, even if upstream doesn't */
 	  munged = 1;
@@ -640,7 +643,7 @@ static size_t process_reply(struct dns_h
 	  SET_RCODE(header, NOERROR);
 	  cache_secure = 0;
 	}
-      
+
       if (extract_addresses(header, n, daemon->namebuff, now, sets, is_sign, check_rebind, no_cache, cache_secure, &doctored))
 	{
 	  my_syslog(LOG_WARNING, _("possible DNS-rebind attack detected: %s"), daemon->namebuff);
@@ -651,9 +654,9 @@ static size_t process_reply(struct dns_h
       if (doctored)
 	cache_secure = 0;
     }
-  
+
 #ifdef HAVE_DNSSEC
-  if (bogusanswer && !(header->hb4 & HB4_CD)) 
+  if (bogusanswer && !(header->hb4 & HB4_CD))
     {
       if (!option_bool(OPT_DNSSEC_DEBUG))
 	{
@@ -665,7 +668,7 @@ static size_t process_reply(struct dns_h
 
   if (option_bool(OPT_DNSSEC_VALID))
     header->hb4 &= ~HB4_AD;
-  
+
   if (!(header->hb4 & HB4_CD) && ad_reqd && cache_secure)
     header->hb4 |= HB4_AD;
 
@@ -676,7 +679,7 @@ static size_t process_reply(struct dns_h
 
   /* do this after extract_addresses. Ensure NODATA reply and remove
      nameserver info. */
-  
+
   if (munged)
     {
       header->ancount = htons(0);
@@ -684,7 +687,7 @@ static size_t process_reply(struct dns_h
       header->arcount = htons(0);
       header->hb3 &= ~HB3_TC;
     }
-  
+
   /* the bogus-nxdomain stuff, doctor and NXDOMAIN->NODATA munging can all elide
      sections of the packet. Find the new length here and put back pseudoheader
      if it was removed. */
@@ -710,43 +713,43 @@ void reply_query(int fd, int family, tim
 
   /* packet buffer overwritten */
   daemon->srv_save = NULL;
-  
+
   /* Determine the address of the server replying  so that we can mark that as good */
   serveraddr.sa.sa_family = family;
 #ifdef HAVE_IPV6
   if (serveraddr.sa.sa_family == AF_INET6)
     serveraddr.in6.sin6_flowinfo = 0;
 #endif
-  
+
   header = (struct dns_header *)daemon->packet;
-  
+
   if (n < (int)sizeof(struct dns_header) || !(header->hb3 & HB3_QR))
     return;
-  
+
   /* spoof check: answer must come from known server, */
   for (server = daemon->servers; server; server = server->next)
     if (!(server->flags & (SERV_LITERAL_ADDRESS | SERV_NO_ADDR)) &&
 	sockaddr_isequal(&server->addr, &serveraddr))
       break;
-  
+
   if (!server)
     return;
-  
+
 #ifdef HAVE_DNSSEC
   hash = hash_questions(header, n, daemon->namebuff);
 #else
   hash = &crc;
   crc = questions_crc(header, n, daemon->namebuff);
 #endif
-  
+
   if (!(forward = lookup_frec(ntohs(header->id), hash)))
     return;
-  
-  /* log_query gets called indirectly all over the place, so 
+
+  /* log_query gets called indirectly all over the place, so
      pass these in global variables - sorry. */
   daemon->log_display_id = forward->log_id;
   daemon->log_source_addr = &forward->source;
-  
+
   if (daemon->ignore_addr && RCODE(header) == NOERROR &&
       check_for_ignored_address(header, n, daemon->ignore_addr))
     return;
@@ -759,7 +762,7 @@ void reply_query(int fd, int family, tim
       unsigned char *pheader;
       size_t plen;
       int is_sign;
-      
+
       /* recreate query from reply */
       pheader = find_pseudoheader(header, (size_t)n, &plen, NULL, &is_sign);
       if (!is_sign)
@@ -775,8 +778,8 @@ void reply_query(int fd, int family, tim
 	      return;
 	    }
 	}
-    }   
-   
+    }
+
   server = forward->sentto;
   if ((forward->sentto->flags & SERV_TYPE) == 0)
     {
@@ -785,8 +788,8 @@ void reply_query(int fd, int family, tim
       else
 	{
 	  struct server *last_server;
-	  
-	  /* find good server by address if possible, otherwise assume the last one we sent to */ 
+
+	  /* find good server by address if possible, otherwise assume the last one we sent to */
 	  for (last_server = daemon->servers; last_server; last_server = last_server->next)
 	    if (!(last_server->flags & (SERV_LITERAL_ADDRESS | SERV_HAS_DOMAIN | SERV_FOR_NODOTS | SERV_NO_ADDR)) &&
 		sockaddr_isequal(&last_server->addr, &serveraddr))
@@ -794,18 +797,18 @@ void reply_query(int fd, int family, tim
 		server = last_server;
 		break;
 	      }
-	} 
+	}
       if (!option_bool(OPT_ALL_SERVERS))
 	daemon->last_server = server;
     }
- 
+
   /* We tried resending to this server with a smaller maximum size and got an answer.
      Make that permanent. To avoid reduxing the packet size for an single dropped packet,
      only do this when we get a truncated answer, or one larger than the safe size. */
-  if (server && (forward->flags & FREC_TEST_PKTSZ) && 
+  if (server && (forward->flags & FREC_TEST_PKTSZ) &&
       ((header->hb3 & HB3_TC) || n >= SAFE_PKTSZ))
     server->edns_pktsz = SAFE_PKTSZ;
-  
+
   /* If the answer is an error, keep the forward record in place in case
      we get a good reply from another server. Kill it when we've
      had replies from all to avoid filling the forwarding table when
@@ -816,12 +819,12 @@ void reply_query(int fd, int family, tim
 
       if (option_bool(OPT_NO_REBIND))
 	check_rebind = !(forward->flags & FREC_NOREBIND);
-      
+
       /*   Don't cache replies where DNSSEC validation was turned off, either
 	   the upstream server told us so, or the original query specified it.  */
       if ((header->hb4 & HB4_CD) || (forward->flags & FREC_CHECKING_DISABLED))
 	no_cache_dnssec = 1;
-      
+
 #ifdef HAVE_DNSSEC
       if (server && option_bool(OPT_DNSSEC_VALID) && !(forward->flags & FREC_CHECKING_DISABLED))
 	{
@@ -848,7 +851,7 @@ void reply_query(int fd, int family, tim
 	      /* Provably no DS, everything below is insecure, even if signatures are offered */
 	      if (status == STAT_NO_DS)
 		/* We only cache sigs when we've validated a reply.
-		   Avoid caching a reply with sigs if there's a vaildated break in the 
+		   Avoid caching a reply with sigs if there's a vaildated break in the
 		   DS chain, so we don't return replies from cache missing sigs. */
 		status = STAT_INSECURE_DS;
 	      else if (status == STAT_NO_NS || status == STAT_NO_SIG)
@@ -872,21 +875,21 @@ void reply_query(int fd, int family, tim
 		}
 	    }
 	  /* Can't validate, as we're missing key data. Put this
-	     answer aside, whilst we get that. */     
+	     answer aside, whilst we get that. */
 	  if (status == STAT_NEED_DS || status == STAT_NEED_DS_NEG || status == STAT_NEED_KEY)
 	    {
 	      struct frec *new, *orig;
-	      
+
 	      /* Free any saved query */
 	      if (forward->stash)
 		blockdata_free(forward->stash);
-	      
+
 	      /* Now save reply pending receipt of key data */
 	      if (!(forward->stash = blockdata_alloc((char *)header, n)))
 		return;
 	      forward->stash_len = n;
-	      
-	    anotherkey:	      
+
+	    anotherkey:
 	      /* Find the original query that started it all.... */
 	      for (orig = forward; orig->dependent; orig = orig->dependent);
 
@@ -906,17 +909,17 @@ void reply_query(int fd, int family, tim
 		  new->rfd6 = NULL;
 #endif
 		  new->flags &= ~(FREC_DNSKEY_QUERY | FREC_DS_QUERY | FREC_CHECK_NOSIGN);
-		  
+
 		  new->dependent = forward; /* to find query awaiting new one. */
 		  forward->blocking_query = new; /* for garbage cleaning */
 		  /* validate routines leave name of required record in daemon->keyname */
 		  if (status == STAT_NEED_KEY)
 		    {
-		      new->flags |= FREC_DNSKEY_QUERY; 
+		      new->flags |= FREC_DNSKEY_QUERY;
 		      nn = dnssec_generate_query(header, ((char *) header) + daemon->packet_buff_sz,
 						 daemon->keyname, forward->class, T_DNSKEY, &server->addr, server->edns_pktsz);
 		    }
-		  else 
+		  else
 		    {
 		      if (status == STAT_NEED_DS_NEG)
 			new->flags |= FREC_CHECK_NOSIGN;
@@ -932,12 +935,12 @@ void reply_query(int fd, int family, tim
 		  /* Save query for retransmission */
 		  if (!(new->stash = blockdata_alloc((char *)header, nn)))
 		    return;
-		      
+
 		  new->stash_len = nn;
-		  
+
 		  /* Don't resend this. */
 		  daemon->srv_save = NULL;
-		  
+
 		  if (server->sfd)
 		    fd = server->sfd->fd;
 		  else
@@ -956,24 +959,24 @@ void reply_query(int fd, int family, tim
 			    fd = new->rfd4->fd;
 			}
 		    }
-		  
+
 		  if (fd != -1)
 		    {
-		      while (retry_send(sendto(fd, (char *)header, nn, 0, 
-					       &server->addr.sa, 
-					       sa_len(&server->addr)))); 
+		      while (retry_send(sendto(fd, (char *)header, nn, 0,
+					       &server->addr.sa,
+					       sa_len(&server->addr))));
 		      server->queries++;
 		    }
-		  
+
 		  return;
 		}
 	    }
-	  
+
 	  /* Ok, we reached far enough up the chain-of-trust that we can validate something.
 	     Now wind back down, pulling back answers which wouldn't previously validate
 	     and validate them with the new data. Note that if an answer needs multiple
 	     keys to validate, we may find another key is needed, in which case we set off
-	     down another branch of the tree. Once we get to the original answer 
+	     down another branch of the tree. Once we get to the original answer
 	     (FREC_DNSSEC_QUERY not set) and it validates, return it to the original requestor. */
 	  while (forward->dependent)
 	    {
@@ -983,7 +986,7 @@ void reply_query(int fd, int family, tim
 	      forward->blocking_query = NULL; /* already gone */
 	      blockdata_retrieve(forward->stash, forward->stash_len, (void *)header);
 	      n = forward->stash_len;
-	      
+
 	      if (status == STAT_SECURE)
 		{
 		  if (forward->flags & FREC_DNSKEY_QUERY)
@@ -994,11 +997,11 @@ void reply_query(int fd, int family, tim
 		       /* Provably no DS, everything below is insecure, even if signatures are offered */
 		      if (status == STAT_NO_DS)
 			/* We only cache sigs when we've validated a reply.
-			   Avoid caching a reply with sigs if there's a vaildated break in the 
+			   Avoid caching a reply with sigs if there's a vaildated break in the
 			   DS chain, so we don't return replies from cache missing sigs. */
 			status = STAT_INSECURE_DS;
 		      else if (status == STAT_NO_NS || status == STAT_NO_SIG)
-			status = STAT_BOGUS; 
+			status = STAT_BOGUS;
 		    }
 		  else if (forward->flags & FREC_CHECK_NOSIGN)
 		    {
@@ -1008,7 +1011,7 @@ void reply_query(int fd, int family, tim
 		    }
 		  else
 		    {
-		      status = dnssec_validate_reply(now, header, n, daemon->namebuff, daemon->keyname, &forward->class, NULL, NULL);	
+		      status = dnssec_validate_reply(now, header, n, daemon->namebuff, daemon->keyname, &forward->class, NULL, NULL);
 		      if (status == STAT_NO_SIG)
 			{
 			  if (option_bool(OPT_DNSSEC_NO_SIGN))
@@ -1017,29 +1020,29 @@ void reply_query(int fd, int family, tim
 			    status = STAT_INSECURE;
 			}
 		    }
-	       
+
 		  if (status == STAT_NEED_DS || status == STAT_NEED_DS_NEG || status == STAT_NEED_KEY)
 		    goto anotherkey;
 		}
 	    }
-	  
+
 	  no_cache_dnssec = 0;
 
 	  if (status == STAT_INSECURE_DS)
 	    {
 	      /* We only cache sigs when we've validated a reply.
-		 Avoid caching a reply with sigs if there's a vaildated break in the 
+		 Avoid caching a reply with sigs if there's a vaildated break in the
 		 DS chain, so we don't return replies from cache missing sigs. */
 	      status = STAT_INSECURE;
 	      no_cache_dnssec = 1;
 	    }
-	  
+
 	  if (status == STAT_TRUNCATED)
 	    header->hb3 |= HB3_TC;
 	  else
 	    {
 	      char *result, *domain = "result";
-	      
+
 	      if (forward->work_counter == 0)
 		{
 		  result = "ABANDONED";
@@ -1047,13 +1050,13 @@ void reply_query(int fd, int family, tim
 		}
 	      else
 		result = (status == STAT_SECURE ? "SECURE" : (status == STAT_INSECURE ? "INSECURE" : "BOGUS"));
-	      
+
 	      if (status == STAT_BOGUS && extract_request(header, n, daemon->namebuff, NULL))
 		domain = daemon->namebuff;
 
 	      log_query(F_KEYTAG | F_SECSTAT, domain, NULL, result);
 	    }
-	  
+
 	  if (status == STAT_SECURE)
 	    cache_secure = 1;
 	  else if (status == STAT_BOGUS)
@@ -1062,27 +1065,75 @@ void reply_query(int fd, int family, tim
 	      bogusanswer = 1;
 	    }
 	}
-#endif     
-      
+#endif
+
       /* restore CD bit to the value in the query */
       if (forward->flags & FREC_CHECKING_DISABLED)
 	header->hb4 |= HB4_CD;
       else
 	header->hb4 &= ~HB4_CD;
-      
-      if ((nn = process_reply(header, now, server, (size_t)n, check_rebind, no_cache_dnssec, cache_secure, bogusanswer, 
-			      forward->flags & FREC_AD_QUESTION, forward->flags & FREC_DO_QUESTION, 
+
+      if ((nn = process_reply(header, now, server, (size_t)n, check_rebind, no_cache_dnssec, cache_secure, bogusanswer,
+			      forward->flags & FREC_AD_QUESTION, forward->flags & FREC_DO_QUESTION,
 			      forward->flags & FREC_ADDED_PHEADER, forward->flags & FREC_HAS_SUBNET, &forward->source)))
 	{
 	  header->id = htons(forward->orig_id);
 	  header->hb4 |= HB4_RA; /* recursion if available */
-	  send_from(forward->fd, option_bool(OPT_NOWILD) || option_bool (OPT_CLEVERBIND), daemon->packet, nn, 
+	  send_from(forward->fd, option_bool(OPT_NOWILD) || option_bool (OPT_CLEVERBIND), daemon->packet, nn,
 		    &forward->source, &forward->dest, forward->iface);
 	}
       free_frec(forward); /* cancel */
     }
 }
 
+#ifdef URL_LIST
+int get_mac_by_ip(unsigned char* mac,  struct sockaddr *sa){
+	int sock_fd = 0, ret = 0;
+	struct arpreq req;
+	memset(&req, 0, sizeof(struct arpreq));
+	// set ip
+	memcpy(&req.arp_pa, sa, sizeof(struct sockaddr));
+	// set interface
+	strncpy(req.arp_dev, "br-lan", sizeof(req.arp_dev));
+	sock_fd = socket(AF_INET, SOCK_DGRAM, 0);
+	if(sock_fd < 0)
+	{
+		my_syslog(LOG_WARNING, _("%s open socket fail.\n"), __FUNCTION__);
+		return -1;
+	}
+
+	ret = ioctl(sock_fd, SIOCGARP, &req);
+	close(sock_fd);
+	if(ret < 0)
+	{
+		my_syslog(LOG_WARNING, _("ioctl error.\n"));
+		return -1;
+	}
+	memcpy(mac, &req.arp_ha.sa_data, 6);
+	return 0;
+}
+
+int filter_by_mac(struct sockaddr *sa, struct mac_node **ppmac_node){
+	unsigned char mac[6] = {0};
+	struct sockaddr_in sin;
+	memcpy(&sin, sa, sizeof(sin));
+	my_syslog(LOG_ERR, _("addr:%s, port:%d\n"), inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
+	if(get_mac_by_ip(mac, sa) < 0){
+		my_syslog(LOG_WARNING, _("cannot find mac for ip"));
+		return -1;
+	}
+	else{
+		my_syslog(LOG_WARNING, _("mac is %02x:%02x:%02x:%02x:%02x:%02x"), mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	}
+
+	if((*ppmac_node = find_mac_node(mac, gpmac_list_hdr)) == NULL) {
+		my_syslog(LOG_WARNING, _("get null"));
+		return -2;
+	}
+
+	return 0;
+}
+#endif
 
 void receive_query(struct listener *listen, time_t now)
 {
@@ -1124,24 +1175,24 @@ void receive_query(struct listener *list
 
   /* packet buffer overwritten */
   daemon->srv_save = NULL;
-  
+
   dst_addr_4.s_addr = dst_addr.addr.addr4.s_addr = 0;
   netmask.s_addr = 0;
-  
+
   if (option_bool(OPT_NOWILD) && listen->iface)
     {
       auth_dns = listen->iface->dns_auth;
-     
+
       if (listen->family == AF_INET)
 	{
 	  dst_addr_4 = dst_addr.addr.addr4 = listen->iface->addr.in.sin_addr;
 	  netmask = listen->iface->netmask;
 	}
     }
-  
+
   iov[0].iov_base = daemon->packet;
   iov[0].iov_len = daemon->edns_pktsz;
-    
+
   msg.msg_control = control_u.control;
   msg.msg_controllen = sizeof(control_u);
   msg.msg_flags = 0;
@@ -1149,20 +1200,20 @@ void receive_query(struct listener *list
   msg.msg_namelen = sizeof(source_addr);
   msg.msg_iov = iov;
   msg.msg_iovlen = 1;
-  
+
   if ((n = recvmsg(listen->fd, &msg, 0)) == -1)
     return;
-  
-  if (n < (int)sizeof(struct dns_header) || 
+
+  if (n < (int)sizeof(struct dns_header) ||
       (msg.msg_flags & MSG_TRUNC) ||
       (header->hb3 & HB3_QR))
     return;
-  
+
   source_addr.sa.sa_family = listen->family;
-  
+
   if (listen->family == AF_INET)
     {
-       /* Source-port == 0 is an error, we can't send back to that. 
+       /* Source-port == 0 is an error, we can't send back to that.
 	  http://www.ietf.org/mail-archive/web/dnsop/current/msg11441.html */
       if (source_addr.in.sin_port == 0)
 	return;
@@ -1176,13 +1227,13 @@ void receive_query(struct listener *list
       source_addr.in6.sin6_flowinfo = 0;
     }
 #endif
-  
+
   /* We can be configured to only accept queries from at-most-one-hop-away addresses. */
   if (option_bool(OPT_LOCAL_SERVICE))
     {
       struct addrlist *addr;
 #ifdef HAVE_IPV6
-      if (listen->family == AF_INET6) 
+      if (listen->family == AF_INET6)
 	{
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
 	    if ((addr->flags & ADDRLIST_IPV6) &&
@@ -1212,7 +1263,11 @@ void receive_query(struct listener *list
 	  return;
 	}
     }
-		
+#ifdef URL_LIST
+	struct mac_node *pmac_node = NULL;
+	filter_by_mac( &source_addr.sa, &pmac_node);
+#endif
+
   if (check_dst)
     {
       struct ifreq ifr;
@@ -1258,7 +1313,7 @@ void receive_query(struct listener *list
 	    }
 	}
 #endif
-      
+
 #ifdef HAVE_IPV6
       if (listen->family == AF_INET6)
 	{
@@ -1270,22 +1325,22 @@ void receive_query(struct listener *list
 		  struct in6_pktinfo *p;
 		} p;
 		p.c = CMSG_DATA(cmptr);
-		  
+
 		dst_addr.addr.addr6 = p.p->ipi6_addr;
 		if_index = p.p->ipi6_ifindex;
 	      }
 	}
 #endif
-      
+
       /* enforce available interface configuration */
-      
+
       if (!indextoname(listen->fd, if_index, ifr.ifr_name))
 	return;
-      
+
       if (!iface_check(listen->family, &dst_addr, ifr.ifr_name, &auth_dns))
 	{
 	   if (!option_bool(OPT_CLEVERBIND))
-	     enumerate_interfaces(0); 
+	     enumerate_interfaces(0);
 	   if (!loopback_exception(listen->fd, listen->family, &dst_addr, ifr.ifr_name) &&
 	       !label_exception(if_index, listen->family, &dst_addr))
 	     return;
@@ -1294,24 +1349,24 @@ void receive_query(struct listener *list
       if (listen->family == AF_INET && option_bool(OPT_LOCALISE))
 	{
 	  struct irec *iface;
-	  
+
 	  /* get the netmask of the interface whch has the address we were sent to.
 	     This is no neccessarily the interface we arrived on. */
-	  
+
 	  for (iface = daemon->interfaces; iface; iface = iface->next)
 	    if (iface->addr.sa.sa_family == AF_INET &&
 		iface->addr.in.sin_addr.s_addr == dst_addr_4.s_addr)
 	      break;
-	  
+
 	  /* interface may be new */
 	  if (!iface && !option_bool(OPT_CLEVERBIND))
-	    enumerate_interfaces(0); 
-	  
+	    enumerate_interfaces(0);
+
 	  for (iface = daemon->interfaces; iface; iface = iface->next)
 	    if (iface->addr.sa.sa_family == AF_INET &&
 		iface->addr.in.sin_addr.s_addr == dst_addr_4.s_addr)
 	      break;
-	  
+
 	  /* If we failed, abandon localisation */
 	  if (iface)
 	    netmask = iface->netmask;
@@ -1319,28 +1374,50 @@ void receive_query(struct listener *list
 	    dst_addr_4.s_addr = 0;
 	}
     }
-   
-  /* log_query gets called indirectly all over the place, so 
+
+  /* log_query gets called indirectly all over the place, so
      pass these in global variables - sorry. */
   daemon->log_display_id = ++daemon->log_id;
   daemon->log_source_addr = &source_addr;
-  
+
   if (extract_request(header, (size_t)n, daemon->namebuff, &type))
     {
+
+		my_syslog(LOG_ERR, _("get here %s"),daemon->namebuff);
 #ifdef HAVE_AUTH
       struct auth_zone *zone;
 #endif
       char *types = querystr(auth_dns ? "auth" : "query", type);
-      
-      if (listen->family == AF_INET) 
-	log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff, 
+
+      if (listen->family == AF_INET)
+	log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff,
 		  (struct all_addr *)&source_addr.in.sin_addr, types);
 #ifdef HAVE_IPV6
       else
-	log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff, 
+	log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff,
 		  (struct all_addr *)&source_addr.in6.sin6_addr, types);
 #endif
-
+#ifdef URL_LIST
+	  if(pmac_node != NULL){
+		  my_syslog(LOG_ERR, _("in mac node request %s"),daemon->namebuff);
+		  char block = 1;
+		  if(pmac_node->list_type){
+			  block = 0;
+		  }
+		  struct url_node* ptmp = pmac_node->purl_list_hdr;
+		  while(ptmp){
+			  if(strstr(daemon->namebuff, ptmp->url_str) != NULL){
+				  block = !block;
+				  break;
+			  }
+			  ptmp = ptmp->pnext;
+		  }
+		  if(block){
+			  my_syslog(LOG_ERR, _("block this request %s match %s"),daemon->namebuff,ptmp->url_str);
+			  return;
+		  }
+	  }
+#endif
 #ifdef HAVE_AUTH
       /* find queries for zones we're authoritative for, and answer them directly */
       if (!auth_dns)
@@ -1352,14 +1429,14 @@ void receive_query(struct listener *list
 	      break;
 	    }
 #endif
-      
+
 #ifdef HAVE_LOOP
       /* Check for forwarding loop */
       if (detect_loop(daemon->namebuff, type))
 	return;
 #endif
     }
-  
+
 #ifdef HAVE_AUTH
   if (auth_dns)
     {
@@ -1375,9 +1452,9 @@ void receive_query(struct listener *list
 #endif
     {
       int ad_reqd, do_bit;
-      m = answer_request(header, ((char *) header) + daemon->packet_buff_sz, (size_t)n, 
+      m = answer_request(header, ((char *) header) + daemon->packet_buff_sz, (size_t)n,
 			 dst_addr_4, netmask, now, &ad_reqd, &do_bit);
-      
+
       if (m >= 1)
 	{
 	  send_from(listen->fd, option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND),
@@ -1395,13 +1472,13 @@ void receive_query(struct listener *list
 #ifdef HAVE_DNSSEC
 
 /* UDP: we've got an unsigned answer, return STAT_INSECURE if we can prove there's no DS
-   and therefore the answer shouldn't be signed, or STAT_BOGUS if it should be, or 
+   and therefore the answer shouldn't be signed, or STAT_BOGUS if it should be, or
    STAT_NEED_DS_NEG and keyname if we need to do the query. */
-static int send_check_sign(struct frec *forward, time_t now, struct dns_header *header, size_t plen, 
+static int send_check_sign(struct frec *forward, time_t now, struct dns_header *header, size_t plen,
 			   char *name, char *keyname)
 {
   int status = dnssec_chase_cname(now, header, plen, name, keyname);
-  
+
   if (status != STAT_INSECURE)
     return status;
 
@@ -1410,11 +1487,11 @@ static int send_check_sign(struct frec *
   forward->name_len = forward->name_start + 1;
   if (!(forward->orig_domain = blockdata_alloc(name, forward->name_len)))
     return STAT_BOGUS;
-  
+
   return do_check_sign(forward, 0, now, name, keyname);
 }
- 
-/* We either have a a reply (header non-NULL, or we need to start by looking in the cache */ 
+
+/* We either have a a reply (header non-NULL, or we need to start by looking in the cache */
 static int do_check_sign(struct frec *forward, int status, time_t now, char *name, char *keyname)
 {
   /* get domain we're checking back from blockdata store, it's stored on the original query. */
@@ -1422,10 +1499,10 @@ static int do_check_sign(struct frec *fo
     forward = forward->dependent;
 
   blockdata_retrieve(forward->orig_domain, forward->name_len, name);
-  
+
   while (1)
     {
-      char *p; 
+      char *p;
 
       if (status == 0)
 	{
@@ -1440,7 +1517,7 @@ static int do_check_sign(struct frec *fo
 	      return STAT_NEED_DS_NEG;
 	    }
 
-	  /* F_DNSSECOK misused in DS cache records to non-existance of NS record */ 
+	  /* F_DNSSECOK misused in DS cache records to non-existance of NS record */
 	  if (!(crecp->flags & F_NEG))
 	    status = STAT_SECURE;
 	  else if (crecp->flags & F_DNSSECOK)
@@ -1448,8 +1525,8 @@ static int do_check_sign(struct frec *fo
 	  else
 	    status = STAT_NO_NS;
 	}
-      
-      /* Have entered non-signed part of DNS tree. */ 
+
+      /* Have entered non-signed part of DNS tree. */
       if (status == STAT_NO_DS)
 	return STAT_INSECURE;
 
@@ -1458,40 +1535,40 @@ static int do_check_sign(struct frec *fo
 
       if (status == STAT_NO_SIG && *keyname != 0)
 	{
-	  /* There is a validated CNAME chain that doesn't end in a DS record. Start 
+	  /* There is a validated CNAME chain that doesn't end in a DS record. Start
 	     the search again in that domain. */
 	  blockdata_free(forward->orig_domain);
 	  forward->name_start = strlen(keyname);
 	  forward->name_len = forward->name_start + 1;
 	  if (!(forward->orig_domain = blockdata_alloc(keyname, forward->name_len)))
 	    return STAT_BOGUS;
-	  
+
 	  strcpy(name, keyname);
 	  status = 0; /* force to cache when we iterate. */
 	  continue;
 	}
-      
+
       /* There's a proven DS record, or we're within a zone, where there doesn't need
-	 to be a DS record. Add a name and try again. 
+	 to be a DS record. Add a name and try again.
 	 If we've already tried the whole name, then fail */
 
       if (forward->name_start == 0)
 	return STAT_BOGUS;
-      
+
       for (p = &name[forward->name_start-2]; (*p != '.') && (p != name); p--);
-      
+
       if (p != name)
 	p++;
-      
+
       forward->name_start = p - name;
       status = 0; /* force to cache when we iterate. */
     }
 }
 
 /* Move down from the root, until we find a signed non-existance of a DS, in which case
-   an unsigned answer is OK, or we find a signed DS, in which case there should be 
+   an unsigned answer is OK, or we find a signed DS, in which case there should be
    a signature, and the answer is BOGUS */
-static int  tcp_check_for_unsigned_zone(time_t now, struct dns_header *header, size_t plen, int class, char *name, 
+static int  tcp_check_for_unsigned_zone(time_t now, struct dns_header *header, size_t plen, int class, char *name,
 					char *keyname, struct server *server, int *keycount)
 {
   size_t m;
@@ -1506,10 +1583,10 @@ static int  tcp_check_for_unsigned_zone(
   status = tcp_key_recurse(now, STAT_CHASE_CNAME, header, plen, class, name, keyname, server, keycount);
   if (status == STAT_BOGUS)
     return STAT_BOGUS;
-  
+
   if (!(packet = whine_malloc(65536 + MAXDNAME + RRFIXEDSZ + sizeof(u16))))
     return STAT_BOGUS;
-  
+
   payload = &packet[2];
   header = (struct dns_header *)payload;
   length = (u16 *)packet;
@@ -1517,7 +1594,7 @@ static int  tcp_check_for_unsigned_zone(
   /* Stash the name away, since the buffer will be trashed when we recurse */
   name_len = strlen(name) + 1;
   name_start = name + name_len - 1;
-  
+
   if (!(block = blockdata_alloc(name, name_len)))
     {
       free(packet);
@@ -1533,11 +1610,11 @@ static int  tcp_check_for_unsigned_zone(
 	{
 	  free(packet);
 	  blockdata_free(block);
-	  return STAT_BOGUS;    
+	  return STAT_BOGUS;
 	}
-      
+
       while ((crecp = cache_find_by_name(NULL, name_start, now, F_DS)))
-	{      
+	{
 	  if ((crecp->flags & F_NEG) && (crecp->flags & F_DNSSECOK))
 	    {
 	      /* Found a secure denial of DS - delegation is indeed insecure */
@@ -1545,40 +1622,40 @@ static int  tcp_check_for_unsigned_zone(
 	      blockdata_free(block);
 	      return STAT_INSECURE;
 	    }
-      
+
 	  /* Here, either there's a secure DS, or no NS and no DS, and therefore no delegation.
 	     Add another label and continue. */
- 
+
 	  if (name_start == name)
 	    {
 	      free(packet);
 	      blockdata_free(block);
 	      return STAT_BOGUS; /* run out of labels */
 	    }
-	  
+
 	  name_start -= 2;
-	  while (*name_start != '.' && name_start != name) 
+	  while (*name_start != '.' && name_start != name)
 	    name_start--;
 	  if (name_start != name)
 	    name_start++;
 	}
-      
+
       /* Can't find it in the cache, have to send a query */
 
       m = dnssec_generate_query(header, ((char *) header) + 65536, name_start, class, T_DS, &server->addr, server->edns_pktsz);
-      
+
       *length = htons(m);
-      
+
       if (read_write(server->tcpfd, packet, m + sizeof(u16), 0) &&
 	  read_write(server->tcpfd, &c1, 1, 1) &&
 	  read_write(server->tcpfd, &c2, 1, 1) &&
 	  read_write(server->tcpfd, payload, (c1 << 8) | c2, 1))
 	{
 	  m = (c1 << 8) | c2;
-	  
+
 	  /* Note this trashes all three name workspaces */
 	  status = tcp_key_recurse(now, STAT_NEED_DS_NEG, header, m, class, name, keyname, server, keycount);
-	  
+
 	  if (status == STAT_NO_DS)
 	    {
 	      /* Found a secure denial of DS - delegation is indeed insecure */
@@ -1586,44 +1663,44 @@ static int  tcp_check_for_unsigned_zone(
 	      blockdata_free(block);
 	      return STAT_INSECURE;
 	    }
-	  
+
 	  if (status == STAT_NO_SIG && *keyname != 0)
 	    {
-	      /* There is a validated CNAME chain that doesn't end in a DS record. Start 
+	      /* There is a validated CNAME chain that doesn't end in a DS record. Start
 		 the search again in that domain. */
 	      blockdata_free(block);
 	      name_len = strlen(keyname) + 1;
 	      name_start = name + name_len - 1;
-	      
+
 	      if (!(block = blockdata_alloc(keyname, name_len)))
 		return STAT_BOGUS;
-	      
+
 	      strcpy(name, keyname);
 	      continue;
 	    }
-	  
+
 	  if (status == STAT_BOGUS)
 	    {
 	      free(packet);
 	      blockdata_free(block);
 	      return STAT_BOGUS;
 	    }
-	  
+
 	  /* Here, either there's a secure DS, or no NS and no DS, and therefore no delegation.
 	     Add another label and continue. */
-	  
+
 	  /* Get name we're checking back. */
 	  blockdata_retrieve(block, name_len, name);
-	  
+
 	  if (name_start == name)
 	    {
 	      free(packet);
 	      blockdata_free(block);
 	      return STAT_BOGUS; /* run out of labels */
 	    }
-	  
+
 	  name_start -= 2;
-	  while (*name_start != '.' && name_start != name) 
+	  while (*name_start != '.' && name_start != name)
 	    name_start--;
 	  if (name_start != name)
 	    name_start++;
@@ -1638,7 +1715,7 @@ static int  tcp_check_for_unsigned_zone(
     }
 }
 
-static int tcp_key_recurse(time_t now, int status, struct dns_header *header, size_t n, 
+static int tcp_key_recurse(time_t now, int status, struct dns_header *header, size_t n,
 			   int class, char *name, char *keyname, struct server *server, int *keycount)
 {
   /* Recurse up the key heirarchy */
@@ -1647,7 +1724,7 @@ static int tcp_key_recurse(time_t now, i
   /* limit the amount of work we do, to avoid cycling forever on loops in the DNS */
   if (--(*keycount) == 0)
     return STAT_INSECURE;
-  
+
   if (status == STAT_NEED_KEY)
     new_status = dnssec_validate_by_ds(now, header, n, name, keyname, class);
   else if (status == STAT_NEED_DS || status == STAT_NEED_DS_NEG)
@@ -1663,10 +1740,10 @@ static int tcp_key_recurse(time_t now, i
     }
   else if (status == STAT_CHASE_CNAME)
     new_status = dnssec_chase_cname(now, header, n, name, keyname);
-  else 
+  else
     {
       new_status = dnssec_validate_reply(now, header, n, name, keyname, &class, NULL, NULL);
-      
+
       if (new_status == STAT_NO_SIG)
 	{
 	  if (option_bool(OPT_DNSSEC_NO_SIGN))
@@ -1680,22 +1757,22 @@ static int tcp_key_recurse(time_t now, i
      Make query for same, and recurse to validate */
   if (new_status == STAT_NEED_DS || new_status == STAT_NEED_KEY)
     {
-      size_t m; 
+      size_t m;
       unsigned char *packet = whine_malloc(65536 + MAXDNAME + RRFIXEDSZ + sizeof(u16));
       unsigned char *payload = &packet[2];
       struct dns_header *new_header = (struct dns_header *)payload;
       u16 *length = (u16 *)packet;
       unsigned char c1, c2;
-       
+
       if (!packet)
 	return STAT_INSECURE;
 
     another_tcp_key:
-      m = dnssec_generate_query(new_header, ((char *) new_header) + 65536, keyname, class, 
+      m = dnssec_generate_query(new_header, ((char *) new_header) + 65536, keyname, class,
 				new_status == STAT_NEED_KEY ? T_DNSKEY : T_DS, &server->addr, server->edns_pktsz);
-      
+
       *length = htons(m);
-      
+
       if (!read_write(server->tcpfd, packet, m + sizeof(u16), 0) ||
 	  !read_write(server->tcpfd, &c1, 1, 1) ||
 	  !read_write(server->tcpfd, &c2, 1, 1) ||
@@ -1704,15 +1781,15 @@ static int tcp_key_recurse(time_t now, i
       else
 	{
 	  m = (c1 << 8) | c2;
-	  
+
 	  new_status = tcp_key_recurse(now, new_status, new_header, m, class, name, keyname, server, keycount);
-	  
+
 	  if (new_status == STAT_SECURE)
 	    {
 	      /* Reached a validated record, now try again at this level.
 		 Note that we may get ANOTHER NEED_* if an answer needs more than one key.
 		 If so, go round again. */
-	      
+
 	      if (status == STAT_NEED_KEY)
 		new_status = dnssec_validate_by_ds(now, header, n, name, keyname, class);
 	      else if (status == STAT_NEED_DS || status == STAT_NEED_DS_NEG)
@@ -1728,10 +1805,10 @@ static int tcp_key_recurse(time_t now, i
 		}
 	      else if (status == STAT_CHASE_CNAME)
 		new_status = dnssec_chase_cname(now, header, n, name, keyname);
-	      else 
+	      else
 		{
 		  new_status = dnssec_validate_reply(now, header, n, name, keyname, &class, NULL, NULL);
-		  
+
 		  if (new_status == STAT_NO_SIG)
 		    {
 		      if (option_bool(OPT_DNSSEC_NO_SIGN))
@@ -1740,12 +1817,12 @@ static int tcp_key_recurse(time_t now, i
 			new_status = STAT_INSECURE;
 		    }
 		}
-	      
+
 	      if (new_status == STAT_NEED_DS || new_status == STAT_NEED_KEY)
 		goto another_tcp_key;
 	    }
 	}
-      
+
       free(packet);
     }
   return new_status;
@@ -1785,13 +1862,13 @@ unsigned char *tcp_request(int confd, ti
 
   if (getpeername(confd, (struct sockaddr *)&peer_addr, &peer_len) == -1)
     return packet;
-  
+
   /* We can be configured to only accept queries from at-most-one-hop-away addresses. */
   if (option_bool(OPT_LOCAL_SERVICE))
     {
       struct addrlist *addr;
 #ifdef HAVE_IPV6
-      if (peer_addr.sa.sa_family == AF_INET6) 
+      if (peer_addr.sa.sa_family == AF_INET6)
 	{
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
 	    if ((addr->flags & ADDRLIST_IPV6) &&
@@ -1805,7 +1882,7 @@ unsigned char *tcp_request(int confd, ti
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
 	    {
 	      netmask.s_addr = htonl(~(in_addr_t)0 << (32 - addr->prefixlen));
-	      if (!(addr->flags & ADDRLIST_IPV6) && 
+	      if (!(addr->flags & ADDRLIST_IPV6) &&
 		  is_same_net(addr->addr.addr.addr4, peer_addr.in.sin_addr, netmask))
 		break;
 	    }
@@ -1824,40 +1901,40 @@ unsigned char *tcp_request(int confd, ti
 	  !read_write(confd, &c1, 1, 1) || !read_write(confd, &c2, 1, 1) ||
 	  !(size = c1 << 8 | c2) ||
 	  !read_write(confd, payload, size, 1))
-       	return packet; 
-  
+       	return packet;
+
       if (size < (int)sizeof(struct dns_header))
 	continue;
-      
+
       query_count++;
 
-      /* log_query gets called indirectly all over the place, so 
+      /* log_query gets called indirectly all over the place, so
 	 pass these in global variables - sorry. */
       daemon->log_display_id = ++daemon->log_id;
       daemon->log_source_addr = &peer_addr;
-      
+
       check_subnet = 0;
 
       /* save state of "cd" flag in query */
       if ((checking_disabled = header->hb4 & HB4_CD))
 	no_cache_dnssec = 1;
-       
+
       if ((gotname = extract_request(header, (unsigned int)size, daemon->namebuff, &qtype)))
 	{
 #ifdef HAVE_AUTH
 	  struct auth_zone *zone;
 #endif
 	  char *types = querystr(auth_dns ? "auth" : "query", qtype);
-	  
-	  if (peer_addr.sa.sa_family == AF_INET) 
-	    log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff, 
+
+	  if (peer_addr.sa.sa_family == AF_INET)
+	    log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff,
 		      (struct all_addr *)&peer_addr.in.sin_addr, types);
 #ifdef HAVE_IPV6
 	  else
-	    log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff, 
+	    log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff,
 		      (struct all_addr *)&peer_addr.in6.sin6_addr, types);
 #endif
-	  
+
 #ifdef HAVE_AUTH
 	  /* find queries for zones we're authoritative for, and answer them directly */
 	  if (!auth_dns)
@@ -1870,12 +1947,12 @@ unsigned char *tcp_request(int confd, ti
 		}
 #endif
 	}
-      
+
       if (local_addr->sa.sa_family == AF_INET)
 	dst_addr_4 = local_addr->in.sin_addr;
       else
 	dst_addr_4.s_addr = 0;
-      
+
 #ifdef HAVE_AUTH
       if (auth_dns)
 	m = answer_auth(header, ((char *) header) + 65536, (size_t)size, now, &peer_addr, local_auth);
@@ -1883,22 +1960,22 @@ unsigned char *tcp_request(int confd, ti
 #endif
 	{
 	  /* m > 0 if answered from cache */
-	  m = answer_request(header, ((char *) header) + 65536, (size_t)size, 
+	  m = answer_request(header, ((char *) header) + 65536, (size_t)size,
 			     dst_addr_4, netmask, now, &ad_question, &do_bit);
-	  
+
 	  /* Do this by steam now we're not in the select() loop */
-	  check_log_writer(NULL); 
-	  
+	  check_log_writer(NULL);
+
 	  if (m == 0)
 	    {
 	      unsigned int flags = 0;
 	      struct all_addr *addrp = NULL;
 	      int type = 0;
 	      char *domain = NULL;
-	      
+
 	      if (option_bool(OPT_ADD_MAC))
 		size = add_mac(header, size, ((char *) header) + 65536, &peer_addr);
-	      	
+
 	      if (option_bool(OPT_CLIENT_SUBNET))
 		{
 		  size_t new = add_source_addr(header, size, ((char *) header) + 65536, &peer_addr);
@@ -1911,12 +1988,12 @@ unsigned char *tcp_request(int confd, ti
 
 	      if (gotname)
 		flags = search_servers(now, &addrp, gotname, daemon->namebuff, &type, &domain, &norebind);
-	      
+
 	      if (type != 0  || option_bool(OPT_ORDER) || !daemon->last_server)
 		last_server = daemon->servers;
 	      else
 		last_server = daemon->last_server;
-	      
+
 	      if (!flags && last_server)
 		{
 		  struct server *firstsendto = NULL;
@@ -1928,11 +2005,11 @@ unsigned char *tcp_request(int confd, ti
 		    memset(hash, 0, HASH_SIZE);
 #else
 		  unsigned int crc = questions_crc(header, (unsigned int)size, daemon->namebuff);
-#endif		  
+#endif
 		  /* Loop round available servers until we succeed in connecting to one.
 		     Note that this code subtley ensures that consecutive queries on this connection
 		     which can go to the same server, do so. */
-		  while (1) 
+		  while (1)
 		    {
 		      if (!firstsendto)
 			firstsendto = last_server;
@@ -1940,40 +2017,40 @@ unsigned char *tcp_request(int confd, ti
 			{
 			  if (!(last_server = last_server->next))
 			    last_server = daemon->servers;
-			  
+
 			  if (last_server == firstsendto)
 			    break;
 			}
-		      
+
 		      /* server for wrong domain */
 		      if (type != (last_server->flags & SERV_TYPE) ||
 			  (type == SERV_HAS_DOMAIN && !hostname_isequal(domain, last_server->domain)) ||
 			  (last_server->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
 			continue;
-		      
+
 		      if (last_server->tcpfd == -1)
 			{
 			  if ((last_server->tcpfd = socket(last_server->addr.sa.sa_family, SOCK_STREAM, 0)) == -1)
 			    continue;
-			  
+
 #ifdef HAVE_CONNTRACK
 			  /* Copy connection mark of incoming query to outgoing connection. */
 			  if (option_bool(OPT_CONNTRACK))
 			    {
 			      unsigned int mark;
 			      struct all_addr local;
-#ifdef HAVE_IPV6		      
+#ifdef HAVE_IPV6
 			      if (local_addr->sa.sa_family == AF_INET6)
 				local.addr.addr6 = local_addr->in6.sin6_addr;
 			      else
 #endif
 				local.addr.addr4 = local_addr->in.sin_addr;
-			      
+
 			      if (get_incoming_mark(&peer_addr, &local, 1, &mark))
 				setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
 			    }
-#endif	
-		      
+#endif
+
 			  if ((!local_bind(last_server->tcpfd,  &last_server->source_addr, last_server->interface, 1) ||
 			       connect(last_server->tcpfd, &last_server->addr.sa, sa_len(&last_server->addr)) == -1))
 			    {
@@ -1981,31 +2058,31 @@ unsigned char *tcp_request(int confd, ti
 			      last_server->tcpfd = -1;
 			      continue;
 			    }
-			  
+
 #ifdef HAVE_DNSSEC
 			  if (option_bool(OPT_DNSSEC_VALID))
 			    {
 			      size_t new_size = add_do_bit(header, size, ((char *) header) + 65536);
-			      
+
 			      /* For debugging, set Checking Disabled, otherwise, have the upstream check too,
 				 this allows it to select auth servers when one is returning bad data. */
 			      if (option_bool(OPT_DNSSEC_DEBUG))
 				header->hb4 |= HB4_CD;
-			      
+
 			      if (size != new_size)
 				added_pheader = 1;
-			      
+
 			      size = new_size;
 			    }
 #endif
 			}
-		      
+
 		      *length = htons(size);
 
 		      /* get query name again for logging - may have been overwritten */
 		      if (!(gotname = extract_request(header, (unsigned int)size, daemon->namebuff, &qtype)))
 			strcpy(daemon->namebuff, "query");
-		      
+
 		      if (!read_write(last_server->tcpfd, packet, size + sizeof(u16), 0) ||
 			  !read_write(last_server->tcpfd, &c1, 1, 1) ||
 			  !read_write(last_server->tcpfd, &c2, 1, 1) ||
@@ -2014,18 +2091,18 @@ unsigned char *tcp_request(int confd, ti
 			  close(last_server->tcpfd);
 			  last_server->tcpfd = -1;
 			  continue;
-			} 
-		      
+			}
+
 		      m = (c1 << 8) | c2;
-		      
+
 		      if (last_server->addr.sa.sa_family == AF_INET)
-			log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff, 
-				  (struct all_addr *)&last_server->addr.in.sin_addr, NULL); 
+			log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff,
+				  (struct all_addr *)&last_server->addr.in.sin_addr, NULL);
 #ifdef HAVE_IPV6
 		      else
-			log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff, 
+			log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff,
 				  (struct all_addr *)&last_server->addr.in6.sin6_addr, NULL);
-#endif 
+#endif
 
 #ifdef HAVE_DNSSEC
 		      if (option_bool(OPT_DNSSEC_VALID) && !checking_disabled)
@@ -2037,12 +2114,12 @@ unsigned char *tcp_request(int confd, ti
 			  if (status == STAT_INSECURE_DS)
 			    {
 			      /* We only cache sigs when we've validated a reply.
-				 Avoid caching a reply with sigs if there's a vaildated break in the 
+				 Avoid caching a reply with sigs if there's a vaildated break in the
 				 DS chain, so we don't return replies from cache missing sigs. */
 			      status = STAT_INSECURE;
 			      no_cache_dnssec = 1;
 			    }
-			  
+
 			  if (keycount == 0)
 			    {
 			      result = "ABANDONED";
@@ -2050,12 +2127,12 @@ unsigned char *tcp_request(int confd, ti
 			    }
 			  else
 			    result = (status == STAT_SECURE ? "SECURE" : (status == STAT_INSECURE ? "INSECURE" : "BOGUS"));
-			  
+
 			  if (status == STAT_BOGUS && extract_request(header, m, daemon->namebuff, NULL))
 			    domain = daemon->namebuff;
 
 			  log_query(F_KEYTAG | F_SECSTAT, domain, NULL, result);
-			  
+
 			  if (status == STAT_BOGUS)
 			    {
 			      no_cache_dnssec = 1;
@@ -2072,21 +2149,21 @@ unsigned char *tcp_request(int confd, ti
 			header->hb4 |= HB4_CD;
 		      else
 			header->hb4 &= ~HB4_CD;
-		      
+
 		      /* There's no point in updating the cache, since this process will exit and
-			 lose the information after a few queries. We make this call for the alias and 
+			 lose the information after a few queries. We make this call for the alias and
 			 bogus-nxdomain side-effects. */
 		      /* If the crc of the question section doesn't match the crc we sent, then
-			 someone might be attempting to insert bogus values into the cache by 
+			 someone might be attempting to insert bogus values into the cache by
 			 sending replies containing questions and bogus answers. */
 #ifdef HAVE_DNSSEC
 		      newhash = hash_questions(header, (unsigned int)m, daemon->namebuff);
 		      if (!newhash || memcmp(hash, newhash, HASH_SIZE) != 0)
-			{ 
+			{
 			  m = 0;
 			  break;
 			}
-#else			  
+#else
 		      if (crc != questions_crc(header, (unsigned int)m, daemon->namebuff))
 			{
 			  m = 0;
@@ -2094,24 +2171,24 @@ unsigned char *tcp_request(int confd, ti
 			}
 #endif
 
-		      m = process_reply(header, now, last_server, (unsigned int)m, 
+		      m = process_reply(header, now, last_server, (unsigned int)m,
 					option_bool(OPT_NO_REBIND) && !norebind, no_cache_dnssec, cache_secure, bogusanswer,
-					ad_question, do_bit, added_pheader, check_subnet, &peer_addr); 
-		      
+					ad_question, do_bit, added_pheader, check_subnet, &peer_addr);
+
 		      break;
 		    }
 		}
-	
+
 	      /* In case of local answer or no connections made. */
 	      if (m == 0)
 		m = setup_reply(header, (unsigned int)size, addrp, flags, daemon->local_ttl);
 	    }
 	}
-	  
+
       check_log_writer(NULL);
-      
+
       *length = htons(m);
-           
+
       if (m == 0 || !read_write(confd, packet, m + sizeof(u16), 0))
 	return packet;
     }
@@ -2120,7 +2197,7 @@ unsigned char *tcp_request(int confd, ti
 static struct frec *allocate_frec(time_t now)
 {
   struct frec *f;
-  
+
   if ((f = (struct frec *)whine_malloc(sizeof(struct frec))))
     {
       f->next = daemon->frec_list;
@@ -2148,7 +2225,7 @@ struct randfd *allocate_rfd(int family)
   static int finger = 0;
   int i;
 
-  /* limit the number of sockets we have open to avoid starvation of 
+  /* limit the number of sockets we have open to avoid starvation of
      (eg) TFTP. Once we have a reasonable number, randomness should be OK */
 
   for (i = 0; i < RANDOM_SOCKS; i++)
@@ -2156,7 +2233,7 @@ struct randfd *allocate_rfd(int family)
       {
 	if ((daemon->randomsocks[i].fd = random_sock(family)) == -1)
 	  break;
-      
+
 	daemon->randomsocks[i].refcount = 1;
 	daemon->randomsocks[i].family = family;
 	return &daemon->randomsocks[i];
@@ -2167,7 +2244,7 @@ struct randfd *allocate_rfd(int family)
     {
       int j = (i+finger) % RANDOM_SOCKS;
       if (daemon->randomsocks[j].refcount != 0 &&
-	  daemon->randomsocks[j].family == family && 
+	  daemon->randomsocks[j].family == family &&
 	  daemon->randomsocks[j].refcount != 0xffff)
 	{
 	  finger = j;
@@ -2191,7 +2268,7 @@ static void free_frec(struct frec *f)
   f->rfd4 = NULL;
   f->sentto = NULL;
   f->flags = 0;
-  
+
 #ifdef HAVE_IPV6
   free_rfd(f->rfd6);
   f->rfd6 = NULL;
@@ -2228,21 +2305,21 @@ struct frec *get_new_frec(time_t now, in
 {
   struct frec *f, *oldest, *target;
   int count;
-  
+
   if (wait)
     *wait = 0;
 
   for (f = daemon->frec_list, oldest = NULL, target =  NULL, count = 0; f; f = f->next, count++)
     if (!f->sentto)
       target = f;
-    else 
+    else
       {
 	if (difftime(now, f->time) >= 4*TIMEOUT)
 	  {
 	    free_frec(f);
 	    target = f;
 	  }
-	
+
 	if (!oldest || difftime(f->time, oldest->time) <= 0)
 	  oldest = f;
       }
@@ -2252,14 +2329,14 @@ struct frec *get_new_frec(time_t now, in
       target->time = now;
       return target;
     }
-  
+
   /* can't find empty one, use oldest if there is one
      and it's older than timeout */
   if (oldest && ((int)difftime(now, oldest->time)) >= TIMEOUT)
-    { 
+    {
       /* keep stuff for twice timeout if we can by allocating a new
 	 record instead */
-      if (difftime(now, oldest->time) < 2*TIMEOUT && 
+      if (difftime(now, oldest->time) < 2*TIMEOUT &&
 	  count <= daemon->ftabsize &&
 	  (f = allocate_frec(now)))
 	return f;
@@ -2271,15 +2348,15 @@ struct frec *get_new_frec(time_t now, in
 	}
       return oldest;
     }
-  
+
   /* none available, calculate time 'till oldest record expires */
   if (!force && count > daemon->ftabsize)
     {
       static time_t last_log = 0;
-      
+
       if (oldest && wait)
 	*wait = oldest->time + (time_t)TIMEOUT - now;
-      
+
       if ((int)difftime(now, last_log) > 5)
 	{
 	  last_log = now;
@@ -2288,24 +2365,24 @@ struct frec *get_new_frec(time_t now, in
 
       return NULL;
     }
-  
+
   if (!(f = allocate_frec(now)) && wait)
     /* wait one second on malloc failure */
     *wait = 1;
 
   return f; /* OK if malloc fails and this is NULL */
 }
- 
+
 /* crc is all-ones if not known. */
 static struct frec *lookup_frec(unsigned short id, void *hash)
 {
   struct frec *f;
 
   for(f = daemon->frec_list; f; f = f->next)
-    if (f->sentto && f->new_id == id && 
+    if (f->sentto && f->new_id == id &&
 	(!hash || memcmp(hash, f->hash, HASH_SIZE) == 0))
       return f;
-      
+
   return NULL;
 }
 
@@ -2314,34 +2391,34 @@ static struct frec *lookup_frec_by_sende
 					  void *hash)
 {
   struct frec *f;
-  
+
   for(f = daemon->frec_list; f; f = f->next)
     if (f->sentto &&
-	f->orig_id == id && 
+	f->orig_id == id &&
 	memcmp(hash, f->hash, HASH_SIZE) == 0 &&
 	sockaddr_isequal(&f->source, addr))
       return f;
-   
+
   return NULL;
 }
- 
+
 /* Send query packet again, if we can. */
 void resend_query()
 {
   if (daemon->srv_save)
     {
       int fd;
-      
+
       if (daemon->srv_save->sfd)
 	fd = daemon->srv_save->sfd->fd;
       else if (daemon->rfd_save && daemon->rfd_save->refcount != 0)
 	fd = daemon->rfd_save->fd;
       else
 	return;
-      
+
       while(retry_send(sendto(fd, daemon->packet, daemon->packet_len, 0,
-			      &daemon->srv_save->addr.sa, 
-			      sa_len(&daemon->srv_save->addr)))); 
+			      &daemon->srv_save->addr.sa,
+			      sa_len(&daemon->srv_save->addr))));
     }
 }
 
@@ -2349,11 +2426,11 @@ void resend_query()
 void server_gone(struct server *server)
 {
   struct frec *f;
-  
+
   for (f = daemon->frec_list; f; f = f->next)
     if (f->sentto && f->sentto == server)
       free_frec(f);
-  
+
   if (daemon->last_server == server)
     daemon->last_server = NULL;
 
@@ -2365,15 +2442,10 @@ void server_gone(struct server *server)
 static unsigned short get_id(void)
 {
   unsigned short ret = 0;
-  
-  do 
+
+  do
     ret = rand16();
   while (lookup_frec(ret, NULL));
-  
+
   return ret;
 }
-
-
-
-
-
